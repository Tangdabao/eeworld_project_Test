###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       29/Jan/2018  14:45:21
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\src\cube_hal_l1.c
#    Command line =  
#        "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\src\cube_hal_l1.c"
#        -D STM32L151xB -D STM32L1XX_XL -D USE_STM32L1XX_STEVAL_IDB00xV1 -D
#        USE_HAL_DRIVER -D HCLK_32MHZ=1 -D SYSCLK_MSI=1 -D ENABLE_USART -D
#        USER_DEFINED_PLATFORM=USER_EVAL_PLATFORM -D IRQ_RESET_PIN -D DTM_UART
#        -lC "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\List"
#        -o "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        D:\Software\IAR_BlueNRG\arm\INC\c\DLib_Config_Normal.h -I
#        "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\HAL\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\BSP\STM32L1xx_BlueNRG1\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\BSP\STM32L1xx_Nucleo\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\CMSIS\Device\ST\STM32L1xx\Include\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\STM32L1xx_HAL_BlueNRG1_Drivers\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\SimpleBlueNRG1_HCI\includes\"
#        -On --use_c++_inline -I D:\Software\IAR_BlueNRG\arm\CMSIS\Include\
#    Locale       =  Chinese (Simplified)_China.936
#    List file    =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\List\cube_hal_l1.lst
#    Object file  =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\Obj\cube_hal_l1.o
#
###############################################################################

C:\Users\Administrator\Desktop\Temporary Files\eeworld_project\Project_Test\Project\STM32L\DTM\src\cube_hal_l1.c
      1          /**
      2            ******************************************************************************
      3            * @file    cube_hal_l1.c
      4            * @author  RF Application Team - AMG
      5            * @version V1.0.0
      6            * @date    27-April-2015
      7            * @brief   
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     12            *
     13            * Redistribution and use in source and binary forms, with or without modification,
     14            * are permitted provided that the following conditions are met:
     15            *   1. Redistributions of source code must retain the above copyright notice,
     16            *      this list of conditions and the following disclaimer.
     17            *   2. Redistributions in binary form must reproduce the above copyright notice,
     18            *      this list of conditions and the following disclaimer in the documentation
     19            *      and/or other materials provided with the distribution.
     20            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     21            *      may be used to endorse or promote products derived from this software
     22            *      without specific prior written permission.
     23            *
     24            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     25            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     26            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     27            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     28            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     29            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     30            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     31            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     32            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     33            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     34            *
     35            ******************************************************************************
     36            */ 
     37          
     38          /* Includes ------------------------------------------------------------------*/
     39          #include "cube_hal.h"
     40          #include "hal.h"
     41          #include "hci_parser.h"
     42          #include "stm32xx_it.h"
     43          
     44          extern UART_HandleTypeDef DTM_UartHandle;
     45          extern uint8_t DTM_read_data[250];
     46          
     47          /**
     48           * @brief  System Clock Configuration
     49           * @param  None
     50           * @retval None
     51           */

   \                                 In section .text, align 2, keep-with-next
     52          void SystemClock_Config(void)
     53          {
   \                     SystemClock_Config: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB093             SUB      SP,SP,#+76
     54            RCC_OscInitTypeDef RCC_OscInitStruct;
     55            RCC_ClkInitTypeDef RCC_ClkInitStruct;
     56            
     57            /**
     58            * Enable clock on PWR block
     59            * This is used to setup registers when entering low power mode
     60            */
     61            __PWR_CLK_ENABLE();
   \   00000004   0x....             LDR.N    R0,??DataTable5  ;; 0x40023824
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   0000000C   0x....             LDR.N    R1,??DataTable5  ;; 0x40023824
   \   0000000E   0x6008             STR      R0,[R1, #+0]
   \   00000010   0x....             LDR.N    R0,??DataTable5  ;; 0x40023824
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF010 0x5080      ANDS     R0,R0,#0x10000000
   \   00000018   0x9000             STR      R0,[SP, #+0]
   \   0000001A   0x9800             LDR      R0,[SP, #+0]
     62            
     63            /**
     64             * Set voltage scaling range
     65             * The voltage scaling allows optimizing the power consumption when the device is 
     66             * clocked below the maximum system frequency, to update the voltage scaling value 
     67             * regarding system frequency refer to product datasheet.
     68             */
     69          #if (HCLK_32MHZ == 1)
     70            __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
   \   0000001C   0x....             LDR.N    R0,??DataTable5_1  ;; 0x40007000
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF430 0x50C0      BICS     R0,R0,#0x1800
   \   00000024   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   00000028   0x....             LDR.N    R1,??DataTable5_1  ;; 0x40007000
   \   0000002A   0x6008             STR      R0,[R1, #+0]
     71            
     72            /* Poll VOSF bit of in PWR_CSR. Wait until it is reset to 0 */
     73            while (__HAL_PWR_GET_FLAG(PWR_FLAG_VOS) != RESET) {};
   \                     ??SystemClock_Config_0: (+1)
   \   0000002C   0x....             LDR.N    R0,??DataTable5_2  ;; 0x40007004
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x06C0             LSLS     R0,R0,#+27
   \   00000032   0xD4FB             BMI.N    ??SystemClock_Config_0
     74            
     75            /**
     76             *  Enable HSI oscillator and configure the PLL to reach the max system frequency 
     77             *  (32MHz) when using HSI oscillator as PLL clock source.
     78             */
     79            RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
   \   00000034   0x2002             MOVS     R0,#+2
   \   00000036   0x9006             STR      R0,[SP, #+24]
     80            RCC_OscInitStruct.HSICalibrationValue = 0x10;
   \   00000038   0x2010             MOVS     R0,#+16
   \   0000003A   0x900A             STR      R0,[SP, #+40]
     81            RCC_OscInitStruct.HSIState = RCC_HSI_ON;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x9009             STR      R0,[SP, #+36]
     82            RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
   \   00000040   0x2002             MOVS     R0,#+2
   \   00000042   0x900F             STR      R0,[SP, #+60]
     83            RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x9010             STR      R0,[SP, #+64]
     84          
     85            RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6; //USB support
   \   00000048   0xF45F 0x2000      MOVS     R0,#+524288
   \   0000004C   0x9011             STR      R0,[SP, #+68]
     86            RCC_OscInitStruct.PLL.PLLDIV = RCC_PLL_DIV3; 
   \   0000004E   0xF45F 0x0000      MOVS     R0,#+8388608
   \   00000052   0x9012             STR      R0,[SP, #+72]
     87          
     88            
     89            HAL_RCC_OscConfig(&RCC_OscInitStruct);
   \   00000054   0xA806             ADD      R0,SP,#+24
   \   00000056   0x.... 0x....      BL       HAL_RCC_OscConfig
     90            
     91            /**
     92            *  Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers.
     93            *  The SysTick 1 msec interrupt is required for the HAL process (Timeout management); by default
     94            *  the configuration is done using the HAL_Init() API, and when the system clock configuration
     95            *  is updated the SysTick configuration will be adjusted by the HAL_RCC_ClockConfig() API.
     96            */
     97            RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
   \   0000005A   0x200F             MOVS     R0,#+15
   \   0000005C   0x9001             STR      R0,[SP, #+4]
     98            RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
   \   0000005E   0x2003             MOVS     R0,#+3
   \   00000060   0x9002             STR      R0,[SP, #+8]
     99            RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x9003             STR      R0,[SP, #+12]
    100          
    101            RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x9004             STR      R0,[SP, #+16]
    102            RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x9005             STR      R0,[SP, #+20]
    103            HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1);
   \   0000006E   0x2101             MOVS     R1,#+1
   \   00000070   0xA801             ADD      R0,SP,#+4
   \   00000072   0x.... 0x....      BL       HAL_RCC_ClockConfig
    104            
    105          #else
    106            /**
    107            * Reset value is Range 2
    108            */
    109            
    110            /**
    111            *  Enable HSI oscillator and configure the system at 16MHz
    112            */
    113            RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
    114            RCC_OscInitStruct.HSICalibrationValue = 0x10;
    115            RCC_OscInitStruct.HSIState = RCC_HSI_ON;
    116            RCC_OscInitStruct.PLL.PLLState = RCC_PLL_OFF;
    117            
    118            HAL_RCC_OscConfig(&RCC_OscInitStruct);
    119            
    120            /**
    121            *  Configure the HCLK, PCLK1 and PCLK2 clocks dividers  to get 8Mhz.
    122            *  The SysTick 1 msec interrupt is required for the HAL process (Timeout management); by default
    123            *  the configuration is done using the HAL_Init() API, and when the system clock configuration
    124            *  is updated the SysTick configuration will be adjusted by the HAL_RCC_ClockConfig() API.
    125            */
    126            RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
    127            RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
    128            RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
    129            RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
    130            RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
    131            
    132            HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0);
    133            
    134          #endif /* (HCLK_32MHZ == 1) */
    135            
    136            return;
   \   00000076   0xB013             ADD      SP,SP,#+76
   \   00000078   0xBD00             POP      {PC}             ;; return
    137          }
    138          
    139          /*******************************************************************************
    140          * Function Name  : Init_Device
    141          * Description    : Device initialization steps using STM32L1 standard library
    142          * Input          : None.
    143          * Return         : None.
    144          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    145          void Init_Device(void)
    146          {
   \                     Init_Device: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    147            
    148            /* STM32Cube HAL library initialization */
    149            HAL_Init();
   \   00000002   0x.... 0x....      BL       HAL_Init
    150            
    151            /* Configure the system clock */
    152            SystemClock_Config(); 
   \   00000006   0x.... 0x....      BL       SystemClock_Config
    153            
    154            /* Init UART2 port - connection with ST-Link */
    155            SdkEval_IO_Config(hci_input);
   \   0000000A   0x....             LDR.N    R0,??DataTable5_3
   \   0000000C   0x.... 0x....      BL       SdkEval_IO_Config
    156          
    157          #ifdef DTM_SPI
    158            /* Init SPI interface */
    159            SdkEvalSpiInit(SPI_MODE_EXTI);
    160          #endif
    161          #ifdef DTM_UART
    162            /* Init UART1 port - connection with BlueNRG-1 */
    163            DTM_IO_Config();  
   \   00000010   0x.... 0x....      BL       DTM_IO_Config
    164          #endif
    165          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    166          
    167          
    168          
    169          
    170          /**
    171            * @brief UART MSP Initialization 
    172            *        This function configures the hardware resources used in this example: 
    173            *           - Peripheral's clock enable
    174            *           - Peripheral's GPIO Configuration  
    175            * @param huart: UART handle pointer
    176            * @retval None
    177            */

   \                                 In section .text, align 2, keep-with-next
    178          void HAL_UART_MspInit(UART_HandleTypeDef *huart)
    179          {  
   \                     HAL_UART_MspInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x0004             MOVS     R4,R0
    180            GPIO_InitTypeDef  GPIO_InitStruct;
    181            
    182            if(huart->Instance == USART2) {
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x....             LDR.N    R1,??DataTable5_4  ;; 0x40004400
   \   0000000A   0x4288             CMP      R0,R1
   \   0000000C   0xD13E             BNE.N    ??HAL_UART_MspInit_0
    183              UART_TX_CLOCK();
   \   0000000E   0x....             LDR.N    R0,??DataTable5_5  ;; 0x4002381c
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000016   0x....             LDR.N    R1,??DataTable5_5  ;; 0x4002381c
   \   00000018   0x6008             STR      R0,[R1, #+0]
   \   0000001A   0x....             LDR.N    R0,??DataTable5_5  ;; 0x4002381c
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000022   0x9000             STR      R0,[SP, #+0]
   \   00000024   0x9800             LDR      R0,[SP, #+0]
    184              UART_RX_CLOCK();
   \   00000026   0x....             LDR.N    R0,??DataTable5_5  ;; 0x4002381c
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000002E   0x....             LDR.N    R1,??DataTable5_5  ;; 0x4002381c
   \   00000030   0x6008             STR      R0,[R1, #+0]
   \   00000032   0x....             LDR.N    R0,??DataTable5_5  ;; 0x4002381c
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000003A   0x9000             STR      R0,[SP, #+0]
   \   0000003C   0x9800             LDR      R0,[SP, #+0]
    185              
    186              /* Configure USART Tx as alternate function push-pull */
    187              GPIO_InitStruct.Pin       = UART_TX_PIN;
   \   0000003E   0x2004             MOVS     R0,#+4
   \   00000040   0x9001             STR      R0,[SP, #+4]
    188              GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
   \   00000042   0x2002             MOVS     R0,#+2
   \   00000044   0x9002             STR      R0,[SP, #+8]
    189              GPIO_InitStruct.Pull      = GPIO_PULLUP;
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x9003             STR      R0,[SP, #+12]
    190              GPIO_InitStruct.Speed     = GPIO_SPEED_HIGH;
   \   0000004A   0x2003             MOVS     R0,#+3
   \   0000004C   0x9004             STR      R0,[SP, #+16]
    191              GPIO_InitStruct.Alternate = UART_TX_AF;
   \   0000004E   0x2007             MOVS     R0,#+7
   \   00000050   0x9005             STR      R0,[SP, #+20]
    192              HAL_GPIO_Init(UART_TX_PORT, &GPIO_InitStruct);
   \   00000052   0xA901             ADD      R1,SP,#+4
   \   00000054   0x....             LDR.N    R0,??DataTable5_6  ;; 0x40020000
   \   00000056   0x.... 0x....      BL       HAL_GPIO_Init
    193              
    194              /* Configure USART Rx as input floating */
    195              GPIO_InitStruct.Pin = UART_RX_PIN;
   \   0000005A   0x2008             MOVS     R0,#+8
   \   0000005C   0x9001             STR      R0,[SP, #+4]
    196              GPIO_InitStruct.Alternate = UART_RX_AF;
   \   0000005E   0x2007             MOVS     R0,#+7
   \   00000060   0x9005             STR      R0,[SP, #+20]
    197              HAL_GPIO_Init(UART_RX_PORT, &GPIO_InitStruct);
   \   00000062   0xA901             ADD      R1,SP,#+4
   \   00000064   0x....             LDR.N    R0,??DataTable5_6  ;; 0x40020000
   \   00000066   0x.... 0x....      BL       HAL_GPIO_Init
    198              
    199              /* Reset */
    200              GPIO_InitStruct.Pin = BNRG_SPI_RESET_PIN;
   \   0000006A   0xF44F 0x7080      MOV      R0,#+256
   \   0000006E   0x9001             STR      R0,[SP, #+4]
    201              GPIO_InitStruct.Mode = BNRG_SPI_RESET_MODE;
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0x9002             STR      R0,[SP, #+8]
    202              GPIO_InitStruct.Pull = BNRG_SPI_RESET_PULL;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x9003             STR      R0,[SP, #+12]
    203              GPIO_InitStruct.Speed = BNRG_SPI_RESET_SPEED;
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0x9004             STR      R0,[SP, #+16]
    204              GPIO_InitStruct.Alternate = BNRG_SPI_RESET_ALTERNATE;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x9005             STR      R0,[SP, #+20]
    205              HAL_GPIO_Init(BNRG_SPI_RESET_PORT, &GPIO_InitStruct);	
   \   00000080   0xA901             ADD      R1,SP,#+4
   \   00000082   0x....             LDR.N    R0,??DataTable5_6  ;; 0x40020000
   \   00000084   0x.... 0x....      BL       HAL_GPIO_Init
    206              BlueNRG_Power_Down();	/*Added to avoid spurious interrupt from the BlueNRG */
   \   00000088   0x.... 0x....      BL       BlueNRG_Power_Down
    207            }
    208            
    209            if(huart->Instance == USART1) {
   \                     ??HAL_UART_MspInit_0: (+1)
   \   0000008C   0x6820             LDR      R0,[R4, #+0]
   \   0000008E   0x....             LDR.N    R1,??DataTable5_7  ;; 0x40013800
   \   00000090   0x4288             CMP      R0,R1
   \   00000092   0xD137             BNE.N    ??HAL_UART_MspInit_1
    210              DTM_USART_TX_GPIO_CLK_ENABLE();
   \   00000094   0x....             LDR.N    R0,??DataTable5_5  ;; 0x4002381c
   \   00000096   0x6800             LDR      R0,[R0, #+0]
   \   00000098   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000009C   0x....             LDR.N    R1,??DataTable5_5  ;; 0x4002381c
   \   0000009E   0x6008             STR      R0,[R1, #+0]
   \   000000A0   0x....             LDR.N    R0,??DataTable5_5  ;; 0x4002381c
   \   000000A2   0x6800             LDR      R0,[R0, #+0]
   \   000000A4   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   000000A8   0x9000             STR      R0,[SP, #+0]
   \   000000AA   0x9800             LDR      R0,[SP, #+0]
    211              DTM_USART_RX_GPIO_CLK_ENABLE();
   \   000000AC   0x....             LDR.N    R0,??DataTable5_5  ;; 0x4002381c
   \   000000AE   0x6800             LDR      R0,[R0, #+0]
   \   000000B0   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000B4   0x....             LDR.N    R1,??DataTable5_5  ;; 0x4002381c
   \   000000B6   0x6008             STR      R0,[R1, #+0]
   \   000000B8   0x....             LDR.N    R0,??DataTable5_5  ;; 0x4002381c
   \   000000BA   0x6800             LDR      R0,[R0, #+0]
   \   000000BC   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   000000C0   0x9000             STR      R0,[SP, #+0]
   \   000000C2   0x9800             LDR      R0,[SP, #+0]
    212              
    213              /* UART TX GPIO pin configuration  */
    214              GPIO_InitStruct.Pin       = DTM_USART_TX_PIN;
   \   000000C4   0xF44F 0x7000      MOV      R0,#+512
   \   000000C8   0x9001             STR      R0,[SP, #+4]
    215              GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
   \   000000CA   0x2002             MOVS     R0,#+2
   \   000000CC   0x9002             STR      R0,[SP, #+8]
    216              GPIO_InitStruct.Pull      = GPIO_NOPULL;      //GPIO_PULLDOWN; GPIO_PULLUP;
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x9003             STR      R0,[SP, #+12]
    217              GPIO_InitStruct.Speed     = GPIO_SPEED_HIGH;
   \   000000D2   0x2003             MOVS     R0,#+3
   \   000000D4   0x9004             STR      R0,[SP, #+16]
    218              GPIO_InitStruct.Alternate = DTM_USART_TX_AF;  
   \   000000D6   0x2007             MOVS     R0,#+7
   \   000000D8   0x9005             STR      R0,[SP, #+20]
    219              HAL_GPIO_Init(DTM_USART_TX_GPIO_PORT, &GPIO_InitStruct);
   \   000000DA   0xA901             ADD      R1,SP,#+4
   \   000000DC   0x....             LDR.N    R0,??DataTable5_6  ;; 0x40020000
   \   000000DE   0x.... 0x....      BL       HAL_GPIO_Init
    220              
    221              /* UART RX GPIO pin configuration  */
    222              GPIO_InitStruct.Pin = DTM_USART_RX_PIN;
   \   000000E2   0xF44F 0x6080      MOV      R0,#+1024
   \   000000E6   0x9001             STR      R0,[SP, #+4]
    223              GPIO_InitStruct.Alternate = DTM_USART_RX_AF;  
   \   000000E8   0x2007             MOVS     R0,#+7
   \   000000EA   0x9005             STR      R0,[SP, #+20]
    224              HAL_GPIO_Init(DTM_USART_RX_GPIO_PORT, &GPIO_InitStruct);
   \   000000EC   0xA901             ADD      R1,SP,#+4
   \   000000EE   0x....             LDR.N    R0,??DataTable5_6  ;; 0x40020000
   \   000000F0   0x.... 0x....      BL       HAL_GPIO_Init
    225              
    226              /* Configure the NVIC for SPI */  
    227              HAL_NVIC_SetPriority(DTM_USART_IRQn, 4, 0); //TBR Which priority < spi
   \   000000F4   0x2200             MOVS     R2,#+0
   \   000000F6   0x2104             MOVS     R1,#+4
   \   000000F8   0x2025             MOVS     R0,#+37
   \   000000FA   0x.... 0x....      BL       HAL_NVIC_SetPriority
    228              HAL_NVIC_EnableIRQ(DTM_USART_IRQn);
   \   000000FE   0x2025             MOVS     R0,#+37
   \   00000100   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    229            }
    230            
    231          }
   \                     ??HAL_UART_MspInit_1: (+1)
   \   00000104   0xB006             ADD      SP,SP,#+24
   \   00000106   0xBD10             POP      {R4,PC}          ;; return
    232          
    233          
    234          /**
    235            * @brief UART MSP De-Initialization 
    236            *        This function frees the hardware resources used in this example:
    237            *          - Disable the Peripheral's clock
    238            *          - Revert GPIO configuration to their default state
    239            * @param huart: UART handle pointer
    240            * @retval None
    241            */

   \                                 In section .text, align 2, keep-with-next
    242          void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
    243          {
   \                     HAL_UART_MspDeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    244          
    245            if(huart->Instance == USART2) {
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x....             LDR.N    R1,??DataTable5_4  ;; 0x40004400
   \   00000008   0x4288             CMP      R0,R1
   \   0000000A   0xD113             BNE.N    ??HAL_UART_MspDeInit_0
    246              /*##-1- Reset peripherals ##################################################*/
    247              DTM_USART_FORCE_RESET();
   \   0000000C   0x....             LDR.N    R0,??DataTable5_8  ;; 0x40023814
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   00000014   0x....             LDR.N    R1,??DataTable5_8  ;; 0x40023814
   \   00000016   0x6008             STR      R0,[R1, #+0]
    248              DTM_USART_RELEASE_RESET();
   \   00000018   0x....             LDR.N    R0,??DataTable5_8  ;; 0x40023814
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF430 0x4080      BICS     R0,R0,#0x4000
   \   00000020   0x....             LDR.N    R1,??DataTable5_8  ;; 0x40023814
   \   00000022   0x6008             STR      R0,[R1, #+0]
    249              
    250              /*##-2- Disable peripherals and GPIO Clocks #################################*/
    251              /* Configure USART1 Tx as alternate function  */
    252              HAL_GPIO_DeInit(UART_TX_PORT, UART_TX_PIN);
   \   00000024   0x2104             MOVS     R1,#+4
   \   00000026   0x....             LDR.N    R0,??DataTable5_6  ;; 0x40020000
   \   00000028   0x.... 0x....      BL       HAL_GPIO_DeInit
    253              /* Configure USART1 Rx as alternate function  */
    254              HAL_GPIO_DeInit(UART_RX_PORT, UART_RX_PIN);
   \   0000002C   0x2108             MOVS     R1,#+8
   \   0000002E   0x....             LDR.N    R0,??DataTable5_6  ;; 0x40020000
   \   00000030   0x.... 0x....      BL       HAL_GPIO_DeInit
    255            }
    256            if(huart->Instance == USART1) {
   \                     ??HAL_UART_MspDeInit_0: (+1)
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x....             LDR.N    R1,??DataTable5_7  ;; 0x40013800
   \   00000038   0x4288             CMP      R0,R1
   \   0000003A   0xD113             BNE.N    ??HAL_UART_MspDeInit_1
    257              /*##-2- Disable peripherals and GPIO Clocks #################################*/
    258              /* Configure USART1 Tx as alternate function  */
    259              HAL_GPIO_DeInit(DTM_USART_TX_GPIO_PORT, DTM_USART_TX_PIN);
   \   0000003C   0xF44F 0x7100      MOV      R1,#+512
   \   00000040   0x....             LDR.N    R0,??DataTable5_6  ;; 0x40020000
   \   00000042   0x.... 0x....      BL       HAL_GPIO_DeInit
    260              /* Configure USART1 Rx as alternate function  */
    261              HAL_GPIO_DeInit(DTM_USART_RX_GPIO_PORT, DTM_USART_RX_PIN);
   \   00000046   0xF44F 0x6180      MOV      R1,#+1024
   \   0000004A   0x....             LDR.N    R0,??DataTable5_6  ;; 0x40020000
   \   0000004C   0x.... 0x....      BL       HAL_GPIO_DeInit
    262              /* Configure USART1 Tx as alternate function  */
    263              HAL_GPIO_DeInit(DTM_USART_CTS_GPIO_PORT, DTM_USART_CTS_PIN);
   \   00000050   0xF44F 0x6100      MOV      R1,#+2048
   \   00000054   0x....             LDR.N    R0,??DataTable5_6  ;; 0x40020000
   \   00000056   0x.... 0x....      BL       HAL_GPIO_DeInit
    264              /* Configure USART1 Rx as alternate function  */
    265              HAL_GPIO_DeInit(DTM_USART_RTS_GPIO_PORT, DTM_USART_RTS_PIN);
   \   0000005A   0xF44F 0x5180      MOV      R1,#+4096
   \   0000005E   0x....             LDR.N    R0,??DataTable5_6  ;; 0x40020000
   \   00000060   0x.... 0x....      BL       HAL_GPIO_DeInit
    266            }
    267          }
   \                     ??HAL_UART_MspDeInit_1: (+1)
   \   00000064   0xBD10             POP      {R4,PC}          ;; return
    268          
    269          
    270          
    271          
    272          
    273          /**
    274            * @brief  Rx Transfer completed callback
    275            * @param  UartHandle: UART handle
    276            * @note   This example shows a simple way to report end of DMA Rx transfer, and 
    277            *         you can add your own implementation.
    278            * @retval None
    279            */
    280          extern UART_HandleTypeDef xUsartInit;
    281          extern uint8_t read_data;

   \                                 In section .text, align 2, keep-with-next
    282          void HAL_UART_RxCpltCallback(UART_HandleTypeDef *UartHandle)
    283          {
   \                     HAL_UART_RxCpltCallback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    284          #ifdef DTM_UART
    285            if(UartHandle==&DTM_UartHandle) {
   \   00000004   0x....             LDR.N    R0,??DataTable5_9
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD108             BNE.N    ??HAL_UART_RxCpltCallback_0
    286              /* Printout the data */
    287              //    for(uint8_t i = 0; i<data_size;i++) {
    288              putchar(DTM_read_data[0]);
   \   0000000A   0x....             LDR.N    R0,??DataTable5_10
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x.... 0x....      BL       putchar
    289              //    }
    290              /* Start another reception */
    291              HAL_UART_Receive_IT(UartHandle, DTM_read_data, 1);
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0x....             LDR.N    R1,??DataTable5_10
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       HAL_UART_Receive_IT
    292            }
    293          #endif
    294            if(UartHandle==&xUsartInit) {
   \                     ??HAL_UART_RxCpltCallback_0: (+1)
   \   0000001C   0x....             LDR.N    R0,??DataTable5_11
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD108             BNE.N    ??HAL_UART_RxCpltCallback_1
    295              /* Trasfer complete: read data */
    296              SdkEval_IO_Receive_Data(&read_data,1);
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0x....             LDR.N    R0,??DataTable5_12
   \   00000026   0x.... 0x....      BL       SdkEval_IO_Receive_Data
    297              /* Start another reception */
    298              HAL_UART_Receive_IT(UartHandle, &read_data, 1);  
   \   0000002A   0x2201             MOVS     R2,#+1
   \   0000002C   0x....             LDR.N    R1,??DataTable5_12
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       HAL_UART_Receive_IT
    299            }
    300          }
   \                     ??HAL_UART_RxCpltCallback_1: (+1)
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    301          
    302          /**
    303            * @brief  UART error callbacks
    304            * @param  UartHandle: UART handle
    305            * @retval None
    306            */

   \                                 In section .text, align 2, keep-with-next
    307          void HAL_UART_ErrorCallback(UART_HandleTypeDef *UartHandle)
    308          {
   \                     HAL_UART_ErrorCallback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    309          #ifdef DTM_UART
    310            /* This is because if a reset occurs to BlueNRG-1
    311             * the UART lines generate a UART error */
    312            if(UartHandle==&DTM_UartHandle) {
   \   00000004   0x....             LDR.N    R0,??DataTable5_9
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD104             BNE.N    ??HAL_UART_ErrorCallback_0
    313              /* Start another reception */
    314              HAL_UART_Receive_IT(UartHandle, DTM_read_data, 1);
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0x....             LDR.N    R1,??DataTable5_10
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       HAL_UART_Receive_IT
    315            }
    316          #endif
    317          #ifdef DTM_SPI
    318            __NOP();
    319          #endif
    320          }
   \                     ??HAL_UART_ErrorCallback_0: (+1)
   \   00000014   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x40023824         DC32     0x40023824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x40007000         DC32     0x40007000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x40007004         DC32     0x40007004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     hci_input

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x40004400         DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x4002381C         DC32     0x4002381c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x40013800         DC32     0x40013800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x40023814         DC32     0x40023814

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x........         DC32     DTM_UartHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x........         DC32     DTM_read_data

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0x........         DC32     xUsartInit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_12:
   \   00000000   0x........         DC32     read_data
    321          
    322          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_UART_ErrorCallback
         8   -> HAL_UART_Receive_IT
       8   HAL_UART_MspDeInit
         8   -> HAL_GPIO_DeInit
      32   HAL_UART_MspInit
        32   -> BlueNRG_Power_Down
        32   -> HAL_GPIO_Init
        32   -> HAL_NVIC_EnableIRQ
        32   -> HAL_NVIC_SetPriority
       8   HAL_UART_RxCpltCallback
         8   -> HAL_UART_Receive_IT
         8   -> SdkEval_IO_Receive_Data
         8   -> putchar
       8   Init_Device
         8   -> DTM_IO_Config
         8   -> HAL_Init
         8   -> SdkEval_IO_Config
         8   -> SystemClock_Config
      80   SystemClock_Config
        80   -> HAL_RCC_ClockConfig
        80   -> HAL_RCC_OscConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
      22  HAL_UART_ErrorCallback
     102  HAL_UART_MspDeInit
     264  HAL_UART_MspInit
      54  HAL_UART_RxCpltCallback
      22  Init_Device
     122  SystemClock_Config

 
 638 bytes in section .text
 
 638 bytes of CODE memory

Errors: none
Warnings: none
