###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       29/Jan/2018  14:45:21
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\SimpleBlueNRG1_HCI\hci\hci.c
#    Command line =  
#        "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\SimpleBlueNRG1_HCI\hci\hci.c"
#        -D STM32L151xB -D STM32L1XX_XL -D USE_STM32L1XX_STEVAL_IDB00xV1 -D
#        USE_HAL_DRIVER -D HCLK_32MHZ=1 -D SYSCLK_MSI=1 -D ENABLE_USART -D
#        USER_DEFINED_PLATFORM=USER_EVAL_PLATFORM -D IRQ_RESET_PIN -D DTM_UART
#        -lC "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\List"
#        -o "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        D:\Software\IAR_BlueNRG\arm\INC\c\DLib_Config_Normal.h -I
#        "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\HAL\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\BSP\STM32L1xx_BlueNRG1\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\BSP\STM32L1xx_Nucleo\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\CMSIS\Device\ST\STM32L1xx\Include\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\STM32L1xx_HAL_BlueNRG1_Drivers\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\SimpleBlueNRG1_HCI\includes\"
#        -On --use_c++_inline -I D:\Software\IAR_BlueNRG\arm\CMSIS\Include\
#    Locale       =  Chinese (Simplified)_China.936
#    List file    =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\List\hci.lst
#    Object file  =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\Obj\hci.o
#
###############################################################################

C:\Users\Administrator\Desktop\Temporary Files\eeworld_project\Project_Test\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\SimpleBlueNRG1_HCI\hci\hci.c
      1          /**
      2          ******************************************************************************
      3          * @file    hci.c 
      4          * @author  AMG RF Application Team
      5          * @brief   Function for managing framework required for handling HCI interface.
      6          ******************************************************************************
      7          *
      8          *
      9          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     10          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     11          * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     12          * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     13          * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     14          * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     15          *
     16          * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
     17          */ 
     18          
     19          #include "hal_types.h"
     20          #include "osal.h"
     21          #include "ble_status.h"
     22          #include "hal.h"
     23          #include "hci_const.h"
     24          #include "gp_timer.h"
     25          #include "bluenrg1_types.h"
     26          #if ENABLE_MICRO_SLEEP /* only STM32L1xx STD library */   
     27          #include "low_power.h"
     28          #endif 
     29          
     30          #if BLE_CONFIG_DBG_ENABLE
     31          #define PRINTF(...) printf(__VA_ARGS__)
     32          #else
     33          #define PRINTF(...)
     34          #endif
     35          
     36          #define HCI_LOG_ON 0
     37          
     38          #define HCI_READ_PACKET_NUM_MAX 		 (5)
     39          
     40          #define MIN(a,b)            ((a) < (b) )? (a) : (b)
     41          #define MAX(a,b)            ((a) > (b) )? (a) : (b)
     42          

   \                                 In section .bss, align 4
     43          tListNode hciReadPktPool;
   \                     hciReadPktPool:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
     44          tListNode hciReadPktRxQueue;
   \                     hciReadPktRxQueue:
   \   00000000                      DS8 8
     45          /* pool of hci read packets */

   \                                 In section .bss, align 4
     46          static tHciDataPacket     hciReadPacketBuffer[HCI_READ_PACKET_NUM_MAX];
   \                     hciReadPacketBuffer:
   \   00000000                      DS8 700
     47          

   \                                 In section .text, align 2, keep-with-next
     48          uint8_t BlueNRG_Stack_Initialization(void)
     49          {
   \                     BlueNRG_Stack_Initialization: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
     50            uint8_t index;
     51            uint8_t ret = 0;
   \   00000002   0x2500             MOVS     R5,#+0
     52            
     53            /* Initialize list heads of ready and free hci data packet queues */
     54            list_init_head (&hciReadPktPool);
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable5
   \   00000008   0x.... 0x....      BL       list_init_head
     55            list_init_head (&hciReadPktRxQueue);
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   00000010   0x.... 0x....      BL       list_init_head
     56            
     57            /* Initialize the queue of free hci data packets */
     58            for (index = 0; index < HCI_READ_PACKET_NUM_MAX; index++)
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x0004             MOVS     R4,R0
   \                     ??BlueNRG_Stack_Initialization_0: (+1)
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0x2C05             CMP      R4,#+5
   \   0000001C   0xDA0C             BGE.N    ??BlueNRG_Stack_Initialization_1
     59            {
     60              list_insert_tail(&hciReadPktPool, (tListNode *)&hciReadPacketBuffer[index]);
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable5_2
   \   00000022   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000024   0x218C             MOVS     R1,#+140
   \   00000026   0xFB01 0xF104      MUL      R1,R1,R4
   \   0000002A   0x4401             ADD      R1,R0,R1
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable5
   \   00000030   0x.... 0x....      BL       list_insert_tail
     61            }
   \   00000034   0x1C64             ADDS     R4,R4,#+1
   \   00000036   0xE7EF             B.N      ??BlueNRG_Stack_Initialization_0
     62            
     63            /* Reset BlueNRG-1 */
     64            BlueNRG_RST(); 
   \                     ??BlueNRG_Stack_Initialization_1: (+1)
   \   00000038   0x.... 0x....      BL       BlueNRG_RST
     65            
     66            return ret;
   \   0000003C   0x0028             MOVS     R0,R5
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     67          }
     68          
     69          #define HCI_PCK_TYPE_OFFSET                 0
     70          #define  EVENT_PARAMETER_TOT_LEN_OFFSET     2
     71          
     72          /**
     73          * Verify if HCI packet is correctly formatted.
     74          *
     75          * @param[in] hciReadPacket    The packet that is received from HCI interface.
     76          * @return 0 if HCI packet is as expected
     77          */

   \                                 In section .text, align 2, keep-with-next
     78          int HCI_verify(const tHciDataPacket * hciReadPacket)
     79          {
   \                     HCI_verify: (+1)
   \   00000000   0x0001             MOVS     R1,R0
     80            const uint8_t *hci_pckt = hciReadPacket->dataBuff;
   \   00000002   0xF111 0x0208      ADDS     R2,R1,#+8
     81            
     82            if(hci_pckt[HCI_PCK_TYPE_OFFSET] != HCI_EVENT_PKT)
   \   00000006   0x7810             LDRB     R0,[R2, #+0]
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD001             BEQ.N    ??HCI_verify_0
     83              return 1;  /* Incorrect type. */
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE008             B.N      ??HCI_verify_1
     84            
     85            if(hci_pckt[EVENT_PARAMETER_TOT_LEN_OFFSET] != hciReadPacket->data_len - (1+HCI_EVENT_HDR_SIZE))
   \                     ??HCI_verify_0: (+1)
   \   00000010   0x7890             LDRB     R0,[R2, #+2]
   \   00000012   0xF891 0x3088      LDRB     R3,[R1, #+136]
   \   00000016   0x1EDB             SUBS     R3,R3,#+3
   \   00000018   0x4298             CMP      R0,R3
   \   0000001A   0xD001             BEQ.N    ??HCI_verify_2
     86              return 2; /* Wrong length (packet truncated or too long). */
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0xE000             B.N      ??HCI_verify_1
     87            
     88            return 0;      
   \                     ??HCI_verify_2: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \                     ??HCI_verify_1: (+1)
   \   00000022   0x4770             BX       LR               ;; return
     89          }
     90          
     91          
     92          #ifdef BLUENRG1_NWK_COPROC
     93          
     94          void BTLE_StackTick(void)
     95          {
     96            uint32_t i;
     97            tHciDataPacket * hciReadPacket = NULL;
     98            
     99            Disable_SPI_IRQ();
    100            uint8_t list_empty = list_is_empty(&hciReadPktRxQueue);        
    101            /* process any pending events read */
    102            while(list_empty == FALSE)
    103            {
    104              list_remove_head (&hciReadPktRxQueue, (tListNode **)&hciReadPacket);
    105              Enable_SPI_IRQ(); 
    106              
    107              hci_uart_pckt *hci_pckt = (hci_uart_pckt *)hciReadPacket->dataBuff;
    108              
    109              if(hci_pckt->type == HCI_EVENT_PKT) {
    110                hci_event_pckt *event_pckt = (hci_event_pckt*)hci_pckt->data;
    111                
    112                if(event_pckt->evt == EVT_LE_META_EVENT) {
    113                  evt_le_meta_event *evt = (void *)event_pckt->data;
    114                  
    115                  for (i = 0; i < (sizeof(hci_le_meta_events_table)/sizeof(hci_le_meta_events_table_type)); i++) {
    116                    if (evt->subevent == hci_le_meta_events_table[i].evt_code) {
    117                      hci_le_meta_events_table[i].process((void *)evt->data);
    118                    }
    119                  }
    120                }
    121                else if(event_pckt->evt == EVT_VENDOR) {
    122                  evt_blue_aci *blue_evt = (void*)event_pckt->data;        
    123                  
    124                  for (i = 0; i < (sizeof(hci_vendor_specific_events_table)/sizeof(hci_vendor_specific_events_table_type)); i++) {
    125                    if (blue_evt->ecode == hci_vendor_specific_events_table[i].evt_code) {
    126                      hci_vendor_specific_events_table[i].process((void *)blue_evt->data);
    127                    }
    128                  }
    129                }
    130                else {        
    131                  for (i = 0; i < (sizeof(hci_events_table)/sizeof(hci_events_table_type)); i++) {
    132                    if (event_pckt->evt == hci_events_table[i].evt_code) {
    133                      hci_events_table[i].process((void *)event_pckt->data);
    134                    }
    135                  }
    136                }
    137              }
    138              
    139              Disable_SPI_IRQ();
    140              list_insert_tail(&hciReadPktPool, (tListNode *)hciReadPacket);
    141              list_empty = list_is_empty(&hciReadPktRxQueue);
    142            }
    143            
    144            /* Explicit call to HCI_Isr(), since it cannot be called by ISR if IRQ is kept high by
    145            BlueNRG. */
    146            HCI_Isr(); 
    147            Enable_SPI_IRQ();
    148            
    149          }
    150          
    151          #else
    152          

   \                                 In section .bss, align 4
    153          volatile uint8_t command_fifo[1024];
   \                     command_fifo:
   \   00000000                      DS8 1024

   \                                 In section .bss, align 2
    154          volatile uint16_t command_fifo_size = 0;
   \                     command_fifo_size:
   \   00000000                      DS8 2
    155          
    156          #ifdef DTM_SPI
    157          volatile uint8_t spi_irq_flag = FALSE;
    158          
    159          void BTLE_StackTick(void)
    160          {
    161            if(spi_irq_flag == TRUE) {
    162              spi_irq_flag = FALSE;
    163              BlueNRG_SPI_Read_Bridge();
    164            }
    165            
    166            if ((command_fifo_size > 0)) {
    167              /* Run a WRITE request */
    168          //    HAL_NVIC_DisableIRQ(UART_IRQ);
    169            __disable_irq();
    170              while(BlueNRG_SPI_Write_Bridge((uint8_t *)command_fifo, command_fifo_size)<0);
    171              command_fifo_size = 0;
    172          //    HAL_NVIC_EnableIRQ(UART_IRQ);
    173            __enable_irq();
    174            }
    175          }
    176          #else
    177          #ifdef DTM_UART
    178          extern UART_HandleTypeDef DTM_UartHandle;
    179          

   \                                 In section .text, align 2, keep-with-next
    180          void BTLE_StackTick(void)
    181          {
   \                     BTLE_StackTick: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    182            if ((command_fifo_size > 0)) {
   \   00000002   0x....             LDR.N    R0,??DataTable5_3
   \   00000004   0x8800             LDRH     R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD026             BEQ.N    ??BTLE_StackTick_0
    183              DTM_Config_UART_CTS();
   \   0000000A   0x.... 0x....      BL       DTM_Config_UART_CTS
    184              DTM_UART_RTS_OUTPUT_LOW();
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0xF44F 0x5180      MOV      R1,#+4096
   \   00000014   0x....             LDR.N    R0,??DataTable5_4  ;; 0x40020000
   \   00000016   0x.... 0x....      BL       HAL_GPIO_WritePin
    185              
    186              if(HAL_UART_Transmit(&DTM_UartHandle, (uint8_t*)command_fifo, command_fifo_size, 1000)!= HAL_OK) {
   \   0000001A   0xF44F 0x737A      MOV      R3,#+1000
   \   0000001E   0x....             LDR.N    R0,??DataTable5_3
   \   00000020   0x8802             LDRH     R2,[R0, #+0]
   \   00000022   0x....             LDR.N    R1,??DataTable5_5
   \   00000024   0x....             LDR.N    R0,??DataTable5_6
   \   00000026   0x.... 0x....      BL       HAL_UART_Transmit
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD000             BEQ.N    ??BTLE_StackTick_1
    187                while(1);   
   \                     ??BTLE_StackTick_2: (+1)
   \   0000002E   0xE7FE             B.N      ??BTLE_StackTick_2
    188              }
    189              command_fifo_size = 0;
   \                     ??BTLE_StackTick_1: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x....             LDR.N    R1,??DataTable5_3
   \   00000034   0x8008             STRH     R0,[R1, #+0]
    190              DTM_UART_RTS_OUTPUT_HIGH();
   \   00000036   0x2201             MOVS     R2,#+1
   \   00000038   0xF44F 0x5180      MOV      R1,#+4096
   \   0000003C   0x....             LDR.N    R0,??DataTable5_4  ;; 0x40020000
   \   0000003E   0x.... 0x....      BL       HAL_GPIO_WritePin
    191              DTM_UART_CTS_Input();
   \   00000042   0x.... 0x....      BL       DTM_UART_CTS_Input
    192              while((HAL_GPIO_ReadPin(DTM_USART_CTS_GPIO_PORT, DTM_USART_CTS_PIN) == GPIO_PIN_RESET));
   \                     ??BTLE_StackTick_3: (+1)
   \   00000046   0xF44F 0x6100      MOV      R1,#+2048
   \   0000004A   0x....             LDR.N    R0,??DataTable5_4  ;; 0x40020000
   \   0000004C   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD0F8             BEQ.N    ??BTLE_StackTick_3
    193              DTM_Config_GPIO_InputIrq_CTS();
   \   00000054   0x.... 0x....      BL       DTM_Config_GPIO_InputIrq_CTS
    194            }
    195          }
   \                     ??BTLE_StackTick_0: (+1)
   \   00000058   0xBD01             POP      {R0,PC}          ;; return
    196          #endif
    197          #endif
    198          #endif
    199          

   \                                 In section .text, align 2, keep-with-next
    200          BOOL HCI_Queue_Empty(void)
    201          {
   \                     HCI_Queue_Empty: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    202            return list_is_empty(&hciReadPktRxQueue);
   \   00000002   0x....             LDR.N    R0,??DataTable5_1
   \   00000004   0x.... 0x....      BL       list_is_empty
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
    203          }
    204          

   \                                 In section .text, align 2, keep-with-next
    205          void HCI_Isr(void)
    206          {
   \                     HCI_Isr: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    207            tHciDataPacket * hciReadPacket = NULL;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x9000             STR      R0,[SP, #+0]
    208            uint8_t data_len;
    209            
    210            Clear_SPI_EXTI_Flag();
   \   00000008   0x.... 0x....      BL       Clear_SPI_EXTI_Flag
    211            if(SdkEvalSPI_Irq_Pin()){
   \   0000000C   0x.... 0x....      BL       SdkEvalSPI_Irq_Pin
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD027             BEQ.N    ??HCI_Isr_0
    212              if (list_is_empty (&hciReadPktPool) == FALSE){
   \   00000014   0x....             LDR.N    R0,??DataTable5
   \   00000016   0x.... 0x....      BL       list_is_empty
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD122             BNE.N    ??HCI_Isr_0
    213                
    214                /* enqueueing a packet for read */
    215                list_remove_head (&hciReadPktPool, (tListNode **)&hciReadPacket);
   \   0000001E   0x4669             MOV      R1,SP
   \   00000020   0x....             LDR.N    R0,??DataTable5
   \   00000022   0x.... 0x....      BL       list_remove_head
    216                
    217                data_len = BlueNRG_SPI_Read_All(hciReadPacket->dataBuff, HCI_READ_PACKET_SIZE);
   \   00000026   0x2180             MOVS     R1,#+128
   \   00000028   0x9800             LDR      R0,[SP, #+0]
   \   0000002A   0x3008             ADDS     R0,R0,#+8
   \   0000002C   0x.... 0x....      BL       BlueNRG_SPI_Read_All
   \   00000030   0x0004             MOVS     R4,R0
    218                if(data_len > 0){                    
   \   00000032   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000034   0x2C00             CMP      R4,#+0
   \   00000036   0xD011             BEQ.N    ??HCI_Isr_1
    219                  hciReadPacket->data_len = data_len;
   \   00000038   0x9800             LDR      R0,[SP, #+0]
   \   0000003A   0xF880 0x4088      STRB     R4,[R0, #+136]
    220                  if(HCI_verify(hciReadPacket) == 0)
   \   0000003E   0x9800             LDR      R0,[SP, #+0]
   \   00000040   0x.... 0x....      BL       HCI_verify
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD104             BNE.N    ??HCI_Isr_2
    221                    list_insert_tail(&hciReadPktRxQueue, (tListNode *)hciReadPacket);
   \   00000048   0x9900             LDR      R1,[SP, #+0]
   \   0000004A   0x....             LDR.N    R0,??DataTable5_1
   \   0000004C   0x.... 0x....      BL       list_insert_tail
   \   00000050   0xE008             B.N      ??HCI_Isr_0
    222                  else
    223                    list_insert_head(&hciReadPktPool, (tListNode *)hciReadPacket);          
   \                     ??HCI_Isr_2: (+1)
   \   00000052   0x9900             LDR      R1,[SP, #+0]
   \   00000054   0x....             LDR.N    R0,??DataTable5
   \   00000056   0x.... 0x....      BL       list_insert_head
   \   0000005A   0xE003             B.N      ??HCI_Isr_0
    224                }
    225                else {
    226                  // Insert the packet back into the pool.
    227                  list_insert_head(&hciReadPktPool, (tListNode *)hciReadPacket);
   \                     ??HCI_Isr_1: (+1)
   \   0000005C   0x9900             LDR      R1,[SP, #+0]
   \   0000005E   0x....             LDR.N    R0,??DataTable5
   \   00000060   0x.... 0x....      BL       list_insert_head
    228                }
    229              }
    230            }
    231          }
   \                     ??HCI_Isr_0: (+1)
   \   00000064   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    232          

   \                                 In section .text, align 2, keep-with-next
    233          void hci_write(const void* data1, const void* data2, uint8_t n_bytes1, uint8_t n_bytes2){
   \                     hci_write: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    234          #if  HCI_LOG_ON
    235            PRINTF("HCI <- ");
    236            for(int i=0; i < n_bytes1; i++)
    237              PRINTF("%02X ", *((uint8_t*)data1 + i));
    238            for(int i=0; i < n_bytes2; i++)
    239              PRINTF("%02X ", *((uint8_t*)data2 + i));
    240            PRINTF("\n");    
    241          #endif
    242            
    243            Hal_Write_Serial(data1, data2, n_bytes1, n_bytes2);
   \   0000000A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000000C   0x003B             MOVS     R3,R7
   \   0000000E   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000010   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000012   0x0032             MOVS     R2,R6
   \   00000014   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000016   0x0029             MOVS     R1,R5
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       Hal_Write_Serial
    244          }
   \   0000001E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    245          

   \                                 In section .text, align 2, keep-with-next
    246          void hci_send_cmd(uint16_t ogf, uint16_t ocf, uint8_t plen, void *param)
    247          {
   \                     hci_send_cmd: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    248            hci_command_hdr hc;
    249            
    250            hc.opcode = (cmd_opcode_pack(ogf, ocf));
   \   0000000C   0x05A8             LSLS     R0,R5,#+22       ;; ZeroExtS R0,R5,#+22,#+22
   \   0000000E   0x0D80             LSRS     R0,R0,#+22
   \   00000010   0xEA50 0x2084      ORRS     R0,R0,R4, LSL #+10
   \   00000014   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    251            hc.plen= plen;
   \   00000018   0xF88D 0x6006      STRB     R6,[SP, #+6]
    252            
    253            uint8_t header[HCI_HDR_SIZE + HCI_COMMAND_HDR_SIZE];
    254            header[0] = HCI_COMMAND_PKT;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    255            Osal_MemCpy(header+1, &hc, sizeof(hc));
   \   00000022   0x2203             MOVS     R2,#+3
   \   00000024   0xA901             ADD      R1,SP,#+4
   \   00000026   0xF10D 0x0001      ADD      R0,SP,#+1
   \   0000002A   0x.... 0x....      BL       Osal_MemCpy
    256            
    257            hci_write(header, param, sizeof(header), plen);
   \   0000002E   0x0033             MOVS     R3,R6
   \   00000030   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000032   0x2204             MOVS     R2,#+4
   \   00000034   0x0039             MOVS     R1,R7
   \   00000036   0x4668             MOV      R0,SP
   \   00000038   0x.... 0x....      BL       hci_write
    258          }
   \   0000003C   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
    259          

   \                                 In section .text, align 2, keep-with-next
    260          static void move_list(tListNode * dest_list, tListNode * src_list)
    261          {
   \                     move_list: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    262            pListNode tmp_node;
    263            
    264            while(!list_is_empty(src_list)){
   \                     ??move_list_0: (+1)
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x.... 0x....      BL       list_is_empty
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD108             BNE.N    ??move_list_1
    265              list_remove_tail(src_list, &tmp_node);
   \   00000010   0x4669             MOV      R1,SP
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0x.... 0x....      BL       list_remove_tail
    266              list_insert_head(dest_list, tmp_node);
   \   00000018   0x9900             LDR      R1,[SP, #+0]
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       list_insert_head
   \   00000020   0xE7F1             B.N      ??move_list_0
    267            }
    268          }
   \                     ??move_list_1: (+1)
   \   00000022   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    269          
    270          /* It ensures that we have at least half of the free buffers in the pool. */

   \                                 In section .text, align 2, keep-with-next
    271          static void free_event_list(void)
    272          {
   \                     free_event_list: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    273            tHciDataPacket * pckt;
    274            
    275            Disable_SPI_IRQ();
   \   00000002   0x.... 0x....      BL       Disable_SPI_IRQ
    276            
    277            while(list_get_size(&hciReadPktPool) < HCI_READ_PACKET_NUM_MAX/2){
   \                     ??free_event_list_0: (+1)
   \   00000006   0x....             LDR.N    R0,??DataTable5
   \   00000008   0x.... 0x....      BL       list_get_size
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xDA0A             BGE.N    ??free_event_list_1
    278              list_remove_head(&hciReadPktRxQueue, (tListNode **)&pckt);    
   \   00000010   0x4669             MOV      R1,SP
   \   00000012   0x....             LDR.N    R0,??DataTable5_1
   \   00000014   0x.... 0x....      BL       list_remove_head
    279              list_insert_tail(&hciReadPktPool, (tListNode *)pckt);
   \   00000018   0x9900             LDR      R1,[SP, #+0]
   \   0000001A   0x....             LDR.N    R0,??DataTable5
   \   0000001C   0x.... 0x....      BL       list_insert_tail
    280              /* Explicit call to HCI_Isr(), since it cannot be called by ISR if IRQ is kept high by
    281              BlueNRG */
    282              HCI_Isr();
   \   00000020   0x.... 0x....      BL       HCI_Isr
   \   00000024   0xE7EF             B.N      ??free_event_list_0
    283            }
    284            
    285            Enable_SPI_IRQ();
   \                     ??free_event_list_1: (+1)
   \   00000026   0x.... 0x....      BL       Enable_SPI_IRQ
    286          }
   \   0000002A   0xBD01             POP      {R0,PC}          ;; return
    287          

   \                                 In section .text, align 2, keep-with-next
    288          int hci_send_req(struct hci_request *r, BOOL async)
    289          {
   \                     hci_send_req: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB089             SUB      SP,SP,#+36
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
    290            uint8_t *ptr;
    291            uint16_t opcode = (cmd_opcode_pack(r->ogf, r->ocf));
   \   0000000A   0x8860             LDRH     R0,[R4, #+2]
   \   0000000C   0x0580             LSLS     R0,R0,#+22       ;; ZeroExtS R0,R0,#+22,#+22
   \   0000000E   0x0D80             LSRS     R0,R0,#+22
   \   00000010   0x8821             LDRH     R1,[R4, #+0]
   \   00000012   0xEA50 0x2681      ORRS     R6,R0,R1, LSL #+10
    292            hci_event_pckt *event_pckt;
    293            hci_uart_pckt *hci_hdr;
    294            int to = DEFAULT_TIMEOUT;
   \   00000016   0x....             LDR.N    R0,??DataTable5_7
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x210A             MOVS     R1,#+10
   \   0000001C   0xFBB0 0xF8F1      UDIV     R8,R0,R1
    295            struct timer t;
    296            tHciDataPacket * hciReadPacket = NULL;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x9000             STR      R0,[SP, #+0]
    297            tListNode hciTempQueue;
    298            
    299            list_init_head(&hciTempQueue);
   \   00000024   0xA804             ADD      R0,SP,#+16
   \   00000026   0x.... 0x....      BL       list_init_head
    300            
    301            free_event_list();
   \   0000002A   0x.... 0x....      BL       free_event_list
    302            
    303            hci_send_cmd(r->ogf, r->ocf, r->clen, r->cparam);
   \   0000002E   0x68A3             LDR      R3,[R4, #+8]
   \   00000030   0x68E0             LDR      R0,[R4, #+12]
   \   00000032   0x0002             MOVS     R2,R0
   \   00000034   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000036   0x8861             LDRH     R1,[R4, #+2]
   \   00000038   0x8820             LDRH     R0,[R4, #+0]
   \   0000003A   0x.... 0x....      BL       hci_send_cmd
    304            
    305            if(async){
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0x2D00             CMP      R5,#+0
   \   00000042   0xD001             BEQ.N    ??hci_send_req_0
    306              return 0;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xE0B8             B.N      ??hci_send_req_1
    307            }
    308            
    309            /* Minimum timeout is 1. */
    310            if(to == 0)
   \                     ??hci_send_req_0: (+1)
   \   00000048   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000004C   0xD101             BNE.N    ??hci_send_req_2
    311              to = 1;
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0x4680             MOV      R8,R0
    312            
    313            Timer_Set(&t, to);
   \                     ??hci_send_req_2: (+1)
   \   00000052   0x4641             MOV      R1,R8
   \   00000054   0xA806             ADD      R0,SP,#+24
   \   00000056   0x.... 0x....      BL       Timer_Set
    314            
    315            while(1) {
    316              evt_cmd_complete *cc;
    317              evt_cmd_status *cs;
    318              evt_le_meta_event *me;
    319              int len;
    320              
    321          #if ENABLE_MICRO_SLEEP /* only STM32L1xx STD library */   
    322              while(1){
    323                ATOMIC_SECTION_BEGIN();
    324                if(Timer_Expired(&t)){
    325                  ATOMIC_SECTION_END();
    326                  goto failed;
    327                }
    328                if(!HCI_Queue_Empty()){
    329                  ATOMIC_SECTION_END();
    330                  break;
    331                }
    332                Enter_Sleep_Mode();
    333                ATOMIC_SECTION_END();
    334              }
    335          #else
    336              while(1){
    337                if(Timer_Expired(&t)){
   \                     ??hci_send_req_3: (+1)
   \                     ??hci_send_req_4: (+1)
   \   0000005A   0xA806             ADD      R0,SP,#+24
   \   0000005C   0x.... 0x....      BL       Timer_Expired
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xF040 0x808F      BNE.W    ??hci_send_req_5
    338                  goto failed;
    339                }
    340                if(!HCI_Queue_Empty()){
   \                     ??hci_send_req_6: (+1)
   \   00000066   0x.... 0x....      BL       HCI_Queue_Empty
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD1F5             BNE.N    ??hci_send_req_4
    341                  break;
    342                }
    343              }
    344          #endif
    345              
    346              /* Extract packet from HCI event queue. */
    347              Disable_SPI_IRQ();
   \   0000006E   0x.... 0x....      BL       Disable_SPI_IRQ
    348              list_remove_head(&hciReadPktRxQueue, (tListNode **)&hciReadPacket);    
   \   00000072   0x4669             MOV      R1,SP
   \   00000074   0x....             LDR.N    R0,??DataTable5_1
   \   00000076   0x.... 0x....      BL       list_remove_head
    349              
    350              hci_hdr = (void *)hciReadPacket->dataBuff;
   \   0000007A   0x9800             LDR      R0,[SP, #+0]
   \   0000007C   0x3008             ADDS     R0,R0,#+8
   \   0000007E   0x0007             MOVS     R7,R0
    351              
    352              if(hci_hdr->type == HCI_EVENT_PKT){
   \   00000080   0x7838             LDRB     R0,[R7, #+0]
   \   00000082   0x2804             CMP      R0,#+4
   \   00000084   0xD162             BNE.N    ??hci_send_req_7
    353                
    354                event_pckt = (void *) (hci_hdr->data);
   \   00000086   0x1C78             ADDS     R0,R7,#+1
   \   00000088   0x9003             STR      R0,[SP, #+12]
    355                
    356                ptr = hciReadPacket->dataBuff + (1 + HCI_EVENT_HDR_SIZE);
   \   0000008A   0x9800             LDR      R0,[SP, #+0]
   \   0000008C   0x300B             ADDS     R0,R0,#+11
   \   0000008E   0x4682             MOV      R10,R0
    357                len = hciReadPacket->data_len - (1 + HCI_EVENT_HDR_SIZE);
   \   00000090   0x9800             LDR      R0,[SP, #+0]
   \   00000092   0xF890 0x0088      LDRB     R0,[R0, #+136]
   \   00000096   0x1EC0             SUBS     R0,R0,#+3
   \   00000098   0x4683             MOV      R11,R0
    358                
    359                switch (event_pckt->evt) {
   \   0000009A   0x9803             LDR      R0,[SP, #+12]
   \   0000009C   0x7800             LDRB     R0,[R0, #+0]
   \   0000009E   0x280E             CMP      R0,#+14
   \   000000A0   0xD022             BEQ.N    ??hci_send_req_8
   \   000000A2   0x280F             CMP      R0,#+15
   \   000000A4   0xD004             BEQ.N    ??hci_send_req_9
   \   000000A6   0x2810             CMP      R0,#+16
   \   000000A8   0xD04F             BEQ.N    ??hci_send_req_10
   \   000000AA   0x283E             CMP      R0,#+62
   \   000000AC   0xD036             BEQ.N    ??hci_send_req_11
   \   000000AE   0xE04D             B.N      ??hci_send_req_12
    360                  
    361                case EVT_CMD_STATUS:
    362                  cs = (void *) ptr;
   \                     ??hci_send_req_9: (+1)
   \   000000B0   0x46D1             MOV      R9,R10
    363                  
    364                  if (cs->opcode != opcode)
   \   000000B2   0xF8B9 0x0002      LDRH     R0,[R9, #+2]
   \   000000B6   0x0031             MOVS     R1,R6
   \   000000B8   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000BA   0x4288             CMP      R0,R1
   \   000000BC   0xD162             BNE.N    ??hci_send_req_5
    365                    goto failed;
    366                  
    367                  if (r->event != EVT_CMD_STATUS) {
   \                     ??hci_send_req_13: (+1)
   \   000000BE   0x6860             LDR      R0,[R4, #+4]
   \   000000C0   0x280F             CMP      R0,#+15
   \   000000C2   0xD004             BEQ.N    ??hci_send_req_14
    368                    if (cs->status) {
   \   000000C4   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD15B             BNE.N    ??hci_send_req_5
    369                      goto failed;
    370                    }
    371                    break;
   \                     ??hci_send_req_15: (+1)
   \   000000CC   0xE03E             B.N      ??hci_send_req_7
    372                  }
    373                  
    374                  r->rlen = MIN(len, r->rlen);
   \                     ??hci_send_req_14: (+1)
   \   000000CE   0x6960             LDR      R0,[R4, #+20]
   \   000000D0   0x4583             CMP      R11,R0
   \   000000D2   0xDA01             BGE.N    ??hci_send_req_16
   \   000000D4   0x4658             MOV      R0,R11
   \   000000D6   0xE000             B.N      ??hci_send_req_17
   \                     ??hci_send_req_16: (+1)
   \   000000D8   0x6960             LDR      R0,[R4, #+20]
   \                     ??hci_send_req_17: (+1)
   \   000000DA   0x6160             STR      R0,[R4, #+20]
    375                  Osal_MemCpy(r->rparam, ptr, r->rlen);
   \   000000DC   0x6962             LDR      R2,[R4, #+20]
   \   000000DE   0x4651             MOV      R1,R10
   \   000000E0   0x6920             LDR      R0,[R4, #+16]
   \   000000E2   0x.... 0x....      BL       Osal_MemCpy
    376                  goto done;
   \   000000E6   0xE05D             B.N      ??hci_send_req_18
    377                  
    378                case EVT_CMD_COMPLETE:
    379                  cc = (void *) ptr;
   \                     ??hci_send_req_8: (+1)
   \   000000E8   0xF8CD 0xA008      STR      R10,[SP, #+8]
    380                  
    381                  if (cc->opcode != opcode)
   \   000000EC   0x9802             LDR      R0,[SP, #+8]
   \   000000EE   0xF8B0 0x0001      LDRH     R0,[R0, #+1]
   \   000000F2   0x0031             MOVS     R1,R6
   \   000000F4   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000F6   0x4288             CMP      R0,R1
   \   000000F8   0xD144             BNE.N    ??hci_send_req_5
    382                    goto failed;
    383                  
    384                  ptr += EVT_CMD_COMPLETE_SIZE;
   \                     ??hci_send_req_19: (+1)
   \   000000FA   0xF11A 0x0A03      ADDS     R10,R10,#+3
    385                  len -= EVT_CMD_COMPLETE_SIZE;
   \   000000FE   0xF1BB 0x0B03      SUBS     R11,R11,#+3
    386                  
    387                  r->rlen = MIN(len, r->rlen);
   \   00000102   0x6960             LDR      R0,[R4, #+20]
   \   00000104   0x4583             CMP      R11,R0
   \   00000106   0xDA01             BGE.N    ??hci_send_req_20
   \   00000108   0x4658             MOV      R0,R11
   \   0000010A   0xE000             B.N      ??hci_send_req_21
   \                     ??hci_send_req_20: (+1)
   \   0000010C   0x6960             LDR      R0,[R4, #+20]
   \                     ??hci_send_req_21: (+1)
   \   0000010E   0x6160             STR      R0,[R4, #+20]
    388                  Osal_MemCpy(r->rparam, ptr, r->rlen);
   \   00000110   0x6962             LDR      R2,[R4, #+20]
   \   00000112   0x4651             MOV      R1,R10
   \   00000114   0x6920             LDR      R0,[R4, #+16]
   \   00000116   0x.... 0x....      BL       Osal_MemCpy
    389                  goto done;
   \   0000011A   0xE043             B.N      ??hci_send_req_18
    390                  
    391                case EVT_LE_META_EVENT:
    392                  me = (void *) ptr;
   \                     ??hci_send_req_11: (+1)
   \   0000011C   0xF8CD 0xA004      STR      R10,[SP, #+4]
    393                  
    394                  if (me->subevent != r->event)
   \   00000120   0x9801             LDR      R0,[SP, #+4]
   \   00000122   0x7800             LDRB     R0,[R0, #+0]
   \   00000124   0x6861             LDR      R1,[R4, #+4]
   \   00000126   0x4288             CMP      R0,R1
   \   00000128   0xD110             BNE.N    ??hci_send_req_7
    395                    break;
    396                  
    397                  len -= 1;
   \                     ??hci_send_req_22: (+1)
   \   0000012A   0xF1BB 0x0B01      SUBS     R11,R11,#+1
    398                  r->rlen = MIN(len, r->rlen);
   \   0000012E   0x6960             LDR      R0,[R4, #+20]
   \   00000130   0x4583             CMP      R11,R0
   \   00000132   0xDA01             BGE.N    ??hci_send_req_23
   \   00000134   0x4658             MOV      R0,R11
   \   00000136   0xE000             B.N      ??hci_send_req_24
   \                     ??hci_send_req_23: (+1)
   \   00000138   0x6960             LDR      R0,[R4, #+20]
   \                     ??hci_send_req_24: (+1)
   \   0000013A   0x6160             STR      R0,[R4, #+20]
    399                  Osal_MemCpy(r->rparam, me->data, r->rlen);
   \   0000013C   0x6962             LDR      R2,[R4, #+20]
   \   0000013E   0x9801             LDR      R0,[SP, #+4]
   \   00000140   0x1C41             ADDS     R1,R0,#+1
   \   00000142   0x6920             LDR      R0,[R4, #+16]
   \   00000144   0x.... 0x....      BL       Osal_MemCpy
    400                  goto done;
   \   00000148   0xE02C             B.N      ??hci_send_req_18
    401                  
    402                case EVT_HARDWARE_ERROR:            
    403                  goto failed;
   \                     ??hci_send_req_10: (+1)
   \   0000014A   0xE01B             B.N      ??hci_send_req_5
    404                  
    405                default:      
    406                  break;
    407                }
    408              }
    409              
    410              /* If there are no more packets to be processed, be sure there is at list one
    411              packet in the pool to process the expected event.
    412              If no free packets are available, discard the processed event and insert it
    413              into the pool. */
    414              if(list_is_empty(&hciReadPktPool) && list_is_empty(&hciReadPktRxQueue)){
   \                     ??hci_send_req_12: (+1)
   \                     ??hci_send_req_7: (+1)
   \   0000014C   0x....             LDR.N    R0,??DataTable5
   \   0000014E   0x.... 0x....      BL       list_is_empty
   \   00000152   0x2800             CMP      R0,#+0
   \   00000154   0xD00B             BEQ.N    ??hci_send_req_25
   \   00000156   0x....             LDR.N    R0,??DataTable5_1
   \   00000158   0x.... 0x....      BL       list_is_empty
   \   0000015C   0x2800             CMP      R0,#+0
   \   0000015E   0xD006             BEQ.N    ??hci_send_req_25
    415                list_insert_tail(&hciReadPktPool, (tListNode *)hciReadPacket);
   \   00000160   0x9900             LDR      R1,[SP, #+0]
   \   00000162   0x....             LDR.N    R0,??DataTable5
   \   00000164   0x.... 0x....      BL       list_insert_tail
    416                hciReadPacket=NULL;
   \   00000168   0x2000             MOVS     R0,#+0
   \   0000016A   0x9000             STR      R0,[SP, #+0]
   \   0000016C   0xE005             B.N      ??hci_send_req_26
    417              }
    418              else {
    419                /* Insert the packet in a different queue. These packets will be
    420                inserted back in the main queue just before exiting from send_req(), so that
    421                these events can be processed by the application.
    422                */
    423                list_insert_tail(&hciTempQueue, (tListNode *)hciReadPacket);
   \                     ??hci_send_req_25: (+1)
   \   0000016E   0x9900             LDR      R1,[SP, #+0]
   \   00000170   0xA804             ADD      R0,SP,#+16
   \   00000172   0x.... 0x....      BL       list_insert_tail
    424                hciReadPacket=NULL;
   \   00000176   0x2000             MOVS     R0,#+0
   \   00000178   0x9000             STR      R0,[SP, #+0]
    425              }
    426              
    427              HCI_Isr();
   \                     ??hci_send_req_26: (+1)
   \   0000017A   0x.... 0x....      BL       HCI_Isr
    428              
    429              Enable_SPI_IRQ();
   \   0000017E   0x.... 0x....      BL       Enable_SPI_IRQ
   \   00000182   0xE76A             B.N      ??hci_send_req_3
    430              
    431            }
    432            
    433          failed:
    434            if(hciReadPacket!=NULL){
   \                     ??hci_send_req_5: (+1)
   \   00000184   0x9800             LDR      R0,[SP, #+0]
   \   00000186   0x2800             CMP      R0,#+0
   \   00000188   0xD003             BEQ.N    ??hci_send_req_27
    435              list_insert_head(&hciReadPktPool, (tListNode *)hciReadPacket);
   \   0000018A   0x9900             LDR      R1,[SP, #+0]
   \   0000018C   0x....             LDR.N    R0,??DataTable5
   \   0000018E   0x.... 0x....      BL       list_insert_head
    436            }
    437            move_list(&hciReadPktRxQueue, &hciTempQueue);
   \                     ??hci_send_req_27: (+1)
   \   00000192   0xA904             ADD      R1,SP,#+16
   \   00000194   0x....             LDR.N    R0,??DataTable5_1
   \   00000196   0x.... 0x....      BL       move_list
    438            
    439            Enable_SPI_IRQ();
   \   0000019A   0x.... 0x....      BL       Enable_SPI_IRQ
    440            return -1;
   \   0000019E   0xF05F 0x30FF      MOVS     R0,#-1
   \   000001A2   0xE00A             B.N      ??hci_send_req_1
    441            
    442          done:
    443            // Insert the packet back into the pool.
    444            list_insert_head(&hciReadPktPool, (tListNode *)hciReadPacket); 
   \                     ??hci_send_req_18: (+1)
   \   000001A4   0x9900             LDR      R1,[SP, #+0]
   \   000001A6   0x....             LDR.N    R0,??DataTable5
   \   000001A8   0x.... 0x....      BL       list_insert_head
    445            move_list(&hciReadPktRxQueue, &hciTempQueue);
   \   000001AC   0xA904             ADD      R1,SP,#+16
   \   000001AE   0x....             LDR.N    R0,??DataTable5_1
   \   000001B0   0x.... 0x....      BL       move_list
    446            
    447            Enable_SPI_IRQ();
   \   000001B4   0x.... 0x....      BL       Enable_SPI_IRQ
    448            return 0;
   \   000001B8   0x2000             MOVS     R0,#+0
   \                     ??hci_send_req_1: (+1)
   \   000001BA   0xB009             ADD      SP,SP,#+36
   \   000001BC   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    449          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     hciReadPktPool

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     hciReadPktRxQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     hciReadPacketBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     command_fifo_size

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     command_fifo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x........         DC32     DTM_UartHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x........         DC32     CLOCK_SECOND
    450          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   BTLE_StackTick
         8   -> DTM_Config_GPIO_InputIrq_CTS
         8   -> DTM_Config_UART_CTS
         8   -> DTM_UART_CTS_Input
         8   -> HAL_GPIO_ReadPin
         8   -> HAL_GPIO_WritePin
         8   -> HAL_UART_Transmit
      16   BlueNRG_Stack_Initialization
        16   -> BlueNRG_RST
        16   -> list_init_head
        16   -> list_insert_tail
      16   HCI_Isr
        16   -> BlueNRG_SPI_Read_All
        16   -> Clear_SPI_EXTI_Flag
        16   -> HCI_verify
        16   -> SdkEvalSPI_Irq_Pin
        16   -> list_insert_head
        16   -> list_insert_tail
        16   -> list_is_empty
        16   -> list_remove_head
       8   HCI_Queue_Empty
         8   -> list_is_empty
       0   HCI_verify
       8   free_event_list
         8   -> Disable_SPI_IRQ
         8   -> Enable_SPI_IRQ
         8   -> HCI_Isr
         8   -> list_get_size
         8   -> list_insert_tail
         8   -> list_remove_head
      32   hci_send_cmd
        32   -> Osal_MemCpy
        32   -> hci_write
      72   hci_send_req
        72   -> Disable_SPI_IRQ
        72   -> Enable_SPI_IRQ
        72   -> HCI_Isr
        72   -> HCI_Queue_Empty
        72   -> Osal_MemCpy
        72   -> Timer_Expired
        72   -> Timer_Set
        72   -> free_event_list
        72   -> hci_send_cmd
        72   -> list_init_head
        72   -> list_insert_head
        72   -> list_insert_tail
        72   -> list_is_empty
        72   -> list_remove_head
        72   -> move_list
      24   hci_write
        24   -> Hal_Write_Serial
      16   move_list
        16   -> list_insert_head
        16   -> list_is_empty
        16   -> list_remove_tail


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
      90  BTLE_StackTick
      66  BlueNRG_Stack_Initialization
     102  HCI_Isr
      10  HCI_Queue_Empty
      36  HCI_verify
    1024  command_fifo
       2  command_fifo_size
      44  free_event_list
     700  hciReadPacketBuffer
       8  hciReadPktPool
       8  hciReadPktRxQueue
      62  hci_send_cmd
     448  hci_send_req
      32  hci_write
      36  move_list

 
 1 742 bytes in section .bss
   958 bytes in section .text
 
   958 bytes of CODE memory
 1 742 bytes of DATA memory

Errors: none
Warnings: none
