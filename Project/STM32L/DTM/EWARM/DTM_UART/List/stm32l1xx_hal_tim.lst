###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       29/Jan/2018  14:45:27
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_tim.c
#    Command line =  
#        "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_tim.c"
#        -D STM32L151xB -D STM32L1XX_XL -D USE_STM32L1XX_STEVAL_IDB00xV1 -D
#        USE_HAL_DRIVER -D HCLK_32MHZ=1 -D SYSCLK_MSI=1 -D ENABLE_USART -D
#        USER_DEFINED_PLATFORM=USER_EVAL_PLATFORM -D IRQ_RESET_PIN -D DTM_UART
#        -lC "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\List"
#        -o "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        D:\Software\IAR_BlueNRG\arm\INC\c\DLib_Config_Normal.h -I
#        "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\HAL\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\BSP\STM32L1xx_BlueNRG1\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\BSP\STM32L1xx_Nucleo\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\CMSIS\Device\ST\STM32L1xx\Include\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\STM32L1xx_HAL_BlueNRG1_Drivers\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\SimpleBlueNRG1_HCI\includes\"
#        -On --use_c++_inline -I D:\Software\IAR_BlueNRG\arm\CMSIS\Include\
#    Locale       =  Chinese (Simplified)_China.936
#    List file    =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\List\stm32l1xx_hal_tim.lst
#    Object file  =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\Obj\stm32l1xx_hal_tim.o
#
###############################################################################

C:\Users\Administrator\Desktop\Temporary Files\eeworld_project\Project_Test\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_tim.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_hal_tim.c
      4            * @author  MCD Application Team
      5            * @version V1.1.1
      6            * @date    31-March-2015
      7            * @brief   TIM HAL module driver
      8            *          This file provides firmware functions to manage the following
      9            *          functionalities of the Timer (TIM) peripheral:
     10            *           + Time Base Initialization
     11            *           + Time Base Start
     12            *           + Time Base Start Interruption
     13            *           + Time Base Start DMA
     14            *           + Time Output Compare/PWM Initialization
     15            *           + Time Output Compare/PWM Channel Configuration
     16            *           + Time Output Compare/PWM Start
     17            *           + Time Output Compare/PWM Start Interruption
     18            *           + Time Output Compare/PWM Start DMA
     19            *           + Time Input Capture Initialization
     20            *           + Time Input Capture Channel Configuration
     21            *           + Time Input Capture Start
     22            *           + Time Input Capture Start Interruption
     23            *           + Time Input Capture Start DMA
     24            *           + Time One Pulse Initialization
     25            *           + Time One Pulse Channel Configuration
     26            *           + Time One Pulse Start
     27            *           + Time Encoder Interface Initialization
     28            *           + Time Encoder Interface Start
     29            *           + Time Encoder Interface Start Interruption
     30            *           + Time Encoder Interface Start DMA
     31            *           + Commutation Event configuration with Interruption and DMA
     32            *           + Time OCRef clear configuration
     33            *           + Time External Clock configuration
     34            *           + Time Master and Slave synchronization configuration
     35            @verbatim
     36            ==============================================================================
     37                                ##### TIMER Generic features #####
     38            ==============================================================================
     39            [..] The Timer features include:
     40                 (#) 16-bit up, down, up/down auto-reload counter.
     41                 (#) 16-bit programmable prescaler allowing dividing (also on the fly) the
     42                     counter clock frequency either by any factor between 1 and 65536.
     43                 (#) Up to 4 independent channels for:
     44                     (++) Input Capture
     45                     (++) Output Compare
     46                     (++) PWM generation (Edge and Center-aligned Mode)
     47                     (++) One-pulse mode output
     48                 (#) Synchronization circuit to control the timer with external signals and to interconnect
     49                     several timers together.
     50                 (#) Supports incremental (quadrature) encoder
     51          
     52                      ##### How to use this driver #####
     53          ================================================================================
     54              [..]
     55               (#) Initialize the TIM low level resources by implementing the following functions
     56                   depending from feature used :
     57                     (++) Time Base : HAL_TIM_Base_MspInit()
     58                     (++) Input Capture : HAL_TIM_IC_MspInit()
     59                     (++) Output Compare : HAL_TIM_OC_MspInit()
     60                     (++) PWM generation : HAL_TIM_PWM_MspInit()
     61                     (++) One-pulse mode output : HAL_TIM_OnePulse_MspInit()
     62                     (++) Encoder mode output : HAL_TIM_Encoder_MspInit()
     63          
     64               (#) Initialize the TIM low level resources :
     65                  (##) Enable the TIM interface clock using __HAL_RCC_TIMx_CLK_ENABLE();
     66                  (##) TIM pins configuration
     67                      (+++) Enable the clock for the TIM GPIOs using the following function:
     68                       __HAL_RCC_GPIOx_CLK_ENABLE();
     69                      (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();
     70          
     71               (#) The external Clock can be configured, if needed (the default clock is the
     72                   internal clock from the APBx), using the following function:
     73                   HAL_TIM_ConfigClockSource, the clock configuration should be done before
     74                   any start function.
     75          
     76               (#) Configure the TIM in the desired functioning mode using one of the
     77                 Initialization function of this driver:
     78                 (++) HAL_TIM_Base_Init: to use the Timer to generate a simple time base
     79                 (++) HAL_TIM_OC_Init and HAL_TIM_OC_ConfigChannel: to use the Timer to generate an
     80                      Output Compare signal.
     81                 (++) HAL_TIM_PWM_Init and HAL_TIM_PWM_ConfigChannel: to use the Timer to generate a
     82                      PWM signal.
     83                 (++) HAL_TIM_IC_Init and HAL_TIM_IC_ConfigChannel: to use the Timer to measure an
     84                      external signal.
     85                 (++) HAL_TIM_OnePulse_Init and HAL_TIM_OnePulse_ConfigChannel: to use the Timer
     86                      in One Pulse Mode.
     87                 (++) HAL_TIM_Encoder_Init: to use the Timer Encoder Interface.
     88          
     89               (#) Activate the TIM peripheral using one of the start functions depending from the feature used:
     90                     (++) Time Base : HAL_TIM_Base_Start(), HAL_TIM_Base_Start_DMA(), HAL_TIM_Base_Start_IT()
     91                     (++) Input Capture :  HAL_TIM_IC_Start(), HAL_TIM_IC_Start_DMA(), HAL_TIM_IC_Start_IT()
     92                     (++) Output Compare : HAL_TIM_OC_Start(), HAL_TIM_OC_Start_DMA(), HAL_TIM_OC_Start_IT()
     93                     (++) PWM generation : HAL_TIM_PWM_Start(), HAL_TIM_PWM_Start_DMA(), HAL_TIM_PWM_Start_IT()
     94                     (++) One-pulse mode output : HAL_TIM_OnePulse_Start(), HAL_TIM_OnePulse_Start_IT()
     95                     (++) Encoder mode output : HAL_TIM_Encoder_Start(), HAL_TIM_Encoder_Start_DMA(), HAL_TIM_Encoder_Start_IT().
     96          
     97               (#) The DMA Burst is managed with the two following functions:
     98                   HAL_TIM_DMABurst_WriteStart()
     99                   HAL_TIM_DMABurst_ReadStart()
    100          
    101            @endverbatim
    102            ******************************************************************************
    103            * @attention
    104            *
    105            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
    106            *
    107            * Redistribution and use in source and binary forms, with or without modification,
    108            * are permitted provided that the following conditions are met:
    109            *   1. Redistributions of source code must retain the above copyright notice,
    110            *      this list of conditions and the following disclaimer.
    111            *   2. Redistributions in binary form must reproduce the above copyright notice,
    112            *      this list of conditions and the following disclaimer in the documentation
    113            *      and/or other materials provided with the distribution.
    114            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    115            *      may be used to endorse or promote products derived from this software
    116            *      without specific prior written permission.
    117            *
    118            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    119            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    120            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    121            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    122            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    123            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    124            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    125            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    126            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    127            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    128            *
    129            ******************************************************************************
    130            */
    131          
    132          /* Includes ------------------------------------------------------------------*/
    133          #include "stm32l1xx_hal.h"
    134          
    135          /** @addtogroup STM32L1xx_HAL_Driver
    136            * @{
    137            */
    138          
    139          /** @defgroup TIM TIM
    140            * @brief TIM HAL module driver
    141            * @{
    142            */
    143          
    144          #ifdef HAL_TIM_MODULE_ENABLED
    145          
    146          /* Private typedef -----------------------------------------------------------*/
    147          /* Private define ------------------------------------------------------------*/
    148          /* Private macro -------------------------------------------------------------*/
    149          /* Private variables ---------------------------------------------------------*/
    150          /* Private function prototypes -----------------------------------------------*/
    151          /** @defgroup TIM_Private_Functions TIM Private Functions
    152            * @{
    153            */
    154          static void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure);
    155          static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    156          static void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    157          static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    158          static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    159          static void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection, uint32_t TIM_ICFilter);
    160          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    161          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection, uint32_t TIM_ICFilter);
    162          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    163          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection, uint32_t TIM_ICFilter);
    164          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection, uint32_t TIM_ICFilter);
    165          static void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler, uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter);
    166          static void TIM_ITRx_SetConfig(TIM_TypeDef* TIMx, uint16_t InputTriggerSource);
    167          static void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState);
    168          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma);
    169          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma);
    170          static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef * sSlaveConfig);
    171          
    172          /**
    173              * @}
    174            */
    175          
    176          /* Exported functions ---------------------------------------------------------*/
    177          
    178          /** @defgroup TIM_Exported_Functions TIM Exported Functions
    179            * @{
    180            */
    181          
    182          /** @defgroup TIM_Exported_Functions_Group1 Time Base functions
    183           *  @brief    Time Base functions
    184           *
    185          @verbatim
    186            ==============================================================================
    187                        ##### Time Base functions #####
    188            ==============================================================================
    189            [..]
    190              This section provides functions allowing to:
    191              (+) Initialize and configure the TIM base.
    192              (+) De-initialize the TIM base.
    193              (+) Start the Time Base.
    194              (+) Stop the Time Base.
    195              (+) Start the Time Base and enable interrupt.
    196              (+) Stop the Time Base and disable interrupt.
    197              (+) Start the Time Base and enable DMA transfer.
    198              (+) Stop the Time Base and disable DMA transfer.
    199          
    200          @endverbatim
    201            * @{
    202            */
    203          /**
    204            * @brief  Initializes the TIM Time base Unit according to the specified
    205            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    206            * @param  htim: TIM Base handle
    207            * @retval HAL status
    208            */

   \                                 In section .text, align 2, keep-with-next
    209          HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
    210          {
   \                     HAL_TIM_Base_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    211            /* Check the TIM handle allocation */
    212            if(htim == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_TIM_Base_Init_0
    213            {
    214              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE014             B.N      ??HAL_TIM_Base_Init_1
    215            }
    216          
    217            /* Check the parameters */
    218            assert_param(IS_TIM_INSTANCE(htim->Instance));
    219            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    220            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    221          
    222            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_Base_Init_0: (+1)
   \   0000000C   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD105             BNE.N    ??HAL_TIM_Base_Init_2
    223            {
    224              /* Allocate lock resource and initialize it */
    225              htim->Lock = HAL_UNLOCKED;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF884 0x0034      STRB     R0,[R4, #+52]
    226          
    227              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    228              HAL_TIM_Base_MspInit(htim);
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_TIM_Base_MspInit
    229            }
    230          
    231            /* Set the TIM state */
    232            htim->State= HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Base_Init_2: (+1)
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xF884 0x0035      STRB     R0,[R4, #+53]
    233          
    234            /* Set the Time Base configuration */
    235            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \   00000026   0x1D21             ADDS     R1,R4,#+4
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x.... 0x....      BL       TIM_Base_SetConfig
    236          
    237            /* Initialize the TIM state*/
    238            htim->State= HAL_TIM_STATE_READY;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF884 0x0035      STRB     R0,[R4, #+53]
    239          
    240            return HAL_OK;
   \   00000034   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_Base_Init_1: (+1)
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
    241          }
    242          
    243          /**
    244            * @brief  DeInitializes the TIM Base peripheral
    245            * @param  htim: TIM Base handle
    246            * @retval HAL status
    247            */

   \                                 In section .text, align 2, keep-with-next
    248          HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
    249          {
   \                     HAL_TIM_Base_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    250            /* Check the parameters */
    251            assert_param(IS_TIM_INSTANCE(htim->Instance));
    252          
    253            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0035      STRB     R0,[R4, #+53]
    254          
    255            /* Disable the TIM Peripheral Clock */
    256            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A00             LDR      R0,[R0, #+32]
   \   0000000E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000012   0x4208             TST      R0,R1
   \   00000014   0xD105             BNE.N    ??HAL_TIM_Base_DeInit_0
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x0840             LSRS     R0,R0,#+1
   \   0000001C   0x0040             LSLS     R0,R0,#+1
   \   0000001E   0x6821             LDR      R1,[R4, #+0]
   \   00000020   0x6008             STR      R0,[R1, #+0]
    257          
    258            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    259            HAL_TIM_Base_MspDeInit(htim);
   \                     ??HAL_TIM_Base_DeInit_0: (+1)
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       HAL_TIM_Base_MspDeInit
    260          
    261            /* Change TIM state */
    262            htim->State = HAL_TIM_STATE_RESET;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF884 0x0035      STRB     R0,[R4, #+53]
    263          
    264            /* Release Lock */
    265            __HAL_UNLOCK(htim);
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0034      STRB     R0,[R4, #+52]
    266          
    267            return HAL_OK;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
    268          }
    269          
    270          /**
    271            * @brief  Initializes the TIM Base MSP.
    272            * @param  htim: TIM handle
    273            * @retval None
    274            */

   \                                 In section .text, align 2
    275          __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
    276          {
    277            /* NOTE : This function Should not be modified, when the callback is needed,
    278                      the HAL_TIM_Base_MspInit could be implemented in the user file
    279             */
    280          }
   \                     HAL_TIM_Base_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    281          
    282          /**
    283            * @brief  DeInitializes TIM Base MSP.
    284            * @param  htim: TIM handle
    285            * @retval None
    286            */

   \                                 In section .text, align 2
    287          __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
    288          {
    289            /* NOTE : This function Should not be modified, when the callback is needed,
    290                      the HAL_TIM_Base_MspDeInit could be implemented in the user file
    291             */
    292          }
   \                     HAL_TIM_Base_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    293          
    294          
    295          /**
    296            * @brief  Starts the TIM Base generation.
    297            * @param  htim : TIM handle
    298            * @retval HAL status
    299          */

   \                                 In section .text, align 2, keep-with-next
    300          HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
    301          {
   \                     HAL_TIM_Base_Start: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    302            /* Check the parameters */
    303            assert_param(IS_TIM_INSTANCE(htim->Instance));
    304          
    305            /* Set the TIM state */
    306            htim->State= HAL_TIM_STATE_BUSY;
   \   00000002   0x2002             MOVS     R0,#+2
   \   00000004   0xF881 0x0035      STRB     R0,[R1, #+53]
    307          
    308            /* Enable the Peripheral */
    309            __HAL_TIM_ENABLE(htim);
   \   00000008   0x6808             LDR      R0,[R1, #+0]
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000010   0x680A             LDR      R2,[R1, #+0]
   \   00000012   0x6010             STR      R0,[R2, #+0]
    310          
    311            /* Change the TIM state*/
    312            htim->State= HAL_TIM_STATE_READY;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF881 0x0035      STRB     R0,[R1, #+53]
    313          
    314            /* Return function status */
    315            return HAL_OK;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x4770             BX       LR               ;; return
    316          }
    317          
    318          /**
    319            * @brief  Stops the TIM Base generation.
    320            * @param  htim : TIM handle
    321            * @retval HAL status
    322          */

   \                                 In section .text, align 2, keep-with-next
    323          HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
    324          {
   \                     HAL_TIM_Base_Stop: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    325            /* Check the parameters */
    326            assert_param(IS_TIM_INSTANCE(htim->Instance));
    327          
    328            /* Set the TIM state */
    329            htim->State= HAL_TIM_STATE_BUSY;
   \   00000002   0x2002             MOVS     R0,#+2
   \   00000004   0xF881 0x0035      STRB     R0,[R1, #+53]
    330          
    331            /* Disable the Peripheral */
    332            __HAL_TIM_DISABLE(htim);
   \   00000008   0x6808             LDR      R0,[R1, #+0]
   \   0000000A   0x6A00             LDR      R0,[R0, #+32]
   \   0000000C   0xF241 0x1211      MOVW     R2,#+4369
   \   00000010   0x4210             TST      R0,R2
   \   00000012   0xD105             BNE.N    ??HAL_TIM_Base_Stop_0
   \   00000014   0x6808             LDR      R0,[R1, #+0]
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x0840             LSRS     R0,R0,#+1
   \   0000001A   0x0040             LSLS     R0,R0,#+1
   \   0000001C   0x680A             LDR      R2,[R1, #+0]
   \   0000001E   0x6010             STR      R0,[R2, #+0]
    333          
    334            /* Change the TIM state*/
    335            htim->State= HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Base_Stop_0: (+1)
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xF881 0x0035      STRB     R0,[R1, #+53]
    336          
    337            /* Return function status */
    338            return HAL_OK;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x4770             BX       LR               ;; return
    339          }
    340          
    341          /**
    342            * @brief  Starts the TIM Base generation in interrupt mode.
    343            * @param  htim : TIM handle
    344            * @retval HAL status
    345          */

   \                                 In section .text, align 2, keep-with-next
    346          HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
    347          {
   \                     HAL_TIM_Base_Start_IT: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    348            /* Check the parameters */
    349            assert_param(IS_TIM_INSTANCE(htim->Instance));
    350          
    351             /* Enable the TIM Update interrupt */
    352             __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
   \   00000002   0x6808             LDR      R0,[R1, #+0]
   \   00000004   0x68C0             LDR      R0,[R0, #+12]
   \   00000006   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000000A   0x680A             LDR      R2,[R1, #+0]
   \   0000000C   0x60D0             STR      R0,[R2, #+12]
    353          
    354             /* Enable the Peripheral */
    355            __HAL_TIM_ENABLE(htim);
   \   0000000E   0x6808             LDR      R0,[R1, #+0]
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000016   0x680A             LDR      R2,[R1, #+0]
   \   00000018   0x6010             STR      R0,[R2, #+0]
    356          
    357            /* Return function status */
    358            return HAL_OK;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x4770             BX       LR               ;; return
    359          }
    360          
    361          /**
    362            * @brief  Stops the TIM Base generation in interrupt mode.
    363            * @param  htim : TIM handle
    364            * @retval HAL status
    365          */

   \                                 In section .text, align 2, keep-with-next
    366          HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
    367          {
   \                     HAL_TIM_Base_Stop_IT: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    368            /* Check the parameters */
    369            assert_param(IS_TIM_INSTANCE(htim->Instance));
    370            /* Disable the TIM Update interrupt */
    371            __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
   \   00000002   0x6808             LDR      R0,[R1, #+0]
   \   00000004   0x68C0             LDR      R0,[R0, #+12]
   \   00000006   0x0840             LSRS     R0,R0,#+1
   \   00000008   0x0040             LSLS     R0,R0,#+1
   \   0000000A   0x680A             LDR      R2,[R1, #+0]
   \   0000000C   0x60D0             STR      R0,[R2, #+12]
    372          
    373            /* Disable the Peripheral */
    374            __HAL_TIM_DISABLE(htim);
   \   0000000E   0x6808             LDR      R0,[R1, #+0]
   \   00000010   0x6A00             LDR      R0,[R0, #+32]
   \   00000012   0xF241 0x1211      MOVW     R2,#+4369
   \   00000016   0x4210             TST      R0,R2
   \   00000018   0xD105             BNE.N    ??HAL_TIM_Base_Stop_IT_0
   \   0000001A   0x6808             LDR      R0,[R1, #+0]
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x0840             LSRS     R0,R0,#+1
   \   00000020   0x0040             LSLS     R0,R0,#+1
   \   00000022   0x680A             LDR      R2,[R1, #+0]
   \   00000024   0x6010             STR      R0,[R2, #+0]
    375          
    376            /* Return function status */
    377            return HAL_OK;
   \                     ??HAL_TIM_Base_Stop_IT_0: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x4770             BX       LR               ;; return
    378          }
    379          
    380          /**
    381            * @brief  Starts the TIM Base generation in DMA mode.
    382            * @param  htim : TIM handle
    383            * @param  pData: The source Buffer address.
    384            * @param  Length: The length of data to be transferred from memory to peripheral.
    385            * @retval HAL status
    386          */

   \                                 In section .text, align 2, keep-with-next
    387          HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
    388          {
   \                     HAL_TIM_Base_Start_DMA: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    389            /* Check the parameters */
    390            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
    391          
    392            if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000008   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD101             BNE.N    ??HAL_TIM_Base_Start_DMA_0
    393            {
    394               return HAL_BUSY;
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE02D             B.N      ??HAL_TIM_Base_Start_DMA_1
    395            }
    396            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIM_Base_Start_DMA_0: (+1)
   \   00000014   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD128             BNE.N    ??HAL_TIM_Base_Start_DMA_2
    397            {
    398              if((pData == 0 ) && (Length > 0))
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD104             BNE.N    ??HAL_TIM_Base_Start_DMA_3
   \   00000020   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000022   0x2E00             CMP      R6,#+0
   \   00000024   0xD001             BEQ.N    ??HAL_TIM_Base_Start_DMA_3
    399              {
    400                return HAL_ERROR;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE022             B.N      ??HAL_TIM_Base_Start_DMA_1
    401              }
    402              else
    403              {
    404                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Base_Start_DMA_3: (+1)
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0xF884 0x0035      STRB     R0,[R4, #+53]
    405              }
    406            }
    407            else
    408            {
    409              return HAL_ERROR;
    410            }
    411          
    412            /* Set the DMA Period elapsed callback */
    413            htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable4
   \   00000034   0x69A1             LDR      R1,[R4, #+24]
   \   00000036   0x6288             STR      R0,[R1, #+40]
    414          
    415            /* Set the DMA error callback */
    416            htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \   0000003C   0x69A1             LDR      R1,[R4, #+24]
   \   0000003E   0x6308             STR      R0,[R1, #+48]
    417          
    418            /* Enable the DMA channel */
    419            HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length);
   \   00000040   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000042   0x0033             MOVS     R3,R6
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0xF110 0x022C      ADDS     R2,R0,#+44
   \   0000004A   0x0029             MOVS     R1,R5
   \   0000004C   0x69A0             LDR      R0,[R4, #+24]
   \   0000004E   0x.... 0x....      BL       HAL_DMA_Start_IT
    420          
    421            /* Enable the TIM Update DMA request */
    422            __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x68C0             LDR      R0,[R0, #+12]
   \   00000056   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000005A   0x6821             LDR      R1,[R4, #+0]
   \   0000005C   0x60C8             STR      R0,[R1, #+12]
    423          
    424            /* Enable the Peripheral */
    425            __HAL_TIM_ENABLE(htim);
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000066   0x6821             LDR      R1,[R4, #+0]
   \   00000068   0x6008             STR      R0,[R1, #+0]
    426          
    427            /* Return function status */
    428            return HAL_OK;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xE000             B.N      ??HAL_TIM_Base_Start_DMA_1
   \                     ??HAL_TIM_Base_Start_DMA_2: (+1)
   \   0000006E   0x2001             MOVS     R0,#+1
   \                     ??HAL_TIM_Base_Start_DMA_1: (+1)
   \   00000070   0xBD70             POP      {R4-R6,PC}       ;; return
    429          }
    430          
    431          /**
    432            * @brief  Stops the TIM Base generation in DMA mode.
    433            * @param  htim : TIM handle
    434            * @retval HAL status
    435          */

   \                                 In section .text, align 2, keep-with-next
    436          HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
    437          {
   \                     HAL_TIM_Base_Stop_DMA: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    438            /* Check the parameters */
    439            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
    440          
    441            /* Disable the TIM Update DMA request */
    442            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
   \   00000002   0x6808             LDR      R0,[R1, #+0]
   \   00000004   0x68C0             LDR      R0,[R0, #+12]
   \   00000006   0xF430 0x7080      BICS     R0,R0,#0x100
   \   0000000A   0x680A             LDR      R2,[R1, #+0]
   \   0000000C   0x60D0             STR      R0,[R2, #+12]
    443          
    444            /* Disable the Peripheral */
    445            __HAL_TIM_DISABLE(htim);
   \   0000000E   0x6808             LDR      R0,[R1, #+0]
   \   00000010   0x6A00             LDR      R0,[R0, #+32]
   \   00000012   0xF241 0x1211      MOVW     R2,#+4369
   \   00000016   0x4210             TST      R0,R2
   \   00000018   0xD105             BNE.N    ??HAL_TIM_Base_Stop_DMA_0
   \   0000001A   0x6808             LDR      R0,[R1, #+0]
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x0840             LSRS     R0,R0,#+1
   \   00000020   0x0040             LSLS     R0,R0,#+1
   \   00000022   0x680A             LDR      R2,[R1, #+0]
   \   00000024   0x6010             STR      R0,[R2, #+0]
    446          
    447            /* Change the htim state */
    448            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Base_Stop_DMA_0: (+1)
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xF881 0x0035      STRB     R0,[R1, #+53]
    449          
    450            /* Return function status */
    451            return HAL_OK;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x4770             BX       LR               ;; return
    452          }
    453          
    454          /**
    455            * @}
    456            */
    457          
    458          /** @defgroup TIM_Exported_Functions_Group2 Time Output Compare functions
    459           *  @brief    Time Output Compare functions
    460           *
    461          @verbatim
    462            ==============================================================================
    463                            ##### Time Output Compare functions #####
    464            ==============================================================================
    465            [..]
    466              This section provides functions allowing to:
    467              (+) Initialize and configure the TIM Output Compare.
    468              (+) De-initialize the TIM Output Compare.
    469              (+) Start the Time Output Compare.
    470              (+) Stop the Time Output Compare.
    471              (+) Start the Time Output Compare and enable interrupt.
    472              (+) Stop the Time Output Compare and disable interrupt.
    473              (+) Start the Time Output Compare and enable DMA transfer.
    474              (+) Stop the Time Output Compare and disable DMA transfer.
    475          
    476          @endverbatim
    477            * @{
    478            */
    479          /**
    480            * @brief  Initializes the TIM Output Compare according to the specified
    481            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    482            * @param  htim: TIM Output Compare handle
    483            * @retval HAL status
    484            */

   \                                 In section .text, align 2, keep-with-next
    485          HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef* htim)
    486          {
   \                     HAL_TIM_OC_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    487            /* Check the TIM handle allocation */
    488            if(htim == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_TIM_OC_Init_0
    489            {
    490              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE014             B.N      ??HAL_TIM_OC_Init_1
    491            }
    492          
    493            /* Check the parameters */
    494            assert_param(IS_TIM_INSTANCE(htim->Instance));
    495            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    496            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    497          
    498            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_OC_Init_0: (+1)
   \   0000000C   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD105             BNE.N    ??HAL_TIM_OC_Init_2
    499            {
    500              /* Allocate lock resource and initialize it */
    501              htim->Lock = HAL_UNLOCKED;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF884 0x0034      STRB     R0,[R4, #+52]
    502          
    503              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    504              HAL_TIM_OC_MspInit(htim);
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_TIM_OC_MspInit
    505            }
    506          
    507            /* Set the TIM state */
    508            htim->State= HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_OC_Init_2: (+1)
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xF884 0x0035      STRB     R0,[R4, #+53]
    509          
    510            /* Init the base time for the Output Compare */
    511            TIM_Base_SetConfig(htim->Instance,  &htim->Init);
   \   00000026   0x1D21             ADDS     R1,R4,#+4
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x.... 0x....      BL       TIM_Base_SetConfig
    512          
    513            /* Initialize the TIM state*/
    514            htim->State= HAL_TIM_STATE_READY;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF884 0x0035      STRB     R0,[R4, #+53]
    515          
    516            return HAL_OK;
   \   00000034   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Init_1: (+1)
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
    517          }
    518          
    519          /**
    520            * @brief  DeInitializes the TIM peripheral
    521            * @param  htim: TIM Output Compare handle
    522            * @retval HAL status
    523            */

   \                                 In section .text, align 2, keep-with-next
    524          HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
    525          {
   \                     HAL_TIM_OC_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    526            /* Check the parameters */
    527            assert_param(IS_TIM_INSTANCE(htim->Instance));
    528          
    529             htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0035      STRB     R0,[R4, #+53]
    530          
    531            /* Disable the TIM Peripheral Clock */
    532            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A00             LDR      R0,[R0, #+32]
   \   0000000E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000012   0x4208             TST      R0,R1
   \   00000014   0xD105             BNE.N    ??HAL_TIM_OC_DeInit_0
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x0840             LSRS     R0,R0,#+1
   \   0000001C   0x0040             LSLS     R0,R0,#+1
   \   0000001E   0x6821             LDR      R1,[R4, #+0]
   \   00000020   0x6008             STR      R0,[R1, #+0]
    533          
    534            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
    535            HAL_TIM_OC_MspDeInit(htim);
   \                     ??HAL_TIM_OC_DeInit_0: (+1)
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       HAL_TIM_OC_MspDeInit
    536          
    537            /* Change TIM state */
    538            htim->State = HAL_TIM_STATE_RESET;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF884 0x0035      STRB     R0,[R4, #+53]
    539          
    540            /* Release Lock */
    541            __HAL_UNLOCK(htim);
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0034      STRB     R0,[R4, #+52]
    542          
    543            return HAL_OK;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
    544          }
    545          
    546          /**
    547            * @brief  Initializes the TIM Output Compare MSP.
    548            * @param  htim: TIM handle
    549            * @retval None
    550            */

   \                                 In section .text, align 2
    551          __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
    552          {
    553            /* NOTE : This function Should not be modified, when the callback is needed,
    554                      the HAL_TIM_OC_MspInit could be implemented in the user file
    555             */
    556          }
   \                     HAL_TIM_OC_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    557          
    558          /**
    559            * @brief  DeInitializes TIM Output Compare MSP.
    560            * @param  htim: TIM handle
    561            * @retval None
    562            */

   \                                 In section .text, align 2
    563          __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
    564          {
    565            /* NOTE : This function Should not be modified, when the callback is needed,
    566                      the HAL_TIM_OC_MspDeInit could be implemented in the user file
    567             */
    568          }
   \                     HAL_TIM_OC_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    569          
    570          /**
    571            * @brief  Starts the TIM Output Compare signal generation.
    572            * @param  htim : TIM Output Compare handle
    573            * @param  Channel : TIM Channel to be enabled
    574            *          This parameter can be one of the following values:
    575            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    576            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    577            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    578            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    579            * @retval HAL status
    580          */

   \                                 In section .text, align 2, keep-with-next
    581          HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
    582          {
   \                     HAL_TIM_OC_Start: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    583            /* Check the parameters */
    584            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    585          
    586            /* Enable the Output compare channel */
    587            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0x0029             MOVS     R1,R5
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       TIM_CCxChannelCmd
    588          
    589            /* Enable the Peripheral */
    590            __HAL_TIM_ENABLE(htim);
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000018   0x6821             LDR      R1,[R4, #+0]
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    591          
    592            /* Return function status */
    593            return HAL_OK;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    594          }
    595          
    596          /**
    597            * @brief  Stops the TIM Output Compare signal generation.
    598            * @param  htim : TIM handle
    599            * @param  Channel : TIM Channel to be disabled
    600            *          This parameter can be one of the following values:
    601            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    602            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    603            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    604            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    605            * @retval HAL status
    606          */

   \                                 In section .text, align 2, keep-with-next
    607          HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
    608          {
   \                     HAL_TIM_OC_Stop: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    609            /* Check the parameters */
    610            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    611          
    612            /* Disable the Output compare channel */
    613            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x0029             MOVS     R1,R5
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       TIM_CCxChannelCmd
    614          
    615            /* Disable the Peripheral */
    616            __HAL_TIM_DISABLE(htim);
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x6A00             LDR      R0,[R0, #+32]
   \   00000014   0xF241 0x1111      MOVW     R1,#+4369
   \   00000018   0x4208             TST      R0,R1
   \   0000001A   0xD105             BNE.N    ??HAL_TIM_OC_Stop_0
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x0840             LSRS     R0,R0,#+1
   \   00000022   0x0040             LSLS     R0,R0,#+1
   \   00000024   0x6821             LDR      R1,[R4, #+0]
   \   00000026   0x6008             STR      R0,[R1, #+0]
    617          
    618            /* Return function status */
    619            return HAL_OK;
   \                     ??HAL_TIM_OC_Stop_0: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    620          }
    621          
    622          /**
    623            * @brief  Starts the TIM Output Compare signal generation in interrupt mode.
    624            * @param  htim : TIM OC handle
    625            * @param  Channel : TIM Channel to be enabled
    626            *          This parameter can be one of the following values:
    627            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    628            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    629            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    630            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    631            * @retval HAL status
    632          */

   \                                 In section .text, align 2, keep-with-next
    633          HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    634          {
   \                     HAL_TIM_OC_Start_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    635            /* Check the parameters */
    636            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    637          
    638            switch (Channel)
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD006             BEQ.N    ??HAL_TIM_OC_Start_IT_0
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD00B             BEQ.N    ??HAL_TIM_OC_Start_IT_1
   \   00000010   0x2808             CMP      R0,#+8
   \   00000012   0xD010             BEQ.N    ??HAL_TIM_OC_Start_IT_2
   \   00000014   0x280C             CMP      R0,#+12
   \   00000016   0xD015             BEQ.N    ??HAL_TIM_OC_Start_IT_3
   \   00000018   0xE01B             B.N      ??HAL_TIM_OC_Start_IT_4
    639            {
    640              case TIM_CHANNEL_1:
    641              {
    642                /* Enable the TIM Capture/Compare 1 interrupt */
    643                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_OC_Start_IT_0: (+1)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000022   0x6821             LDR      R1,[R4, #+0]
   \   00000024   0x60C8             STR      R0,[R1, #+12]
    644              }
    645              break;
   \   00000026   0xE014             B.N      ??HAL_TIM_OC_Start_IT_5
    646          
    647              case TIM_CHANNEL_2:
    648              {
    649                /* Enable the TIM Capture/Compare 2 interrupt */
    650                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_OC_Start_IT_1: (+1)
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x68C0             LDR      R0,[R0, #+12]
   \   0000002C   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x60C8             STR      R0,[R1, #+12]
    651              }
    652              break;
   \   00000034   0xE00D             B.N      ??HAL_TIM_OC_Start_IT_5
    653          
    654              case TIM_CHANNEL_3:
    655              {
    656                /* Enable the TIM Capture/Compare 3 interrupt */
    657                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_OC_Start_IT_2: (+1)
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x68C0             LDR      R0,[R0, #+12]
   \   0000003A   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000003E   0x6821             LDR      R1,[R4, #+0]
   \   00000040   0x60C8             STR      R0,[R1, #+12]
    658              }
    659              break;
   \   00000042   0xE006             B.N      ??HAL_TIM_OC_Start_IT_5
    660          
    661              case TIM_CHANNEL_4:
    662              {
    663                /* Enable the TIM Capture/Compare 4 interrupt */
    664                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_OC_Start_IT_3: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x68C0             LDR      R0,[R0, #+12]
   \   00000048   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x60C8             STR      R0,[R1, #+12]
    665              }
    666              break;
   \   00000050   0xE7FF             B.N      ??HAL_TIM_OC_Start_IT_5
    667          
    668              default:
    669              break;
    670            }
    671          
    672            /* Enable the Output compare channel */
    673            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_OC_Start_IT_4: (+1)
   \                     ??HAL_TIM_OC_Start_IT_5: (+1)
   \   00000052   0x2201             MOVS     R2,#+1
   \   00000054   0x0029             MOVS     R1,R5
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x.... 0x....      BL       TIM_CCxChannelCmd
    674          
    675            /* Enable the Peripheral */
    676            __HAL_TIM_ENABLE(htim);
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x6008             STR      R0,[R1, #+0]
    677          
    678            /* Return function status */
    679            return HAL_OK;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    680          }
    681          
    682          /**
    683            * @brief  Stops the TIM Output Compare signal generation in interrupt mode.
    684            * @param  htim : TIM Output Compare handle
    685            * @param  Channel : TIM Channel to be disabled
    686            *          This parameter can be one of the following values:
    687            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    688            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    689            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    690            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    691            * @retval HAL status
    692          */

   \                                 In section .text, align 2, keep-with-next
    693          HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    694          {
   \                     HAL_TIM_OC_Stop_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    695            /* Check the parameters */
    696            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    697          
    698            switch (Channel)
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD006             BEQ.N    ??HAL_TIM_OC_Stop_IT_0
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD00B             BEQ.N    ??HAL_TIM_OC_Stop_IT_1
   \   00000010   0x2808             CMP      R0,#+8
   \   00000012   0xD010             BEQ.N    ??HAL_TIM_OC_Stop_IT_2
   \   00000014   0x280C             CMP      R0,#+12
   \   00000016   0xD015             BEQ.N    ??HAL_TIM_OC_Stop_IT_3
   \   00000018   0xE01B             B.N      ??HAL_TIM_OC_Stop_IT_4
    699            {
    700              case TIM_CHANNEL_1:
    701              {
    702                /* Disable the TIM Capture/Compare 1 interrupt */
    703                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_OC_Stop_IT_0: (+1)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000022   0x6821             LDR      R1,[R4, #+0]
   \   00000024   0x60C8             STR      R0,[R1, #+12]
    704              }
    705              break;
   \   00000026   0xE014             B.N      ??HAL_TIM_OC_Stop_IT_5
    706          
    707              case TIM_CHANNEL_2:
    708              {
    709                /* Disable the TIM Capture/Compare 2 interrupt */
    710                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_OC_Stop_IT_1: (+1)
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x68C0             LDR      R0,[R0, #+12]
   \   0000002C   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x60C8             STR      R0,[R1, #+12]
    711              }
    712              break;
   \   00000034   0xE00D             B.N      ??HAL_TIM_OC_Stop_IT_5
    713          
    714              case TIM_CHANNEL_3:
    715              {
    716                /* Disable the TIM Capture/Compare 3 interrupt */
    717                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_OC_Stop_IT_2: (+1)
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x68C0             LDR      R0,[R0, #+12]
   \   0000003A   0xF030 0x0008      BICS     R0,R0,#0x8
   \   0000003E   0x6821             LDR      R1,[R4, #+0]
   \   00000040   0x60C8             STR      R0,[R1, #+12]
    718              }
    719              break;
   \   00000042   0xE006             B.N      ??HAL_TIM_OC_Stop_IT_5
    720          
    721              case TIM_CHANNEL_4:
    722              {
    723                /* Disable the TIM Capture/Compare 4 interrupt */
    724                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_OC_Stop_IT_3: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x68C0             LDR      R0,[R0, #+12]
   \   00000048   0xF030 0x0010      BICS     R0,R0,#0x10
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x60C8             STR      R0,[R1, #+12]
    725              }
    726              break;
   \   00000050   0xE7FF             B.N      ??HAL_TIM_OC_Stop_IT_5
    727          
    728              default:
    729              break;
    730            }
    731          
    732            /* Disable the Output compare channel */
    733            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_OC_Stop_IT_4: (+1)
   \                     ??HAL_TIM_OC_Stop_IT_5: (+1)
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x0029             MOVS     R1,R5
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x.... 0x....      BL       TIM_CCxChannelCmd
    734          
    735            /* Disable the Peripheral */
    736            __HAL_TIM_DISABLE(htim);
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6A00             LDR      R0,[R0, #+32]
   \   00000060   0xF241 0x1111      MOVW     R1,#+4369
   \   00000064   0x4208             TST      R0,R1
   \   00000066   0xD105             BNE.N    ??HAL_TIM_OC_Stop_IT_6
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x0840             LSRS     R0,R0,#+1
   \   0000006E   0x0040             LSLS     R0,R0,#+1
   \   00000070   0x6821             LDR      R1,[R4, #+0]
   \   00000072   0x6008             STR      R0,[R1, #+0]
    737          
    738            /* Return function status */
    739            return HAL_OK;
   \                     ??HAL_TIM_OC_Stop_IT_6: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    740          }
    741          
    742          /**
    743            * @brief  Starts the TIM Output Compare signal generation in DMA mode.
    744            * @param  htim : TIM Output Compare handle
    745            * @param  Channel : TIM Channel to be enabled
    746            *          This parameter can be one of the following values:
    747            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    748            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    749            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    750            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    751            * @param  pData: The source Buffer address.
    752            * @param  Length: The length of data to be transferred from memory to TIM peripheral
    753            * @retval HAL status
    754          */

   \                                 In section .text, align 2, keep-with-next
    755          HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
    756          {
   \                     HAL_TIM_OC_Start_DMA: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    757            /* Check the parameters */
    758            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    759          
    760            if((htim->State == HAL_TIM_STATE_BUSY))
   \   0000000A   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xD101             BNE.N    ??HAL_TIM_OC_Start_DMA_0
    761            {
    762               return HAL_BUSY;
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xE085             B.N      ??HAL_TIM_OC_Start_DMA_1
    763            }
    764            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIM_OC_Start_DMA_0: (+1)
   \   00000016   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD113             BNE.N    ??HAL_TIM_OC_Start_DMA_2
    765            {
    766              if(((uint32_t)pData == 0 ) && (Length > 0))
   \   0000001E   0x2E00             CMP      R6,#+0
   \   00000020   0xD104             BNE.N    ??HAL_TIM_OC_Start_DMA_3
   \   00000022   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000024   0x2F00             CMP      R7,#+0
   \   00000026   0xD001             BEQ.N    ??HAL_TIM_OC_Start_DMA_3
    767              {
    768                return HAL_ERROR;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xE07A             B.N      ??HAL_TIM_OC_Start_DMA_1
    769              }
    770              else
    771              {
    772                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_OC_Start_DMA_3: (+1)
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0xF884 0x0035      STRB     R0,[R4, #+53]
    773              }
    774            }
    775            else
    776            {
    777              return HAL_ERROR;
    778            }
    779          
    780            switch (Channel)
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD008             BEQ.N    ??HAL_TIM_OC_Start_DMA_4
   \   00000038   0x2804             CMP      R0,#+4
   \   0000003A   0xD01E             BEQ.N    ??HAL_TIM_OC_Start_DMA_5
   \   0000003C   0x2808             CMP      R0,#+8
   \   0000003E   0xD034             BEQ.N    ??HAL_TIM_OC_Start_DMA_6
   \   00000040   0x280C             CMP      R0,#+12
   \   00000042   0xD04A             BEQ.N    ??HAL_TIM_OC_Start_DMA_7
   \   00000044   0xE061             B.N      ??HAL_TIM_OC_Start_DMA_8
   \                     ??HAL_TIM_OC_Start_DMA_2: (+1)
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0xE06B             B.N      ??HAL_TIM_OC_Start_DMA_1
    781            {
    782              case TIM_CHANNEL_1:
    783              {
    784                /* Set the DMA Period elapsed callback */
    785                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_4: (+1)
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable5
   \   0000004E   0x69E1             LDR      R1,[R4, #+28]
   \   00000050   0x6288             STR      R0,[R1, #+40]
    786          
    787                /* Set the DMA error callback */
    788                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   00000056   0x69E1             LDR      R1,[R4, #+28]
   \   00000058   0x6308             STR      R0,[R1, #+48]
    789          
    790                /* Enable the DMA channel */
    791                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
   \   0000005A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000005C   0x003B             MOVS     R3,R7
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0xF110 0x0234      ADDS     R2,R0,#+52
   \   00000064   0x0031             MOVS     R1,R6
   \   00000066   0x69E0             LDR      R0,[R4, #+28]
   \   00000068   0x.... 0x....      BL       HAL_DMA_Start_IT
    792          
    793                /* Enable the TIM Capture/Compare 1 DMA request */
    794                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x68C0             LDR      R0,[R0, #+12]
   \   00000070   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000074   0x6821             LDR      R1,[R4, #+0]
   \   00000076   0x60C8             STR      R0,[R1, #+12]
    795              }
    796              break;
   \   00000078   0xE047             B.N      ??HAL_TIM_OC_Start_DMA_9
    797          
    798              case TIM_CHANNEL_2:
    799              {
    800                /* Set the DMA Period elapsed callback */
    801                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_5: (+1)
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable5
   \   0000007E   0x6A21             LDR      R1,[R4, #+32]
   \   00000080   0x6288             STR      R0,[R1, #+40]
    802          
    803                /* Set the DMA error callback */
    804                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   00000086   0x6A21             LDR      R1,[R4, #+32]
   \   00000088   0x6308             STR      R0,[R1, #+48]
    805          
    806                /* Enable the DMA channel */
    807                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
   \   0000008A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000008C   0x003B             MOVS     R3,R7
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0xF110 0x0238      ADDS     R2,R0,#+56
   \   00000094   0x0031             MOVS     R1,R6
   \   00000096   0x6A20             LDR      R0,[R4, #+32]
   \   00000098   0x.... 0x....      BL       HAL_DMA_Start_IT
    808          
    809                /* Enable the TIM Capture/Compare 2 DMA request */
    810                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0x68C0             LDR      R0,[R0, #+12]
   \   000000A0   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   000000A4   0x6821             LDR      R1,[R4, #+0]
   \   000000A6   0x60C8             STR      R0,[R1, #+12]
    811              }
    812              break;
   \   000000A8   0xE02F             B.N      ??HAL_TIM_OC_Start_DMA_9
    813          
    814              case TIM_CHANNEL_3:
    815              {
    816                /* Set the DMA Period elapsed callback */
    817                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_6: (+1)
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable5
   \   000000AE   0x6A61             LDR      R1,[R4, #+36]
   \   000000B0   0x6288             STR      R0,[R1, #+40]
    818          
    819                /* Set the DMA error callback */
    820                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   000000B6   0x6A61             LDR      R1,[R4, #+36]
   \   000000B8   0x6308             STR      R0,[R1, #+48]
    821          
    822                /* Enable the DMA channel */
    823                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
   \   000000BA   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000BC   0x003B             MOVS     R3,R7
   \   000000BE   0x6820             LDR      R0,[R4, #+0]
   \   000000C0   0xF110 0x023C      ADDS     R2,R0,#+60
   \   000000C4   0x0031             MOVS     R1,R6
   \   000000C6   0x6A60             LDR      R0,[R4, #+36]
   \   000000C8   0x.... 0x....      BL       HAL_DMA_Start_IT
    824          
    825                /* Enable the TIM Capture/Compare 3 DMA request */
    826                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \   000000CC   0x6820             LDR      R0,[R4, #+0]
   \   000000CE   0x68C0             LDR      R0,[R0, #+12]
   \   000000D0   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   000000D4   0x6821             LDR      R1,[R4, #+0]
   \   000000D6   0x60C8             STR      R0,[R1, #+12]
    827              }
    828              break;
   \   000000D8   0xE017             B.N      ??HAL_TIM_OC_Start_DMA_9
    829          
    830              case TIM_CHANNEL_4:
    831              {
    832               /* Set the DMA Period elapsed callback */
    833                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_7: (+1)
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable5
   \   000000DE   0x6AA1             LDR      R1,[R4, #+40]
   \   000000E0   0x6288             STR      R0,[R1, #+40]
    834          
    835                /* Set the DMA error callback */
    836                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   000000E6   0x6AA1             LDR      R1,[R4, #+40]
   \   000000E8   0x6308             STR      R0,[R1, #+48]
    837          
    838                /* Enable the DMA channel */
    839                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
   \   000000EA   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000EC   0x003B             MOVS     R3,R7
   \   000000EE   0x6820             LDR      R0,[R4, #+0]
   \   000000F0   0xF110 0x0240      ADDS     R2,R0,#+64
   \   000000F4   0x0031             MOVS     R1,R6
   \   000000F6   0x6AA0             LDR      R0,[R4, #+40]
   \   000000F8   0x.... 0x....      BL       HAL_DMA_Start_IT
    840          
    841                /* Enable the TIM Capture/Compare 4 DMA request */
    842                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \   000000FC   0x6820             LDR      R0,[R4, #+0]
   \   000000FE   0x68C0             LDR      R0,[R0, #+12]
   \   00000100   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   00000104   0x6821             LDR      R1,[R4, #+0]
   \   00000106   0x60C8             STR      R0,[R1, #+12]
    843              }
    844              break;
   \   00000108   0xE7FF             B.N      ??HAL_TIM_OC_Start_DMA_9
    845          
    846              default:
    847              break;
    848            }
    849          
    850            /* Enable the Output compare channel */
    851            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_OC_Start_DMA_8: (+1)
   \                     ??HAL_TIM_OC_Start_DMA_9: (+1)
   \   0000010A   0x2201             MOVS     R2,#+1
   \   0000010C   0x0029             MOVS     R1,R5
   \   0000010E   0x6820             LDR      R0,[R4, #+0]
   \   00000110   0x.... 0x....      BL       TIM_CCxChannelCmd
    852          
    853            /* Enable the Peripheral */
    854            __HAL_TIM_ENABLE(htim);
   \   00000114   0x6820             LDR      R0,[R4, #+0]
   \   00000116   0x6800             LDR      R0,[R0, #+0]
   \   00000118   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000011C   0x6821             LDR      R1,[R4, #+0]
   \   0000011E   0x6008             STR      R0,[R1, #+0]
    855          
    856            /* Return function status */
    857            return HAL_OK;
   \   00000120   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Start_DMA_1: (+1)
   \   00000122   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    858          }
    859          
    860          /**
    861            * @brief  Stops the TIM Output Compare signal generation in DMA mode.
    862            * @param  htim : TIM Output Compare handle
    863            * @param  Channel : TIM Channel to be disabled
    864            *          This parameter can be one of the following values:
    865            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    866            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    867            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    868            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    869            * @retval HAL status
    870          */

   \                                 In section .text, align 2, keep-with-next
    871          HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
    872          {
   \                     HAL_TIM_OC_Stop_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    873            /* Check the parameters */
    874            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    875          
    876            switch (Channel)
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD006             BEQ.N    ??HAL_TIM_OC_Stop_DMA_0
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD00B             BEQ.N    ??HAL_TIM_OC_Stop_DMA_1
   \   00000010   0x2808             CMP      R0,#+8
   \   00000012   0xD010             BEQ.N    ??HAL_TIM_OC_Stop_DMA_2
   \   00000014   0x280C             CMP      R0,#+12
   \   00000016   0xD015             BEQ.N    ??HAL_TIM_OC_Stop_DMA_3
   \   00000018   0xE01B             B.N      ??HAL_TIM_OC_Stop_DMA_4
    877            {
    878              case TIM_CHANNEL_1:
    879              {
    880                /* Disable the TIM Capture/Compare 1 DMA request */
    881                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_OC_Stop_DMA_0: (+1)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF430 0x7000      BICS     R0,R0,#0x200
   \   00000022   0x6821             LDR      R1,[R4, #+0]
   \   00000024   0x60C8             STR      R0,[R1, #+12]
    882              }
    883              break;
   \   00000026   0xE014             B.N      ??HAL_TIM_OC_Stop_DMA_5
    884          
    885              case TIM_CHANNEL_2:
    886              {
    887                /* Disable the TIM Capture/Compare 2 DMA request */
    888                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_OC_Stop_DMA_1: (+1)
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x68C0             LDR      R0,[R0, #+12]
   \   0000002C   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x60C8             STR      R0,[R1, #+12]
    889              }
    890              break;
   \   00000034   0xE00D             B.N      ??HAL_TIM_OC_Stop_DMA_5
    891          
    892              case TIM_CHANNEL_3:
    893              {
    894                /* Disable the TIM Capture/Compare 3 DMA request */
    895                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_OC_Stop_DMA_2: (+1)
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x68C0             LDR      R0,[R0, #+12]
   \   0000003A   0xF430 0x6000      BICS     R0,R0,#0x800
   \   0000003E   0x6821             LDR      R1,[R4, #+0]
   \   00000040   0x60C8             STR      R0,[R1, #+12]
    896              }
    897              break;
   \   00000042   0xE006             B.N      ??HAL_TIM_OC_Stop_DMA_5
    898          
    899              case TIM_CHANNEL_4:
    900              {
    901                /* Disable the TIM Capture/Compare 4 interrupt */
    902                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_OC_Stop_DMA_3: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x68C0             LDR      R0,[R0, #+12]
   \   00000048   0xF430 0x5080      BICS     R0,R0,#0x1000
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x60C8             STR      R0,[R1, #+12]
    903              }
    904              break;
   \   00000050   0xE7FF             B.N      ??HAL_TIM_OC_Stop_DMA_5
    905          
    906              default:
    907              break;
    908            }
    909          
    910            /* Disable the Output compare channel */
    911            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_OC_Stop_DMA_4: (+1)
   \                     ??HAL_TIM_OC_Stop_DMA_5: (+1)
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x0029             MOVS     R1,R5
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x.... 0x....      BL       TIM_CCxChannelCmd
    912          
    913            /* Disable the Peripheral */
    914            __HAL_TIM_DISABLE(htim);
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6A00             LDR      R0,[R0, #+32]
   \   00000060   0xF241 0x1111      MOVW     R1,#+4369
   \   00000064   0x4208             TST      R0,R1
   \   00000066   0xD105             BNE.N    ??HAL_TIM_OC_Stop_DMA_6
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x0840             LSRS     R0,R0,#+1
   \   0000006E   0x0040             LSLS     R0,R0,#+1
   \   00000070   0x6821             LDR      R1,[R4, #+0]
   \   00000072   0x6008             STR      R0,[R1, #+0]
    915          
    916            /* Change the htim state */
    917            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OC_Stop_DMA_6: (+1)
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xF884 0x0035      STRB     R0,[R4, #+53]
    918          
    919            /* Return function status */
    920            return HAL_OK;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    921          }
    922          
    923          /**
    924            * @}
    925            */
    926          
    927          /** @defgroup TIM_Exported_Functions_Group3 Time PWM functions
    928           *  @brief    Time PWM functions
    929           *
    930          @verbatim
    931            ==============================================================================
    932                                    ##### Time PWM functions #####
    933            ==============================================================================
    934            [..]
    935              This section provides functions allowing to:
    936              (+) Initialize and configure the TIM PWM.
    937              (+) De-initialize the TIM PWM.
    938              (+) Start the Time PWM.
    939              (+) Stop the Time PWM.
    940              (+) Start the Time PWM and enable interrupt.
    941              (+) Stop the Time PWM and disable interrupt.
    942              (+) Start the Time PWM and enable DMA transfer.
    943              (+) Stop the Time PWM and disable DMA transfer.
    944          
    945          @endverbatim
    946            * @{
    947            */
    948          /**
    949            * @brief  Initializes the TIM PWM Time Base according to the specified
    950            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    951            * @param  htim: TIM handle
    952            * @retval HAL status
    953            */

   \                                 In section .text, align 2, keep-with-next
    954          HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
    955          {
   \                     HAL_TIM_PWM_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    956            /* Check the TIM handle allocation */
    957            if(htim == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_TIM_PWM_Init_0
    958            {
    959              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE014             B.N      ??HAL_TIM_PWM_Init_1
    960            }
    961          
    962            /* Check the parameters */
    963            assert_param(IS_TIM_INSTANCE(htim->Instance));
    964            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    965            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    966          
    967            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_PWM_Init_0: (+1)
   \   0000000C   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD105             BNE.N    ??HAL_TIM_PWM_Init_2
    968            {
    969              /* Allocate lock resource and initialize it */
    970              htim->Lock = HAL_UNLOCKED;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF884 0x0034      STRB     R0,[R4, #+52]
    971          
    972              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    973              HAL_TIM_PWM_MspInit(htim);
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_TIM_PWM_MspInit
    974            }
    975          
    976            /* Set the TIM state */
    977            htim->State= HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_PWM_Init_2: (+1)
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xF884 0x0035      STRB     R0,[R4, #+53]
    978          
    979            /* Init the base time for the PWM */
    980            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \   00000026   0x1D21             ADDS     R1,R4,#+4
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x.... 0x....      BL       TIM_Base_SetConfig
    981          
    982            /* Initialize the TIM state*/
    983            htim->State= HAL_TIM_STATE_READY;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF884 0x0035      STRB     R0,[R4, #+53]
    984          
    985            return HAL_OK;
   \   00000034   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Init_1: (+1)
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
    986          }
    987          
    988          /**
    989            * @brief  DeInitializes the TIM peripheral
    990            * @param  htim: TIM handle
    991            * @retval HAL status
    992            */

   \                                 In section .text, align 2, keep-with-next
    993          HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
    994          {
   \                     HAL_TIM_PWM_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    995            /* Check the parameters */
    996            assert_param(IS_TIM_INSTANCE(htim->Instance));
    997          
    998            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0035      STRB     R0,[R4, #+53]
    999          
   1000            /* Disable the TIM Peripheral Clock */
   1001            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A00             LDR      R0,[R0, #+32]
   \   0000000E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000012   0x4208             TST      R0,R1
   \   00000014   0xD105             BNE.N    ??HAL_TIM_PWM_DeInit_0
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x0840             LSRS     R0,R0,#+1
   \   0000001C   0x0040             LSLS     R0,R0,#+1
   \   0000001E   0x6821             LDR      R1,[R4, #+0]
   \   00000020   0x6008             STR      R0,[R1, #+0]
   1002          
   1003            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1004            HAL_TIM_PWM_MspDeInit(htim);
   \                     ??HAL_TIM_PWM_DeInit_0: (+1)
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       HAL_TIM_PWM_MspDeInit
   1005          
   1006            /* Change TIM state */
   1007            htim->State = HAL_TIM_STATE_RESET;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF884 0x0035      STRB     R0,[R4, #+53]
   1008          
   1009            /* Release Lock */
   1010            __HAL_UNLOCK(htim);
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0034      STRB     R0,[R4, #+52]
   1011          
   1012            return HAL_OK;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
   1013          }
   1014          
   1015          /**
   1016            * @brief  Initializes the TIM PWM MSP.
   1017            * @param  htim: TIM handle
   1018            * @retval None
   1019            */

   \                                 In section .text, align 2
   1020          __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
   1021          {
   1022            /* NOTE : This function Should not be modified, when the callback is needed,
   1023                      the HAL_TIM_PWM_MspInit could be implemented in the user file
   1024             */
   1025          }
   \                     HAL_TIM_PWM_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1026          
   1027          /**
   1028            * @brief  DeInitializes TIM PWM MSP.
   1029            * @param  htim: TIM handle
   1030            * @retval None
   1031            */

   \                                 In section .text, align 2
   1032          __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
   1033          {
   1034            /* NOTE : This function Should not be modified, when the callback is needed,
   1035                      the HAL_TIM_PWM_MspDeInit could be implemented in the user file
   1036             */
   1037          }
   \                     HAL_TIM_PWM_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1038          
   1039          /**
   1040            * @brief  Starts the PWM signal generation.
   1041            * @param  htim : TIM handle
   1042            * @param  Channel : TIM Channels to be enabled
   1043            *          This parameter can be one of the following values:
   1044            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1045            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1046            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1047            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1048            * @retval HAL status
   1049          */

   \                                 In section .text, align 2, keep-with-next
   1050          HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   1051          {
   \                     HAL_TIM_PWM_Start: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1052            /* Check the parameters */
   1053            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1054          
   1055            /* Enable the Capture compare channel */
   1056            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0x0029             MOVS     R1,R5
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       TIM_CCxChannelCmd
   1057          
   1058            /* Enable the Peripheral */
   1059            __HAL_TIM_ENABLE(htim);
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000018   0x6821             LDR      R1,[R4, #+0]
   \   0000001A   0x6008             STR      R0,[R1, #+0]
   1060          
   1061            /* Return function status */
   1062            return HAL_OK;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1063          }
   1064          
   1065          /**
   1066            * @brief  Stops the PWM signal generation.
   1067            * @param  htim : TIM handle
   1068            * @param  Channel : TIM Channels to be disabled
   1069            *          This parameter can be one of the following values:
   1070            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1071            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1072            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1073            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1074            * @retval HAL status
   1075          */

   \                                 In section .text, align 2, keep-with-next
   1076          HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1077          {
   \                     HAL_TIM_PWM_Stop: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1078            /* Check the parameters */
   1079            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1080          
   1081            /* Disable the Capture compare channel */
   1082            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x0029             MOVS     R1,R5
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       TIM_CCxChannelCmd
   1083          
   1084            /* Disable the Peripheral */
   1085            __HAL_TIM_DISABLE(htim);
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x6A00             LDR      R0,[R0, #+32]
   \   00000014   0xF241 0x1111      MOVW     R1,#+4369
   \   00000018   0x4208             TST      R0,R1
   \   0000001A   0xD105             BNE.N    ??HAL_TIM_PWM_Stop_0
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x0840             LSRS     R0,R0,#+1
   \   00000022   0x0040             LSLS     R0,R0,#+1
   \   00000024   0x6821             LDR      R1,[R4, #+0]
   \   00000026   0x6008             STR      R0,[R1, #+0]
   1086          
   1087            /* Change the htim state */
   1088            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_PWM_Stop_0: (+1)
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xF884 0x0035      STRB     R0,[R4, #+53]
   1089          
   1090            /* Return function status */
   1091            return HAL_OK;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1092          }
   1093          
   1094          /**
   1095            * @brief  Starts the PWM signal generation in interrupt mode.
   1096            * @param  htim : TIM handle
   1097            * @param  Channel : TIM Channel to be disabled
   1098            *          This parameter can be one of the following values:
   1099            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1100            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1101            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1102            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1103            * @retval HAL status
   1104          */

   \                                 In section .text, align 2, keep-with-next
   1105          HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1106          {
   \                     HAL_TIM_PWM_Start_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1107            /* Check the parameters */
   1108            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1109          
   1110            switch (Channel)
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD006             BEQ.N    ??HAL_TIM_PWM_Start_IT_0
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD00B             BEQ.N    ??HAL_TIM_PWM_Start_IT_1
   \   00000010   0x2808             CMP      R0,#+8
   \   00000012   0xD010             BEQ.N    ??HAL_TIM_PWM_Start_IT_2
   \   00000014   0x280C             CMP      R0,#+12
   \   00000016   0xD015             BEQ.N    ??HAL_TIM_PWM_Start_IT_3
   \   00000018   0xE01B             B.N      ??HAL_TIM_PWM_Start_IT_4
   1111            {
   1112              case TIM_CHANNEL_1:
   1113              {
   1114                /* Enable the TIM Capture/Compare 1 interrupt */
   1115                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_PWM_Start_IT_0: (+1)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000022   0x6821             LDR      R1,[R4, #+0]
   \   00000024   0x60C8             STR      R0,[R1, #+12]
   1116              }
   1117              break;
   \   00000026   0xE014             B.N      ??HAL_TIM_PWM_Start_IT_5
   1118          
   1119              case TIM_CHANNEL_2:
   1120              {
   1121                /* Enable the TIM Capture/Compare 2 interrupt */
   1122                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_PWM_Start_IT_1: (+1)
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x68C0             LDR      R0,[R0, #+12]
   \   0000002C   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x60C8             STR      R0,[R1, #+12]
   1123              }
   1124              break;
   \   00000034   0xE00D             B.N      ??HAL_TIM_PWM_Start_IT_5
   1125          
   1126              case TIM_CHANNEL_3:
   1127              {
   1128                /* Enable the TIM Capture/Compare 3 interrupt */
   1129                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_PWM_Start_IT_2: (+1)
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x68C0             LDR      R0,[R0, #+12]
   \   0000003A   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000003E   0x6821             LDR      R1,[R4, #+0]
   \   00000040   0x60C8             STR      R0,[R1, #+12]
   1130              }
   1131              break;
   \   00000042   0xE006             B.N      ??HAL_TIM_PWM_Start_IT_5
   1132          
   1133              case TIM_CHANNEL_4:
   1134              {
   1135                /* Enable the TIM Capture/Compare 4 interrupt */
   1136                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_PWM_Start_IT_3: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x68C0             LDR      R0,[R0, #+12]
   \   00000048   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x60C8             STR      R0,[R1, #+12]
   1137              }
   1138              break;
   \   00000050   0xE7FF             B.N      ??HAL_TIM_PWM_Start_IT_5
   1139          
   1140              default:
   1141              break;
   1142            }
   1143          
   1144            /* Enable the Capture compare channel */
   1145            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_PWM_Start_IT_4: (+1)
   \                     ??HAL_TIM_PWM_Start_IT_5: (+1)
   \   00000052   0x2201             MOVS     R2,#+1
   \   00000054   0x0029             MOVS     R1,R5
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x.... 0x....      BL       TIM_CCxChannelCmd
   1146          
   1147            /* Enable the Peripheral */
   1148            __HAL_TIM_ENABLE(htim);
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x6008             STR      R0,[R1, #+0]
   1149          
   1150            /* Return function status */
   1151            return HAL_OK;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1152          }
   1153          
   1154          /**
   1155            * @brief  Stops the PWM signal generation in interrupt mode.
   1156            * @param  htim : TIM handle
   1157            * @param  Channel : TIM Channels to be disabled
   1158            *          This parameter can be one of the following values:
   1159            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1160            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1161            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1162            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1163            * @retval HAL status
   1164          */

   \                                 In section .text, align 2, keep-with-next
   1165          HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
   1166          {
   \                     HAL_TIM_PWM_Stop_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1167            /* Check the parameters */
   1168            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1169          
   1170            switch (Channel)
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD006             BEQ.N    ??HAL_TIM_PWM_Stop_IT_0
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD00B             BEQ.N    ??HAL_TIM_PWM_Stop_IT_1
   \   00000010   0x2808             CMP      R0,#+8
   \   00000012   0xD010             BEQ.N    ??HAL_TIM_PWM_Stop_IT_2
   \   00000014   0x280C             CMP      R0,#+12
   \   00000016   0xD015             BEQ.N    ??HAL_TIM_PWM_Stop_IT_3
   \   00000018   0xE01B             B.N      ??HAL_TIM_PWM_Stop_IT_4
   1171            {
   1172              case TIM_CHANNEL_1:
   1173              {
   1174                /* Disable the TIM Capture/Compare 1 interrupt */
   1175                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_PWM_Stop_IT_0: (+1)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000022   0x6821             LDR      R1,[R4, #+0]
   \   00000024   0x60C8             STR      R0,[R1, #+12]
   1176              }
   1177              break;
   \   00000026   0xE014             B.N      ??HAL_TIM_PWM_Stop_IT_5
   1178          
   1179              case TIM_CHANNEL_2:
   1180              {
   1181                /* Disable the TIM Capture/Compare 2 interrupt */
   1182                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_PWM_Stop_IT_1: (+1)
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x68C0             LDR      R0,[R0, #+12]
   \   0000002C   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x60C8             STR      R0,[R1, #+12]
   1183              }
   1184              break;
   \   00000034   0xE00D             B.N      ??HAL_TIM_PWM_Stop_IT_5
   1185          
   1186              case TIM_CHANNEL_3:
   1187              {
   1188                /* Disable the TIM Capture/Compare 3 interrupt */
   1189                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_PWM_Stop_IT_2: (+1)
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x68C0             LDR      R0,[R0, #+12]
   \   0000003A   0xF030 0x0008      BICS     R0,R0,#0x8
   \   0000003E   0x6821             LDR      R1,[R4, #+0]
   \   00000040   0x60C8             STR      R0,[R1, #+12]
   1190              }
   1191              break;
   \   00000042   0xE006             B.N      ??HAL_TIM_PWM_Stop_IT_5
   1192          
   1193              case TIM_CHANNEL_4:
   1194              {
   1195                /* Disable the TIM Capture/Compare 4 interrupt */
   1196                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_PWM_Stop_IT_3: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x68C0             LDR      R0,[R0, #+12]
   \   00000048   0xF030 0x0010      BICS     R0,R0,#0x10
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x60C8             STR      R0,[R1, #+12]
   1197              }
   1198              break;
   \   00000050   0xE7FF             B.N      ??HAL_TIM_PWM_Stop_IT_5
   1199          
   1200              default:
   1201              break;
   1202            }
   1203          
   1204            /* Disable the Capture compare channel */
   1205            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_PWM_Stop_IT_4: (+1)
   \                     ??HAL_TIM_PWM_Stop_IT_5: (+1)
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x0029             MOVS     R1,R5
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x.... 0x....      BL       TIM_CCxChannelCmd
   1206          
   1207          
   1208            /* Disable the Peripheral */
   1209            __HAL_TIM_DISABLE(htim);
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6A00             LDR      R0,[R0, #+32]
   \   00000060   0xF241 0x1111      MOVW     R1,#+4369
   \   00000064   0x4208             TST      R0,R1
   \   00000066   0xD105             BNE.N    ??HAL_TIM_PWM_Stop_IT_6
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x0840             LSRS     R0,R0,#+1
   \   0000006E   0x0040             LSLS     R0,R0,#+1
   \   00000070   0x6821             LDR      R1,[R4, #+0]
   \   00000072   0x6008             STR      R0,[R1, #+0]
   1210          
   1211            /* Return function status */
   1212            return HAL_OK;
   \                     ??HAL_TIM_PWM_Stop_IT_6: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1213          }
   1214          
   1215          /**
   1216            * @brief  Starts the TIM PWM signal generation in DMA mode.
   1217            * @param  htim : TIM handle
   1218            * @param  Channel : TIM Channels to be enabled
   1219            *          This parameter can be one of the following values:
   1220            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1221            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1222            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1223            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1224            * @param  pData: The source Buffer address.
   1225            * @param  Length: The length of data to be transferred from memory to TIM peripheral
   1226            * @retval HAL status
   1227          */

   \                                 In section .text, align 2, keep-with-next
   1228          HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1229          {
   \                     HAL_TIM_PWM_Start_DMA: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
   1230            /* Check the parameters */
   1231            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1232          
   1233            if((htim->State == HAL_TIM_STATE_BUSY))
   \   0000000A   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xD101             BNE.N    ??HAL_TIM_PWM_Start_DMA_0
   1234            {
   1235               return HAL_BUSY;
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xE085             B.N      ??HAL_TIM_PWM_Start_DMA_1
   1236            }
   1237            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIM_PWM_Start_DMA_0: (+1)
   \   00000016   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD113             BNE.N    ??HAL_TIM_PWM_Start_DMA_2
   1238            {
   1239              if(((uint32_t)pData == 0 ) && (Length > 0))
   \   0000001E   0x2E00             CMP      R6,#+0
   \   00000020   0xD104             BNE.N    ??HAL_TIM_PWM_Start_DMA_3
   \   00000022   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000024   0x2F00             CMP      R7,#+0
   \   00000026   0xD001             BEQ.N    ??HAL_TIM_PWM_Start_DMA_3
   1240              {
   1241                return HAL_ERROR;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xE07A             B.N      ??HAL_TIM_PWM_Start_DMA_1
   1242              }
   1243              else
   1244              {
   1245                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_PWM_Start_DMA_3: (+1)
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0xF884 0x0035      STRB     R0,[R4, #+53]
   1246              }
   1247            }
   1248            else
   1249            {
   1250              return HAL_ERROR;
   1251            }
   1252          
   1253            switch (Channel)
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD008             BEQ.N    ??HAL_TIM_PWM_Start_DMA_4
   \   00000038   0x2804             CMP      R0,#+4
   \   0000003A   0xD01E             BEQ.N    ??HAL_TIM_PWM_Start_DMA_5
   \   0000003C   0x2808             CMP      R0,#+8
   \   0000003E   0xD034             BEQ.N    ??HAL_TIM_PWM_Start_DMA_6
   \   00000040   0x280C             CMP      R0,#+12
   \   00000042   0xD04A             BEQ.N    ??HAL_TIM_PWM_Start_DMA_7
   \   00000044   0xE061             B.N      ??HAL_TIM_PWM_Start_DMA_8
   \                     ??HAL_TIM_PWM_Start_DMA_2: (+1)
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0xE06B             B.N      ??HAL_TIM_PWM_Start_DMA_1
   1254            {
   1255              case TIM_CHANNEL_1:
   1256              {
   1257                /* Set the DMA Period elapsed callback */
   1258                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_4: (+1)
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable5
   \   0000004E   0x69E1             LDR      R1,[R4, #+28]
   \   00000050   0x6288             STR      R0,[R1, #+40]
   1259          
   1260                /* Set the DMA error callback */
   1261                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   00000056   0x69E1             LDR      R1,[R4, #+28]
   \   00000058   0x6308             STR      R0,[R1, #+48]
   1262          
   1263                /* Enable the DMA channel */
   1264                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
   \   0000005A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000005C   0x003B             MOVS     R3,R7
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0xF110 0x0234      ADDS     R2,R0,#+52
   \   00000064   0x0031             MOVS     R1,R6
   \   00000066   0x69E0             LDR      R0,[R4, #+28]
   \   00000068   0x.... 0x....      BL       HAL_DMA_Start_IT
   1265          
   1266                /* Enable the TIM Capture/Compare 1 DMA request */
   1267                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x68C0             LDR      R0,[R0, #+12]
   \   00000070   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000074   0x6821             LDR      R1,[R4, #+0]
   \   00000076   0x60C8             STR      R0,[R1, #+12]
   1268              }
   1269              break;
   \   00000078   0xE047             B.N      ??HAL_TIM_PWM_Start_DMA_9
   1270          
   1271              case TIM_CHANNEL_2:
   1272              {
   1273                /* Set the DMA Period elapsed callback */
   1274                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_5: (+1)
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable5
   \   0000007E   0x6A21             LDR      R1,[R4, #+32]
   \   00000080   0x6288             STR      R0,[R1, #+40]
   1275          
   1276                /* Set the DMA error callback */
   1277                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   00000086   0x6A21             LDR      R1,[R4, #+32]
   \   00000088   0x6308             STR      R0,[R1, #+48]
   1278          
   1279                /* Enable the DMA channel */
   1280                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
   \   0000008A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000008C   0x003B             MOVS     R3,R7
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0xF110 0x0238      ADDS     R2,R0,#+56
   \   00000094   0x0031             MOVS     R1,R6
   \   00000096   0x6A20             LDR      R0,[R4, #+32]
   \   00000098   0x.... 0x....      BL       HAL_DMA_Start_IT
   1281          
   1282                /* Enable the TIM Capture/Compare 2 DMA request */
   1283                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0x68C0             LDR      R0,[R0, #+12]
   \   000000A0   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   000000A4   0x6821             LDR      R1,[R4, #+0]
   \   000000A6   0x60C8             STR      R0,[R1, #+12]
   1284              }
   1285              break;
   \   000000A8   0xE02F             B.N      ??HAL_TIM_PWM_Start_DMA_9
   1286          
   1287              case TIM_CHANNEL_3:
   1288              {
   1289                /* Set the DMA Period elapsed callback */
   1290                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_6: (+1)
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable5
   \   000000AE   0x6A61             LDR      R1,[R4, #+36]
   \   000000B0   0x6288             STR      R0,[R1, #+40]
   1291          
   1292                /* Set the DMA error callback */
   1293                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   000000B6   0x6A61             LDR      R1,[R4, #+36]
   \   000000B8   0x6308             STR      R0,[R1, #+48]
   1294          
   1295                /* Enable the DMA channel */
   1296                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
   \   000000BA   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000BC   0x003B             MOVS     R3,R7
   \   000000BE   0x6820             LDR      R0,[R4, #+0]
   \   000000C0   0xF110 0x023C      ADDS     R2,R0,#+60
   \   000000C4   0x0031             MOVS     R1,R6
   \   000000C6   0x6A60             LDR      R0,[R4, #+36]
   \   000000C8   0x.... 0x....      BL       HAL_DMA_Start_IT
   1297          
   1298                /* Enable the TIM Output Capture/Compare 3 request */
   1299                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \   000000CC   0x6820             LDR      R0,[R4, #+0]
   \   000000CE   0x68C0             LDR      R0,[R0, #+12]
   \   000000D0   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   000000D4   0x6821             LDR      R1,[R4, #+0]
   \   000000D6   0x60C8             STR      R0,[R1, #+12]
   1300              }
   1301              break;
   \   000000D8   0xE017             B.N      ??HAL_TIM_PWM_Start_DMA_9
   1302          
   1303              case TIM_CHANNEL_4:
   1304              {
   1305               /* Set the DMA Period elapsed callback */
   1306                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_7: (+1)
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable5
   \   000000DE   0x6AA1             LDR      R1,[R4, #+40]
   \   000000E0   0x6288             STR      R0,[R1, #+40]
   1307          
   1308                /* Set the DMA error callback */
   1309                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   000000E6   0x6AA1             LDR      R1,[R4, #+40]
   \   000000E8   0x6308             STR      R0,[R1, #+48]
   1310          
   1311                /* Enable the DMA channel */
   1312                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
   \   000000EA   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000EC   0x003B             MOVS     R3,R7
   \   000000EE   0x6820             LDR      R0,[R4, #+0]
   \   000000F0   0xF110 0x0240      ADDS     R2,R0,#+64
   \   000000F4   0x0031             MOVS     R1,R6
   \   000000F6   0x6AA0             LDR      R0,[R4, #+40]
   \   000000F8   0x.... 0x....      BL       HAL_DMA_Start_IT
   1313          
   1314                /* Enable the TIM Capture/Compare 4 DMA request */
   1315                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \   000000FC   0x6820             LDR      R0,[R4, #+0]
   \   000000FE   0x68C0             LDR      R0,[R0, #+12]
   \   00000100   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   00000104   0x6821             LDR      R1,[R4, #+0]
   \   00000106   0x60C8             STR      R0,[R1, #+12]
   1316              }
   1317              break;
   \   00000108   0xE7FF             B.N      ??HAL_TIM_PWM_Start_DMA_9
   1318          
   1319              default:
   1320              break;
   1321            }
   1322          
   1323            /* Enable the Capture compare channel */
   1324            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_PWM_Start_DMA_8: (+1)
   \                     ??HAL_TIM_PWM_Start_DMA_9: (+1)
   \   0000010A   0x2201             MOVS     R2,#+1
   \   0000010C   0x0029             MOVS     R1,R5
   \   0000010E   0x6820             LDR      R0,[R4, #+0]
   \   00000110   0x.... 0x....      BL       TIM_CCxChannelCmd
   1325          
   1326            /* Enable the Peripheral */
   1327            __HAL_TIM_ENABLE(htim);
   \   00000114   0x6820             LDR      R0,[R4, #+0]
   \   00000116   0x6800             LDR      R0,[R0, #+0]
   \   00000118   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000011C   0x6821             LDR      R1,[R4, #+0]
   \   0000011E   0x6008             STR      R0,[R1, #+0]
   1328          
   1329            /* Return function status */
   1330            return HAL_OK;
   \   00000120   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Start_DMA_1: (+1)
   \   00000122   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1331          }
   1332          
   1333          /**
   1334            * @brief  Stops the TIM PWM signal generation in DMA mode.
   1335            * @param  htim : TIM handle
   1336            * @param  Channel : TIM Channels to be disabled
   1337            *          This parameter can be one of the following values:
   1338            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1339            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1340            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1341            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1342            * @retval HAL status
   1343          */

   \                                 In section .text, align 2, keep-with-next
   1344          HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1345          {
   \                     HAL_TIM_PWM_Stop_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1346            /* Check the parameters */
   1347            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1348          
   1349            switch (Channel)
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD006             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_0
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD00B             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_1
   \   00000010   0x2808             CMP      R0,#+8
   \   00000012   0xD010             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_2
   \   00000014   0x280C             CMP      R0,#+12
   \   00000016   0xD015             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_3
   \   00000018   0xE01B             B.N      ??HAL_TIM_PWM_Stop_DMA_4
   1350            {
   1351              case TIM_CHANNEL_1:
   1352              {
   1353                /* Disable the TIM Capture/Compare 1 DMA request */
   1354                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_PWM_Stop_DMA_0: (+1)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF430 0x7000      BICS     R0,R0,#0x200
   \   00000022   0x6821             LDR      R1,[R4, #+0]
   \   00000024   0x60C8             STR      R0,[R1, #+12]
   1355              }
   1356              break;
   \   00000026   0xE014             B.N      ??HAL_TIM_PWM_Stop_DMA_5
   1357          
   1358              case TIM_CHANNEL_2:
   1359              {
   1360                /* Disable the TIM Capture/Compare 2 DMA request */
   1361                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_PWM_Stop_DMA_1: (+1)
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x68C0             LDR      R0,[R0, #+12]
   \   0000002C   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x60C8             STR      R0,[R1, #+12]
   1362              }
   1363              break;
   \   00000034   0xE00D             B.N      ??HAL_TIM_PWM_Stop_DMA_5
   1364          
   1365              case TIM_CHANNEL_3:
   1366              {
   1367                /* Disable the TIM Capture/Compare 3 DMA request */
   1368                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_PWM_Stop_DMA_2: (+1)
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x68C0             LDR      R0,[R0, #+12]
   \   0000003A   0xF430 0x6000      BICS     R0,R0,#0x800
   \   0000003E   0x6821             LDR      R1,[R4, #+0]
   \   00000040   0x60C8             STR      R0,[R1, #+12]
   1369              }
   1370              break;
   \   00000042   0xE006             B.N      ??HAL_TIM_PWM_Stop_DMA_5
   1371          
   1372              case TIM_CHANNEL_4:
   1373              {
   1374                /* Disable the TIM Capture/Compare 4 interrupt */
   1375                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_PWM_Stop_DMA_3: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x68C0             LDR      R0,[R0, #+12]
   \   00000048   0xF430 0x5080      BICS     R0,R0,#0x1000
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x60C8             STR      R0,[R1, #+12]
   1376              }
   1377              break;
   \   00000050   0xE7FF             B.N      ??HAL_TIM_PWM_Stop_DMA_5
   1378          
   1379              default:
   1380              break;
   1381            }
   1382          
   1383            /* Disable the Capture compare channel */
   1384            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_PWM_Stop_DMA_4: (+1)
   \                     ??HAL_TIM_PWM_Stop_DMA_5: (+1)
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x0029             MOVS     R1,R5
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x.... 0x....      BL       TIM_CCxChannelCmd
   1385          
   1386            /* Disable the Peripheral */
   1387            __HAL_TIM_DISABLE(htim);
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6A00             LDR      R0,[R0, #+32]
   \   00000060   0xF241 0x1111      MOVW     R1,#+4369
   \   00000064   0x4208             TST      R0,R1
   \   00000066   0xD105             BNE.N    ??HAL_TIM_PWM_Stop_DMA_6
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x0840             LSRS     R0,R0,#+1
   \   0000006E   0x0040             LSLS     R0,R0,#+1
   \   00000070   0x6821             LDR      R1,[R4, #+0]
   \   00000072   0x6008             STR      R0,[R1, #+0]
   1388          
   1389            /* Change the htim state */
   1390            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_PWM_Stop_DMA_6: (+1)
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xF884 0x0035      STRB     R0,[R4, #+53]
   1391          
   1392            /* Return function status */
   1393            return HAL_OK;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1394          }
   1395          
   1396          /**
   1397            * @}
   1398            */
   1399          
   1400          /** @defgroup TIM_Exported_Functions_Group4 Time Input Capture functions
   1401           *  @brief    Time Input Capture functions
   1402           *
   1403          @verbatim
   1404            ==============================================================================
   1405                        ##### Time Input Capture functions #####
   1406            ==============================================================================
   1407           [..]
   1408             This section provides functions allowing to:
   1409             (+) Initialize and configure the TIM Input Capture.
   1410             (+) De-initialize the TIM Input Capture.
   1411             (+) Start the Time Input Capture.
   1412             (+) Stop the Time Input Capture.
   1413             (+) Start the Time Input Capture and enable interrupt.
   1414             (+) Stop the Time Input Capture and disable interrupt.
   1415             (+) Start the Time Input Capture and enable DMA transfer.
   1416             (+) Stop the Time Input Capture and disable DMA transfer.
   1417          
   1418          @endverbatim
   1419            * @{
   1420            */
   1421          /**
   1422            * @brief  Initializes the TIM Input Capture Time base according to the specified
   1423            *         parameters in the TIM_HandleTypeDef and create the associated handle.
   1424            * @param  htim: TIM Input Capture handle
   1425            * @retval HAL status
   1426            */

   \                                 In section .text, align 2, keep-with-next
   1427          HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
   1428          {
   \                     HAL_TIM_IC_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1429            /* Check the TIM handle allocation */
   1430            if(htim == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_TIM_IC_Init_0
   1431            {
   1432              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE014             B.N      ??HAL_TIM_IC_Init_1
   1433            }
   1434          
   1435            /* Check the parameters */
   1436            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1437            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1438            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   1439          
   1440            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_IC_Init_0: (+1)
   \   0000000C   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD105             BNE.N    ??HAL_TIM_IC_Init_2
   1441            {
   1442              /* Allocate lock resource and initialize it */
   1443              htim->Lock = HAL_UNLOCKED;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF884 0x0034      STRB     R0,[R4, #+52]
   1444          
   1445              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1446              HAL_TIM_IC_MspInit(htim);
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_TIM_IC_MspInit
   1447            }
   1448          
   1449            /* Set the TIM state */
   1450            htim->State= HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_IC_Init_2: (+1)
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xF884 0x0035      STRB     R0,[R4, #+53]
   1451          
   1452            /* Init the base time for the input capture */
   1453            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \   00000026   0x1D21             ADDS     R1,R4,#+4
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x.... 0x....      BL       TIM_Base_SetConfig
   1454          
   1455            /* Initialize the TIM state*/
   1456            htim->State= HAL_TIM_STATE_READY;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF884 0x0035      STRB     R0,[R4, #+53]
   1457          
   1458            return HAL_OK;
   \   00000034   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_IC_Init_1: (+1)
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
   1459          }
   1460          
   1461          /**
   1462            * @brief  DeInitializes the TIM peripheral
   1463            * @param  htim: TIM Input Capture handle
   1464            * @retval HAL status
   1465            */

   \                                 In section .text, align 2, keep-with-next
   1466          HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
   1467          {
   \                     HAL_TIM_IC_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1468            /* Check the parameters */
   1469            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1470          
   1471            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0035      STRB     R0,[R4, #+53]
   1472          
   1473            /* Disable the TIM Peripheral Clock */
   1474            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A00             LDR      R0,[R0, #+32]
   \   0000000E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000012   0x4208             TST      R0,R1
   \   00000014   0xD105             BNE.N    ??HAL_TIM_IC_DeInit_0
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x0840             LSRS     R0,R0,#+1
   \   0000001C   0x0040             LSLS     R0,R0,#+1
   \   0000001E   0x6821             LDR      R1,[R4, #+0]
   \   00000020   0x6008             STR      R0,[R1, #+0]
   1475          
   1476            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1477            HAL_TIM_IC_MspDeInit(htim);
   \                     ??HAL_TIM_IC_DeInit_0: (+1)
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       HAL_TIM_IC_MspDeInit
   1478          
   1479            /* Change TIM state */
   1480            htim->State = HAL_TIM_STATE_RESET;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF884 0x0035      STRB     R0,[R4, #+53]
   1481          
   1482            /* Release Lock */
   1483            __HAL_UNLOCK(htim);
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0034      STRB     R0,[R4, #+52]
   1484          
   1485            return HAL_OK;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
   1486          }
   1487          
   1488          /**
   1489            * @brief  Initializes the TIM Input Capture MSP.
   1490            * @param  htim: TIM handle
   1491            * @retval None
   1492            */

   \                                 In section .text, align 2
   1493          __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
   1494          {
   1495            /* NOTE : This function Should not be modified, when the callback is needed,
   1496                      the HAL_TIM_IC_MspInit could be implemented in the user file
   1497             */
   1498          }
   \                     HAL_TIM_IC_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1499          
   1500          /**
   1501            * @brief  DeInitializes TIM Input Capture MSP.
   1502            * @param  htim: TIM handle
   1503            * @retval None
   1504            */

   \                                 In section .text, align 2
   1505          __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
   1506          {
   1507            /* NOTE : This function Should not be modified, when the callback is needed,
   1508                      the HAL_TIM_IC_MspDeInit could be implemented in the user file
   1509             */
   1510          }
   \                     HAL_TIM_IC_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1511          
   1512          /**
   1513            * @brief  Starts the TIM Input Capture measurement.
   1514            * @param  htim : TIM Input Capture handle
   1515            * @param  Channel : TIM Channels to be enabled
   1516            *          This parameter can be one of the following values:
   1517            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1518            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1519            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1520            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1521            * @retval HAL status
   1522          */

   \                                 In section .text, align 2, keep-with-next
   1523          HAL_StatusTypeDef HAL_TIM_IC_Start (TIM_HandleTypeDef *htim, uint32_t Channel)
   1524          {
   \                     HAL_TIM_IC_Start: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1525            /* Check the parameters */
   1526            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1527          
   1528            /* Enable the Input Capture channel */
   1529            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0x0029             MOVS     R1,R5
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       TIM_CCxChannelCmd
   1530          
   1531            /* Enable the Peripheral */
   1532            __HAL_TIM_ENABLE(htim);
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000018   0x6821             LDR      R1,[R4, #+0]
   \   0000001A   0x6008             STR      R0,[R1, #+0]
   1533          
   1534            /* Return function status */
   1535            return HAL_OK;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1536          }
   1537          
   1538          /**
   1539            * @brief  Stops the TIM Input Capture measurement.
   1540            * @param  htim : TIM handle
   1541            * @param  Channel : TIM Channels to be disabled
   1542            *          This parameter can be one of the following values:
   1543            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1544            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1545            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1546            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1547            * @retval HAL status
   1548          */

   \                                 In section .text, align 2, keep-with-next
   1549          HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1550          {
   \                     HAL_TIM_IC_Stop: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1551            /* Check the parameters */
   1552            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1553          
   1554            /* Disable the Input Capture channel */
   1555            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x0029             MOVS     R1,R5
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       TIM_CCxChannelCmd
   1556          
   1557            /* Disable the Peripheral */
   1558            __HAL_TIM_DISABLE(htim);
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x6A00             LDR      R0,[R0, #+32]
   \   00000014   0xF241 0x1111      MOVW     R1,#+4369
   \   00000018   0x4208             TST      R0,R1
   \   0000001A   0xD105             BNE.N    ??HAL_TIM_IC_Stop_0
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x0840             LSRS     R0,R0,#+1
   \   00000022   0x0040             LSLS     R0,R0,#+1
   \   00000024   0x6821             LDR      R1,[R4, #+0]
   \   00000026   0x6008             STR      R0,[R1, #+0]
   1559          
   1560            /* Return function status */
   1561            return HAL_OK;
   \                     ??HAL_TIM_IC_Stop_0: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1562          }
   1563          
   1564          /**
   1565            * @brief  Starts the TIM Input Capture measurement in interrupt mode.
   1566            * @param  htim : TIM Input Capture handle
   1567            * @param  Channel : TIM Channels to be enabled
   1568            *          This parameter can be one of the following values:
   1569            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1570            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1571            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1572            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1573            * @retval HAL status
   1574          */

   \                                 In section .text, align 2, keep-with-next
   1575          HAL_StatusTypeDef HAL_TIM_IC_Start_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
   1576          {
   \                     HAL_TIM_IC_Start_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1577            /* Check the parameters */
   1578            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1579          
   1580            switch (Channel)
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD006             BEQ.N    ??HAL_TIM_IC_Start_IT_0
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD00B             BEQ.N    ??HAL_TIM_IC_Start_IT_1
   \   00000010   0x2808             CMP      R0,#+8
   \   00000012   0xD010             BEQ.N    ??HAL_TIM_IC_Start_IT_2
   \   00000014   0x280C             CMP      R0,#+12
   \   00000016   0xD015             BEQ.N    ??HAL_TIM_IC_Start_IT_3
   \   00000018   0xE01B             B.N      ??HAL_TIM_IC_Start_IT_4
   1581            {
   1582              case TIM_CHANNEL_1:
   1583              {
   1584                /* Enable the TIM Capture/Compare 1 interrupt */
   1585                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_IC_Start_IT_0: (+1)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000022   0x6821             LDR      R1,[R4, #+0]
   \   00000024   0x60C8             STR      R0,[R1, #+12]
   1586              }
   1587              break;
   \   00000026   0xE014             B.N      ??HAL_TIM_IC_Start_IT_5
   1588          
   1589              case TIM_CHANNEL_2:
   1590              {
   1591                /* Enable the TIM Capture/Compare 2 interrupt */
   1592                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_IC_Start_IT_1: (+1)
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x68C0             LDR      R0,[R0, #+12]
   \   0000002C   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x60C8             STR      R0,[R1, #+12]
   1593              }
   1594              break;
   \   00000034   0xE00D             B.N      ??HAL_TIM_IC_Start_IT_5
   1595          
   1596              case TIM_CHANNEL_3:
   1597              {
   1598                /* Enable the TIM Capture/Compare 3 interrupt */
   1599                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_IC_Start_IT_2: (+1)
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x68C0             LDR      R0,[R0, #+12]
   \   0000003A   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000003E   0x6821             LDR      R1,[R4, #+0]
   \   00000040   0x60C8             STR      R0,[R1, #+12]
   1600              }
   1601              break;
   \   00000042   0xE006             B.N      ??HAL_TIM_IC_Start_IT_5
   1602          
   1603              case TIM_CHANNEL_4:
   1604              {
   1605                /* Enable the TIM Capture/Compare 4 interrupt */
   1606                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_IC_Start_IT_3: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x68C0             LDR      R0,[R0, #+12]
   \   00000048   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x60C8             STR      R0,[R1, #+12]
   1607              }
   1608              break;
   \   00000050   0xE7FF             B.N      ??HAL_TIM_IC_Start_IT_5
   1609          
   1610              default:
   1611              break;
   1612            }
   1613            /* Enable the Input Capture channel */
   1614            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_IC_Start_IT_4: (+1)
   \                     ??HAL_TIM_IC_Start_IT_5: (+1)
   \   00000052   0x2201             MOVS     R2,#+1
   \   00000054   0x0029             MOVS     R1,R5
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x.... 0x....      BL       TIM_CCxChannelCmd
   1615          
   1616            /* Enable the Peripheral */
   1617            __HAL_TIM_ENABLE(htim);
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x6008             STR      R0,[R1, #+0]
   1618          
   1619            /* Return function status */
   1620            return HAL_OK;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1621          }
   1622          
   1623          /**
   1624            * @brief  Stops the TIM Input Capture measurement in interrupt mode.
   1625            * @param  htim : TIM handle
   1626            * @param  Channel : TIM Channels to be disabled
   1627            *          This parameter can be one of the following values:
   1628            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1629            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1630            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1631            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1632            * @retval HAL status
   1633          */

   \                                 In section .text, align 2, keep-with-next
   1634          HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1635          {
   \                     HAL_TIM_IC_Stop_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1636            /* Check the parameters */
   1637            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1638          
   1639            switch (Channel)
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD006             BEQ.N    ??HAL_TIM_IC_Stop_IT_0
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD00B             BEQ.N    ??HAL_TIM_IC_Stop_IT_1
   \   00000010   0x2808             CMP      R0,#+8
   \   00000012   0xD010             BEQ.N    ??HAL_TIM_IC_Stop_IT_2
   \   00000014   0x280C             CMP      R0,#+12
   \   00000016   0xD015             BEQ.N    ??HAL_TIM_IC_Stop_IT_3
   \   00000018   0xE01B             B.N      ??HAL_TIM_IC_Stop_IT_4
   1640            {
   1641              case TIM_CHANNEL_1:
   1642              {
   1643                /* Disable the TIM Capture/Compare 1 interrupt */
   1644                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_IC_Stop_IT_0: (+1)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000022   0x6821             LDR      R1,[R4, #+0]
   \   00000024   0x60C8             STR      R0,[R1, #+12]
   1645              }
   1646              break;
   \   00000026   0xE014             B.N      ??HAL_TIM_IC_Stop_IT_5
   1647          
   1648              case TIM_CHANNEL_2:
   1649              {
   1650                /* Disable the TIM Capture/Compare 2 interrupt */
   1651                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_IC_Stop_IT_1: (+1)
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x68C0             LDR      R0,[R0, #+12]
   \   0000002C   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x60C8             STR      R0,[R1, #+12]
   1652              }
   1653              break;
   \   00000034   0xE00D             B.N      ??HAL_TIM_IC_Stop_IT_5
   1654          
   1655              case TIM_CHANNEL_3:
   1656              {
   1657                /* Disable the TIM Capture/Compare 3 interrupt */
   1658                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_IC_Stop_IT_2: (+1)
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x68C0             LDR      R0,[R0, #+12]
   \   0000003A   0xF030 0x0008      BICS     R0,R0,#0x8
   \   0000003E   0x6821             LDR      R1,[R4, #+0]
   \   00000040   0x60C8             STR      R0,[R1, #+12]
   1659              }
   1660              break;
   \   00000042   0xE006             B.N      ??HAL_TIM_IC_Stop_IT_5
   1661          
   1662              case TIM_CHANNEL_4:
   1663              {
   1664                /* Disable the TIM Capture/Compare 4 interrupt */
   1665                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_IC_Stop_IT_3: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x68C0             LDR      R0,[R0, #+12]
   \   00000048   0xF030 0x0010      BICS     R0,R0,#0x10
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x60C8             STR      R0,[R1, #+12]
   1666              }
   1667              break;
   \   00000050   0xE7FF             B.N      ??HAL_TIM_IC_Stop_IT_5
   1668          
   1669              default:
   1670              break;
   1671            }
   1672          
   1673            /* Disable the Input Capture channel */
   1674            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_IC_Stop_IT_4: (+1)
   \                     ??HAL_TIM_IC_Stop_IT_5: (+1)
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x0029             MOVS     R1,R5
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x.... 0x....      BL       TIM_CCxChannelCmd
   1675          
   1676            /* Disable the Peripheral */
   1677            __HAL_TIM_DISABLE(htim);
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6A00             LDR      R0,[R0, #+32]
   \   00000060   0xF241 0x1111      MOVW     R1,#+4369
   \   00000064   0x4208             TST      R0,R1
   \   00000066   0xD105             BNE.N    ??HAL_TIM_IC_Stop_IT_6
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x0840             LSRS     R0,R0,#+1
   \   0000006E   0x0040             LSLS     R0,R0,#+1
   \   00000070   0x6821             LDR      R1,[R4, #+0]
   \   00000072   0x6008             STR      R0,[R1, #+0]
   1678          
   1679            /* Return function status */
   1680            return HAL_OK;
   \                     ??HAL_TIM_IC_Stop_IT_6: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1681          }
   1682          
   1683          /**
   1684            * @brief  Starts the TIM Input Capture measurement in DMA mode.
   1685            * @param  htim : TIM Input Capture handle
   1686            * @param  Channel : TIM Channels to be enabled
   1687            *          This parameter can be one of the following values:
   1688            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1689            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1690            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1691            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1692            * @param  pData: The destination Buffer address.
   1693            * @param  Length: The length of data to be transferred from TIM peripheral to memory.
   1694            * @retval HAL status
   1695          */

   \                                 In section .text, align 2, keep-with-next
   1696          HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1697          {
   \                     HAL_TIM_IC_Start_DMA: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
   1698            /* Check the parameters */
   1699            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1700            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   1701          
   1702            if((htim->State == HAL_TIM_STATE_BUSY))
   \   0000000A   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xD101             BNE.N    ??HAL_TIM_IC_Start_DMA_0
   1703            {
   1704               return HAL_BUSY;
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xE085             B.N      ??HAL_TIM_IC_Start_DMA_1
   1705            }
   1706            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIM_IC_Start_DMA_0: (+1)
   \   00000016   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD113             BNE.N    ??HAL_TIM_IC_Start_DMA_2
   1707            {
   1708              if((pData == 0 ) && (Length > 0))
   \   0000001E   0x2E00             CMP      R6,#+0
   \   00000020   0xD104             BNE.N    ??HAL_TIM_IC_Start_DMA_3
   \   00000022   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000024   0x2F00             CMP      R7,#+0
   \   00000026   0xD001             BEQ.N    ??HAL_TIM_IC_Start_DMA_3
   1709              {
   1710                return HAL_ERROR;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xE07A             B.N      ??HAL_TIM_IC_Start_DMA_1
   1711              }
   1712              else
   1713              {
   1714                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_IC_Start_DMA_3: (+1)
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0xF884 0x0035      STRB     R0,[R4, #+53]
   1715              }
   1716            }
   1717            else
   1718            {
   1719              return HAL_ERROR;
   1720            }
   1721          
   1722            switch (Channel)
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD008             BEQ.N    ??HAL_TIM_IC_Start_DMA_4
   \   00000038   0x2804             CMP      R0,#+4
   \   0000003A   0xD01E             BEQ.N    ??HAL_TIM_IC_Start_DMA_5
   \   0000003C   0x2808             CMP      R0,#+8
   \   0000003E   0xD034             BEQ.N    ??HAL_TIM_IC_Start_DMA_6
   \   00000040   0x280C             CMP      R0,#+12
   \   00000042   0xD04A             BEQ.N    ??HAL_TIM_IC_Start_DMA_7
   \   00000044   0xE061             B.N      ??HAL_TIM_IC_Start_DMA_8
   \                     ??HAL_TIM_IC_Start_DMA_2: (+1)
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0xE06B             B.N      ??HAL_TIM_IC_Start_DMA_1
   1723            {
   1724              case TIM_CHANNEL_1:
   1725              {
   1726                /* Set the DMA Period elapsed callback */
   1727                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_4: (+1)
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable5_2
   \   0000004E   0x69E1             LDR      R1,[R4, #+28]
   \   00000050   0x6288             STR      R0,[R1, #+40]
   1728          
   1729                /* Set the DMA error callback */
   1730                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   00000056   0x69E1             LDR      R1,[R4, #+28]
   \   00000058   0x6308             STR      R0,[R1, #+48]
   1731          
   1732                /* Enable the DMA channel */
   1733                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length);
   \   0000005A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000005C   0x003B             MOVS     R3,R7
   \   0000005E   0x0032             MOVS     R2,R6
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0xF110 0x0134      ADDS     R1,R0,#+52
   \   00000066   0x69E0             LDR      R0,[R4, #+28]
   \   00000068   0x.... 0x....      BL       HAL_DMA_Start_IT
   1734          
   1735                /* Enable the TIM Capture/Compare 1 DMA request */
   1736                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x68C0             LDR      R0,[R0, #+12]
   \   00000070   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000074   0x6821             LDR      R1,[R4, #+0]
   \   00000076   0x60C8             STR      R0,[R1, #+12]
   1737              }
   1738              break;
   \   00000078   0xE047             B.N      ??HAL_TIM_IC_Start_DMA_9
   1739          
   1740              case TIM_CHANNEL_2:
   1741              {
   1742                /* Set the DMA Period elapsed callback */
   1743                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_5: (+1)
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable5_2
   \   0000007E   0x6A21             LDR      R1,[R4, #+32]
   \   00000080   0x6288             STR      R0,[R1, #+40]
   1744          
   1745                /* Set the DMA error callback */
   1746                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   00000086   0x6A21             LDR      R1,[R4, #+32]
   \   00000088   0x6308             STR      R0,[R1, #+48]
   1747          
   1748                /* Enable the DMA channel */
   1749                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length);
   \   0000008A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000008C   0x003B             MOVS     R3,R7
   \   0000008E   0x0032             MOVS     R2,R6
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0xF110 0x0138      ADDS     R1,R0,#+56
   \   00000096   0x6A20             LDR      R0,[R4, #+32]
   \   00000098   0x.... 0x....      BL       HAL_DMA_Start_IT
   1750          
   1751                /* Enable the TIM Capture/Compare 2  DMA request */
   1752                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0x68C0             LDR      R0,[R0, #+12]
   \   000000A0   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   000000A4   0x6821             LDR      R1,[R4, #+0]
   \   000000A6   0x60C8             STR      R0,[R1, #+12]
   1753              }
   1754              break;
   \   000000A8   0xE02F             B.N      ??HAL_TIM_IC_Start_DMA_9
   1755          
   1756              case TIM_CHANNEL_3:
   1757              {
   1758                /* Set the DMA Period elapsed callback */
   1759                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_6: (+1)
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable5_2
   \   000000AE   0x6A61             LDR      R1,[R4, #+36]
   \   000000B0   0x6288             STR      R0,[R1, #+40]
   1760          
   1761                /* Set the DMA error callback */
   1762                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   000000B6   0x6A61             LDR      R1,[R4, #+36]
   \   000000B8   0x6308             STR      R0,[R1, #+48]
   1763          
   1764                /* Enable the DMA channel */
   1765                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length);
   \   000000BA   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000BC   0x003B             MOVS     R3,R7
   \   000000BE   0x0032             MOVS     R2,R6
   \   000000C0   0x6820             LDR      R0,[R4, #+0]
   \   000000C2   0xF110 0x013C      ADDS     R1,R0,#+60
   \   000000C6   0x6A60             LDR      R0,[R4, #+36]
   \   000000C8   0x.... 0x....      BL       HAL_DMA_Start_IT
   1766          
   1767                /* Enable the TIM Capture/Compare 3  DMA request */
   1768                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \   000000CC   0x6820             LDR      R0,[R4, #+0]
   \   000000CE   0x68C0             LDR      R0,[R0, #+12]
   \   000000D0   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   000000D4   0x6821             LDR      R1,[R4, #+0]
   \   000000D6   0x60C8             STR      R0,[R1, #+12]
   1769              }
   1770              break;
   \   000000D8   0xE017             B.N      ??HAL_TIM_IC_Start_DMA_9
   1771          
   1772              case TIM_CHANNEL_4:
   1773              {
   1774                /* Set the DMA Period elapsed callback */
   1775                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_7: (+1)
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable5_2
   \   000000DE   0x6AA1             LDR      R1,[R4, #+40]
   \   000000E0   0x6288             STR      R0,[R1, #+40]
   1776          
   1777                /* Set the DMA error callback */
   1778                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   000000E6   0x6AA1             LDR      R1,[R4, #+40]
   \   000000E8   0x6308             STR      R0,[R1, #+48]
   1779          
   1780                /* Enable the DMA channel */
   1781                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length);
   \   000000EA   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000EC   0x003B             MOVS     R3,R7
   \   000000EE   0x0032             MOVS     R2,R6
   \   000000F0   0x6820             LDR      R0,[R4, #+0]
   \   000000F2   0xF110 0x0140      ADDS     R1,R0,#+64
   \   000000F6   0x6AA0             LDR      R0,[R4, #+40]
   \   000000F8   0x.... 0x....      BL       HAL_DMA_Start_IT
   1782          
   1783                /* Enable the TIM Capture/Compare 4  DMA request */
   1784                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \   000000FC   0x6820             LDR      R0,[R4, #+0]
   \   000000FE   0x68C0             LDR      R0,[R0, #+12]
   \   00000100   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   00000104   0x6821             LDR      R1,[R4, #+0]
   \   00000106   0x60C8             STR      R0,[R1, #+12]
   1785              }
   1786              break;
   \   00000108   0xE7FF             B.N      ??HAL_TIM_IC_Start_DMA_9
   1787          
   1788              default:
   1789              break;
   1790            }
   1791          
   1792            /* Enable the Input Capture channel */
   1793            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_IC_Start_DMA_8: (+1)
   \                     ??HAL_TIM_IC_Start_DMA_9: (+1)
   \   0000010A   0x2201             MOVS     R2,#+1
   \   0000010C   0x0029             MOVS     R1,R5
   \   0000010E   0x6820             LDR      R0,[R4, #+0]
   \   00000110   0x.... 0x....      BL       TIM_CCxChannelCmd
   1794          
   1795            /* Enable the Peripheral */
   1796            __HAL_TIM_ENABLE(htim);
   \   00000114   0x6820             LDR      R0,[R4, #+0]
   \   00000116   0x6800             LDR      R0,[R0, #+0]
   \   00000118   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000011C   0x6821             LDR      R1,[R4, #+0]
   \   0000011E   0x6008             STR      R0,[R1, #+0]
   1797          
   1798            /* Return function status */
   1799            return HAL_OK;
   \   00000120   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_IC_Start_DMA_1: (+1)
   \   00000122   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1800          }
   1801          
   1802          /**
   1803            * @brief  Stops the TIM Input Capture measurement in DMA mode.
   1804            * @param  htim : TIM Input Capture handle
   1805            * @param  Channel : TIM Channels to be disabled
   1806            *          This parameter can be one of the following values:
   1807            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1808            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1809            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1810            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1811            * @retval HAL status
   1812          */

   \                                 In section .text, align 2, keep-with-next
   1813          HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1814          {
   \                     HAL_TIM_IC_Stop_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1815            /* Check the parameters */
   1816            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1817            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   1818          
   1819            switch (Channel)
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD006             BEQ.N    ??HAL_TIM_IC_Stop_DMA_0
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD00B             BEQ.N    ??HAL_TIM_IC_Stop_DMA_1
   \   00000010   0x2808             CMP      R0,#+8
   \   00000012   0xD010             BEQ.N    ??HAL_TIM_IC_Stop_DMA_2
   \   00000014   0x280C             CMP      R0,#+12
   \   00000016   0xD015             BEQ.N    ??HAL_TIM_IC_Stop_DMA_3
   \   00000018   0xE01B             B.N      ??HAL_TIM_IC_Stop_DMA_4
   1820            {
   1821              case TIM_CHANNEL_1:
   1822              {
   1823                /* Disable the TIM Capture/Compare 1 DMA request */
   1824                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_IC_Stop_DMA_0: (+1)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF430 0x7000      BICS     R0,R0,#0x200
   \   00000022   0x6821             LDR      R1,[R4, #+0]
   \   00000024   0x60C8             STR      R0,[R1, #+12]
   1825              }
   1826              break;
   \   00000026   0xE014             B.N      ??HAL_TIM_IC_Stop_DMA_5
   1827          
   1828              case TIM_CHANNEL_2:
   1829              {
   1830                /* Disable the TIM Capture/Compare 2 DMA request */
   1831                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_IC_Stop_DMA_1: (+1)
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x68C0             LDR      R0,[R0, #+12]
   \   0000002C   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x60C8             STR      R0,[R1, #+12]
   1832              }
   1833              break;
   \   00000034   0xE00D             B.N      ??HAL_TIM_IC_Stop_DMA_5
   1834          
   1835              case TIM_CHANNEL_3:
   1836              {
   1837                /* Disable the TIM Capture/Compare 3  DMA request */
   1838                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_IC_Stop_DMA_2: (+1)
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x68C0             LDR      R0,[R0, #+12]
   \   0000003A   0xF430 0x6000      BICS     R0,R0,#0x800
   \   0000003E   0x6821             LDR      R1,[R4, #+0]
   \   00000040   0x60C8             STR      R0,[R1, #+12]
   1839              }
   1840              break;
   \   00000042   0xE006             B.N      ??HAL_TIM_IC_Stop_DMA_5
   1841          
   1842              case TIM_CHANNEL_4:
   1843              {
   1844                /* Disable the TIM Capture/Compare 4  DMA request */
   1845                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_IC_Stop_DMA_3: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x68C0             LDR      R0,[R0, #+12]
   \   00000048   0xF430 0x5080      BICS     R0,R0,#0x1000
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x60C8             STR      R0,[R1, #+12]
   1846              }
   1847              break;
   \   00000050   0xE7FF             B.N      ??HAL_TIM_IC_Stop_DMA_5
   1848          
   1849              default:
   1850              break;
   1851            }
   1852          
   1853            /* Disable the Input Capture channel */
   1854            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_IC_Stop_DMA_4: (+1)
   \                     ??HAL_TIM_IC_Stop_DMA_5: (+1)
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x0029             MOVS     R1,R5
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x.... 0x....      BL       TIM_CCxChannelCmd
   1855          
   1856            /* Disable the Peripheral */
   1857            __HAL_TIM_DISABLE(htim);
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6A00             LDR      R0,[R0, #+32]
   \   00000060   0xF241 0x1111      MOVW     R1,#+4369
   \   00000064   0x4208             TST      R0,R1
   \   00000066   0xD105             BNE.N    ??HAL_TIM_IC_Stop_DMA_6
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x0840             LSRS     R0,R0,#+1
   \   0000006E   0x0040             LSLS     R0,R0,#+1
   \   00000070   0x6821             LDR      R1,[R4, #+0]
   \   00000072   0x6008             STR      R0,[R1, #+0]
   1858          
   1859            /* Change the htim state */
   1860            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_IC_Stop_DMA_6: (+1)
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xF884 0x0035      STRB     R0,[R4, #+53]
   1861          
   1862            /* Return function status */
   1863            return HAL_OK;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1864          }
   1865          /**
   1866            * @}
   1867            */
   1868          
   1869          /** @defgroup TIM_Exported_Functions_Group5 Time One Pulse functions
   1870           *  @brief    Time One Pulse functions
   1871           *
   1872          @verbatim
   1873            ==============================================================================
   1874                                  ##### Time One Pulse functions #####
   1875            ==============================================================================
   1876            [..]
   1877              This section provides functions allowing to:
   1878              (+) Initialize and configure the TIM One Pulse.
   1879              (+) De-initialize the TIM One Pulse.
   1880              (+) Start the Time One Pulse.
   1881              (+) Stop the Time One Pulse.
   1882              (+) Start the Time One Pulse and enable interrupt.
   1883              (+) Stop the Time One Pulse and disable interrupt.
   1884              (+) Start the Time One Pulse and enable DMA transfer.
   1885              (+) Stop the Time One Pulse and disable DMA transfer.
   1886          
   1887          @endverbatim
   1888            * @{
   1889            */
   1890          /**
   1891            * @brief  Initializes the TIM One Pulse Time Base according to the specified
   1892            *         parameters in the TIM_HandleTypeDef and create the associated handle.
   1893            * @param  htim: TIM OnePulse handle
   1894            * @param  OnePulseMode: Select the One pulse mode.
   1895            *         This parameter can be one of the following values:
   1896            *            @arg TIM_OPMODE_SINGLE: Only one pulse will be generated.
   1897            *            @arg TIM_OPMODE_REPETITIVE: Repetitive pulses wil be generated.
   1898            * @retval HAL status
   1899            */

   \                                 In section .text, align 2, keep-with-next
   1900          HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
   1901          {
   \                     HAL_TIM_OnePulse_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1902            /* Check the TIM handle allocation */
   1903            if(htim == NULL)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??HAL_TIM_OnePulse_Init_0
   1904            {
   1905              return HAL_ERROR;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE01F             B.N      ??HAL_TIM_OnePulse_Init_1
   1906            }
   1907          
   1908            /* Check the parameters */
   1909            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1910            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1911            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   1912            assert_param(IS_TIM_OPM_MODE(OnePulseMode));
   1913          
   1914            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_OnePulse_Init_0: (+1)
   \   0000000E   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD105             BNE.N    ??HAL_TIM_OnePulse_Init_2
   1915            {
   1916              /* Allocate lock resource and initialize it */
   1917              htim->Lock = HAL_UNLOCKED;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF884 0x0034      STRB     R0,[R4, #+52]
   1918          
   1919              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1920              HAL_TIM_OnePulse_MspInit(htim);
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       HAL_TIM_OnePulse_MspInit
   1921            }
   1922          
   1923            /* Set the TIM state */
   1924            htim->State= HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_OnePulse_Init_2: (+1)
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xF884 0x0035      STRB     R0,[R4, #+53]
   1925          
   1926            /* Configure the Time base in the One Pulse Mode */
   1927            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \   00000028   0x1D21             ADDS     R1,R4,#+4
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      BL       TIM_Base_SetConfig
   1928          
   1929            /* Reset the OPM Bit */
   1930            htim->Instance->CR1 &= ~TIM_CR1_OPM;
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0xF030 0x0008      BICS     R0,R0,#0x8
   \   00000038   0x6821             LDR      R1,[R4, #+0]
   \   0000003A   0x6008             STR      R0,[R1, #+0]
   1931          
   1932            /* Configure the OPM Mode */
   1933            htim->Instance->CR1 |= OnePulseMode;
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x4328             ORRS     R0,R5,R0
   \   00000042   0x6821             LDR      R1,[R4, #+0]
   \   00000044   0x6008             STR      R0,[R1, #+0]
   1934          
   1935            /* Initialize the TIM state*/
   1936            htim->State= HAL_TIM_STATE_READY;
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0xF884 0x0035      STRB     R0,[R4, #+53]
   1937          
   1938            return HAL_OK;
   \   0000004C   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OnePulse_Init_1: (+1)
   \   0000004E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1939          }
   1940          
   1941          /**
   1942            * @brief  DeInitializes the TIM One Pulse
   1943            * @param  htim: TIM One Pulse handle
   1944            * @retval HAL status
   1945            */

   \                                 In section .text, align 2, keep-with-next
   1946          HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
   1947          {
   \                     HAL_TIM_OnePulse_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1948            /* Check the parameters */
   1949            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1950          
   1951            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0035      STRB     R0,[R4, #+53]
   1952          
   1953            /* Disable the TIM Peripheral Clock */
   1954            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A00             LDR      R0,[R0, #+32]
   \   0000000E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000012   0x4208             TST      R0,R1
   \   00000014   0xD105             BNE.N    ??HAL_TIM_OnePulse_DeInit_0
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x0840             LSRS     R0,R0,#+1
   \   0000001C   0x0040             LSLS     R0,R0,#+1
   \   0000001E   0x6821             LDR      R1,[R4, #+0]
   \   00000020   0x6008             STR      R0,[R1, #+0]
   1955          
   1956            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   1957            HAL_TIM_OnePulse_MspDeInit(htim);
   \                     ??HAL_TIM_OnePulse_DeInit_0: (+1)
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       HAL_TIM_OnePulse_MspDeInit
   1958          
   1959            /* Change TIM state */
   1960            htim->State = HAL_TIM_STATE_RESET;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF884 0x0035      STRB     R0,[R4, #+53]
   1961          
   1962            /* Release Lock */
   1963            __HAL_UNLOCK(htim);
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0034      STRB     R0,[R4, #+52]
   1964          
   1965            return HAL_OK;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
   1966          }
   1967          
   1968          /**
   1969            * @brief  Initializes the TIM One Pulse MSP.
   1970            * @param  htim: TIM handle
   1971            * @retval None
   1972            */

   \                                 In section .text, align 2
   1973          __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
   1974          {
   1975            /* NOTE : This function Should not be modified, when the callback is needed,
   1976                      the HAL_TIM_OnePulse_MspInit could be implemented in the user file
   1977             */
   1978          }
   \                     HAL_TIM_OnePulse_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1979          
   1980          /**
   1981            * @brief  DeInitializes TIM One Pulse MSP.
   1982            * @param  htim: TIM handle
   1983            * @retval None
   1984            */

   \                                 In section .text, align 2
   1985          __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
   1986          {
   1987            /* NOTE : This function Should not be modified, when the callback is needed,
   1988                      the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
   1989             */
   1990          }
   \                     HAL_TIM_OnePulse_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1991          
   1992          /**
   1993            * @brief  Starts the TIM One Pulse signal generation.
   1994            * @param  htim : TIM One Pulse handle
   1995            * @param  OutputChannel : TIM Channels to be enabled
   1996            *          This parameter can be one of the following values:
   1997            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1998            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1999            * @retval HAL status
   2000          */

   \                                 In section .text, align 2, keep-with-next
   2001          HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2002          {
   \                     HAL_TIM_OnePulse_Start: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2003            /* Enable the Capture compare and the Input Capture channels
   2004              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2005              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2006              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
   2007              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together
   2008          
   2009              No need to enable the counter, it's enabled automatically by hardware
   2010              (the counter starts in response to a stimulus and generate a pulse */
   2011          
   2012            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       TIM_CCxChannelCmd
   2013            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \   00000010   0x2201             MOVS     R2,#+1
   \   00000012   0x2104             MOVS     R1,#+4
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x.... 0x....      BL       TIM_CCxChannelCmd
   2014          
   2015            /* Return function status */
   2016            return HAL_OK;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2017          }
   2018          
   2019          /**
   2020            * @brief  Stops the TIM One Pulse signal generation.
   2021            * @param  htim : TIM One Pulse handle
   2022            * @param  OutputChannel : TIM Channels to be disable
   2023            *          This parameter can be one of the following values:
   2024            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2025            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2026            * @retval HAL status
   2027          */

   \                                 In section .text, align 2, keep-with-next
   2028          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2029          {
   \                     HAL_TIM_OnePulse_Stop: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2030            /* Disable the Capture compare and the Input Capture channels
   2031            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2032            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2033            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
   2034            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
   2035          
   2036            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       TIM_CCxChannelCmd
   2037            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x2104             MOVS     R1,#+4
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x.... 0x....      BL       TIM_CCxChannelCmd
   2038          
   2039            /* Disable the Peripheral */
   2040            __HAL_TIM_DISABLE(htim);
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x6A00             LDR      R0,[R0, #+32]
   \   0000001E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000022   0x4208             TST      R0,R1
   \   00000024   0xD105             BNE.N    ??HAL_TIM_OnePulse_Stop_0
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x0840             LSRS     R0,R0,#+1
   \   0000002C   0x0040             LSLS     R0,R0,#+1
   \   0000002E   0x6821             LDR      R1,[R4, #+0]
   \   00000030   0x6008             STR      R0,[R1, #+0]
   2041          
   2042            /* Return function status */
   2043            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Stop_0: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2044          }
   2045          
   2046          /**
   2047            * @brief  Starts the TIM One Pulse signal generation in interrupt mode.
   2048            * @param  htim : TIM One Pulse handle
   2049            * @param  OutputChannel : TIM Channels to be enabled
   2050            *          This parameter can be one of the following values:
   2051            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2052            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2053            * @retval HAL status
   2054          */

   \                                 In section .text, align 2, keep-with-next
   2055          HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2056          {
   \                     HAL_TIM_OnePulse_Start_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2057            /* Enable the Capture compare and the Input Capture channels
   2058              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2059              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2060              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
   2061              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together
   2062          
   2063              No need to enable the counter, it's enabled automatically by hardware
   2064              (the counter starts in response to a stimulus and generate a pulse */
   2065          
   2066            /* Enable the TIM Capture/Compare 1 interrupt */
   2067            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x68C0             LDR      R0,[R0, #+12]
   \   0000000A   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000000E   0x6821             LDR      R1,[R4, #+0]
   \   00000010   0x60C8             STR      R0,[R1, #+12]
   2068          
   2069            /* Enable the TIM Capture/Compare 2 interrupt */
   2070            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x68C0             LDR      R0,[R0, #+12]
   \   00000016   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000001A   0x6821             LDR      R1,[R4, #+0]
   \   0000001C   0x60C8             STR      R0,[R1, #+12]
   2071          
   2072            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \   0000001E   0x2201             MOVS     R2,#+1
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x.... 0x....      BL       TIM_CCxChannelCmd
   2073            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \   00000028   0x2201             MOVS     R2,#+1
   \   0000002A   0x2104             MOVS     R1,#+4
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x.... 0x....      BL       TIM_CCxChannelCmd
   2074          
   2075            /* Return function status */
   2076            return HAL_OK;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2077          }
   2078          
   2079          /**
   2080            * @brief  Stops the TIM One Pulse signal generation in interrupt mode.
   2081            * @param  htim : TIM One Pulse handle
   2082            * @param  OutputChannel : TIM Channels to be enabled
   2083            *          This parameter can be one of the following values:
   2084            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2085            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2086            * @retval HAL status
   2087          */

   \                                 In section .text, align 2, keep-with-next
   2088          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2089          {
   \                     HAL_TIM_OnePulse_Stop_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2090            /* Disable the TIM Capture/Compare 1 interrupt */
   2091            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x68C0             LDR      R0,[R0, #+12]
   \   0000000A   0xF030 0x0002      BICS     R0,R0,#0x2
   \   0000000E   0x6821             LDR      R1,[R4, #+0]
   \   00000010   0x60C8             STR      R0,[R1, #+12]
   2092          
   2093            /* Disable the TIM Capture/Compare 2 interrupt */
   2094            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x68C0             LDR      R0,[R0, #+12]
   \   00000016   0xF030 0x0004      BICS     R0,R0,#0x4
   \   0000001A   0x6821             LDR      R1,[R4, #+0]
   \   0000001C   0x60C8             STR      R0,[R1, #+12]
   2095          
   2096            /* Disable the Capture compare and the Input Capture channels
   2097            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2098            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2099            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
   2100            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
   2101            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \   0000001E   0x2200             MOVS     R2,#+0
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x.... 0x....      BL       TIM_CCxChannelCmd
   2102            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0x2104             MOVS     R1,#+4
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x.... 0x....      BL       TIM_CCxChannelCmd
   2103          
   2104            /* Disable the Peripheral */
   2105             __HAL_TIM_DISABLE(htim);
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x6A00             LDR      R0,[R0, #+32]
   \   00000036   0xF241 0x1111      MOVW     R1,#+4369
   \   0000003A   0x4208             TST      R0,R1
   \   0000003C   0xD105             BNE.N    ??HAL_TIM_OnePulse_Stop_IT_0
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x0840             LSRS     R0,R0,#+1
   \   00000044   0x0040             LSLS     R0,R0,#+1
   \   00000046   0x6821             LDR      R1,[R4, #+0]
   \   00000048   0x6008             STR      R0,[R1, #+0]
   2106          
   2107            /* Return function status */
   2108            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Stop_IT_0: (+1)
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2109          }
   2110          
   2111          /**
   2112            * @}
   2113            */
   2114          
   2115          /** @defgroup TIM_Exported_Functions_Group6 Time Encoder functions
   2116           *  @brief    Time Encoder functions
   2117           *
   2118          @verbatim
   2119            ==============================================================================
   2120                                    ##### Time Encoder functions #####
   2121            ==============================================================================
   2122            [..]
   2123              This section provides functions allowing to:
   2124              (+) Initialize and configure the TIM Encoder.
   2125              (+) De-initialize the TIM Encoder.
   2126              (+) Start the Time Encoder.
   2127              (+) Stop the Time Encoder.
   2128              (+) Start the Time Encoder and enable interrupt.
   2129              (+) Stop the Time Encoder and disable interrupt.
   2130              (+) Start the Time Encoder and enable DMA transfer.
   2131              (+) Stop the Time Encoder and disable DMA transfer.
   2132          
   2133          @endverbatim
   2134            * @{
   2135            */
   2136          /**
   2137            * @brief  Initializes the TIM Encoder Interface and create the associated handle.
   2138            * @param  htim: TIM Encoder Interface handle
   2139            * @param  sConfig: TIM Encoder Interface configuration structure
   2140            * @retval HAL status
   2141            */

   \                                 In section .text, align 2, keep-with-next
   2142          HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef* sConfig)
   2143          {
   \                     HAL_TIM_Encoder_Init: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   2144            uint32_t tmpsmcr = 0;
   \   00000008   0x2600             MOVS     R6,#+0
   2145            uint32_t tmpccmr1 = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
   2146            uint32_t tmpccer = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   2147          
   2148            /* Check the TIM handle allocation */
   2149            if(htim == NULL)
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD101             BNE.N    ??HAL_TIM_Encoder_Init_0
   2150            {
   2151              return HAL_ERROR;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xE04F             B.N      ??HAL_TIM_Encoder_Init_1
   2152            }
   2153          
   2154            /* Check the parameters */
   2155            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2156            assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
   2157            assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
   2158            assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
   2159            assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
   2160            assert_param(IS_TIM_IC_POLARITY(sConfig->IC2Polarity));
   2161            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
   2162            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
   2163            assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
   2164            assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
   2165          
   2166            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_Encoder_Init_0: (+1)
   \   00000018   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD105             BNE.N    ??HAL_TIM_Encoder_Init_2
   2167            {
   2168              /* Allocate lock resource and initialize it */
   2169              htim->Lock = HAL_UNLOCKED;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xF884 0x0034      STRB     R0,[R4, #+52]
   2170          
   2171              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   2172              HAL_TIM_Encoder_MspInit(htim);
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       HAL_TIM_Encoder_MspInit
   2173            }
   2174          
   2175            /* Set the TIM state */
   2176            htim->State= HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Encoder_Init_2: (+1)
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0xF884 0x0035      STRB     R0,[R4, #+53]
   2177          
   2178            /* Reset the SMS bits */
   2179            htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x6880             LDR      R0,[R0, #+8]
   \   00000036   0x08C0             LSRS     R0,R0,#+3
   \   00000038   0x00C0             LSLS     R0,R0,#+3
   \   0000003A   0x6821             LDR      R1,[R4, #+0]
   \   0000003C   0x6088             STR      R0,[R1, #+8]
   2180          
   2181            /* Configure the Time base in the Encoder Mode */
   2182            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \   0000003E   0x1D21             ADDS     R1,R4,#+4
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x.... 0x....      BL       TIM_Base_SetConfig
   2183          
   2184            /* Get the TIMx SMCR register value */
   2185            tmpsmcr = htim->Instance->SMCR;
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6880             LDR      R0,[R0, #+8]
   \   0000004A   0x0006             MOVS     R6,R0
   2186          
   2187            /* Get the TIMx CCMR1 register value */
   2188            tmpccmr1 = htim->Instance->CCMR1;
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6980             LDR      R0,[R0, #+24]
   \   00000050   0x0007             MOVS     R7,R0
   2189          
   2190            /* Get the TIMx CCER register value */
   2191            tmpccer = htim->Instance->CCER;
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x6A00             LDR      R0,[R0, #+32]
   \   00000056   0x4680             MOV      R8,R0
   2192          
   2193            /* Set the encoder Mode */
   2194            tmpsmcr |= sConfig->EncoderMode;
   \   00000058   0x6828             LDR      R0,[R5, #+0]
   \   0000005A   0x4306             ORRS     R6,R0,R6
   2195          
   2196            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   2197            tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable5_3  ;; 0xfffffcfc
   \   00000060   0x4007             ANDS     R7,R0,R7
   2198            tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8));
   \   00000062   0x68A8             LDR      R0,[R5, #+8]
   \   00000064   0x69A9             LDR      R1,[R5, #+24]
   \   00000066   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   0000006A   0x4307             ORRS     R7,R0,R7
   2199          
   2200            /* Set the the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
   2201            tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable5_4  ;; 0xfffff3f3
   \   00000070   0x4007             ANDS     R7,R0,R7
   2202            tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable5_5  ;; 0xffff0f0f
   \   00000076   0x4007             ANDS     R7,R0,R7
   2203            tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8);
   \   00000078   0x68E8             LDR      R0,[R5, #+12]
   \   0000007A   0x69E9             LDR      R1,[R5, #+28]
   \   0000007C   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000080   0x4307             ORRS     R7,R0,R7
   2204            tmpccmr1 |= (sConfig->IC1Filter << 4) | (sConfig->IC2Filter << 12);
   \   00000082   0x6928             LDR      R0,[R5, #+16]
   \   00000084   0x6A29             LDR      R1,[R5, #+32]
   \   00000086   0x0309             LSLS     R1,R1,#+12
   \   00000088   0xEA51 0x1000      ORRS     R0,R1,R0, LSL #+4
   \   0000008C   0x4307             ORRS     R7,R0,R7
   2205          
   2206            /* Set the TI1 and the TI2 Polarities */
   2207            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
   \   0000008E   0xF038 0x0822      BICS     R8,R8,#0x22
   2208            tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
   \   00000092   0xF038 0x0888      BICS     R8,R8,#0x88
   2209            tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4);
   \   00000096   0x6868             LDR      R0,[R5, #+4]
   \   00000098   0x6969             LDR      R1,[R5, #+20]
   \   0000009A   0xEA50 0x1001      ORRS     R0,R0,R1, LSL #+4
   \   0000009E   0xEA50 0x0808      ORRS     R8,R0,R8
   2210          
   2211            /* Write to TIMx SMCR */
   2212            htim->Instance->SMCR = tmpsmcr;
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x6086             STR      R6,[R0, #+8]
   2213          
   2214            /* Write to TIMx CCMR1 */
   2215            htim->Instance->CCMR1 = tmpccmr1;
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0x6187             STR      R7,[R0, #+24]
   2216          
   2217            /* Write to TIMx CCER */
   2218            htim->Instance->CCER = tmpccer;
   \   000000AA   0x6820             LDR      R0,[R4, #+0]
   \   000000AC   0xF8C0 0x8020      STR      R8,[R0, #+32]
   2219          
   2220            /* Initialize the TIM state*/
   2221            htim->State= HAL_TIM_STATE_READY;
   \   000000B0   0x2001             MOVS     R0,#+1
   \   000000B2   0xF884 0x0035      STRB     R0,[R4, #+53]
   2222          
   2223            return HAL_OK;
   \   000000B6   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_Encoder_Init_1: (+1)
   \   000000B8   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2224          }
   2225          
   2226          
   2227          /**
   2228            * @brief  DeInitializes the TIM Encoder interface
   2229            * @param  htim: TIM Encoder handle
   2230            * @retval HAL status
   2231            */

   \                                 In section .text, align 2, keep-with-next
   2232          HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
   2233          {
   \                     HAL_TIM_Encoder_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2234            /* Check the parameters */
   2235            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2236          
   2237            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0035      STRB     R0,[R4, #+53]
   2238          
   2239            /* Disable the TIM Peripheral Clock */
   2240            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A00             LDR      R0,[R0, #+32]
   \   0000000E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000012   0x4208             TST      R0,R1
   \   00000014   0xD105             BNE.N    ??HAL_TIM_Encoder_DeInit_0
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x0840             LSRS     R0,R0,#+1
   \   0000001C   0x0040             LSLS     R0,R0,#+1
   \   0000001E   0x6821             LDR      R1,[R4, #+0]
   \   00000020   0x6008             STR      R0,[R1, #+0]
   2241          
   2242            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   2243            HAL_TIM_Encoder_MspDeInit(htim);
   \                     ??HAL_TIM_Encoder_DeInit_0: (+1)
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       HAL_TIM_Encoder_MspDeInit
   2244          
   2245            /* Change TIM state */
   2246            htim->State = HAL_TIM_STATE_RESET;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF884 0x0035      STRB     R0,[R4, #+53]
   2247          
   2248            /* Release Lock */
   2249            __HAL_UNLOCK(htim);
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0034      STRB     R0,[R4, #+52]
   2250          
   2251            return HAL_OK;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
   2252          }
   2253          
   2254          /**
   2255            * @brief  Initializes the TIM Encoder Interface MSP.
   2256            * @param  htim: TIM handle
   2257            * @retval None
   2258            */

   \                                 In section .text, align 2
   2259          __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
   2260          {
   2261            /* NOTE : This function Should not be modified, when the callback is needed,
   2262                      the HAL_TIM_Encoder_MspInit could be implemented in the user file
   2263             */
   2264          }
   \                     HAL_TIM_Encoder_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2265          
   2266          /**
   2267            * @brief  DeInitializes TIM Encoder Interface MSP.
   2268            * @param  htim: TIM handle
   2269            * @retval None
   2270            */

   \                                 In section .text, align 2
   2271          __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
   2272          {
   2273            /* NOTE : This function Should not be modified, when the callback is needed,
   2274                      the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
   2275             */
   2276          }
   \                     HAL_TIM_Encoder_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2277          
   2278          /**
   2279            * @brief  Starts the TIM Encoder Interface.
   2280            * @param  htim : TIM Encoder Interface handle
   2281            * @param  Channel : TIM Channels to be enabled
   2282            *          This parameter can be one of the following values:
   2283            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2284            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2285            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2286            * @retval HAL status
   2287          */

   \                                 In section .text, align 2, keep-with-next
   2288          HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   2289          {
   \                     HAL_TIM_Encoder_Start: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2290            /* Check the parameters */
   2291            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2292          
   2293            /* Enable the encoder interface channels */
   2294            switch (Channel)
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD002             BEQ.N    ??HAL_TIM_Encoder_Start_0
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD006             BEQ.N    ??HAL_TIM_Encoder_Start_1
   \   00000010   0xE00B             B.N      ??HAL_TIM_Encoder_Start_2
   2295            {
   2296              case TIM_CHANNEL_1:
   2297            {
   2298              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_0: (+1)
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       TIM_CCxChannelCmd
   2299                break;
   \   0000001C   0xE00F             B.N      ??HAL_TIM_Encoder_Start_3
   2300            }
   2301              case TIM_CHANNEL_2:
   2302            {
   2303              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_1: (+1)
   \   0000001E   0x2201             MOVS     R2,#+1
   \   00000020   0x2104             MOVS     R1,#+4
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x.... 0x....      BL       TIM_CCxChannelCmd
   2304                break;
   \   00000028   0xE009             B.N      ??HAL_TIM_Encoder_Start_3
   2305            }
   2306              default :
   2307            {
   2308               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_2: (+1)
   \   0000002A   0x2201             MOVS     R2,#+1
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x.... 0x....      BL       TIM_CCxChannelCmd
   2309               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \   00000034   0x2201             MOVS     R2,#+1
   \   00000036   0x2104             MOVS     R1,#+4
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x.... 0x....      BL       TIM_CCxChannelCmd
   2310               break;
   2311              }
   2312            }
   2313            /* Enable the Peripheral */
   2314            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_Encoder_Start_3: (+1)
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000046   0x6821             LDR      R1,[R4, #+0]
   \   00000048   0x6008             STR      R0,[R1, #+0]
   2315          
   2316            /* Return function status */
   2317            return HAL_OK;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2318          }
   2319          
   2320          /**
   2321            * @brief  Stops the TIM Encoder Interface.
   2322            * @param  htim : TIM Encoder Interface handle
   2323            * @param  Channel : TIM Channels to be disabled
   2324            *          This parameter can be one of the following values:
   2325            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2326            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2327            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2328            * @retval HAL status
   2329          */

   \                                 In section .text, align 2, keep-with-next
   2330          HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   2331          {
   \                     HAL_TIM_Encoder_Stop: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2332            /* Check the parameters */
   2333              assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2334          
   2335             /* Disable the Input Capture channels 1 and 2
   2336              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   2337            switch (Channel)
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD002             BEQ.N    ??HAL_TIM_Encoder_Stop_0
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD006             BEQ.N    ??HAL_TIM_Encoder_Stop_1
   \   00000010   0xE00B             B.N      ??HAL_TIM_Encoder_Stop_2
   2338            {
   2339              case TIM_CHANNEL_1:
   2340            {
   2341               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_0: (+1)
   \   00000012   0x2200             MOVS     R2,#+0
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       TIM_CCxChannelCmd
   2342                break;
   \   0000001C   0xE00F             B.N      ??HAL_TIM_Encoder_Stop_3
   2343            }
   2344              case TIM_CHANNEL_2:
   2345            {
   2346              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_1: (+1)
   \   0000001E   0x2200             MOVS     R2,#+0
   \   00000020   0x2104             MOVS     R1,#+4
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x.... 0x....      BL       TIM_CCxChannelCmd
   2347                break;
   \   00000028   0xE009             B.N      ??HAL_TIM_Encoder_Stop_3
   2348            }
   2349              default :
   2350            {
   2351              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_2: (+1)
   \   0000002A   0x2200             MOVS     R2,#+0
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x.... 0x....      BL       TIM_CCxChannelCmd
   2352              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \   00000034   0x2200             MOVS     R2,#+0
   \   00000036   0x2104             MOVS     R1,#+4
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x.... 0x....      BL       TIM_CCxChannelCmd
   2353               break;
   2354              }
   2355            }
   2356          
   2357            /* Disable the Peripheral */
   2358            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_Encoder_Stop_3: (+1)
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6A00             LDR      R0,[R0, #+32]
   \   00000042   0xF241 0x1111      MOVW     R1,#+4369
   \   00000046   0x4208             TST      R0,R1
   \   00000048   0xD105             BNE.N    ??HAL_TIM_Encoder_Stop_4
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x0840             LSRS     R0,R0,#+1
   \   00000050   0x0040             LSLS     R0,R0,#+1
   \   00000052   0x6821             LDR      R1,[R4, #+0]
   \   00000054   0x6008             STR      R0,[R1, #+0]
   2359          
   2360            /* Return function status */
   2361            return HAL_OK;
   \                     ??HAL_TIM_Encoder_Stop_4: (+1)
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2362          }
   2363          
   2364          /**
   2365            * @brief  Starts the TIM Encoder Interface in interrupt mode.
   2366            * @param  htim : TIM Encoder Interface handle
   2367            * @param  Channel : TIM Channels to be enabled
   2368            *          This parameter can be one of the following values:
   2369            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2370            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2371            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2372            * @retval HAL status
   2373          */

   \                                 In section .text, align 2, keep-with-next
   2374          HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2375          {
   \                     HAL_TIM_Encoder_Start_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2376            /* Check the parameters */
   2377            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2378          
   2379            /* Enable the encoder interface channels */
   2380            /* Enable the capture compare Interrupts 1 and/or 2 */
   2381            switch (Channel)
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD002             BEQ.N    ??HAL_TIM_Encoder_Start_IT_0
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD00C             BEQ.N    ??HAL_TIM_Encoder_Start_IT_1
   \   00000010   0xE017             B.N      ??HAL_TIM_Encoder_Start_IT_2
   2382            {
   2383              case TIM_CHANNEL_1:
   2384            {
   2385              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_0: (+1)
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       TIM_CCxChannelCmd
   2386              __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x68C0             LDR      R0,[R0, #+12]
   \   00000020   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000024   0x6821             LDR      R1,[R4, #+0]
   \   00000026   0x60C8             STR      R0,[R1, #+12]
   2387                break;
   \   00000028   0xE021             B.N      ??HAL_TIM_Encoder_Start_IT_3
   2388            }
   2389              case TIM_CHANNEL_2:
   2390            {
   2391              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_1: (+1)
   \   0000002A   0x2201             MOVS     R2,#+1
   \   0000002C   0x2104             MOVS     R1,#+4
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x.... 0x....      BL       TIM_CCxChannelCmd
   2392              __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x68C0             LDR      R0,[R0, #+12]
   \   00000038   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000003C   0x6821             LDR      R1,[R4, #+0]
   \   0000003E   0x60C8             STR      R0,[R1, #+12]
   2393                break;
   \   00000040   0xE015             B.N      ??HAL_TIM_Encoder_Start_IT_3
   2394            }
   2395              default :
   2396            {
   2397               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_2: (+1)
   \   00000042   0x2201             MOVS     R2,#+1
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       TIM_CCxChannelCmd
   2398               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \   0000004C   0x2201             MOVS     R2,#+1
   \   0000004E   0x2104             MOVS     R1,#+4
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x.... 0x....      BL       TIM_CCxChannelCmd
   2399               __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x68C0             LDR      R0,[R0, #+12]
   \   0000005A   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000005E   0x6821             LDR      R1,[R4, #+0]
   \   00000060   0x60C8             STR      R0,[R1, #+12]
   2400               __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x68C0             LDR      R0,[R0, #+12]
   \   00000066   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000006A   0x6821             LDR      R1,[R4, #+0]
   \   0000006C   0x60C8             STR      R0,[R1, #+12]
   2401               break;
   2402              }
   2403            }
   2404          
   2405            /* Enable the Peripheral */
   2406            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_Encoder_Start_IT_3: (+1)
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000076   0x6821             LDR      R1,[R4, #+0]
   \   00000078   0x6008             STR      R0,[R1, #+0]
   2407          
   2408            /* Return function status */
   2409            return HAL_OK;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2410          }
   2411          
   2412          /**
   2413            * @brief  Stops the TIM Encoder Interface in interrupt mode.
   2414            * @param  htim : TIM Encoder Interface handle
   2415            * @param  Channel : TIM Channels to be disabled
   2416            *          This parameter can be one of the following values:
   2417            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2418            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2419            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2420            * @retval HAL status
   2421          */

   \                                 In section .text, align 2, keep-with-next
   2422          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2423          {
   \                     HAL_TIM_Encoder_Stop_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2424            /* Check the parameters */
   2425            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2426          
   2427            /* Disable the Input Capture channels 1 and 2
   2428              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   2429            if(Channel == TIM_CHANNEL_1)
   \   00000006   0x2D00             CMP      R5,#+0
   \   00000008   0xD10B             BNE.N    ??HAL_TIM_Encoder_Stop_IT_0
   2430            {
   2431              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x.... 0x....      BL       TIM_CCxChannelCmd
   2432          
   2433              /* Disable the capture compare Interrupts 1 */
   2434            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x68C0             LDR      R0,[R0, #+12]
   \   00000018   0xF030 0x0002      BICS     R0,R0,#0x2
   \   0000001C   0x6821             LDR      R1,[R4, #+0]
   \   0000001E   0x60C8             STR      R0,[R1, #+12]
   \   00000020   0xE023             B.N      ??HAL_TIM_Encoder_Stop_IT_1
   2435            }
   2436            else if(Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_Encoder_Stop_IT_0: (+1)
   \   00000022   0x2D04             CMP      R5,#+4
   \   00000024   0xD10B             BNE.N    ??HAL_TIM_Encoder_Stop_IT_2
   2437            {
   2438              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \   00000026   0x2200             MOVS     R2,#+0
   \   00000028   0x2104             MOVS     R1,#+4
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      BL       TIM_CCxChannelCmd
   2439          
   2440              /* Disable the capture compare Interrupts 2 */
   2441            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x68C0             LDR      R0,[R0, #+12]
   \   00000034   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000038   0x6821             LDR      R1,[R4, #+0]
   \   0000003A   0x60C8             STR      R0,[R1, #+12]
   \   0000003C   0xE015             B.N      ??HAL_TIM_Encoder_Stop_IT_1
   2442            }
   2443            else
   2444            {
   2445              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_IT_2: (+1)
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x.... 0x....      BL       TIM_CCxChannelCmd
   2446              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \   00000048   0x2200             MOVS     R2,#+0
   \   0000004A   0x2104             MOVS     R1,#+4
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x.... 0x....      BL       TIM_CCxChannelCmd
   2447          
   2448              /* Disable the capture compare Interrupts 1 and 2 */
   2449              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x68C0             LDR      R0,[R0, #+12]
   \   00000056   0xF030 0x0002      BICS     R0,R0,#0x2
   \   0000005A   0x6821             LDR      R1,[R4, #+0]
   \   0000005C   0x60C8             STR      R0,[R1, #+12]
   2450              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x68C0             LDR      R0,[R0, #+12]
   \   00000062   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000066   0x6821             LDR      R1,[R4, #+0]
   \   00000068   0x60C8             STR      R0,[R1, #+12]
   2451            }
   2452          
   2453            /* Disable the Peripheral */
   2454            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_Encoder_Stop_IT_1: (+1)
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x6A00             LDR      R0,[R0, #+32]
   \   0000006E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000072   0x4208             TST      R0,R1
   \   00000074   0xD105             BNE.N    ??HAL_TIM_Encoder_Stop_IT_3
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x0840             LSRS     R0,R0,#+1
   \   0000007C   0x0040             LSLS     R0,R0,#+1
   \   0000007E   0x6821             LDR      R1,[R4, #+0]
   \   00000080   0x6008             STR      R0,[R1, #+0]
   2455          
   2456            /* Change the htim state */
   2457            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Encoder_Stop_IT_3: (+1)
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0xF884 0x0035      STRB     R0,[R4, #+53]
   2458          
   2459            /* Return function status */
   2460            return HAL_OK;
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2461          }
   2462          
   2463          /**
   2464            * @brief  Starts the TIM Encoder Interface in DMA mode.
   2465            * @param  htim : TIM Encoder Interface handle
   2466            * @param  Channel : TIM Channels to be enabled
   2467            *          This parameter can be one of the following values:
   2468            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2469            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2470            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2471            * @param  pData1: The destination Buffer address for IC1.
   2472            * @param  pData2: The destination Buffer address for IC2.
   2473            * @param  Length: The length of data to be transferred from TIM peripheral to memory.
   2474            * @retval HAL status
   2475          */

   \                                 In section .text, align 2, keep-with-next
   2476          HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1, uint32_t *pData2, uint16_t Length)
   2477          {
   \                     HAL_TIM_Encoder_Start_DMA: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0x9C06             LDR      R4,[SP, #+24]
   2478            /* Check the parameters */
   2479            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2480          
   2481            if((htim->State == HAL_TIM_STATE_BUSY))
   \   0000000E   0xF895 0x0035      LDRB     R0,[R5, #+53]
   \   00000012   0x2802             CMP      R0,#+2
   \   00000014   0xD101             BNE.N    ??HAL_TIM_Encoder_Start_DMA_0
   2482            {
   2483               return HAL_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xE099             B.N      ??HAL_TIM_Encoder_Start_DMA_1
   2484            }
   2485            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIM_Encoder_Start_DMA_0: (+1)
   \   0000001A   0xF895 0x0035      LDRB     R0,[R5, #+53]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD113             BNE.N    ??HAL_TIM_Encoder_Start_DMA_2
   2486            {
   2487              if((((pData1 == 0) || (pData2 == 0) )) && (Length > 0))
   \   00000022   0x2E00             CMP      R6,#+0
   \   00000024   0xD001             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_3
   \   00000026   0x2F00             CMP      R7,#+0
   \   00000028   0xD104             BNE.N    ??HAL_TIM_Encoder_Start_DMA_4
   \                     ??HAL_TIM_Encoder_Start_DMA_3: (+1)
   \   0000002A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000002C   0x2C00             CMP      R4,#+0
   \   0000002E   0xD001             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_4
   2488              {
   2489                return HAL_ERROR;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0xE08C             B.N      ??HAL_TIM_Encoder_Start_DMA_1
   2490              }
   2491              else
   2492              {
   2493                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Encoder_Start_DMA_4: (+1)
   \   00000034   0x2002             MOVS     R0,#+2
   \   00000036   0xF885 0x0035      STRB     R0,[R5, #+53]
   2494              }
   2495            }
   2496            else
   2497            {
   2498              return HAL_ERROR;
   2499            }
   2500          
   2501            switch (Channel)
   \   0000003A   0x4640             MOV      R0,R8
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD006             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_5
   \   00000040   0x2804             CMP      R0,#+4
   \   00000042   0xD025             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_6
   \   00000044   0x2818             CMP      R0,#+24
   \   00000046   0xD044             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_7
   \   00000048   0xE080             B.N      ??HAL_TIM_Encoder_Start_DMA_8
   \                     ??HAL_TIM_Encoder_Start_DMA_2: (+1)
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0xE07F             B.N      ??HAL_TIM_Encoder_Start_DMA_1
   2502            {
   2503              case TIM_CHANNEL_1:
   2504              {
   2505                /* Set the DMA Period elapsed callback */
   2506                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_5: (+1)
   \   0000004E   0x....             LDR.N    R0,??DataTable5_2
   \   00000050   0x69E9             LDR      R1,[R5, #+28]
   \   00000052   0x6288             STR      R0,[R1, #+40]
   2507          
   2508                /* Set the DMA error callback */
   2509                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   00000054   0x....             LDR.N    R0,??DataTable5_1
   \   00000056   0x69E9             LDR      R1,[R5, #+28]
   \   00000058   0x6308             STR      R0,[R1, #+48]
   2510          
   2511                /* Enable the DMA channel */
   2512                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t )pData1, Length);
   \   0000005A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000005C   0x0023             MOVS     R3,R4
   \   0000005E   0x0032             MOVS     R2,R6
   \   00000060   0x6828             LDR      R0,[R5, #+0]
   \   00000062   0xF110 0x0134      ADDS     R1,R0,#+52
   \   00000066   0x69E8             LDR      R0,[R5, #+28]
   \   00000068   0x.... 0x....      BL       HAL_DMA_Start_IT
   2513          
   2514                /* Enable the TIM Input Capture DMA request */
   2515                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   0000006C   0x6828             LDR      R0,[R5, #+0]
   \   0000006E   0x68C0             LDR      R0,[R0, #+12]
   \   00000070   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000074   0x6829             LDR      R1,[R5, #+0]
   \   00000076   0x60C8             STR      R0,[R1, #+12]
   2516          
   2517                /* Enable the Peripheral */
   2518                __HAL_TIM_ENABLE(htim);
   \   00000078   0x6828             LDR      R0,[R5, #+0]
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000080   0x6829             LDR      R1,[R5, #+0]
   \   00000082   0x6008             STR      R0,[R1, #+0]
   2519          
   2520                /* Enable the Capture compare channel */
   2521                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \   00000084   0x2201             MOVS     R2,#+1
   \   00000086   0x2100             MOVS     R1,#+0
   \   00000088   0x6828             LDR      R0,[R5, #+0]
   \   0000008A   0x.... 0x....      BL       TIM_CCxChannelCmd
   2522              }
   2523              break;
   \   0000008E   0xE05D             B.N      ??HAL_TIM_Encoder_Start_DMA_9
   2524          
   2525              case TIM_CHANNEL_2:
   2526              {
   2527                /* Set the DMA Period elapsed callback */
   2528                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_6: (+1)
   \   00000090   0x....             LDR.N    R0,??DataTable5_2
   \   00000092   0x6A29             LDR      R1,[R5, #+32]
   \   00000094   0x6288             STR      R0,[R1, #+40]
   2529          
   2530                /* Set the DMA error callback */
   2531                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError;
   \   00000096   0x....             LDR.N    R0,??DataTable5_1
   \   00000098   0x6A29             LDR      R1,[R5, #+32]
   \   0000009A   0x6308             STR      R0,[R1, #+48]
   2532                /* Enable the DMA channel */
   2533                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
   \   0000009C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000009E   0x0023             MOVS     R3,R4
   \   000000A0   0x003A             MOVS     R2,R7
   \   000000A2   0x6828             LDR      R0,[R5, #+0]
   \   000000A4   0xF110 0x0138      ADDS     R1,R0,#+56
   \   000000A8   0x6A28             LDR      R0,[R5, #+32]
   \   000000AA   0x.... 0x....      BL       HAL_DMA_Start_IT
   2534          
   2535                /* Enable the TIM Input Capture  DMA request */
   2536                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   000000AE   0x6828             LDR      R0,[R5, #+0]
   \   000000B0   0x68C0             LDR      R0,[R0, #+12]
   \   000000B2   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   000000B6   0x6829             LDR      R1,[R5, #+0]
   \   000000B8   0x60C8             STR      R0,[R1, #+12]
   2537          
   2538                /* Enable the Peripheral */
   2539                __HAL_TIM_ENABLE(htim);
   \   000000BA   0x6828             LDR      R0,[R5, #+0]
   \   000000BC   0x6800             LDR      R0,[R0, #+0]
   \   000000BE   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000C2   0x6829             LDR      R1,[R5, #+0]
   \   000000C4   0x6008             STR      R0,[R1, #+0]
   2540          
   2541                /* Enable the Capture compare channel */
   2542                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \   000000C6   0x2201             MOVS     R2,#+1
   \   000000C8   0x2104             MOVS     R1,#+4
   \   000000CA   0x6828             LDR      R0,[R5, #+0]
   \   000000CC   0x.... 0x....      BL       TIM_CCxChannelCmd
   2543              }
   2544              break;
   \   000000D0   0xE03C             B.N      ??HAL_TIM_Encoder_Start_DMA_9
   2545          
   2546              case TIM_CHANNEL_ALL:
   2547              {
   2548                /* Set the DMA Period elapsed callback */
   2549                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_7: (+1)
   \   000000D2   0x....             LDR.N    R0,??DataTable5_2
   \   000000D4   0x69E9             LDR      R1,[R5, #+28]
   \   000000D6   0x6288             STR      R0,[R1, #+40]
   2550          
   2551                /* Set the DMA error callback */
   2552                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   000000D8   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000DC   0x69E9             LDR      R1,[R5, #+28]
   \   000000DE   0x6308             STR      R0,[R1, #+48]
   2553          
   2554                /* Enable the DMA channel */
   2555                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length);
   \   000000E0   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000E2   0x0023             MOVS     R3,R4
   \   000000E4   0x0032             MOVS     R2,R6
   \   000000E6   0x6828             LDR      R0,[R5, #+0]
   \   000000E8   0xF110 0x0134      ADDS     R1,R0,#+52
   \   000000EC   0x69E8             LDR      R0,[R5, #+28]
   \   000000EE   0x.... 0x....      BL       HAL_DMA_Start_IT
   2556          
   2557                /* Set the DMA Period elapsed callback */
   2558                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   \   000000F2   0x....             LDR.N    R0,??DataTable5_2
   \   000000F4   0x6A29             LDR      R1,[R5, #+32]
   \   000000F6   0x6288             STR      R0,[R1, #+40]
   2559          
   2560                /* Set the DMA error callback */
   2561                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \   000000F8   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000FC   0x6A29             LDR      R1,[R5, #+32]
   \   000000FE   0x6308             STR      R0,[R1, #+48]
   2562          
   2563                /* Enable the DMA channel */
   2564                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
   \   00000100   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000102   0x0023             MOVS     R3,R4
   \   00000104   0x003A             MOVS     R2,R7
   \   00000106   0x6828             LDR      R0,[R5, #+0]
   \   00000108   0xF110 0x0138      ADDS     R1,R0,#+56
   \   0000010C   0x6A28             LDR      R0,[R5, #+32]
   \   0000010E   0x.... 0x....      BL       HAL_DMA_Start_IT
   2565          
   2566               /* Enable the Peripheral */
   2567                __HAL_TIM_ENABLE(htim);
   \   00000112   0x6828             LDR      R0,[R5, #+0]
   \   00000114   0x6800             LDR      R0,[R0, #+0]
   \   00000116   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000011A   0x6829             LDR      R1,[R5, #+0]
   \   0000011C   0x6008             STR      R0,[R1, #+0]
   2568          
   2569                /* Enable the Capture compare channel */
   2570                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \   0000011E   0x2201             MOVS     R2,#+1
   \   00000120   0x2100             MOVS     R1,#+0
   \   00000122   0x6828             LDR      R0,[R5, #+0]
   \   00000124   0x.... 0x....      BL       TIM_CCxChannelCmd
   2571                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \   00000128   0x2201             MOVS     R2,#+1
   \   0000012A   0x2104             MOVS     R1,#+4
   \   0000012C   0x6828             LDR      R0,[R5, #+0]
   \   0000012E   0x.... 0x....      BL       TIM_CCxChannelCmd
   2572          
   2573                /* Enable the TIM Input Capture  DMA request */
   2574                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   00000132   0x6828             LDR      R0,[R5, #+0]
   \   00000134   0x68C0             LDR      R0,[R0, #+12]
   \   00000136   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   0000013A   0x6829             LDR      R1,[R5, #+0]
   \   0000013C   0x60C8             STR      R0,[R1, #+12]
   2575                /* Enable the TIM Input Capture  DMA request */
   2576                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   0000013E   0x6828             LDR      R0,[R5, #+0]
   \   00000140   0x68C0             LDR      R0,[R0, #+12]
   \   00000142   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000146   0x6829             LDR      R1,[R5, #+0]
   \   00000148   0x60C8             STR      R0,[R1, #+12]
   2577              }
   2578              break;
   \   0000014A   0xE7FF             B.N      ??HAL_TIM_Encoder_Start_DMA_9
   2579          
   2580              default:
   2581              break;
   2582            }
   2583            /* Return function status */
   2584            return HAL_OK;
   \                     ??HAL_TIM_Encoder_Start_DMA_8: (+1)
   \                     ??HAL_TIM_Encoder_Start_DMA_9: (+1)
   \   0000014C   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_Encoder_Start_DMA_1: (+1)
   \   0000014E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2585          }
   2586          
   2587          /**
   2588            * @brief  Stops the TIM Encoder Interface in DMA mode.
   2589            * @param  htim : TIM Encoder Interface handle
   2590            * @param  Channel : TIM Channels to be enabled
   2591            *          This parameter can be one of the following values:
   2592            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2593            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2594            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2595            * @retval HAL status
   2596          */

   \                                 In section .text, align 2, keep-with-next
   2597          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   2598          {
   \                     HAL_TIM_Encoder_Stop_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2599            /* Check the parameters */
   2600            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2601          
   2602            /* Disable the Input Capture channels 1 and 2
   2603              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   2604            if(Channel == TIM_CHANNEL_1)
   \   00000006   0x2D00             CMP      R5,#+0
   \   00000008   0xD10B             BNE.N    ??HAL_TIM_Encoder_Stop_DMA_0
   2605            {
   2606              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x.... 0x....      BL       TIM_CCxChannelCmd
   2607          
   2608              /* Disable the capture compare DMA Request 1 */
   2609              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x68C0             LDR      R0,[R0, #+12]
   \   00000018   0xF430 0x7000      BICS     R0,R0,#0x200
   \   0000001C   0x6821             LDR      R1,[R4, #+0]
   \   0000001E   0x60C8             STR      R0,[R1, #+12]
   \   00000020   0xE023             B.N      ??HAL_TIM_Encoder_Stop_DMA_1
   2610            }
   2611            else if(Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_Encoder_Stop_DMA_0: (+1)
   \   00000022   0x2D04             CMP      R5,#+4
   \   00000024   0xD10B             BNE.N    ??HAL_TIM_Encoder_Stop_DMA_2
   2612            {
   2613              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \   00000026   0x2200             MOVS     R2,#+0
   \   00000028   0x2104             MOVS     R1,#+4
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      BL       TIM_CCxChannelCmd
   2614          
   2615              /* Disable the capture compare DMA Request 2 */
   2616              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x68C0             LDR      R0,[R0, #+12]
   \   00000034   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000038   0x6821             LDR      R1,[R4, #+0]
   \   0000003A   0x60C8             STR      R0,[R1, #+12]
   \   0000003C   0xE015             B.N      ??HAL_TIM_Encoder_Stop_DMA_1
   2617            }
   2618            else
   2619            {
   2620              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_DMA_2: (+1)
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x.... 0x....      BL       TIM_CCxChannelCmd
   2621              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \   00000048   0x2200             MOVS     R2,#+0
   \   0000004A   0x2104             MOVS     R1,#+4
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x.... 0x....      BL       TIM_CCxChannelCmd
   2622          
   2623              /* Disable the capture compare DMA Request 1 and 2 */
   2624              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x68C0             LDR      R0,[R0, #+12]
   \   00000056   0xF430 0x7000      BICS     R0,R0,#0x200
   \   0000005A   0x6821             LDR      R1,[R4, #+0]
   \   0000005C   0x60C8             STR      R0,[R1, #+12]
   2625              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x68C0             LDR      R0,[R0, #+12]
   \   00000062   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000066   0x6821             LDR      R1,[R4, #+0]
   \   00000068   0x60C8             STR      R0,[R1, #+12]
   2626            }
   2627          
   2628            /* Disable the Peripheral */
   2629            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_Encoder_Stop_DMA_1: (+1)
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x6A00             LDR      R0,[R0, #+32]
   \   0000006E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000072   0x4208             TST      R0,R1
   \   00000074   0xD105             BNE.N    ??HAL_TIM_Encoder_Stop_DMA_3
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x0840             LSRS     R0,R0,#+1
   \   0000007C   0x0040             LSLS     R0,R0,#+1
   \   0000007E   0x6821             LDR      R1,[R4, #+0]
   \   00000080   0x6008             STR      R0,[R1, #+0]
   2630          
   2631            /* Change the htim state */
   2632            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Encoder_Stop_DMA_3: (+1)
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0xF884 0x0035      STRB     R0,[R4, #+53]
   2633          
   2634            /* Return function status */
   2635            return HAL_OK;
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2636          }
   2637          
   2638          /**
   2639            * @}
   2640            */
   2641          /** @defgroup TIM_Exported_Functions_Group7 TIM IRQ handler management
   2642           *  @brief    IRQ handler management
   2643           *
   2644          @verbatim
   2645            ==============================================================================
   2646                                  ##### IRQ handler management #####
   2647            ==============================================================================
   2648            [..]
   2649              This section provides Timer IRQ handler function.
   2650          
   2651          @endverbatim
   2652            * @{
   2653            */
   2654          /**
   2655            * @brief  This function handles TIM interrupts requests.
   2656            * @param  htim: TIM  handle
   2657            * @retval None
   2658            */

   \                                 In section .text, align 2, keep-with-next
   2659          void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
   2660          {
   \                     HAL_TIM_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2661            /* Capture compare 1 event */
   2662            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6900             LDR      R0,[R0, #+16]
   \   00000008   0x0780             LSLS     R0,R0,#+30
   \   0000000A   0xD51A             BPL.N    ??HAL_TIM_IRQHandler_0
   2663            {
   2664              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x68C0             LDR      R0,[R0, #+12]
   \   00000010   0x0780             LSLS     R0,R0,#+30
   \   00000012   0xD516             BPL.N    ??HAL_TIM_IRQHandler_0
   2665              {
   2666                {
   2667                  __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
   \   00000014   0xF07F 0x0002      MVNS     R0,#+2
   \   00000018   0x6821             LDR      R1,[R4, #+0]
   \   0000001A   0x6108             STR      R0,[R1, #+16]
   2668                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x7520             STRB     R0,[R4, #+20]
   2669          
   2670                  /* Input capture event */
   2671                  if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00)
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x6980             LDR      R0,[R0, #+24]
   \   00000024   0xF010 0x0F03      TST      R0,#0x3
   \   00000028   0xD003             BEQ.N    ??HAL_TIM_IRQHandler_1
   2672                  {
   2673                    HAL_TIM_IC_CaptureCallback(htim);
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \   00000030   0xE005             B.N      ??HAL_TIM_IRQHandler_2
   2674                  }
   2675                  /* Output compare event */
   2676                  else
   2677                  {
   2678                    HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_1: (+1)
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   2679                    HAL_TIM_PWM_PulseFinishedCallback(htim);
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2680                  }
   2681                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_2: (+1)
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x7520             STRB     R0,[R4, #+20]
   2682                }
   2683              }
   2684            }
   2685            /* Capture compare 2 event */
   2686            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
   \                     ??HAL_TIM_IRQHandler_0: (+1)
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x6900             LDR      R0,[R0, #+16]
   \   00000046   0x0740             LSLS     R0,R0,#+29
   \   00000048   0xD51A             BPL.N    ??HAL_TIM_IRQHandler_3
   2687            {
   2688              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x68C0             LDR      R0,[R0, #+12]
   \   0000004E   0x0740             LSLS     R0,R0,#+29
   \   00000050   0xD516             BPL.N    ??HAL_TIM_IRQHandler_3
   2689              {
   2690                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
   \   00000052   0xF07F 0x0004      MVNS     R0,#+4
   \   00000056   0x6821             LDR      R1,[R4, #+0]
   \   00000058   0x6108             STR      R0,[R1, #+16]
   2691                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \   0000005A   0x2002             MOVS     R0,#+2
   \   0000005C   0x7520             STRB     R0,[R4, #+20]
   2692                /* Input capture event */
   2693                if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x6980             LDR      R0,[R0, #+24]
   \   00000062   0xF410 0x7F40      TST      R0,#0x300
   \   00000066   0xD003             BEQ.N    ??HAL_TIM_IRQHandler_4
   2694                {
   2695                  HAL_TIM_IC_CaptureCallback(htim);
   \   00000068   0x0020             MOVS     R0,R4
   \   0000006A   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \   0000006E   0xE005             B.N      ??HAL_TIM_IRQHandler_5
   2696                }
   2697                /* Output compare event */
   2698                else
   2699                {
   2700                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_4: (+1)
   \   00000070   0x0020             MOVS     R0,R4
   \   00000072   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   2701                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   \   00000076   0x0020             MOVS     R0,R4
   \   00000078   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2702                }
   2703                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_5: (+1)
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x7520             STRB     R0,[R4, #+20]
   2704              }
   2705            }
   2706            /* Capture compare 3 event */
   2707            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
   \                     ??HAL_TIM_IRQHandler_3: (+1)
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x6900             LDR      R0,[R0, #+16]
   \   00000084   0x0700             LSLS     R0,R0,#+28
   \   00000086   0xD51A             BPL.N    ??HAL_TIM_IRQHandler_6
   2708            {
   2709              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x68C0             LDR      R0,[R0, #+12]
   \   0000008C   0x0700             LSLS     R0,R0,#+28
   \   0000008E   0xD516             BPL.N    ??HAL_TIM_IRQHandler_6
   2710              {
   2711                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
   \   00000090   0xF07F 0x0008      MVNS     R0,#+8
   \   00000094   0x6821             LDR      R1,[R4, #+0]
   \   00000096   0x6108             STR      R0,[R1, #+16]
   2712                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \   00000098   0x2004             MOVS     R0,#+4
   \   0000009A   0x7520             STRB     R0,[R4, #+20]
   2713                /* Input capture event */
   2714                if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0x69C0             LDR      R0,[R0, #+28]
   \   000000A0   0xF010 0x0F03      TST      R0,#0x3
   \   000000A4   0xD003             BEQ.N    ??HAL_TIM_IRQHandler_7
   2715                {
   2716                  HAL_TIM_IC_CaptureCallback(htim);
   \   000000A6   0x0020             MOVS     R0,R4
   \   000000A8   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \   000000AC   0xE005             B.N      ??HAL_TIM_IRQHandler_8
   2717                }
   2718                /* Output compare event */
   2719                else
   2720                {
   2721                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_7: (+1)
   \   000000AE   0x0020             MOVS     R0,R4
   \   000000B0   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   2722                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   \   000000B4   0x0020             MOVS     R0,R4
   \   000000B6   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2723                }
   2724                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_8: (+1)
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x7520             STRB     R0,[R4, #+20]
   2725              }
   2726            }
   2727            /* Capture compare 4 event */
   2728            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
   \                     ??HAL_TIM_IRQHandler_6: (+1)
   \   000000BE   0x6820             LDR      R0,[R4, #+0]
   \   000000C0   0x6900             LDR      R0,[R0, #+16]
   \   000000C2   0x06C0             LSLS     R0,R0,#+27
   \   000000C4   0xD51A             BPL.N    ??HAL_TIM_IRQHandler_9
   2729            {
   2730              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
   \   000000C6   0x6820             LDR      R0,[R4, #+0]
   \   000000C8   0x68C0             LDR      R0,[R0, #+12]
   \   000000CA   0x06C0             LSLS     R0,R0,#+27
   \   000000CC   0xD516             BPL.N    ??HAL_TIM_IRQHandler_9
   2731              {
   2732                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
   \   000000CE   0xF07F 0x0010      MVNS     R0,#+16
   \   000000D2   0x6821             LDR      R1,[R4, #+0]
   \   000000D4   0x6108             STR      R0,[R1, #+16]
   2733                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \   000000D6   0x2008             MOVS     R0,#+8
   \   000000D8   0x7520             STRB     R0,[R4, #+20]
   2734                /* Input capture event */
   2735                if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
   \   000000DA   0x6820             LDR      R0,[R4, #+0]
   \   000000DC   0x69C0             LDR      R0,[R0, #+28]
   \   000000DE   0xF410 0x7F40      TST      R0,#0x300
   \   000000E2   0xD003             BEQ.N    ??HAL_TIM_IRQHandler_10
   2736                {
   2737                  HAL_TIM_IC_CaptureCallback(htim);
   \   000000E4   0x0020             MOVS     R0,R4
   \   000000E6   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \   000000EA   0xE005             B.N      ??HAL_TIM_IRQHandler_11
   2738                }
   2739                /* Output compare event */
   2740                else
   2741                {
   2742                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_10: (+1)
   \   000000EC   0x0020             MOVS     R0,R4
   \   000000EE   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   2743                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   \   000000F2   0x0020             MOVS     R0,R4
   \   000000F4   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2744                }
   2745                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_11: (+1)
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0x7520             STRB     R0,[R4, #+20]
   2746              }
   2747            }
   2748            /* TIM Update event */
   2749            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
   \                     ??HAL_TIM_IRQHandler_9: (+1)
   \   000000FC   0x6820             LDR      R0,[R4, #+0]
   \   000000FE   0x6900             LDR      R0,[R0, #+16]
   \   00000100   0x07C0             LSLS     R0,R0,#+31
   \   00000102   0xD50A             BPL.N    ??HAL_TIM_IRQHandler_12
   2750            {
   2751              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
   \   00000104   0x6820             LDR      R0,[R4, #+0]
   \   00000106   0x68C0             LDR      R0,[R0, #+12]
   \   00000108   0x07C0             LSLS     R0,R0,#+31
   \   0000010A   0xD506             BPL.N    ??HAL_TIM_IRQHandler_12
   2752              {
   2753                __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
   \   0000010C   0xF07F 0x0001      MVNS     R0,#+1
   \   00000110   0x6821             LDR      R1,[R4, #+0]
   \   00000112   0x6108             STR      R0,[R1, #+16]
   2754                HAL_TIM_PeriodElapsedCallback(htim);
   \   00000114   0x0020             MOVS     R0,R4
   \   00000116   0x.... 0x....      BL       HAL_TIM_PeriodElapsedCallback
   2755              }
   2756            }
   2757            /* TIM Trigger detection event */
   2758            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
   \                     ??HAL_TIM_IRQHandler_12: (+1)
   \   0000011A   0x6820             LDR      R0,[R4, #+0]
   \   0000011C   0x6900             LDR      R0,[R0, #+16]
   \   0000011E   0x0640             LSLS     R0,R0,#+25
   \   00000120   0xD50A             BPL.N    ??HAL_TIM_IRQHandler_13
   2759            {
   2760              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
   \   00000122   0x6820             LDR      R0,[R4, #+0]
   \   00000124   0x68C0             LDR      R0,[R0, #+12]
   \   00000126   0x0640             LSLS     R0,R0,#+25
   \   00000128   0xD506             BPL.N    ??HAL_TIM_IRQHandler_13
   2761              {
   2762                __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
   \   0000012A   0xF07F 0x0040      MVNS     R0,#+64
   \   0000012E   0x6821             LDR      R1,[R4, #+0]
   \   00000130   0x6108             STR      R0,[R1, #+16]
   2763                HAL_TIM_TriggerCallback(htim);
   \   00000132   0x0020             MOVS     R0,R4
   \   00000134   0x.... 0x....      BL       HAL_TIM_TriggerCallback
   2764              }
   2765            }
   2766          }
   \                     ??HAL_TIM_IRQHandler_13: (+1)
   \   00000138   0xBD10             POP      {R4,PC}          ;; return
   2767          
   2768          /**
   2769            * @}
   2770            */
   2771          
   2772          /** @defgroup TIM_Exported_Functions_Group8 Peripheral Control functions
   2773           *  @brief   	Peripheral Control functions
   2774           *
   2775          @verbatim
   2776            ==============================================================================
   2777                             ##### Peripheral Control functions #####
   2778            ==============================================================================
   2779           [..]
   2780             This section provides functions allowing to:
   2781                (+) Configure The Input Output channels for OC, PWM, IC or One Pulse mode.
   2782                (+) Configure External Clock source.
   2783                (+) Configure Complementary channels, break features and dead time.
   2784                (+) Configure Master and the Slave synchronization.
   2785                (+) Configure the DMA Burst Mode.
   2786          
   2787          @endverbatim
   2788            * @{
   2789            */
   2790          
   2791          /**
   2792            * @brief  Initializes the TIM Output Compare Channels according to the specified
   2793            *         parameters in the TIM_OC_InitTypeDef.
   2794            * @param  htim: TIM Output Compare handle
   2795            * @param  sConfig: TIM Output Compare configuration structure
   2796            * @param  Channel : TIM Channels to be enabled
   2797            *          This parameter can be one of the following values:
   2798            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2799            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2800            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2801            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   2802            * @retval HAL status
   2803            */

   \                                 In section .text, align 2, keep-with-next
   2804          HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
   2805          {
   \                     HAL_TIM_OC_ConfigChannel: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   2806            /* Check the parameters */
   2807            assert_param(IS_TIM_CHANNELS(Channel));
   2808            assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
   2809            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   2810          
   2811            /* Check input state */
   2812            __HAL_LOCK(htim);
   \   00000008   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_TIM_OC_ConfigChannel_0
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE02A             B.N      ??HAL_TIM_OC_ConfigChannel_1
   \                     ??HAL_TIM_OC_ConfigChannel_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF884 0x0034      STRB     R0,[R4, #+52]
   2813          
   2814            htim->State = HAL_TIM_STATE_BUSY;
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xF884 0x0035      STRB     R0,[R4, #+53]
   2815          
   2816            switch (Channel)
   \   00000020   0x0030             MOVS     R0,R6
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD006             BEQ.N    ??HAL_TIM_OC_ConfigChannel_2
   \   00000026   0x2804             CMP      R0,#+4
   \   00000028   0xD009             BEQ.N    ??HAL_TIM_OC_ConfigChannel_3
   \   0000002A   0x2808             CMP      R0,#+8
   \   0000002C   0xD00C             BEQ.N    ??HAL_TIM_OC_ConfigChannel_4
   \   0000002E   0x280C             CMP      R0,#+12
   \   00000030   0xD00F             BEQ.N    ??HAL_TIM_OC_ConfigChannel_5
   \   00000032   0xE013             B.N      ??HAL_TIM_OC_ConfigChannel_6
   2817            {
   2818              case TIM_CHANNEL_1:
   2819              {
   2820                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   2821                /* Configure the TIM Channel 1 in Output Compare */
   2822                TIM_OC1_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_2: (+1)
   \   00000034   0x0029             MOVS     R1,R5
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x.... 0x....      BL       TIM_OC1_SetConfig
   2823              }
   2824              break;
   \   0000003C   0xE00E             B.N      ??HAL_TIM_OC_ConfigChannel_7
   2825          
   2826              case TIM_CHANNEL_2:
   2827              {
   2828                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2829                /* Configure the TIM Channel 2 in Output Compare */
   2830                TIM_OC2_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_3: (+1)
   \   0000003E   0x0029             MOVS     R1,R5
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x.... 0x....      BL       TIM_OC2_SetConfig
   2831              }
   2832              break;
   \   00000046   0xE009             B.N      ??HAL_TIM_OC_ConfigChannel_7
   2833          
   2834              case TIM_CHANNEL_3:
   2835              {
   2836                 assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   2837                /* Configure the TIM Channel 3 in Output Compare */
   2838                TIM_OC3_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_4: (+1)
   \   00000048   0x0029             MOVS     R1,R5
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x.... 0x....      BL       TIM_OC3_SetConfig
   2839              }
   2840              break;
   \   00000050   0xE004             B.N      ??HAL_TIM_OC_ConfigChannel_7
   2841          
   2842              case TIM_CHANNEL_4:
   2843              {
   2844                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   2845                 /* Configure the TIM Channel 4 in Output Compare */
   2846                 TIM_OC4_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_5: (+1)
   \   00000052   0x0029             MOVS     R1,R5
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x.... 0x....      BL       TIM_OC4_SetConfig
   2847              }
   2848              break;
   \   0000005A   0xE7FF             B.N      ??HAL_TIM_OC_ConfigChannel_7
   2849          
   2850              default:
   2851              break;
   2852            }
   2853            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OC_ConfigChannel_6: (+1)
   \                     ??HAL_TIM_OC_ConfigChannel_7: (+1)
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0xF884 0x0035      STRB     R0,[R4, #+53]
   2854          
   2855            __HAL_UNLOCK(htim);
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0xF884 0x0034      STRB     R0,[R4, #+52]
   2856          
   2857            return HAL_OK;
   \   00000068   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_ConfigChannel_1: (+1)
   \   0000006A   0xBD70             POP      {R4-R6,PC}       ;; return
   2858          }
   2859          
   2860          /**
   2861            * @brief  Initializes the TIM Input Capture Channels according to the specified
   2862            *         parameters in the TIM_IC_InitTypeDef.
   2863            * @param  htim: TIM IC handle
   2864            * @param  sConfig: TIM Input Capture configuration structure
   2865            * @param  Channel : TIM Channels to be enabled
   2866            *          This parameter can be one of the following values:
   2867            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2868            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2869            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2870            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   2871            * @retval HAL status
   2872            */

   \                                 In section .text, align 2, keep-with-next
   2873          HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef* sConfig, uint32_t Channel)
   2874          {
   \                     HAL_TIM_IC_ConfigChannel: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   2875            /* Check the parameters */
   2876            assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   2877            assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
   2878            assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
   2879            assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
   2880            assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
   2881          
   2882            __HAL_LOCK(htim);
   \   00000008   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_TIM_IC_ConfigChannel_0
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE05F             B.N      ??HAL_TIM_IC_ConfigChannel_1
   \                     ??HAL_TIM_IC_ConfigChannel_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF884 0x0034      STRB     R0,[R4, #+52]
   2883          
   2884            htim->State = HAL_TIM_STATE_BUSY;
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xF884 0x0035      STRB     R0,[R4, #+53]
   2885          
   2886            if (Channel == TIM_CHANNEL_1)
   \   00000020   0x2E00             CMP      R6,#+0
   \   00000022   0xD112             BNE.N    ??HAL_TIM_IC_ConfigChannel_2
   2887            {
   2888              /* TI1 Configuration */
   2889              TIM_TI1_SetConfig(htim->Instance,
   2890                         sConfig->ICPolarity,
   2891                         sConfig->ICSelection,
   2892                         sConfig->ICFilter);
   \   00000024   0x68EB             LDR      R3,[R5, #+12]
   \   00000026   0x686A             LDR      R2,[R5, #+4]
   \   00000028   0x6829             LDR      R1,[R5, #+0]
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      BL       TIM_TI1_SetConfig
   2893          
   2894              /* Reset the IC1PSC Bits */
   2895              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6980             LDR      R0,[R0, #+24]
   \   00000034   0xF030 0x000C      BICS     R0,R0,#0xC
   \   00000038   0x6821             LDR      R1,[R4, #+0]
   \   0000003A   0x6188             STR      R0,[R1, #+24]
   2896          
   2897              /* Set the IC1PSC value */
   2898              htim->Instance->CCMR1 |= sConfig->ICPrescaler;
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6980             LDR      R0,[R0, #+24]
   \   00000040   0x68A9             LDR      R1,[R5, #+8]
   \   00000042   0x4308             ORRS     R0,R1,R0
   \   00000044   0x6821             LDR      R1,[R4, #+0]
   \   00000046   0x6188             STR      R0,[R1, #+24]
   \   00000048   0xE03D             B.N      ??HAL_TIM_IC_ConfigChannel_3
   2899            }
   2900            else if (Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_IC_ConfigChannel_2: (+1)
   \   0000004A   0x2E04             CMP      R6,#+4
   \   0000004C   0xD113             BNE.N    ??HAL_TIM_IC_ConfigChannel_4
   2901            {
   2902              /* TI2 Configuration */
   2903              assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2904          
   2905              TIM_TI2_SetConfig(htim->Instance,
   2906                                sConfig->ICPolarity,
   2907                                sConfig->ICSelection,
   2908                                sConfig->ICFilter);
   \   0000004E   0x68EB             LDR      R3,[R5, #+12]
   \   00000050   0x686A             LDR      R2,[R5, #+4]
   \   00000052   0x6829             LDR      R1,[R5, #+0]
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x.... 0x....      BL       TIM_TI2_SetConfig
   2909          
   2910              /* Reset the IC2PSC Bits */
   2911              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x6980             LDR      R0,[R0, #+24]
   \   0000005E   0xF430 0x6040      BICS     R0,R0,#0xC00
   \   00000062   0x6821             LDR      R1,[R4, #+0]
   \   00000064   0x6188             STR      R0,[R1, #+24]
   2912          
   2913              /* Set the IC2PSC value */
   2914              htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8);
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x6980             LDR      R0,[R0, #+24]
   \   0000006A   0x68A9             LDR      R1,[R5, #+8]
   \   0000006C   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000070   0x6821             LDR      R1,[R4, #+0]
   \   00000072   0x6188             STR      R0,[R1, #+24]
   \   00000074   0xE027             B.N      ??HAL_TIM_IC_ConfigChannel_3
   2915            }
   2916            else if (Channel == TIM_CHANNEL_3)
   \                     ??HAL_TIM_IC_ConfigChannel_4: (+1)
   \   00000076   0x2E08             CMP      R6,#+8
   \   00000078   0xD112             BNE.N    ??HAL_TIM_IC_ConfigChannel_5
   2917            {
   2918              /* TI3 Configuration */
   2919              assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   2920          
   2921              TIM_TI3_SetConfig(htim->Instance,
   2922                         sConfig->ICPolarity,
   2923                         sConfig->ICSelection,
   2924                         sConfig->ICFilter);
   \   0000007A   0x68EB             LDR      R3,[R5, #+12]
   \   0000007C   0x686A             LDR      R2,[R5, #+4]
   \   0000007E   0x6829             LDR      R1,[R5, #+0]
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x.... 0x....      BL       TIM_TI3_SetConfig
   2925          
   2926              /* Reset the IC3PSC Bits */
   2927              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x69C0             LDR      R0,[R0, #+28]
   \   0000008A   0xF030 0x000C      BICS     R0,R0,#0xC
   \   0000008E   0x6821             LDR      R1,[R4, #+0]
   \   00000090   0x61C8             STR      R0,[R1, #+28]
   2928          
   2929              /* Set the IC3PSC value */
   2930              htim->Instance->CCMR2 |= sConfig->ICPrescaler;
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x69C0             LDR      R0,[R0, #+28]
   \   00000096   0x68A9             LDR      R1,[R5, #+8]
   \   00000098   0x4308             ORRS     R0,R1,R0
   \   0000009A   0x6821             LDR      R1,[R4, #+0]
   \   0000009C   0x61C8             STR      R0,[R1, #+28]
   \   0000009E   0xE012             B.N      ??HAL_TIM_IC_ConfigChannel_3
   2931            }
   2932            else
   2933            {
   2934              /* TI4 Configuration */
   2935              assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   2936          
   2937              TIM_TI4_SetConfig(htim->Instance,
   2938                         sConfig->ICPolarity,
   2939                         sConfig->ICSelection,
   2940                         sConfig->ICFilter);
   \                     ??HAL_TIM_IC_ConfigChannel_5: (+1)
   \   000000A0   0x68EB             LDR      R3,[R5, #+12]
   \   000000A2   0x686A             LDR      R2,[R5, #+4]
   \   000000A4   0x6829             LDR      R1,[R5, #+0]
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0x.... 0x....      BL       TIM_TI4_SetConfig
   2941          
   2942              /* Reset the IC4PSC Bits */
   2943              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0x69C0             LDR      R0,[R0, #+28]
   \   000000B0   0xF430 0x6040      BICS     R0,R0,#0xC00
   \   000000B4   0x6821             LDR      R1,[R4, #+0]
   \   000000B6   0x61C8             STR      R0,[R1, #+28]
   2944          
   2945              /* Set the IC4PSC value */
   2946              htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8);
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0x69C0             LDR      R0,[R0, #+28]
   \   000000BC   0x68A9             LDR      R1,[R5, #+8]
   \   000000BE   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   000000C2   0x6821             LDR      R1,[R4, #+0]
   \   000000C4   0x61C8             STR      R0,[R1, #+28]
   2947            }
   2948          
   2949            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_IC_ConfigChannel_3: (+1)
   \   000000C6   0x2001             MOVS     R0,#+1
   \   000000C8   0xF884 0x0035      STRB     R0,[R4, #+53]
   2950          
   2951            __HAL_UNLOCK(htim);
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0xF884 0x0034      STRB     R0,[R4, #+52]
   2952          
   2953            return HAL_OK;
   \   000000D2   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_IC_ConfigChannel_1: (+1)
   \   000000D4   0xBD70             POP      {R4-R6,PC}       ;; return
   2954          }
   2955          
   2956          /**
   2957            * @brief  Initializes the TIM PWM  channels according to the specified
   2958            *         parameters in the TIM_OC_InitTypeDef.
   2959            * @param  htim: TIM handle
   2960            * @param  sConfig: TIM PWM configuration structure
   2961            * @param  Channel : TIM Channels to be enabled
   2962            *          This parameter can be one of the following values:
   2963            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2964            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2965            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2966            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   2967            * @retval HAL status
   2968            */

   \                                 In section .text, align 2, keep-with-next
   2969          HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
   2970          {
   \                     HAL_TIM_PWM_ConfigChannel: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   2971            __HAL_LOCK(htim);
   \   00000008   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_TIM_PWM_ConfigChannel_0
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE074             B.N      ??HAL_TIM_PWM_ConfigChannel_1
   \                     ??HAL_TIM_PWM_ConfigChannel_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF884 0x0034      STRB     R0,[R4, #+52]
   2972          
   2973            /* Check the parameters */
   2974            assert_param(IS_TIM_CHANNELS(Channel));
   2975            assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
   2976            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   2977            assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
   2978          
   2979            htim->State = HAL_TIM_STATE_BUSY;
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xF884 0x0035      STRB     R0,[R4, #+53]
   2980          
   2981            switch (Channel)
   \   00000020   0x0030             MOVS     R0,R6
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD006             BEQ.N    ??HAL_TIM_PWM_ConfigChannel_2
   \   00000026   0x2804             CMP      R0,#+4
   \   00000028   0xD01B             BEQ.N    ??HAL_TIM_PWM_ConfigChannel_3
   \   0000002A   0x2808             CMP      R0,#+8
   \   0000002C   0xD031             BEQ.N    ??HAL_TIM_PWM_ConfigChannel_4
   \   0000002E   0x280C             CMP      R0,#+12
   \   00000030   0xD046             BEQ.N    ??HAL_TIM_PWM_ConfigChannel_5
   \   00000032   0xE05D             B.N      ??HAL_TIM_PWM_ConfigChannel_6
   2982            {
   2983              case TIM_CHANNEL_1:
   2984              {
   2985                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   2986                /* Configure the Channel 1 in PWM mode */
   2987                TIM_OC1_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_2: (+1)
   \   00000034   0x0029             MOVS     R1,R5
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x.... 0x....      BL       TIM_OC1_SetConfig
   2988          
   2989                /* Set the Preload enable bit for channel1 */
   2990                htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6980             LDR      R0,[R0, #+24]
   \   00000040   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000044   0x6821             LDR      R1,[R4, #+0]
   \   00000046   0x6188             STR      R0,[R1, #+24]
   2991          
   2992                /* Configure the Output Fast mode */
   2993                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x6980             LDR      R0,[R0, #+24]
   \   0000004C   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000050   0x6821             LDR      R1,[R4, #+0]
   \   00000052   0x6188             STR      R0,[R1, #+24]
   2994                htim->Instance->CCMR1 |= sConfig->OCFastMode;
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x6980             LDR      R0,[R0, #+24]
   \   00000058   0x68E9             LDR      R1,[R5, #+12]
   \   0000005A   0x4308             ORRS     R0,R1,R0
   \   0000005C   0x6821             LDR      R1,[R4, #+0]
   \   0000005E   0x6188             STR      R0,[R1, #+24]
   2995              }
   2996              break;
   \   00000060   0xE046             B.N      ??HAL_TIM_PWM_ConfigChannel_7
   2997          
   2998              case TIM_CHANNEL_2:
   2999              {
   3000                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3001                /* Configure the Channel 2 in PWM mode */
   3002                TIM_OC2_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_3: (+1)
   \   00000062   0x0029             MOVS     R1,R5
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x.... 0x....      BL       TIM_OC2_SetConfig
   3003          
   3004                /* Set the Preload enable bit for channel2 */
   3005                htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x6980             LDR      R0,[R0, #+24]
   \   0000006E   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   00000072   0x6821             LDR      R1,[R4, #+0]
   \   00000074   0x6188             STR      R0,[R1, #+24]
   3006          
   3007                /* Configure the Output Fast mode */
   3008                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x6980             LDR      R0,[R0, #+24]
   \   0000007A   0xF430 0x6080      BICS     R0,R0,#0x400
   \   0000007E   0x6821             LDR      R1,[R4, #+0]
   \   00000080   0x6188             STR      R0,[R1, #+24]
   3009                htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0x6980             LDR      R0,[R0, #+24]
   \   00000086   0x68E9             LDR      R1,[R5, #+12]
   \   00000088   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   0000008C   0x6821             LDR      R1,[R4, #+0]
   \   0000008E   0x6188             STR      R0,[R1, #+24]
   3010              }
   3011              break;
   \   00000090   0xE02E             B.N      ??HAL_TIM_PWM_ConfigChannel_7
   3012          
   3013              case TIM_CHANNEL_3:
   3014              {
   3015                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3016                /* Configure the Channel 3 in PWM mode */
   3017                TIM_OC3_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_4: (+1)
   \   00000092   0x0029             MOVS     R1,R5
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x.... 0x....      BL       TIM_OC3_SetConfig
   3018          
   3019                /* Set the Preload enable bit for channel3 */
   3020                htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
   \   0000009A   0x6820             LDR      R0,[R4, #+0]
   \   0000009C   0x69C0             LDR      R0,[R0, #+28]
   \   0000009E   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   000000A2   0x6821             LDR      R1,[R4, #+0]
   \   000000A4   0x61C8             STR      R0,[R1, #+28]
   3021          
   3022               /* Configure the Output Fast mode */
   3023                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0x69C0             LDR      R0,[R0, #+28]
   \   000000AA   0xF030 0x0004      BICS     R0,R0,#0x4
   \   000000AE   0x6821             LDR      R1,[R4, #+0]
   \   000000B0   0x61C8             STR      R0,[R1, #+28]
   3024                htim->Instance->CCMR2 |= sConfig->OCFastMode;
   \   000000B2   0x6820             LDR      R0,[R4, #+0]
   \   000000B4   0x69C0             LDR      R0,[R0, #+28]
   \   000000B6   0x68E9             LDR      R1,[R5, #+12]
   \   000000B8   0x4308             ORRS     R0,R1,R0
   \   000000BA   0x6821             LDR      R1,[R4, #+0]
   \   000000BC   0x61C8             STR      R0,[R1, #+28]
   3025              }
   3026              break;
   \   000000BE   0xE017             B.N      ??HAL_TIM_PWM_ConfigChannel_7
   3027          
   3028              case TIM_CHANNEL_4:
   3029              {
   3030                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3031                /* Configure the Channel 4 in PWM mode */
   3032                TIM_OC4_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_5: (+1)
   \   000000C0   0x0029             MOVS     R1,R5
   \   000000C2   0x6820             LDR      R0,[R4, #+0]
   \   000000C4   0x.... 0x....      BL       TIM_OC4_SetConfig
   3033          
   3034                /* Set the Preload enable bit for channel4 */
   3035                htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
   \   000000C8   0x6820             LDR      R0,[R4, #+0]
   \   000000CA   0x69C0             LDR      R0,[R0, #+28]
   \   000000CC   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   000000D0   0x6821             LDR      R1,[R4, #+0]
   \   000000D2   0x61C8             STR      R0,[R1, #+28]
   3036          
   3037               /* Configure the Output Fast mode */
   3038                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
   \   000000D4   0x6820             LDR      R0,[R4, #+0]
   \   000000D6   0x69C0             LDR      R0,[R0, #+28]
   \   000000D8   0xF430 0x6080      BICS     R0,R0,#0x400
   \   000000DC   0x6821             LDR      R1,[R4, #+0]
   \   000000DE   0x61C8             STR      R0,[R1, #+28]
   3039                htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;
   \   000000E0   0x6820             LDR      R0,[R4, #+0]
   \   000000E2   0x69C0             LDR      R0,[R0, #+28]
   \   000000E4   0x68E9             LDR      R1,[R5, #+12]
   \   000000E6   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   000000EA   0x6821             LDR      R1,[R4, #+0]
   \   000000EC   0x61C8             STR      R0,[R1, #+28]
   3040              }
   3041              break;
   \   000000EE   0xE7FF             B.N      ??HAL_TIM_PWM_ConfigChannel_7
   3042          
   3043              default:
   3044              break;
   3045            }
   3046          
   3047            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_PWM_ConfigChannel_6: (+1)
   \                     ??HAL_TIM_PWM_ConfigChannel_7: (+1)
   \   000000F0   0x2001             MOVS     R0,#+1
   \   000000F2   0xF884 0x0035      STRB     R0,[R4, #+53]
   3048          
   3049            __HAL_UNLOCK(htim);
   \   000000F6   0x2000             MOVS     R0,#+0
   \   000000F8   0xF884 0x0034      STRB     R0,[R4, #+52]
   3050          
   3051            return HAL_OK;
   \   000000FC   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_ConfigChannel_1: (+1)
   \   000000FE   0xBD70             POP      {R4-R6,PC}       ;; return
   3052          }
   3053          
   3054          /**
   3055            * @brief  Initializes the TIM One Pulse Channels according to the specified
   3056            *         parameters in the TIM_OnePulse_InitTypeDef.
   3057            * @param  htim: TIM One Pulse handle
   3058            * @param  sConfig: TIM One Pulse configuration structure
   3059            * @param  OutputChannel : TIM Channels to be enabled
   3060            *          This parameter can be one of the following values:
   3061            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3062            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3063            * @param  InputChannel : TIM Channels to be enabled
   3064            *          This parameter can be one of the following values:
   3065            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3066            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3067            * @retval HAL status
   3068            */

   \                                 In section .text, align 2, keep-with-next
   3069          HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef* sConfig, uint32_t OutputChannel,  uint32_t InputChannel)
   3070          {
   \                     HAL_TIM_OnePulse_ConfigChannel: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   3071            TIM_OC_InitTypeDef temp1;
   3072          
   3073            /* Check the parameters */
   3074            assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
   3075            assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
   3076          
   3077            if(OutputChannel != InputChannel)
   \   0000000C   0x42BE             CMP      R6,R7
   \   0000000E   0xD07B             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_0
   3078            {
   3079            __HAL_LOCK(htim);
   \   00000010   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD101             BNE.N    ??HAL_TIM_OnePulse_ConfigChannel_1
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0xE076             B.N      ??HAL_TIM_OnePulse_ConfigChannel_2
   \                     ??HAL_TIM_OnePulse_ConfigChannel_1: (+1)
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xF884 0x0034      STRB     R0,[R4, #+52]
   3080          
   3081            htim->State = HAL_TIM_STATE_BUSY;
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xF884 0x0035      STRB     R0,[R4, #+53]
   3082          
   3083            /* Extract the Ouput compare configuration from sConfig structure */
   3084            temp1.OCMode = sConfig->OCMode;
   \   00000028   0x6828             LDR      R0,[R5, #+0]
   \   0000002A   0x9000             STR      R0,[SP, #+0]
   3085            temp1.Pulse = sConfig->Pulse;
   \   0000002C   0x6868             LDR      R0,[R5, #+4]
   \   0000002E   0x9001             STR      R0,[SP, #+4]
   3086            temp1.OCPolarity = sConfig->OCPolarity;
   \   00000030   0x68A8             LDR      R0,[R5, #+8]
   \   00000032   0x9002             STR      R0,[SP, #+8]
   3087            temp1.OCIdleState = sConfig->OCIdleState;
   \   00000034   0x68E8             LDR      R0,[R5, #+12]
   \   00000036   0x9004             STR      R0,[SP, #+16]
   3088          
   3089              switch (OutputChannel)
   \   00000038   0x0030             MOVS     R0,R6
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD002             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_3
   \   0000003E   0x2804             CMP      R0,#+4
   \   00000040   0xD005             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_4
   \   00000042   0xE009             B.N      ??HAL_TIM_OnePulse_ConfigChannel_5
   3090            {
   3091              case TIM_CHANNEL_1:
   3092              {
   3093                  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3094          
   3095                TIM_OC1_SetConfig(htim->Instance, &temp1);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_3: (+1)
   \   00000044   0x4669             MOV      R1,SP
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       TIM_OC1_SetConfig
   3096              }
   3097              break;
   \   0000004C   0xE004             B.N      ??HAL_TIM_OnePulse_ConfigChannel_6
   3098              case TIM_CHANNEL_2:
   3099              {
   3100                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3101          
   3102                TIM_OC2_SetConfig(htim->Instance, &temp1);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_4: (+1)
   \   0000004E   0x4669             MOV      R1,SP
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x.... 0x....      BL       TIM_OC2_SetConfig
   3103              }
   3104              break;
   \   00000056   0xE7FF             B.N      ??HAL_TIM_OnePulse_ConfigChannel_6
   3105              default:
   3106              break;
   3107            }
   3108            switch (InputChannel)
   \                     ??HAL_TIM_OnePulse_ConfigChannel_5: (+1)
   \                     ??HAL_TIM_OnePulse_ConfigChannel_6: (+1)
   \   00000058   0x0038             MOVS     R0,R7
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD002             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_7
   \   0000005E   0x2804             CMP      R0,#+4
   \   00000060   0xD025             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_8
   \   00000062   0xE049             B.N      ??HAL_TIM_OnePulse_ConfigChannel_9
   3109            {
   3110              case TIM_CHANNEL_1:
   3111              {
   3112                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3113          
   3114                TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
   3115                                  sConfig->ICSelection, sConfig->ICFilter);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_7: (+1)
   \   00000064   0x69AB             LDR      R3,[R5, #+24]
   \   00000066   0x696A             LDR      R2,[R5, #+20]
   \   00000068   0x6929             LDR      R1,[R5, #+16]
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x.... 0x....      BL       TIM_TI1_SetConfig
   3116          
   3117                /* Reset the IC1PSC Bits */
   3118                htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6980             LDR      R0,[R0, #+24]
   \   00000074   0xF030 0x000C      BICS     R0,R0,#0xC
   \   00000078   0x6821             LDR      R1,[R4, #+0]
   \   0000007A   0x6188             STR      R0,[R1, #+24]
   3119          
   3120                /* Select the Trigger source */
   3121                htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x6880             LDR      R0,[R0, #+8]
   \   00000080   0xF030 0x0070      BICS     R0,R0,#0x70
   \   00000084   0x6821             LDR      R1,[R4, #+0]
   \   00000086   0x6088             STR      R0,[R1, #+8]
   3122                htim->Instance->SMCR |= TIM_TS_TI1FP1;
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x6880             LDR      R0,[R0, #+8]
   \   0000008C   0xF050 0x0050      ORRS     R0,R0,#0x50
   \   00000090   0x6821             LDR      R1,[R4, #+0]
   \   00000092   0x6088             STR      R0,[R1, #+8]
   3123          
   3124                /* Select the Slave Mode */
   3125                htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x6880             LDR      R0,[R0, #+8]
   \   00000098   0x08C0             LSRS     R0,R0,#+3
   \   0000009A   0x00C0             LSLS     R0,R0,#+3
   \   0000009C   0x6821             LDR      R1,[R4, #+0]
   \   0000009E   0x6088             STR      R0,[R1, #+8]
   3126                htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x6880             LDR      R0,[R0, #+8]
   \   000000A4   0xF050 0x0006      ORRS     R0,R0,#0x6
   \   000000A8   0x6821             LDR      R1,[R4, #+0]
   \   000000AA   0x6088             STR      R0,[R1, #+8]
   3127              }
   3128              break;
   \   000000AC   0xE024             B.N      ??HAL_TIM_OnePulse_ConfigChannel_10
   3129              case TIM_CHANNEL_2:
   3130              {
   3131                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3132          
   3133                TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
   3134                           sConfig->ICSelection, sConfig->ICFilter);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_8: (+1)
   \   000000AE   0x69AB             LDR      R3,[R5, #+24]
   \   000000B0   0x696A             LDR      R2,[R5, #+20]
   \   000000B2   0x6929             LDR      R1,[R5, #+16]
   \   000000B4   0x6820             LDR      R0,[R4, #+0]
   \   000000B6   0x.... 0x....      BL       TIM_TI2_SetConfig
   3135          
   3136                /* Reset the IC2PSC Bits */
   3137                htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   \   000000BA   0x6820             LDR      R0,[R4, #+0]
   \   000000BC   0x6980             LDR      R0,[R0, #+24]
   \   000000BE   0xF430 0x6040      BICS     R0,R0,#0xC00
   \   000000C2   0x6821             LDR      R1,[R4, #+0]
   \   000000C4   0x6188             STR      R0,[R1, #+24]
   3138          
   3139                /* Select the Trigger source */
   3140                htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \   000000C6   0x6820             LDR      R0,[R4, #+0]
   \   000000C8   0x6880             LDR      R0,[R0, #+8]
   \   000000CA   0xF030 0x0070      BICS     R0,R0,#0x70
   \   000000CE   0x6821             LDR      R1,[R4, #+0]
   \   000000D0   0x6088             STR      R0,[R1, #+8]
   3141                htim->Instance->SMCR |= TIM_TS_TI2FP2;
   \   000000D2   0x6820             LDR      R0,[R4, #+0]
   \   000000D4   0x6880             LDR      R0,[R0, #+8]
   \   000000D6   0xF050 0x0060      ORRS     R0,R0,#0x60
   \   000000DA   0x6821             LDR      R1,[R4, #+0]
   \   000000DC   0x6088             STR      R0,[R1, #+8]
   3142          
   3143                /* Select the Slave Mode */
   3144                htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \   000000DE   0x6820             LDR      R0,[R4, #+0]
   \   000000E0   0x6880             LDR      R0,[R0, #+8]
   \   000000E2   0x08C0             LSRS     R0,R0,#+3
   \   000000E4   0x00C0             LSLS     R0,R0,#+3
   \   000000E6   0x6821             LDR      R1,[R4, #+0]
   \   000000E8   0x6088             STR      R0,[R1, #+8]
   3145                htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   \   000000EA   0x6820             LDR      R0,[R4, #+0]
   \   000000EC   0x6880             LDR      R0,[R0, #+8]
   \   000000EE   0xF050 0x0006      ORRS     R0,R0,#0x6
   \   000000F2   0x6821             LDR      R1,[R4, #+0]
   \   000000F4   0x6088             STR      R0,[R1, #+8]
   3146              }
   3147              break;
   \   000000F6   0xE7FF             B.N      ??HAL_TIM_OnePulse_ConfigChannel_10
   3148          
   3149              default:
   3150              break;
   3151            }
   3152          
   3153            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OnePulse_ConfigChannel_9: (+1)
   \                     ??HAL_TIM_OnePulse_ConfigChannel_10: (+1)
   \   000000F8   0x2001             MOVS     R0,#+1
   \   000000FA   0xF884 0x0035      STRB     R0,[R4, #+53]
   3154          
   3155            __HAL_UNLOCK(htim);
   \   000000FE   0x2000             MOVS     R0,#+0
   \   00000100   0xF884 0x0034      STRB     R0,[R4, #+52]
   3156          
   3157            return HAL_OK;
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0xE000             B.N      ??HAL_TIM_OnePulse_ConfigChannel_2
   3158          }
   3159            else
   3160            {
   3161              return HAL_ERROR;
   \                     ??HAL_TIM_OnePulse_ConfigChannel_0: (+1)
   \   00000108   0x2001             MOVS     R0,#+1
   \                     ??HAL_TIM_OnePulse_ConfigChannel_2: (+1)
   \   0000010A   0xB005             ADD      SP,SP,#+20
   \   0000010C   0xBDF0             POP      {R4-R7,PC}       ;; return
   3162            }
   3163          }
   3164          
   3165          /**
   3166            * @brief  Configure the DMA Burst to transfer Data from the memory to the TIM peripheral
   3167            * @param  htim: TIM handle
   3168            * @param  BurstBaseAddress : TIM Base address from where the DMA will start the Data write
   3169            *         This parameter can be one of the following values:
   3170            *            @arg TIM_DMABASE_CR1
   3171            *            @arg TIM_DMABASE_CR2
   3172            *            @arg TIM_DMABASE_SMCR
   3173            *            @arg TIM_DMABASE_DIER
   3174            *            @arg TIM_DMABASE_SR
   3175            *            @arg TIM_DMABASE_EGR
   3176            *            @arg TIM_DMABASE_CCMR1
   3177            *            @arg TIM_DMABASE_CCMR2
   3178            *            @arg TIM_DMABASE_CCER
   3179            *            @arg TIM_DMABASE_CNT
   3180            *            @arg TIM_DMABASE_PSC
   3181            *            @arg TIM_DMABASE_ARR
   3182            *            @arg TIM_DMABASE_CCR1
   3183            *            @arg TIM_DMABASE_CCR2
   3184            *            @arg TIM_DMABASE_CCR3
   3185            *            @arg TIM_DMABASE_CCR4
   3186            *            @arg TIM_DMABASE_DCR
   3187            * @param  BurstRequestSrc: TIM DMA Request sources
   3188            *         This parameter can be one of the following values:
   3189            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   3190            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   3191            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   3192            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   3193            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   3194            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   3195            * @param  BurstBuffer: The Buffer address.
   3196            * @param  BurstLength: DMA Burst length. This parameter can be one value
   3197            *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   3198            * @retval HAL status
   3199            */

   \                                 In section .text, align 2, keep-with-next
   3200          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
   3201                                                        uint32_t* BurstBuffer, uint32_t  BurstLength)
   3202          {
   \                     HAL_TIM_DMABurst_WriteStart: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x001E             MOVS     R6,R3
   \   0000000C   0x9F06             LDR      R7,[SP, #+24]
   3203            /* Check the parameters */
   3204            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   3205            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   3206            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3207            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   3208          
   3209            if((htim->State == HAL_TIM_STATE_BUSY))
   \   0000000E   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000012   0x2802             CMP      R0,#+2
   \   00000014   0xD101             BNE.N    ??HAL_TIM_DMABurst_WriteStart_0
   3210            {
   3211               return HAL_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xE09C             B.N      ??HAL_TIM_DMABurst_WriteStart_1
   3212            }
   3213            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIM_DMABurst_WriteStart_0: (+1)
   \   0000001A   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD11C             BNE.N    ??HAL_TIM_DMABurst_WriteStart_2
   3214            {
   3215              if((BurstBuffer == 0 ) && (BurstLength > 0))
   \   00000022   0x2E00             CMP      R6,#+0
   \   00000024   0xD103             BNE.N    ??HAL_TIM_DMABurst_WriteStart_3
   \   00000026   0x2F00             CMP      R7,#+0
   \   00000028   0xD001             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_3
   3216              {
   3217                return HAL_ERROR;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xE092             B.N      ??HAL_TIM_DMABurst_WriteStart_1
   3218              }
   3219              else
   3220              {
   3221                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_DMABurst_WriteStart_3: (+1)
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0xF884 0x0035      STRB     R0,[R4, #+53]
   3222              }
   3223            }
   3224            else
   3225            {
   3226              return HAL_ERROR;
   3227            }
   3228          
   3229            switch(BurstRequestSrc)
   \   00000034   0x4640             MOV      R0,R8
   \   00000036   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000003A   0xD011             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_4
   \   0000003C   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000040   0xD020             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_5
   \   00000042   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000046   0xD02F             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_6
   \   00000048   0xF5B0 0x6F00      CMP      R0,#+2048
   \   0000004C   0xD03E             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_7
   \   0000004E   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000052   0xD04D             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_8
   \   00000054   0xF5B0 0x4F80      CMP      R0,#+16384
   \   00000058   0xD05C             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_9
   \   0000005A   0xE06D             B.N      ??HAL_TIM_DMABurst_WriteStart_10
   \                     ??HAL_TIM_DMABurst_WriteStart_2: (+1)
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0xE079             B.N      ??HAL_TIM_DMABurst_WriteStart_1
   3230            {
   3231              case TIM_DMA_UPDATE:
   3232              {
   3233                /* Set the DMA Period elapsed callback */
   3234                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_4: (+1)
   \   00000060   0x.... 0x....      ADR.W    R0,TIM_DMAPeriodElapsedCplt
   \   00000064   0x69A1             LDR      R1,[R4, #+24]
   \   00000066   0x6288             STR      R0,[R1, #+40]
   3235          
   3236                /* Set the DMA error callback */
   3237                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   \   00000068   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   0000006C   0x69A1             LDR      R1,[R4, #+24]
   \   0000006E   0x6308             STR      R0,[R1, #+48]
   3238          
   3239                /* Enable the DMA channel */
   3240                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);
   \   00000070   0x0A38             LSRS     R0,R7,#+8
   \   00000072   0x1C43             ADDS     R3,R0,#+1
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0xF110 0x024C      ADDS     R2,R0,#+76
   \   0000007A   0x0031             MOVS     R1,R6
   \   0000007C   0x69A0             LDR      R0,[R4, #+24]
   \   0000007E   0x.... 0x....      BL       HAL_DMA_Start_IT
   3241              }
   3242              break;
   \   00000082   0xE059             B.N      ??HAL_TIM_DMABurst_WriteStart_11
   3243              case TIM_DMA_CC1:
   3244              {
   3245                /* Set the DMA Period elapsed callback */
   3246                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback =  TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_5: (+1)
   \   00000084   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseCplt
   \   00000088   0x69E1             LDR      R1,[R4, #+28]
   \   0000008A   0x6288             STR      R0,[R1, #+40]
   3247          
   3248                /* Set the DMA error callback */
   3249                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   0000008C   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   00000090   0x69E1             LDR      R1,[R4, #+28]
   \   00000092   0x6308             STR      R0,[R1, #+48]
   3250          
   3251                /* Enable the DMA channel */
   3252                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);
   \   00000094   0x0A38             LSRS     R0,R7,#+8
   \   00000096   0x1C43             ADDS     R3,R0,#+1
   \   00000098   0x6820             LDR      R0,[R4, #+0]
   \   0000009A   0xF110 0x024C      ADDS     R2,R0,#+76
   \   0000009E   0x0031             MOVS     R1,R6
   \   000000A0   0x69E0             LDR      R0,[R4, #+28]
   \   000000A2   0x.... 0x....      BL       HAL_DMA_Start_IT
   3253              }
   3254              break;
   \   000000A6   0xE047             B.N      ??HAL_TIM_DMABurst_WriteStart_11
   3255              case TIM_DMA_CC2:
   3256              {
   3257                /* Set the DMA Period elapsed callback */
   3258                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback =  TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_6: (+1)
   \   000000A8   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseCplt
   \   000000AC   0x6A21             LDR      R1,[R4, #+32]
   \   000000AE   0x6288             STR      R0,[R1, #+40]
   3259          
   3260                /* Set the DMA error callback */
   3261                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \   000000B0   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000B4   0x6A21             LDR      R1,[R4, #+32]
   \   000000B6   0x6308             STR      R0,[R1, #+48]
   3262          
   3263                /* Enable the DMA channel */
   3264                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);
   \   000000B8   0x0A38             LSRS     R0,R7,#+8
   \   000000BA   0x1C43             ADDS     R3,R0,#+1
   \   000000BC   0x6820             LDR      R0,[R4, #+0]
   \   000000BE   0xF110 0x024C      ADDS     R2,R0,#+76
   \   000000C2   0x0031             MOVS     R1,R6
   \   000000C4   0x6A20             LDR      R0,[R4, #+32]
   \   000000C6   0x.... 0x....      BL       HAL_DMA_Start_IT
   3265              }
   3266              break;
   \   000000CA   0xE035             B.N      ??HAL_TIM_DMABurst_WriteStart_11
   3267              case TIM_DMA_CC3:
   3268              {
   3269                /* Set the DMA Period elapsed callback */
   3270                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback =  TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_7: (+1)
   \   000000CC   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseCplt
   \   000000D0   0x6A61             LDR      R1,[R4, #+36]
   \   000000D2   0x6288             STR      R0,[R1, #+40]
   3271          
   3272                /* Set the DMA error callback */
   3273                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \   000000D4   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000D8   0x6A61             LDR      R1,[R4, #+36]
   \   000000DA   0x6308             STR      R0,[R1, #+48]
   3274          
   3275                /* Enable the DMA channel */
   3276                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);
   \   000000DC   0x0A38             LSRS     R0,R7,#+8
   \   000000DE   0x1C43             ADDS     R3,R0,#+1
   \   000000E0   0x6820             LDR      R0,[R4, #+0]
   \   000000E2   0xF110 0x024C      ADDS     R2,R0,#+76
   \   000000E6   0x0031             MOVS     R1,R6
   \   000000E8   0x6A60             LDR      R0,[R4, #+36]
   \   000000EA   0x.... 0x....      BL       HAL_DMA_Start_IT
   3277              }
   3278              break;
   \   000000EE   0xE023             B.N      ??HAL_TIM_DMABurst_WriteStart_11
   3279              case TIM_DMA_CC4:
   3280              {
   3281                /* Set the DMA Period elapsed callback */
   3282                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback =  TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_8: (+1)
   \   000000F0   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseCplt
   \   000000F4   0x6AA1             LDR      R1,[R4, #+40]
   \   000000F6   0x6288             STR      R0,[R1, #+40]
   3283          
   3284                /* Set the DMA error callback */
   3285                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \   000000F8   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000FC   0x6AA1             LDR      R1,[R4, #+40]
   \   000000FE   0x6308             STR      R0,[R1, #+48]
   3286          
   3287                /* Enable the DMA channel */
   3288                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);
   \   00000100   0x0A38             LSRS     R0,R7,#+8
   \   00000102   0x1C43             ADDS     R3,R0,#+1
   \   00000104   0x6820             LDR      R0,[R4, #+0]
   \   00000106   0xF110 0x024C      ADDS     R2,R0,#+76
   \   0000010A   0x0031             MOVS     R1,R6
   \   0000010C   0x6AA0             LDR      R0,[R4, #+40]
   \   0000010E   0x.... 0x....      BL       HAL_DMA_Start_IT
   3289              }
   3290              break;
   \   00000112   0xE011             B.N      ??HAL_TIM_DMABurst_WriteStart_11
   3291              case TIM_DMA_TRIGGER:
   3292              {
   3293                /* Set the DMA Period elapsed callback */
   3294                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_9: (+1)
   \   00000114   0x.... 0x....      ADR.W    R0,TIM_DMATriggerCplt
   \   00000118   0x6B21             LDR      R1,[R4, #+48]
   \   0000011A   0x6288             STR      R0,[R1, #+40]
   3295          
   3296                /* Set the DMA error callback */
   3297                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
   \   0000011C   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   00000120   0x6B21             LDR      R1,[R4, #+48]
   \   00000122   0x6308             STR      R0,[R1, #+48]
   3298          
   3299                /* Enable the DMA channel */
   3300                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);
   \   00000124   0x0A38             LSRS     R0,R7,#+8
   \   00000126   0x1C43             ADDS     R3,R0,#+1
   \   00000128   0x6820             LDR      R0,[R4, #+0]
   \   0000012A   0xF110 0x024C      ADDS     R2,R0,#+76
   \   0000012E   0x0031             MOVS     R1,R6
   \   00000130   0x6B20             LDR      R0,[R4, #+48]
   \   00000132   0x.... 0x....      BL       HAL_DMA_Start_IT
   3301              }
   3302              break;
   \   00000136   0xE7FF             B.N      ??HAL_TIM_DMABurst_WriteStart_11
   3303              default:
   3304              break;
   3305            }
   3306             /* configure the DMA Burst Mode */
   3307             htim->Instance->DCR = BurstBaseAddress | BurstLength;
   \                     ??HAL_TIM_DMABurst_WriteStart_10: (+1)
   \                     ??HAL_TIM_DMABurst_WriteStart_11: (+1)
   \   00000138   0xEA57 0x0005      ORRS     R0,R7,R5
   \   0000013C   0x6821             LDR      R1,[R4, #+0]
   \   0000013E   0x6488             STR      R0,[R1, #+72]
   3308          
   3309             /* Enable the TIM DMA Request */
   3310             __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
   \   00000140   0x6820             LDR      R0,[R4, #+0]
   \   00000142   0x68C0             LDR      R0,[R0, #+12]
   \   00000144   0xEA58 0x0000      ORRS     R0,R8,R0
   \   00000148   0x6821             LDR      R1,[R4, #+0]
   \   0000014A   0x60C8             STR      R0,[R1, #+12]
   3311          
   3312             htim->State = HAL_TIM_STATE_READY;
   \   0000014C   0x2001             MOVS     R0,#+1
   \   0000014E   0xF884 0x0035      STRB     R0,[R4, #+53]
   3313          
   3314            /* Return function status */
   3315            return HAL_OK;
   \   00000152   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_DMABurst_WriteStart_1: (+1)
   \   00000154   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   3316          }
   3317          
   3318          /**
   3319            * @brief  Stops the TIM DMA Burst mode
   3320            * @param  htim: TIM handle
   3321            * @param  BurstRequestSrc: TIM DMA Request sources to disable
   3322            * @retval HAL status
   3323            */

   \                                 In section .text, align 2, keep-with-next
   3324          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   3325          {
   \                     HAL_TIM_DMABurst_WriteStop: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   3326            /* Check the parameters */
   3327            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3328          
   3329            /* Abort the DMA transfer (at least disable the DMA channel) */
   3330            switch(BurstRequestSrc)
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000000C   0xD00F             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_0
   \   0000000E   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000012   0xD010             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_1
   \   00000014   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000018   0xD011             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_2
   \   0000001A   0xF5B0 0x6F00      CMP      R0,#+2048
   \   0000001E   0xD012             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_3
   \   00000020   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000024   0xD013             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_4
   \   00000026   0xF5B0 0x4F80      CMP      R0,#+16384
   \   0000002A   0xD014             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_5
   \   0000002C   0xE017             B.N      ??HAL_TIM_DMABurst_WriteStop_6
   3331            {
   3332              case TIM_DMA_UPDATE:
   3333              {
   3334                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
   \                     ??HAL_TIM_DMABurst_WriteStop_0: (+1)
   \   0000002E   0x69A0             LDR      R0,[R4, #+24]
   \   00000030   0x.... 0x....      BL       HAL_DMA_Abort
   3335              }
   3336              break;
   \   00000034   0xE013             B.N      ??HAL_TIM_DMABurst_WriteStop_7
   3337              case TIM_DMA_CC1:
   3338              {
   3339                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
   \                     ??HAL_TIM_DMABurst_WriteStop_1: (+1)
   \   00000036   0x69E0             LDR      R0,[R4, #+28]
   \   00000038   0x.... 0x....      BL       HAL_DMA_Abort
   3340              }
   3341              break;
   \   0000003C   0xE00F             B.N      ??HAL_TIM_DMABurst_WriteStop_7
   3342              case TIM_DMA_CC2:
   3343              {
   3344                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
   \                     ??HAL_TIM_DMABurst_WriteStop_2: (+1)
   \   0000003E   0x6A20             LDR      R0,[R4, #+32]
   \   00000040   0x.... 0x....      BL       HAL_DMA_Abort
   3345              }
   3346              break;
   \   00000044   0xE00B             B.N      ??HAL_TIM_DMABurst_WriteStop_7
   3347              case TIM_DMA_CC3:
   3348              {
   3349                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
   \                     ??HAL_TIM_DMABurst_WriteStop_3: (+1)
   \   00000046   0x6A60             LDR      R0,[R4, #+36]
   \   00000048   0x.... 0x....      BL       HAL_DMA_Abort
   3350              }
   3351              break;
   \   0000004C   0xE007             B.N      ??HAL_TIM_DMABurst_WriteStop_7
   3352              case TIM_DMA_CC4:
   3353              {
   3354                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
   \                     ??HAL_TIM_DMABurst_WriteStop_4: (+1)
   \   0000004E   0x6AA0             LDR      R0,[R4, #+40]
   \   00000050   0x.... 0x....      BL       HAL_DMA_Abort
   3355              }
   3356              break;
   \   00000054   0xE003             B.N      ??HAL_TIM_DMABurst_WriteStop_7
   3357              case TIM_DMA_TRIGGER:
   3358              {
   3359                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
   \                     ??HAL_TIM_DMABurst_WriteStop_5: (+1)
   \   00000056   0x6B20             LDR      R0,[R4, #+48]
   \   00000058   0x.... 0x....      BL       HAL_DMA_Abort
   3360              }
   3361              break;
   \   0000005C   0xE7FF             B.N      ??HAL_TIM_DMABurst_WriteStop_7
   3362              default:
   3363              break;
   3364            }
   3365          
   3366            /* Disable the TIM Update DMA request */
   3367            __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   \                     ??HAL_TIM_DMABurst_WriteStop_6: (+1)
   \                     ??HAL_TIM_DMABurst_WriteStop_7: (+1)
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x68C0             LDR      R0,[R0, #+12]
   \   00000062   0x43A8             BICS     R0,R0,R5
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x60C8             STR      R0,[R1, #+12]
   3368          
   3369            /* Return function status */
   3370            return HAL_OK;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   3371          }
   3372          
   3373          /**
   3374            * @brief  Configure the DMA Burst to transfer Data from the TIM peripheral to the memory
   3375            * @param  htim: TIM handle
   3376            * @param  BurstBaseAddress : TIM Base address from where the DMA will starts the Data read
   3377            *         This parameter can be one of the following values:
   3378            *            @arg TIM_DMABASE_CR1
   3379            *            @arg TIM_DMABASE_CR2
   3380            *            @arg TIM_DMABASE_SMCR
   3381            *            @arg TIM_DMABASE_DIER
   3382            *            @arg TIM_DMABASE_SR
   3383            *            @arg TIM_DMABASE_EGR
   3384            *            @arg TIM_DMABASE_CCMR1
   3385            *            @arg TIM_DMABASE_CCMR2
   3386            *            @arg TIM_DMABASE_CCER
   3387            *            @arg TIM_DMABASE_CNT
   3388            *            @arg TIM_DMABASE_PSC
   3389            *            @arg TIM_DMABASE_ARR
   3390            *            @arg TIM_DMABASE_CCR1
   3391            *            @arg TIM_DMABASE_CCR2
   3392            *            @arg TIM_DMABASE_CCR3
   3393            *            @arg TIM_DMABASE_CCR4
   3394            *            @arg TIM_DMABASE_DCR
   3395            * @param  BurstRequestSrc: TIM DMA Request sources
   3396            *         This parameter can be one of the following values:
   3397            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   3398            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   3399            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   3400            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   3401            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   3402            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   3403            * @param  BurstBuffer: The Buffer address.
   3404            * @param  BurstLength: DMA Burst length. This parameter can be one value
   3405            *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   3406            * @retval HAL status
   3407            */

   \                                 In section .text, align 2, keep-with-next
   3408          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
   3409                                                       uint32_t  *BurstBuffer, uint32_t  BurstLength)
   3410          {
   \                     HAL_TIM_DMABurst_ReadStart: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x001E             MOVS     R6,R3
   \   0000000C   0x9F06             LDR      R7,[SP, #+24]
   3411            /* Check the parameters */
   3412            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   3413            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   3414            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3415            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   3416          
   3417            if((htim->State == HAL_TIM_STATE_BUSY))
   \   0000000E   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000012   0x2802             CMP      R0,#+2
   \   00000014   0xD101             BNE.N    ??HAL_TIM_DMABurst_ReadStart_0
   3418            {
   3419               return HAL_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xE09C             B.N      ??HAL_TIM_DMABurst_ReadStart_1
   3420            }
   3421            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIM_DMABurst_ReadStart_0: (+1)
   \   0000001A   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD11C             BNE.N    ??HAL_TIM_DMABurst_ReadStart_2
   3422            {
   3423              if((BurstBuffer == 0 ) && (BurstLength > 0))
   \   00000022   0x2E00             CMP      R6,#+0
   \   00000024   0xD103             BNE.N    ??HAL_TIM_DMABurst_ReadStart_3
   \   00000026   0x2F00             CMP      R7,#+0
   \   00000028   0xD001             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_3
   3424              {
   3425                return HAL_ERROR;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xE092             B.N      ??HAL_TIM_DMABurst_ReadStart_1
   3426              }
   3427              else
   3428              {
   3429                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_DMABurst_ReadStart_3: (+1)
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0xF884 0x0035      STRB     R0,[R4, #+53]
   3430              }
   3431            }
   3432            else
   3433            {
   3434              return HAL_ERROR;
   3435            }
   3436          
   3437            switch(BurstRequestSrc)
   \   00000034   0x4640             MOV      R0,R8
   \   00000036   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000003A   0xD011             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_4
   \   0000003C   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000040   0xD020             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_5
   \   00000042   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000046   0xD02F             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_6
   \   00000048   0xF5B0 0x6F00      CMP      R0,#+2048
   \   0000004C   0xD03E             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_7
   \   0000004E   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000052   0xD04D             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_8
   \   00000054   0xF5B0 0x4F80      CMP      R0,#+16384
   \   00000058   0xD05C             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_9
   \   0000005A   0xE06D             B.N      ??HAL_TIM_DMABurst_ReadStart_10
   \                     ??HAL_TIM_DMABurst_ReadStart_2: (+1)
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0xE079             B.N      ??HAL_TIM_DMABurst_ReadStart_1
   3438            {
   3439              case TIM_DMA_UPDATE:
   3440              {
   3441                /* Set the DMA Period elapsed callback */
   3442                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_4: (+1)
   \   00000060   0x.... 0x....      ADR.W    R0,TIM_DMAPeriodElapsedCplt
   \   00000064   0x69A1             LDR      R1,[R4, #+24]
   \   00000066   0x6288             STR      R0,[R1, #+40]
   3443          
   3444                /* Set the DMA error callback */
   3445                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   \   00000068   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   0000006C   0x69A1             LDR      R1,[R4, #+24]
   \   0000006E   0x6308             STR      R0,[R1, #+48]
   3446          
   3447                /* Enable the DMA channel */
   3448                 HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);
   \   00000070   0x0A38             LSRS     R0,R7,#+8
   \   00000072   0x1C43             ADDS     R3,R0,#+1
   \   00000074   0x0032             MOVS     R2,R6
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0xF110 0x014C      ADDS     R1,R0,#+76
   \   0000007C   0x69A0             LDR      R0,[R4, #+24]
   \   0000007E   0x.... 0x....      BL       HAL_DMA_Start_IT
   3449              }
   3450              break;
   \   00000082   0xE059             B.N      ??HAL_TIM_DMABurst_ReadStart_11
   3451              case TIM_DMA_CC1:
   3452              {
   3453                /* Set the DMA Period elapsed callback */
   3454                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback =  TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_5: (+1)
   \   00000084   0x.... 0x....      ADR.W    R0,TIM_DMACaptureCplt
   \   00000088   0x69E1             LDR      R1,[R4, #+28]
   \   0000008A   0x6288             STR      R0,[R1, #+40]
   3455          
   3456                /* Set the DMA error callback */
   3457                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   0000008C   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   00000090   0x69E1             LDR      R1,[R4, #+28]
   \   00000092   0x6308             STR      R0,[R1, #+48]
   3458          
   3459                /* Enable the DMA channel */
   3460                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);
   \   00000094   0x0A38             LSRS     R0,R7,#+8
   \   00000096   0x1C43             ADDS     R3,R0,#+1
   \   00000098   0x0032             MOVS     R2,R6
   \   0000009A   0x6820             LDR      R0,[R4, #+0]
   \   0000009C   0xF110 0x014C      ADDS     R1,R0,#+76
   \   000000A0   0x69E0             LDR      R0,[R4, #+28]
   \   000000A2   0x.... 0x....      BL       HAL_DMA_Start_IT
   3461              }
   3462              break;
   \   000000A6   0xE047             B.N      ??HAL_TIM_DMABurst_ReadStart_11
   3463              case TIM_DMA_CC2:
   3464              {
   3465                /* Set the DMA Period elapsed callback */
   3466                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback =  TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_6: (+1)
   \   000000A8   0x.... 0x....      ADR.W    R0,TIM_DMACaptureCplt
   \   000000AC   0x6A21             LDR      R1,[R4, #+32]
   \   000000AE   0x6288             STR      R0,[R1, #+40]
   3467          
   3468                /* Set the DMA error callback */
   3469                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \   000000B0   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000B4   0x6A21             LDR      R1,[R4, #+32]
   \   000000B6   0x6308             STR      R0,[R1, #+48]
   3470          
   3471                /* Enable the DMA channel */
   3472                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);
   \   000000B8   0x0A38             LSRS     R0,R7,#+8
   \   000000BA   0x1C43             ADDS     R3,R0,#+1
   \   000000BC   0x0032             MOVS     R2,R6
   \   000000BE   0x6820             LDR      R0,[R4, #+0]
   \   000000C0   0xF110 0x014C      ADDS     R1,R0,#+76
   \   000000C4   0x6A20             LDR      R0,[R4, #+32]
   \   000000C6   0x.... 0x....      BL       HAL_DMA_Start_IT
   3473              }
   3474              break;
   \   000000CA   0xE035             B.N      ??HAL_TIM_DMABurst_ReadStart_11
   3475              case TIM_DMA_CC3:
   3476              {
   3477                /* Set the DMA Period elapsed callback */
   3478                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback =  TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_7: (+1)
   \   000000CC   0x.... 0x....      ADR.W    R0,TIM_DMACaptureCplt
   \   000000D0   0x6A61             LDR      R1,[R4, #+36]
   \   000000D2   0x6288             STR      R0,[R1, #+40]
   3479          
   3480                /* Set the DMA error callback */
   3481                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \   000000D4   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000D8   0x6A61             LDR      R1,[R4, #+36]
   \   000000DA   0x6308             STR      R0,[R1, #+48]
   3482          
   3483                /* Enable the DMA channel */
   3484                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);
   \   000000DC   0x0A38             LSRS     R0,R7,#+8
   \   000000DE   0x1C43             ADDS     R3,R0,#+1
   \   000000E0   0x0032             MOVS     R2,R6
   \   000000E2   0x6820             LDR      R0,[R4, #+0]
   \   000000E4   0xF110 0x014C      ADDS     R1,R0,#+76
   \   000000E8   0x6A60             LDR      R0,[R4, #+36]
   \   000000EA   0x.... 0x....      BL       HAL_DMA_Start_IT
   3485              }
   3486              break;
   \   000000EE   0xE023             B.N      ??HAL_TIM_DMABurst_ReadStart_11
   3487              case TIM_DMA_CC4:
   3488              {
   3489                /* Set the DMA Period elapsed callback */
   3490                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback =  TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_8: (+1)
   \   000000F0   0x.... 0x....      ADR.W    R0,TIM_DMACaptureCplt
   \   000000F4   0x6AA1             LDR      R1,[R4, #+40]
   \   000000F6   0x6288             STR      R0,[R1, #+40]
   3491          
   3492                /* Set the DMA error callback */
   3493                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \   000000F8   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000FC   0x6AA1             LDR      R1,[R4, #+40]
   \   000000FE   0x6308             STR      R0,[R1, #+48]
   3494          
   3495                /* Enable the DMA channel */
   3496                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);
   \   00000100   0x0A38             LSRS     R0,R7,#+8
   \   00000102   0x1C43             ADDS     R3,R0,#+1
   \   00000104   0x0032             MOVS     R2,R6
   \   00000106   0x6820             LDR      R0,[R4, #+0]
   \   00000108   0xF110 0x014C      ADDS     R1,R0,#+76
   \   0000010C   0x6AA0             LDR      R0,[R4, #+40]
   \   0000010E   0x.... 0x....      BL       HAL_DMA_Start_IT
   3497              }
   3498              break;
   \   00000112   0xE011             B.N      ??HAL_TIM_DMABurst_ReadStart_11
   3499              case TIM_DMA_TRIGGER:
   3500              {
   3501                /* Set the DMA Period elapsed callback */
   3502                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_9: (+1)
   \   00000114   0x.... 0x....      ADR.W    R0,TIM_DMATriggerCplt
   \   00000118   0x6B21             LDR      R1,[R4, #+48]
   \   0000011A   0x6288             STR      R0,[R1, #+40]
   3503          
   3504                /* Set the DMA error callback */
   3505                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
   \   0000011C   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   00000120   0x6B21             LDR      R1,[R4, #+48]
   \   00000122   0x6308             STR      R0,[R1, #+48]
   3506          
   3507                /* Enable the DMA channel */
   3508                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);
   \   00000124   0x0A38             LSRS     R0,R7,#+8
   \   00000126   0x1C43             ADDS     R3,R0,#+1
   \   00000128   0x0032             MOVS     R2,R6
   \   0000012A   0x6820             LDR      R0,[R4, #+0]
   \   0000012C   0xF110 0x014C      ADDS     R1,R0,#+76
   \   00000130   0x6B20             LDR      R0,[R4, #+48]
   \   00000132   0x.... 0x....      BL       HAL_DMA_Start_IT
   3509              }
   3510              break;
   \   00000136   0xE7FF             B.N      ??HAL_TIM_DMABurst_ReadStart_11
   3511              default:
   3512              break;
   3513            }
   3514          
   3515            /* configure the DMA Burst Mode */
   3516            htim->Instance->DCR = BurstBaseAddress | BurstLength;
   \                     ??HAL_TIM_DMABurst_ReadStart_10: (+1)
   \                     ??HAL_TIM_DMABurst_ReadStart_11: (+1)
   \   00000138   0xEA57 0x0005      ORRS     R0,R7,R5
   \   0000013C   0x6821             LDR      R1,[R4, #+0]
   \   0000013E   0x6488             STR      R0,[R1, #+72]
   3517          
   3518            /* Enable the TIM DMA Request */
   3519            __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
   \   00000140   0x6820             LDR      R0,[R4, #+0]
   \   00000142   0x68C0             LDR      R0,[R0, #+12]
   \   00000144   0xEA58 0x0000      ORRS     R0,R8,R0
   \   00000148   0x6821             LDR      R1,[R4, #+0]
   \   0000014A   0x60C8             STR      R0,[R1, #+12]
   3520          
   3521            htim->State = HAL_TIM_STATE_READY;
   \   0000014C   0x2001             MOVS     R0,#+1
   \   0000014E   0xF884 0x0035      STRB     R0,[R4, #+53]
   3522          
   3523            /* Return function status */
   3524            return HAL_OK;
   \   00000152   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_DMABurst_ReadStart_1: (+1)
   \   00000154   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   3525          }
   3526          
   3527          /**
   3528            * @brief  Stop the DMA burst reading
   3529            * @param  htim: TIM handle
   3530            * @param  BurstRequestSrc: TIM DMA Request sources to disable.
   3531            * @retval HAL status
   3532            */

   \                                 In section .text, align 2, keep-with-next
   3533          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   3534          {
   \                     HAL_TIM_DMABurst_ReadStop: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   3535            /* Check the parameters */
   3536            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3537          
   3538            /* Abort the DMA transfer (at least disable the DMA channel) */
   3539            switch(BurstRequestSrc)
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000000C   0xD00F             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_0
   \   0000000E   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000012   0xD010             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_1
   \   00000014   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000018   0xD011             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_2
   \   0000001A   0xF5B0 0x6F00      CMP      R0,#+2048
   \   0000001E   0xD012             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_3
   \   00000020   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000024   0xD013             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_4
   \   00000026   0xF5B0 0x4F80      CMP      R0,#+16384
   \   0000002A   0xD014             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_5
   \   0000002C   0xE017             B.N      ??HAL_TIM_DMABurst_ReadStop_6
   3540            {
   3541              case TIM_DMA_UPDATE:
   3542              {
   3543                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
   \                     ??HAL_TIM_DMABurst_ReadStop_0: (+1)
   \   0000002E   0x69A0             LDR      R0,[R4, #+24]
   \   00000030   0x.... 0x....      BL       HAL_DMA_Abort
   3544              }
   3545              break;
   \   00000034   0xE013             B.N      ??HAL_TIM_DMABurst_ReadStop_7
   3546              case TIM_DMA_CC1:
   3547              {
   3548                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
   \                     ??HAL_TIM_DMABurst_ReadStop_1: (+1)
   \   00000036   0x69E0             LDR      R0,[R4, #+28]
   \   00000038   0x.... 0x....      BL       HAL_DMA_Abort
   3549              }
   3550              break;
   \   0000003C   0xE00F             B.N      ??HAL_TIM_DMABurst_ReadStop_7
   3551              case TIM_DMA_CC2:
   3552              {
   3553                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
   \                     ??HAL_TIM_DMABurst_ReadStop_2: (+1)
   \   0000003E   0x6A20             LDR      R0,[R4, #+32]
   \   00000040   0x.... 0x....      BL       HAL_DMA_Abort
   3554              }
   3555              break;
   \   00000044   0xE00B             B.N      ??HAL_TIM_DMABurst_ReadStop_7
   3556              case TIM_DMA_CC3:
   3557              {
   3558                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
   \                     ??HAL_TIM_DMABurst_ReadStop_3: (+1)
   \   00000046   0x6A60             LDR      R0,[R4, #+36]
   \   00000048   0x.... 0x....      BL       HAL_DMA_Abort
   3559              }
   3560              break;
   \   0000004C   0xE007             B.N      ??HAL_TIM_DMABurst_ReadStop_7
   3561              case TIM_DMA_CC4:
   3562              {
   3563                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
   \                     ??HAL_TIM_DMABurst_ReadStop_4: (+1)
   \   0000004E   0x6AA0             LDR      R0,[R4, #+40]
   \   00000050   0x.... 0x....      BL       HAL_DMA_Abort
   3564              }
   3565              break;
   \   00000054   0xE003             B.N      ??HAL_TIM_DMABurst_ReadStop_7
   3566              case TIM_DMA_TRIGGER:
   3567              {
   3568                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
   \                     ??HAL_TIM_DMABurst_ReadStop_5: (+1)
   \   00000056   0x6B20             LDR      R0,[R4, #+48]
   \   00000058   0x.... 0x....      BL       HAL_DMA_Abort
   3569              }
   3570              break;
   \   0000005C   0xE7FF             B.N      ??HAL_TIM_DMABurst_ReadStop_7
   3571              default:
   3572              break;
   3573            }
   3574          
   3575            /* Disable the TIM Update DMA request */
   3576            __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   \                     ??HAL_TIM_DMABurst_ReadStop_6: (+1)
   \                     ??HAL_TIM_DMABurst_ReadStop_7: (+1)
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x68C0             LDR      R0,[R0, #+12]
   \   00000062   0x43A8             BICS     R0,R0,R5
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x60C8             STR      R0,[R1, #+12]
   3577          
   3578            /* Return function status */
   3579            return HAL_OK;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   3580          }
   3581          
   3582          /**
   3583            * @brief  Generate a software event
   3584            * @param  htim: TIM handle
   3585            * @param  EventSource: specifies the event source.
   3586            *          This parameter can be one of the following values:
   3587            *            @arg TIM_EVENTSOURCE_UPDATE: Timer update Event source
   3588            *            @arg TIM_EVENTSOURCE_CC1: Timer Capture Compare 1 Event source
   3589            *            @arg TIM_EVENTSOURCE_CC2: Timer Capture Compare 2 Event source
   3590            *            @arg TIM_EVENTSOURCE_CC3: Timer Capture Compare 3 Event source
   3591            *            @arg TIM_EVENTSOURCE_CC4: Timer Capture Compare 4 Event source
   3592            *            @arg TIM_EVENTSOURCE_TRIGGER: Timer Trigger Event source
   3593            * @note   TIM6 and TIM7 can only generate an update event.
   3594            * @retval HAL status
   3595            */
   3596          

   \                                 In section .text, align 2, keep-with-next
   3597          HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
   3598          {
   \                     HAL_TIM_GenerateEvent: (+1)
   \   00000000   0x0002             MOVS     R2,R0
   3599            /* Check the parameters */
   3600            assert_param(IS_TIM_INSTANCE(htim->Instance));
   3601            assert_param(IS_TIM_EVENT_SOURCE(EventSource));
   3602          
   3603            /* Process Locked */
   3604            __HAL_LOCK(htim);
   \   00000002   0xF892 0x0034      LDRB     R0,[R2, #+52]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_TIM_GenerateEvent_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE00E             B.N      ??HAL_TIM_GenerateEvent_1
   \                     ??HAL_TIM_GenerateEvent_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF882 0x0034      STRB     R0,[R2, #+52]
   3605          
   3606            /* Change the TIM state */
   3607            htim->State = HAL_TIM_STATE_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xF882 0x0035      STRB     R0,[R2, #+53]
   3608          
   3609            /* Set the event sources */
   3610            htim->Instance->EGR = EventSource;
   \   0000001A   0x6810             LDR      R0,[R2, #+0]
   \   0000001C   0x6141             STR      R1,[R0, #+20]
   3611          
   3612            /* Change the TIM state */
   3613            htim->State = HAL_TIM_STATE_READY;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xF882 0x0035      STRB     R0,[R2, #+53]
   3614          
   3615            __HAL_UNLOCK(htim);
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xF882 0x0034      STRB     R0,[R2, #+52]
   3616          
   3617            /* Return function status */
   3618            return HAL_OK;
   \   0000002A   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_GenerateEvent_1: (+1)
   \   0000002C   0x4770             BX       LR               ;; return
   3619          }
   3620          
   3621          /**
   3622            * @brief  Configures the OCRef clear feature
   3623            * @param  htim: TIM handle
   3624            * @param  sClearInputConfig: pointer to a TIM_ClearInputConfigTypeDef structure that
   3625            *         contains the OCREF clear feature and parameters for the TIM peripheral.
   3626            * @param  Channel: specifies the TIM Channel
   3627            *          This parameter can be one of the following values:
   3628            *            @arg TIM_CHANNEL_1: TIM Channel 1
   3629            *            @arg TIM_CHANNEL_2: TIM Channel 2
   3630            *            @arg TIM_CHANNEL_3: TIM Channel 3
   3631            *            @arg TIM_CHANNEL_4: TIM Channel 4
   3632            * @retval HAL status
   3633            */

   \                                 In section .text, align 2, keep-with-next
   3634          HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim, TIM_ClearInputConfigTypeDef * sClearInputConfig, uint32_t Channel)
   3635          {
   \                     HAL_TIM_ConfigOCrefClear: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   3636          
   3637            /* Check the parameters */
   3638            assert_param(IS_TIM_OCXREF_CLEAR_INSTANCE(htim->Instance));
   3639            assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
   3640            assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
   3641            assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
   3642            assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
   3643          
   3644            /* Process Locked */
   3645            __HAL_LOCK(htim);
   \   00000008   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_TIM_ConfigOCrefClear_0
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE082             B.N      ??HAL_TIM_ConfigOCrefClear_1
   \                     ??HAL_TIM_ConfigOCrefClear_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF884 0x0034      STRB     R0,[R4, #+52]
   3646          
   3647            htim->State = HAL_TIM_STATE_BUSY;
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xF884 0x0035      STRB     R0,[R4, #+53]
   3648          
   3649            switch (sClearInputConfig->ClearInputSource)
   \   00000020   0x6868             LDR      R0,[R5, #+4]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD003             BEQ.N    ??HAL_TIM_ConfigOCrefClear_2
   \   00000026   0x2802             CMP      R0,#+2
   \   00000028   0xD00E             BEQ.N    ??HAL_TIM_ConfigOCrefClear_3
   \   0000002A   0xD314             BCC.N    ??HAL_TIM_ConfigOCrefClear_4
   \   0000002C   0xE020             B.N      ??HAL_TIM_ConfigOCrefClear_5
   3650            {
   3651              case TIM_CLEARINPUTSOURCE_NONE:
   3652              {
   3653                /* Clear the OCREF clear selection bit */
   3654                CLEAR_BIT(htim->Instance->SMCR, TIM_SMCR_OCCS);
   \                     ??HAL_TIM_ConfigOCrefClear_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x6880             LDR      R0,[R0, #+8]
   \   00000032   0xF030 0x0008      BICS     R0,R0,#0x8
   \   00000036   0x6821             LDR      R1,[R4, #+0]
   \   00000038   0x6088             STR      R0,[R1, #+8]
   3655          
   3656                /* Clear the ETR Bits */
   3657                CLEAR_BIT(htim->Instance->SMCR, (TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP));
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6880             LDR      R0,[R0, #+8]
   \   0000003E   0xF430 0x407F      BICS     R0,R0,#0xFF00
   \   00000042   0x6821             LDR      R1,[R4, #+0]
   \   00000044   0x6088             STR      R0,[R1, #+8]
   3658          
   3659              }
   3660              break;
   \   00000046   0xE013             B.N      ??HAL_TIM_ConfigOCrefClear_6
   3661          
   3662              case TIM_CLEARINPUTSOURCE_OCREFCLR:
   3663              {
   3664                /* Clear the OCREF clear selection bit */
   3665                CLEAR_BIT(htim->Instance->SMCR, TIM_SMCR_OCCS);
   \                     ??HAL_TIM_ConfigOCrefClear_3: (+1)
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x6880             LDR      R0,[R0, #+8]
   \   0000004C   0xF030 0x0008      BICS     R0,R0,#0x8
   \   00000050   0x6821             LDR      R1,[R4, #+0]
   \   00000052   0x6088             STR      R0,[R1, #+8]
   3666              }
   3667              break;
   \   00000054   0xE00C             B.N      ??HAL_TIM_ConfigOCrefClear_6
   3668              
   3669              case TIM_CLEARINPUTSOURCE_ETR:
   3670              {
   3671                TIM_ETR_SetConfig(htim->Instance,
   3672                                  sClearInputConfig->ClearInputPrescaler,
   3673                                  sClearInputConfig->ClearInputPolarity,
   3674                                  sClearInputConfig->ClearInputFilter);
   \                     ??HAL_TIM_ConfigOCrefClear_4: (+1)
   \   00000056   0x692B             LDR      R3,[R5, #+16]
   \   00000058   0x68AA             LDR      R2,[R5, #+8]
   \   0000005A   0x68E9             LDR      R1,[R5, #+12]
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x.... 0x....      BL       TIM_ETR_SetConfig
   3675          
   3676                /* Set the OCREF clear selection bit */
   3677                SET_BIT(htim->Instance->SMCR, TIM_SMCR_OCCS);
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x6880             LDR      R0,[R0, #+8]
   \   00000066   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000006A   0x6821             LDR      R1,[R4, #+0]
   \   0000006C   0x6088             STR      R0,[R1, #+8]
   3678              }
   3679              break;
   \   0000006E   0xE7FF             B.N      ??HAL_TIM_ConfigOCrefClear_6
   3680          
   3681            default:
   3682              break;
   3683          
   3684            }
   3685          
   3686            switch (Channel)
   \                     ??HAL_TIM_ConfigOCrefClear_5: (+1)
   \                     ??HAL_TIM_ConfigOCrefClear_6: (+1)
   \   00000070   0x0030             MOVS     R0,R6
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD006             BEQ.N    ??HAL_TIM_ConfigOCrefClear_7
   \   00000076   0x2804             CMP      R0,#+4
   \   00000078   0xD015             BEQ.N    ??HAL_TIM_ConfigOCrefClear_8
   \   0000007A   0x2808             CMP      R0,#+8
   \   0000007C   0xD024             BEQ.N    ??HAL_TIM_ConfigOCrefClear_9
   \   0000007E   0x280C             CMP      R0,#+12
   \   00000080   0xD033             BEQ.N    ??HAL_TIM_ConfigOCrefClear_10
   \   00000082   0xE043             B.N      ??HAL_TIM_ConfigOCrefClear_11
   3687            {
   3688              case TIM_CHANNEL_1:
   3689                {
   3690                  if(sClearInputConfig->ClearInputState != RESET)
   \                     ??HAL_TIM_ConfigOCrefClear_7: (+1)
   \   00000084   0x6828             LDR      R0,[R5, #+0]
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD006             BEQ.N    ??HAL_TIM_ConfigOCrefClear_12
   3691                  {
   3692                    /* Enable the Ocref clear feature for Channel 1 */
   3693                    htim->Instance->CCMR1 |= TIM_CCMR1_OC1CE;
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x6980             LDR      R0,[R0, #+24]
   \   0000008E   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000092   0x6821             LDR      R1,[R4, #+0]
   \   00000094   0x6188             STR      R0,[R1, #+24]
   \   00000096   0xE005             B.N      ??HAL_TIM_ConfigOCrefClear_13
   3694                  }
   3695                  else
   3696                  {
   3697                    /* Disable the Ocref clear feature for Channel 1 */
   3698                    htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1CE;
   \                     ??HAL_TIM_ConfigOCrefClear_12: (+1)
   \   00000098   0x6820             LDR      R0,[R4, #+0]
   \   0000009A   0x6980             LDR      R0,[R0, #+24]
   \   0000009C   0xF030 0x0080      BICS     R0,R0,#0x80
   \   000000A0   0x6821             LDR      R1,[R4, #+0]
   \   000000A2   0x6188             STR      R0,[R1, #+24]
   3699                  }
   3700                }
   3701                break;
   \                     ??HAL_TIM_ConfigOCrefClear_13: (+1)
   \   000000A4   0xE032             B.N      ??HAL_TIM_ConfigOCrefClear_14
   3702              case TIM_CHANNEL_2:
   3703                {
   3704                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3705                  if(sClearInputConfig->ClearInputState != RESET)
   \                     ??HAL_TIM_ConfigOCrefClear_8: (+1)
   \   000000A6   0x6828             LDR      R0,[R5, #+0]
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD006             BEQ.N    ??HAL_TIM_ConfigOCrefClear_15
   3706                  {
   3707                    /* Enable the Ocref clear feature for Channel 2 */
   3708                    htim->Instance->CCMR1 |= TIM_CCMR1_OC2CE;
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0x6980             LDR      R0,[R0, #+24]
   \   000000B0   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   000000B4   0x6821             LDR      R1,[R4, #+0]
   \   000000B6   0x6188             STR      R0,[R1, #+24]
   \   000000B8   0xE005             B.N      ??HAL_TIM_ConfigOCrefClear_16
   3709                  }
   3710                  else
   3711                  {
   3712                    /* Disable the Ocref clear feature for Channel 2 */
   3713                    htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2CE;
   \                     ??HAL_TIM_ConfigOCrefClear_15: (+1)
   \   000000BA   0x6820             LDR      R0,[R4, #+0]
   \   000000BC   0x6980             LDR      R0,[R0, #+24]
   \   000000BE   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   000000C2   0x6821             LDR      R1,[R4, #+0]
   \   000000C4   0x6188             STR      R0,[R1, #+24]
   3714                  }
   3715                }
   3716              break;
   \                     ??HAL_TIM_ConfigOCrefClear_16: (+1)
   \   000000C6   0xE021             B.N      ??HAL_TIM_ConfigOCrefClear_14
   3717              case TIM_CHANNEL_3:
   3718                {
   3719                  assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3720                  if(sClearInputConfig->ClearInputState != RESET)
   \                     ??HAL_TIM_ConfigOCrefClear_9: (+1)
   \   000000C8   0x6828             LDR      R0,[R5, #+0]
   \   000000CA   0x2800             CMP      R0,#+0
   \   000000CC   0xD006             BEQ.N    ??HAL_TIM_ConfigOCrefClear_17
   3721                  {
   3722                    /* Enable the Ocref clear feature for Channel 3 */
   3723                    htim->Instance->CCMR2 |= TIM_CCMR2_OC3CE;
   \   000000CE   0x6820             LDR      R0,[R4, #+0]
   \   000000D0   0x69C0             LDR      R0,[R0, #+28]
   \   000000D2   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000D6   0x6821             LDR      R1,[R4, #+0]
   \   000000D8   0x61C8             STR      R0,[R1, #+28]
   \   000000DA   0xE005             B.N      ??HAL_TIM_ConfigOCrefClear_18
   3724                  }
   3725                  else
   3726                  {
   3727                    /* Disable the Ocref clear feature for Channel 3 */
   3728                    htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3CE;
   \                     ??HAL_TIM_ConfigOCrefClear_17: (+1)
   \   000000DC   0x6820             LDR      R0,[R4, #+0]
   \   000000DE   0x69C0             LDR      R0,[R0, #+28]
   \   000000E0   0xF030 0x0080      BICS     R0,R0,#0x80
   \   000000E4   0x6821             LDR      R1,[R4, #+0]
   \   000000E6   0x61C8             STR      R0,[R1, #+28]
   3729                  }
   3730                }
   3731              break;
   \                     ??HAL_TIM_ConfigOCrefClear_18: (+1)
   \   000000E8   0xE010             B.N      ??HAL_TIM_ConfigOCrefClear_14
   3732              case TIM_CHANNEL_4:
   3733                {
   3734                  assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3735                  if(sClearInputConfig->ClearInputState != RESET)
   \                     ??HAL_TIM_ConfigOCrefClear_10: (+1)
   \   000000EA   0x6828             LDR      R0,[R5, #+0]
   \   000000EC   0x2800             CMP      R0,#+0
   \   000000EE   0xD006             BEQ.N    ??HAL_TIM_ConfigOCrefClear_19
   3736                  {
   3737                    /* Enable the Ocref clear feature for Channel 4 */
   3738                    htim->Instance->CCMR2 |= TIM_CCMR2_OC4CE;
   \   000000F0   0x6820             LDR      R0,[R4, #+0]
   \   000000F2   0x69C0             LDR      R0,[R0, #+28]
   \   000000F4   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   000000F8   0x6821             LDR      R1,[R4, #+0]
   \   000000FA   0x61C8             STR      R0,[R1, #+28]
   \   000000FC   0xE005             B.N      ??HAL_TIM_ConfigOCrefClear_20
   3739                  }
   3740                  else
   3741                  {
   3742                    /* Disable the Ocref clear feature for Channel 4 */
   3743                    htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4CE;
   \                     ??HAL_TIM_ConfigOCrefClear_19: (+1)
   \   000000FE   0x6820             LDR      R0,[R4, #+0]
   \   00000100   0x69C0             LDR      R0,[R0, #+28]
   \   00000102   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   00000106   0x6821             LDR      R1,[R4, #+0]
   \   00000108   0x61C8             STR      R0,[R1, #+28]
   3744                  }
   3745                }
   3746              break;
   \                     ??HAL_TIM_ConfigOCrefClear_20: (+1)
   \   0000010A   0xE7FF             B.N      ??HAL_TIM_ConfigOCrefClear_14
   3747              default:
   3748              break;
   3749            }
   3750          
   3751            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_ConfigOCrefClear_11: (+1)
   \                     ??HAL_TIM_ConfigOCrefClear_14: (+1)
   \   0000010C   0x2001             MOVS     R0,#+1
   \   0000010E   0xF884 0x0035      STRB     R0,[R4, #+53]
   3752          
   3753            __HAL_UNLOCK(htim);
   \   00000112   0x2000             MOVS     R0,#+0
   \   00000114   0xF884 0x0034      STRB     R0,[R4, #+52]
   3754          
   3755            return HAL_OK;
   \   00000118   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_ConfigOCrefClear_1: (+1)
   \   0000011A   0xBD70             POP      {R4-R6,PC}       ;; return
   3756          }
   3757          
   3758          /**
   3759            * @brief   Configures the clock source to be used
   3760            * @param  htim: TIM handle
   3761            * @param  sClockSourceConfig: pointer to a TIM_ClockConfigTypeDef structure that
   3762            *         contains the clock source information for the TIM peripheral.
   3763            * @retval HAL status
   3764            */

   \                                 In section .text, align 2, keep-with-next
   3765          HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)
   3766          {
   \                     HAL_TIM_ConfigClockSource: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   3767            uint32_t tmpsmcr = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   3768          
   3769            /* Process Locked */
   3770            __HAL_LOCK(htim);
   \   00000008   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_TIM_ConfigClockSource_0
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE083             B.N      ??HAL_TIM_ConfigClockSource_1
   \                     ??HAL_TIM_ConfigClockSource_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF884 0x0034      STRB     R0,[R4, #+52]
   3771          
   3772            htim->State = HAL_TIM_STATE_BUSY;
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xF884 0x0035      STRB     R0,[R4, #+53]
   3773          
   3774            /* Check the parameters */
   3775            assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
   3776            assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   3777            assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   3778            assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   3779          
   3780            /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
   3781            tmpsmcr = htim->Instance->SMCR;
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x6880             LDR      R0,[R0, #+8]
   \   00000024   0x0006             MOVS     R6,R0
   3782            tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
   \   00000026   0xF036 0x0677      BICS     R6,R6,#0x77
   3783            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   \   0000002A   0xF436 0x467F      BICS     R6,R6,#0xFF00
   3784            htim->Instance->SMCR = tmpsmcr;
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x6086             STR      R6,[R0, #+8]
   3785          
   3786            switch (sClockSourceConfig->ClockSource)
   \   00000032   0x6828             LDR      R0,[R5, #+0]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD056             BEQ.N    ??HAL_TIM_ConfigClockSource_2
   \   00000038   0x2810             CMP      R0,#+16
   \   0000003A   0xD059             BEQ.N    ??HAL_TIM_ConfigClockSource_3
   \   0000003C   0x2820             CMP      R0,#+32
   \   0000003E   0xD05C             BEQ.N    ??HAL_TIM_ConfigClockSource_4
   \   00000040   0x2830             CMP      R0,#+48
   \   00000042   0xD05F             BEQ.N    ??HAL_TIM_ConfigClockSource_5
   \   00000044   0x2840             CMP      R0,#+64
   \   00000046   0xD044             BEQ.N    ??HAL_TIM_ConfigClockSource_6
   \   00000048   0x2850             CMP      R0,#+80
   \   0000004A   0xD02E             BEQ.N    ??HAL_TIM_ConfigClockSource_7
   \   0000004C   0x2860             CMP      R0,#+96
   \   0000004E   0xD036             BEQ.N    ??HAL_TIM_ConfigClockSource_8
   \   00000050   0x2870             CMP      R0,#+112
   \   00000052   0xD00D             BEQ.N    ??HAL_TIM_ConfigClockSource_9
   \   00000054   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000058   0xD003             BEQ.N    ??HAL_TIM_ConfigClockSource_10
   \   0000005A   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000005E   0xD017             BEQ.N    ??HAL_TIM_ConfigClockSource_11
   \   00000060   0xE055             B.N      ??HAL_TIM_ConfigClockSource_12
   3787            {
   3788            case TIM_CLOCKSOURCE_INTERNAL:
   3789              {
   3790                assert_param(IS_TIM_INSTANCE(htim->Instance));
   3791                /* Disable slave mode to clock the prescaler directly with the internal clock */
   3792                htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \                     ??HAL_TIM_ConfigClockSource_10: (+1)
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x6880             LDR      R0,[R0, #+8]
   \   00000066   0x08C0             LSRS     R0,R0,#+3
   \   00000068   0x00C0             LSLS     R0,R0,#+3
   \   0000006A   0x6821             LDR      R1,[R4, #+0]
   \   0000006C   0x6088             STR      R0,[R1, #+8]
   3793              }
   3794              break;
   \   0000006E   0xE04E             B.N      ??HAL_TIM_ConfigClockSource_13
   3795          
   3796            case TIM_CLOCKSOURCE_ETRMODE1:
   3797              {
   3798                /* Check whether or not the timer instance supports external trigger input mode 1 (ETRF)*/
   3799                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
   3800          
   3801                /* Configure the ETR Clock source */
   3802                TIM_ETR_SetConfig(htim->Instance,
   3803                                  sClockSourceConfig->ClockPrescaler,
   3804                                  sClockSourceConfig->ClockPolarity,
   3805                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_9: (+1)
   \   00000070   0x68EB             LDR      R3,[R5, #+12]
   \   00000072   0x686A             LDR      R2,[R5, #+4]
   \   00000074   0x68A9             LDR      R1,[R5, #+8]
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x.... 0x....      BL       TIM_ETR_SetConfig
   3806                /* Get the TIMx SMCR register value */
   3807                tmpsmcr = htim->Instance->SMCR;
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x6880             LDR      R0,[R0, #+8]
   \   00000080   0x0006             MOVS     R6,R0
   3808                /* Reset the SMS and TS Bits */
   3809                tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
   \   00000082   0xF036 0x0677      BICS     R6,R6,#0x77
   3810                /* Select the External clock mode1 and the ETRF trigger */
   3811                tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
   \   00000086   0xF056 0x0677      ORRS     R6,R6,#0x77
   3812                /* Write to TIMx SMCR */
   3813                htim->Instance->SMCR = tmpsmcr;
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x6086             STR      R6,[R0, #+8]
   3814              }
   3815              break;
   \   0000008E   0xE03E             B.N      ??HAL_TIM_ConfigClockSource_13
   3816          
   3817            case TIM_CLOCKSOURCE_ETRMODE2:
   3818              {
   3819                /* Check whether or not the timer instance supports external trigger input mode 2 (ETRF)*/
   3820                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
   3821          
   3822                /* Configure the ETR Clock source */
   3823                TIM_ETR_SetConfig(htim->Instance,
   3824                                  sClockSourceConfig->ClockPrescaler,
   3825                                  sClockSourceConfig->ClockPolarity,
   3826                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_11: (+1)
   \   00000090   0x68EB             LDR      R3,[R5, #+12]
   \   00000092   0x686A             LDR      R2,[R5, #+4]
   \   00000094   0x68A9             LDR      R1,[R5, #+8]
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0x.... 0x....      BL       TIM_ETR_SetConfig
   3827                /* Enable the External clock mode2 */
   3828                htim->Instance->SMCR |= TIM_SMCR_ECE;
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0x6880             LDR      R0,[R0, #+8]
   \   000000A0   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   000000A4   0x6821             LDR      R1,[R4, #+0]
   \   000000A6   0x6088             STR      R0,[R1, #+8]
   3829              }
   3830              break;
   \   000000A8   0xE031             B.N      ??HAL_TIM_ConfigClockSource_13
   3831          
   3832            case TIM_CLOCKSOURCE_TI1:
   3833              {
   3834                /* Check whether or not the timer instance supports external clock mode 1 */
   3835                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   3836          
   3837                TIM_TI1_ConfigInputStage(htim->Instance,
   3838                                         sClockSourceConfig->ClockPolarity,
   3839                                         sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_7: (+1)
   \   000000AA   0x68EA             LDR      R2,[R5, #+12]
   \   000000AC   0x6869             LDR      R1,[R5, #+4]
   \   000000AE   0x6820             LDR      R0,[R4, #+0]
   \   000000B0   0x.... 0x....      BL       TIM_TI1_ConfigInputStage
   3840                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
   \   000000B4   0x2150             MOVS     R1,#+80
   \   000000B6   0x6820             LDR      R0,[R4, #+0]
   \   000000B8   0x.... 0x....      BL       TIM_ITRx_SetConfig
   3841              }
   3842              break;
   \   000000BC   0xE027             B.N      ??HAL_TIM_ConfigClockSource_13
   3843            case TIM_CLOCKSOURCE_TI2:
   3844              {
   3845                /* Check whether or not the timer instance supports external clock mode 1 (ETRF)*/
   3846                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   3847          
   3848                TIM_TI2_ConfigInputStage(htim->Instance,
   3849                                         sClockSourceConfig->ClockPolarity,
   3850                                         sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_8: (+1)
   \   000000BE   0x68EA             LDR      R2,[R5, #+12]
   \   000000C0   0x6869             LDR      R1,[R5, #+4]
   \   000000C2   0x6820             LDR      R0,[R4, #+0]
   \   000000C4   0x.... 0x....      BL       TIM_TI2_ConfigInputStage
   3851                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
   \   000000C8   0x2160             MOVS     R1,#+96
   \   000000CA   0x6820             LDR      R0,[R4, #+0]
   \   000000CC   0x.... 0x....      BL       TIM_ITRx_SetConfig
   3852              }
   3853              break;
   \   000000D0   0xE01D             B.N      ??HAL_TIM_ConfigClockSource_13
   3854            case TIM_CLOCKSOURCE_TI1ED:
   3855              {
   3856                /* Check whether or not the timer instance supports external clock mode 1 */
   3857                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   3858          
   3859                TIM_TI1_ConfigInputStage(htim->Instance,
   3860                                         sClockSourceConfig->ClockPolarity,
   3861                                         sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_6: (+1)
   \   000000D2   0x68EA             LDR      R2,[R5, #+12]
   \   000000D4   0x6869             LDR      R1,[R5, #+4]
   \   000000D6   0x6820             LDR      R0,[R4, #+0]
   \   000000D8   0x.... 0x....      BL       TIM_TI1_ConfigInputStage
   3862                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
   \   000000DC   0x2140             MOVS     R1,#+64
   \   000000DE   0x6820             LDR      R0,[R4, #+0]
   \   000000E0   0x.... 0x....      BL       TIM_ITRx_SetConfig
   3863              }
   3864              break;
   \   000000E4   0xE013             B.N      ??HAL_TIM_ConfigClockSource_13
   3865            case TIM_CLOCKSOURCE_ITR0:
   3866              {
   3867                /* Check whether or not the timer instance supports external clock mode 1 */
   3868                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   3869          
   3870                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR0);
   \                     ??HAL_TIM_ConfigClockSource_2: (+1)
   \   000000E6   0x2100             MOVS     R1,#+0
   \   000000E8   0x6820             LDR      R0,[R4, #+0]
   \   000000EA   0x.... 0x....      BL       TIM_ITRx_SetConfig
   3871              }
   3872              break;
   \   000000EE   0xE00E             B.N      ??HAL_TIM_ConfigClockSource_13
   3873            case TIM_CLOCKSOURCE_ITR1:
   3874              {
   3875                /* Check whether or not the timer instance supports external clock mode 1 */
   3876                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   3877          
   3878                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR1);
   \                     ??HAL_TIM_ConfigClockSource_3: (+1)
   \   000000F0   0x2110             MOVS     R1,#+16
   \   000000F2   0x6820             LDR      R0,[R4, #+0]
   \   000000F4   0x.... 0x....      BL       TIM_ITRx_SetConfig
   3879              }
   3880              break;
   \   000000F8   0xE009             B.N      ??HAL_TIM_ConfigClockSource_13
   3881            case TIM_CLOCKSOURCE_ITR2:
   3882              {
   3883                /* Check whether or not the timer instance supports external clock mode 1 */
   3884                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   3885          
   3886                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR2);
   \                     ??HAL_TIM_ConfigClockSource_4: (+1)
   \   000000FA   0x2120             MOVS     R1,#+32
   \   000000FC   0x6820             LDR      R0,[R4, #+0]
   \   000000FE   0x.... 0x....      BL       TIM_ITRx_SetConfig
   3887              }
   3888              break;
   \   00000102   0xE004             B.N      ??HAL_TIM_ConfigClockSource_13
   3889            case TIM_CLOCKSOURCE_ITR3:
   3890              {
   3891                /* Check whether or not the timer instance supports external clock mode 1 */
   3892                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   3893          
   3894                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR3);
   \                     ??HAL_TIM_ConfigClockSource_5: (+1)
   \   00000104   0x2130             MOVS     R1,#+48
   \   00000106   0x6820             LDR      R0,[R4, #+0]
   \   00000108   0x.... 0x....      BL       TIM_ITRx_SetConfig
   3895              }
   3896              break;
   \   0000010C   0xE7FF             B.N      ??HAL_TIM_ConfigClockSource_13
   3897          
   3898            default:
   3899              break;
   3900            }
   3901            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_ConfigClockSource_12: (+1)
   \                     ??HAL_TIM_ConfigClockSource_13: (+1)
   \   0000010E   0x2001             MOVS     R0,#+1
   \   00000110   0xF884 0x0035      STRB     R0,[R4, #+53]
   3902          
   3903            __HAL_UNLOCK(htim);
   \   00000114   0x2000             MOVS     R0,#+0
   \   00000116   0xF884 0x0034      STRB     R0,[R4, #+52]
   3904          
   3905            return HAL_OK;
   \   0000011A   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_ConfigClockSource_1: (+1)
   \   0000011C   0xBD70             POP      {R4-R6,PC}       ;; return
   3906          }
   3907          
   3908          /**
   3909            * @brief  Selects the signal connected to the TI1 input: direct from CH1_input
   3910            *         or a XOR combination between CH1_input, CH2_input & CH3_input
   3911            * @param  htim: TIM handle.
   3912            * @param  TI1_Selection: Indicate whether or not channel 1 is connected to the
   3913            *         output of a XOR gate.
   3914            *          This parameter can be one of the following values:
   3915            *            @arg TIM_TI1SELECTION_CH1: The TIMx_CH1 pin is connected to TI1 input
   3916            *            @arg TIM_TI1SELECTION_XORCOMBINATION: The TIMx_CH1, CH2 and CH3
   3917            *            pins are connected to the TI1 input (XOR combination)
   3918            * @retval HAL status
   3919            */

   \                                 In section .text, align 2, keep-with-next
   3920          HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
   3921          {
   \                     HAL_TIM_ConfigTI1Input: (+1)
   \   00000000   0x0002             MOVS     R2,R0
   3922            uint32_t tmpcr2 = 0;
   \   00000002   0x2300             MOVS     R3,#+0
   3923          
   3924            /* Check the parameters */
   3925            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
   3926            assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
   3927          
   3928            /* Get the TIMx CR2 register value */
   3929            tmpcr2 = htim->Instance->CR2;
   \   00000004   0x6810             LDR      R0,[R2, #+0]
   \   00000006   0x6840             LDR      R0,[R0, #+4]
   \   00000008   0x0003             MOVS     R3,R0
   3930          
   3931            /* Reset the TI1 selection */
   3932            tmpcr2 &= ~TIM_CR2_TI1S;
   \   0000000A   0xF033 0x0380      BICS     R3,R3,#0x80
   3933          
   3934            /* Set the the TI1 selection */
   3935            tmpcr2 |= TI1_Selection;
   \   0000000E   0x430B             ORRS     R3,R1,R3
   3936          
   3937            /* Write to TIMxCR2 */
   3938            htim->Instance->CR2 = tmpcr2;
   \   00000010   0x6810             LDR      R0,[R2, #+0]
   \   00000012   0x6043             STR      R3,[R0, #+4]
   3939          
   3940            return HAL_OK;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x4770             BX       LR               ;; return
   3941          }
   3942          
   3943          /**
   3944            * @brief  Configures the TIM in Slave mode
   3945            * @param  htim : TIM handle.
   3946            * @param  sSlaveConfig: pointer to a TIM_SlaveConfigTypeDef structure that
   3947            *         contains the selected trigger (internal trigger input, filtered
   3948            *         timer input or external trigger input) and the ) and the Slave 
   3949            *         mode (Disable, Reset, Gated, Trigger, External clock mode 1). 
   3950            * @retval HAL status
   3951            */

   \                                 In section .text, align 2, keep-with-next
   3952          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef * sSlaveConfig)
   3953          {
   \                     HAL_TIM_SlaveConfigSynchronization: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   3954            /* Check the parameters */
   3955            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   3956            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   3957            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   3958             
   3959            __HAL_LOCK(htim);
   \   00000006   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_TIM_SlaveConfigSynchronization_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE01C             B.N      ??HAL_TIM_SlaveConfigSynchronization_1
   \                     ??HAL_TIM_SlaveConfigSynchronization_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF884 0x0034      STRB     R0,[R4, #+52]
   3960            
   3961            htim->State = HAL_TIM_STATE_BUSY;
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0xF884 0x0035      STRB     R0,[R4, #+53]
   3962          
   3963            TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
   \   0000001E   0x0029             MOVS     R1,R5
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       TIM_SlaveTimer_SetConfig
   3964            
   3965            /* Disable Trigger Interrupt */
   3966            __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x68C0             LDR      R0,[R0, #+12]
   \   0000002A   0xF030 0x0040      BICS     R0,R0,#0x40
   \   0000002E   0x6821             LDR      R1,[R4, #+0]
   \   00000030   0x60C8             STR      R0,[R1, #+12]
   3967            
   3968            /* Disable Trigger DMA request */
   3969            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x68C0             LDR      R0,[R0, #+12]
   \   00000036   0xF430 0x4080      BICS     R0,R0,#0x4000
   \   0000003A   0x6821             LDR      R1,[R4, #+0]
   \   0000003C   0x60C8             STR      R0,[R1, #+12]
   3970            
   3971            htim->State = HAL_TIM_STATE_READY;
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0xF884 0x0035      STRB     R0,[R4, #+53]
   3972               
   3973            __HAL_UNLOCK(htim);  
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF884 0x0034      STRB     R0,[R4, #+52]
   3974            
   3975            return HAL_OK;
   \   0000004A   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_SlaveConfigSynchronization_1: (+1)
   \   0000004C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   3976          } 
   3977          
   3978          /**
   3979            * @brief  Configures the TIM in Slave mode in interrupt mode
   3980            * @param  htim: TIM handle.
   3981            * @param  sSlaveConfig: pointer to a TIM_SlaveConfigTypeDef structure that
   3982            *         contains the selected trigger (internal trigger input, filtered
   3983            *         timer input or external trigger input) and the ) and the Slave 
   3984            *         mode (Disable, Reset, Gated, Trigger, External clock mode 1). 
   3985            * @retval HAL status
   3986            */

   \                                 In section .text, align 2, keep-with-next
   3987          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization_IT(TIM_HandleTypeDef *htim, 
   3988                                                                  TIM_SlaveConfigTypeDef * sSlaveConfig)
   3989          {
   \                     HAL_TIM_SlaveConfigSynchronization_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   3990            /* Check the parameters */
   3991            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   3992            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   3993            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   3994            
   3995            __HAL_LOCK(htim);
   \   00000006   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_TIM_SlaveConfigSynchronization_IT_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE01C             B.N      ??HAL_TIM_SlaveConfigSynchronization_IT_1
   \                     ??HAL_TIM_SlaveConfigSynchronization_IT_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF884 0x0034      STRB     R0,[R4, #+52]
   3996          
   3997            htim->State = HAL_TIM_STATE_BUSY;
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0xF884 0x0035      STRB     R0,[R4, #+53]
   3998            
   3999            TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
   \   0000001E   0x0029             MOVS     R1,R5
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       TIM_SlaveTimer_SetConfig
   4000            
   4001            /* Enable Trigger Interrupt */
   4002            __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x68C0             LDR      R0,[R0, #+12]
   \   0000002A   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000002E   0x6821             LDR      R1,[R4, #+0]
   \   00000030   0x60C8             STR      R0,[R1, #+12]
   4003            
   4004            /* Disable Trigger DMA request */
   4005            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x68C0             LDR      R0,[R0, #+12]
   \   00000036   0xF430 0x4080      BICS     R0,R0,#0x4000
   \   0000003A   0x6821             LDR      R1,[R4, #+0]
   \   0000003C   0x60C8             STR      R0,[R1, #+12]
   4006            
   4007            htim->State = HAL_TIM_STATE_READY;
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0xF884 0x0035      STRB     R0,[R4, #+53]
   4008               
   4009            __HAL_UNLOCK(htim);  
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF884 0x0034      STRB     R0,[R4, #+52]
   4010            
   4011            return HAL_OK;
   \   0000004A   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_SlaveConfigSynchronization_IT_1: (+1)
   \   0000004C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   4012          }
   4013          
   4014          /**
   4015            * @brief  Read the captured value from Capture Compare unit
   4016            * @param  htim: TIM handle.
   4017            * @param  Channel : TIM Channels to be enabled
   4018            *          This parameter can be one of the following values:
   4019            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   4020            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   4021            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   4022            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   4023            * @retval Captured value
   4024            */

   \                                 In section .text, align 2, keep-with-next
   4025          uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
   4026          {
   \                     HAL_TIM_ReadCapturedValue: (+1)
   \   00000000   0x0002             MOVS     R2,R0
   4027            uint32_t tmpreg = 0;
   \   00000002   0x2300             MOVS     R3,#+0
   4028          
   4029            __HAL_LOCK(htim);
   \   00000004   0xF892 0x0034      LDRB     R0,[R2, #+52]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_TIM_ReadCapturedValue_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE020             B.N      ??HAL_TIM_ReadCapturedValue_1
   \                     ??HAL_TIM_ReadCapturedValue_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF882 0x0034      STRB     R0,[R2, #+52]
   4030          
   4031            switch (Channel)
   \   00000016   0x0008             MOVS     R0,R1
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD006             BEQ.N    ??HAL_TIM_ReadCapturedValue_2
   \   0000001C   0x2804             CMP      R0,#+4
   \   0000001E   0xD008             BEQ.N    ??HAL_TIM_ReadCapturedValue_3
   \   00000020   0x2808             CMP      R0,#+8
   \   00000022   0xD00A             BEQ.N    ??HAL_TIM_ReadCapturedValue_4
   \   00000024   0x280C             CMP      R0,#+12
   \   00000026   0xD00C             BEQ.N    ??HAL_TIM_ReadCapturedValue_5
   \   00000028   0xE00F             B.N      ??HAL_TIM_ReadCapturedValue_6
   4032            {
   4033            case TIM_CHANNEL_1:
   4034              {
   4035                /* Check the parameters */
   4036                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4037          
   4038                /* Return the capture 1 value */
   4039                tmpreg =  htim->Instance->CCR1;
   \                     ??HAL_TIM_ReadCapturedValue_2: (+1)
   \   0000002A   0x6810             LDR      R0,[R2, #+0]
   \   0000002C   0x6B40             LDR      R0,[R0, #+52]
   \   0000002E   0x0003             MOVS     R3,R0
   4040          
   4041                break;
   \   00000030   0xE00B             B.N      ??HAL_TIM_ReadCapturedValue_7
   4042              }
   4043            case TIM_CHANNEL_2:
   4044              {
   4045                /* Check the parameters */
   4046                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4047          
   4048                /* Return the capture 2 value */
   4049                tmpreg =   htim->Instance->CCR2;
   \                     ??HAL_TIM_ReadCapturedValue_3: (+1)
   \   00000032   0x6810             LDR      R0,[R2, #+0]
   \   00000034   0x6B80             LDR      R0,[R0, #+56]
   \   00000036   0x0003             MOVS     R3,R0
   4050          
   4051                break;
   \   00000038   0xE007             B.N      ??HAL_TIM_ReadCapturedValue_7
   4052              }
   4053          
   4054            case TIM_CHANNEL_3:
   4055              {
   4056                /* Check the parameters */
   4057                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   4058          
   4059                /* Return the capture 3 value */
   4060                tmpreg =   htim->Instance->CCR3;
   \                     ??HAL_TIM_ReadCapturedValue_4: (+1)
   \   0000003A   0x6810             LDR      R0,[R2, #+0]
   \   0000003C   0x6BC0             LDR      R0,[R0, #+60]
   \   0000003E   0x0003             MOVS     R3,R0
   4061          
   4062                break;
   \   00000040   0xE003             B.N      ??HAL_TIM_ReadCapturedValue_7
   4063              }
   4064          
   4065            case TIM_CHANNEL_4:
   4066              {
   4067                /* Check the parameters */
   4068                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   4069          
   4070                /* Return the capture 4 value */
   4071                tmpreg =   htim->Instance->CCR4;
   \                     ??HAL_TIM_ReadCapturedValue_5: (+1)
   \   00000042   0x6810             LDR      R0,[R2, #+0]
   \   00000044   0x6C00             LDR      R0,[R0, #+64]
   \   00000046   0x0003             MOVS     R3,R0
   4072          
   4073                break;
   \   00000048   0xE7FF             B.N      ??HAL_TIM_ReadCapturedValue_7
   4074              }
   4075          
   4076            default:
   4077              break;
   4078            }
   4079          
   4080            __HAL_UNLOCK(htim);
   \                     ??HAL_TIM_ReadCapturedValue_6: (+1)
   \                     ??HAL_TIM_ReadCapturedValue_7: (+1)
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xF882 0x0034      STRB     R0,[R2, #+52]
   4081            return tmpreg;
   \   00000050   0x0018             MOVS     R0,R3
   \                     ??HAL_TIM_ReadCapturedValue_1: (+1)
   \   00000052   0x4770             BX       LR               ;; return
   4082          }
   4083          
   4084          /**
   4085            * @}
   4086            */
   4087          
   4088          /** @defgroup TIM_Exported_Functions_Group9 TIM Callbacks functions
   4089           *  @brief    TIM Callbacks functions
   4090           *
   4091          @verbatim
   4092            ==============================================================================
   4093                                  ##### TIM Callbacks functions #####
   4094            ==============================================================================
   4095           [..]
   4096             This section provides TIM callback functions:
   4097             (+) Timer Period elapsed callback
   4098             (+) Timer Output Compare callback
   4099             (+) Timer Input capture callback
   4100             (+) Timer Trigger callback
   4101             (+) Timer Error callback
   4102          
   4103          @endverbatim
   4104            * @{
   4105            */
   4106          
   4107          /**
   4108            * @brief  Period elapsed callback in non blocking mode
   4109            * @param  htim : TIM handle
   4110            * @retval None
   4111            */

   \                                 In section .text, align 2
   4112          __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
   4113          {
   4114            /* NOTE : This function Should not be modified, when the callback is needed,
   4115                      the __HAL_TIM_PeriodElapsedCallback could be implemented in the user file
   4116             */
   4117          
   4118          }
   \                     HAL_TIM_PeriodElapsedCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4119          /**
   4120            * @brief  Output Compare callback in non blocking mode
   4121            * @param  htim : TIM OC handle
   4122            * @retval None
   4123            */

   \                                 In section .text, align 2
   4124          __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
   4125          {
   4126            /* NOTE : This function Should not be modified, when the callback is needed,
   4127                      the __HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   4128             */
   4129          }
   \                     HAL_TIM_OC_DelayElapsedCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4130          /**
   4131            * @brief  Input Capture callback in non blocking mode
   4132            * @param  htim : TIM IC handle
   4133            * @retval None
   4134            */

   \                                 In section .text, align 2
   4135          __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
   4136          {
   4137            /* NOTE : This function Should not be modified, when the callback is needed,
   4138                      the __HAL_TIM_IC_CaptureCallback could be implemented in the user file
   4139             */
   4140          }
   \                     HAL_TIM_IC_CaptureCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4141          
   4142          /**
   4143            * @brief  PWM Pulse finished callback in non blocking mode
   4144            * @param  htim : TIM handle
   4145            * @retval None
   4146            */

   \                                 In section .text, align 2
   4147          __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
   4148          {
   4149            /* NOTE : This function Should not be modified, when the callback is needed,
   4150                      the __HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   4151             */
   4152          }
   \                     HAL_TIM_PWM_PulseFinishedCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4153          
   4154          /**
   4155            * @brief  Hall Trigger detection callback in non blocking mode
   4156            * @param  htim : TIM handle
   4157            * @retval None
   4158            */

   \                                 In section .text, align 2
   4159          __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
   4160          {
   4161            /* NOTE : This function Should not be modified, when the callback is needed,
   4162                      the HAL_TIM_TriggerCallback could be implemented in the user file
   4163             */
   4164          }
   \                     HAL_TIM_TriggerCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4165          
   4166          /**
   4167            * @brief  Timer error callback in non blocking mode
   4168            * @param  htim : TIM handle
   4169            * @retval None
   4170            */

   \                                 In section .text, align 2
   4171          __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
   4172          {
   4173            /* NOTE : This function Should not be modified, when the callback is needed,
   4174                      the HAL_TIM_ErrorCallback could be implemented in the user file
   4175             */
   4176          }
   \                     HAL_TIM_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4177          
   4178          /**
   4179            * @}
   4180            */
   4181          
   4182          /** @defgroup TIM_Exported_Functions_Group10 Peripheral State functions
   4183           *  @brief   Peripheral State functions
   4184           *
   4185          @verbatim
   4186            ==============================================================================
   4187                                  ##### Peripheral State functions #####
   4188            ==============================================================================
   4189              [..]
   4190              This subsection permit to get in run-time the status of the peripheral
   4191              and the data flow.
   4192          
   4193          @endverbatim
   4194            * @{
   4195            */
   4196          
   4197          /**
   4198            * @brief  Return the TIM Base state
   4199            * @param  htim: TIM Base handle
   4200            * @retval HAL state
   4201            */

   \                                 In section .text, align 2, keep-with-next
   4202          HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
   4203          {
   4204            return htim->State;
   \                     HAL_TIM_Base_GetState: (+1)
   \   00000000   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   00000004   0x4770             BX       LR               ;; return
   4205          }
   4206          
   4207          /**
   4208            * @brief  Return the TIM OC state
   4209            * @param  htim: TIM Ouput Compare handle
   4210            * @retval HAL state
   4211            */

   \                                 In section .text, align 2, keep-with-next
   4212          HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
   4213          {
   4214            return htim->State;
   \                     HAL_TIM_OC_GetState: (+1)
   \   00000000   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   00000004   0x4770             BX       LR               ;; return
   4215          }
   4216          
   4217          /**
   4218            * @brief  Return the TIM PWM state
   4219            * @param  htim: TIM handle
   4220            * @retval HAL state
   4221            */

   \                                 In section .text, align 2, keep-with-next
   4222          HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
   4223          {
   4224            return htim->State;
   \                     HAL_TIM_PWM_GetState: (+1)
   \   00000000   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   00000004   0x4770             BX       LR               ;; return
   4225          }
   4226          
   4227          /**
   4228            * @brief  Return the TIM Input Capture state
   4229            * @param  htim: TIM IC handle
   4230            * @retval HAL state
   4231            */

   \                                 In section .text, align 2, keep-with-next
   4232          HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
   4233          {
   4234            return htim->State;
   \                     HAL_TIM_IC_GetState: (+1)
   \   00000000   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   00000004   0x4770             BX       LR               ;; return
   4235          }
   4236          
   4237          /**
   4238            * @brief  Return the TIM One Pulse Mode state
   4239            * @param  htim: TIM OPM handle
   4240            * @retval HAL state
   4241            */

   \                                 In section .text, align 2, keep-with-next
   4242          HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
   4243          {
   4244            return htim->State;
   \                     HAL_TIM_OnePulse_GetState: (+1)
   \   00000000   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   00000004   0x4770             BX       LR               ;; return
   4245          }
   4246          
   4247          /**
   4248            * @brief  Return the TIM Encoder Mode state
   4249            * @param  htim: TIM Encoder handle
   4250            * @retval HAL state
   4251            */

   \                                 In section .text, align 2, keep-with-next
   4252          HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
   4253          {
   4254            return htim->State;
   \                     HAL_TIM_Encoder_GetState: (+1)
   \   00000000   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   00000004   0x4770             BX       LR               ;; return
   4255          }
   4256          
   4257          /**
   4258            * @brief  TIM DMA error callback
   4259            * @param  hdma : pointer to DMA handle.
   4260            * @retval None
   4261            */

   \                                 In section .text, align 4, keep-with-next
   4262          void TIM_DMAError(DMA_HandleTypeDef *hdma)
   4263          {
   \                     TIM_DMAError: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   4264            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   4265          
   4266            htim->State= HAL_TIM_STATE_READY;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xF885 0x0035      STRB     R0,[R5, #+53]
   4267          
   4268            HAL_TIM_ErrorCallback(htim);
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0x.... 0x....      BL       HAL_TIM_ErrorCallback
   4269          }
   \   00000012   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   4270          
   4271          /**
   4272            * @brief  TIM DMA Delay Pulse complete callback.
   4273            * @param  hdma : pointer to DMA handle.
   4274            * @retval None
   4275            */

   \                                 In section .text, align 4, keep-with-next
   4276          void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
   4277          {
   \                     TIM_DMADelayPulseCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   4278            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   4279          
   4280            htim->State= HAL_TIM_STATE_READY;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xF885 0x0035      STRB     R0,[R5, #+53]
   4281          
   4282            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   \   0000000C   0x69E8             LDR      R0,[R5, #+28]
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD102             BNE.N    ??TIM_DMADelayPulseCplt_0
   4283            {
   4284              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x7528             STRB     R0,[R5, #+20]
   \   00000016   0xE010             B.N      ??TIM_DMADelayPulseCplt_1
   4285            }
   4286            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   \                     ??TIM_DMADelayPulseCplt_0: (+1)
   \   00000018   0x6A28             LDR      R0,[R5, #+32]
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD102             BNE.N    ??TIM_DMADelayPulseCplt_2
   4287            {
   4288              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0x7528             STRB     R0,[R5, #+20]
   \   00000022   0xE00A             B.N      ??TIM_DMADelayPulseCplt_1
   4289            }
   4290            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   \                     ??TIM_DMADelayPulseCplt_2: (+1)
   \   00000024   0x6A68             LDR      R0,[R5, #+36]
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD102             BNE.N    ??TIM_DMADelayPulseCplt_3
   4291            {
   4292              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \   0000002A   0x2004             MOVS     R0,#+4
   \   0000002C   0x7528             STRB     R0,[R5, #+20]
   \   0000002E   0xE004             B.N      ??TIM_DMADelayPulseCplt_1
   4293            }
   4294            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   \                     ??TIM_DMADelayPulseCplt_3: (+1)
   \   00000030   0x6AA8             LDR      R0,[R5, #+40]
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD101             BNE.N    ??TIM_DMADelayPulseCplt_1
   4295            {
   4296              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \   00000036   0x2008             MOVS     R0,#+8
   \   00000038   0x7528             STRB     R0,[R5, #+20]
   4297            }
   4298          
   4299            HAL_TIM_PWM_PulseFinishedCallback(htim);
   \                     ??TIM_DMADelayPulseCplt_1: (+1)
   \   0000003A   0x0028             MOVS     R0,R5
   \   0000003C   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   4300          
   4301            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x7528             STRB     R0,[R5, #+20]
   4302          }
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   4303          
   4304          /**
   4305            * @brief  TIM DMA Capture complete callback.
   4306            * @param  hdma : pointer to DMA handle.
   4307            * @retval None
   4308            */

   \                                 In section .text, align 4, keep-with-next
   4309          void TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
   4310          {
   \                     TIM_DMACaptureCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   4311            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   4312          
   4313            htim->State= HAL_TIM_STATE_READY;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xF885 0x0035      STRB     R0,[R5, #+53]
   4314          
   4315            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   \   0000000C   0x69E8             LDR      R0,[R5, #+28]
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD102             BNE.N    ??TIM_DMACaptureCplt_0
   4316            {
   4317              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x7528             STRB     R0,[R5, #+20]
   \   00000016   0xE010             B.N      ??TIM_DMACaptureCplt_1
   4318            }
   4319            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   \                     ??TIM_DMACaptureCplt_0: (+1)
   \   00000018   0x6A28             LDR      R0,[R5, #+32]
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD102             BNE.N    ??TIM_DMACaptureCplt_2
   4320            {
   4321              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0x7528             STRB     R0,[R5, #+20]
   \   00000022   0xE00A             B.N      ??TIM_DMACaptureCplt_1
   4322            }
   4323            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   \                     ??TIM_DMACaptureCplt_2: (+1)
   \   00000024   0x6A68             LDR      R0,[R5, #+36]
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD102             BNE.N    ??TIM_DMACaptureCplt_3
   4324            {
   4325              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \   0000002A   0x2004             MOVS     R0,#+4
   \   0000002C   0x7528             STRB     R0,[R5, #+20]
   \   0000002E   0xE004             B.N      ??TIM_DMACaptureCplt_1
   4326            }
   4327            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   \                     ??TIM_DMACaptureCplt_3: (+1)
   \   00000030   0x6AA8             LDR      R0,[R5, #+40]
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD101             BNE.N    ??TIM_DMACaptureCplt_1
   4328            {
   4329              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \   00000036   0x2008             MOVS     R0,#+8
   \   00000038   0x7528             STRB     R0,[R5, #+20]
   4330            }
   4331          
   4332            HAL_TIM_IC_CaptureCallback(htim);
   \                     ??TIM_DMACaptureCplt_1: (+1)
   \   0000003A   0x0028             MOVS     R0,R5
   \   0000003C   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   4333          
   4334            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x7528             STRB     R0,[R5, #+20]
   4335          }
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   4336          
   4337          /**
   4338            * @}
   4339            */
   4340          
   4341          /**
   4342            * @}
   4343            */
   4344          
   4345          
   4346          /** @addtogroup TIM_Private_Functions
   4347            * @{
   4348            */
   4349          
   4350          /**
   4351            * @brief  TIM DMA Period Elapse complete callback.
   4352            * @param  hdma : pointer to DMA handle.
   4353            * @retval None
   4354            */

   \                                 In section .text, align 4, keep-with-next
   4355          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
   4356          {
   \                     TIM_DMAPeriodElapsedCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   4357            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   4358          
   4359            htim->State= HAL_TIM_STATE_READY;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xF885 0x0035      STRB     R0,[R5, #+53]
   4360          
   4361            HAL_TIM_PeriodElapsedCallback(htim);
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0x.... 0x....      BL       HAL_TIM_PeriodElapsedCallback
   4362          }
   \   00000012   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   4363          
   4364          /**
   4365            * @brief  TIM DMA Trigger callback.
   4366            * @param  hdma : pointer to DMA handle.
   4367            * @retval None
   4368            */

   \                                 In section .text, align 4, keep-with-next
   4369          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
   4370          {
   \                     TIM_DMATriggerCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   4371            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   4372          
   4373            htim->State= HAL_TIM_STATE_READY;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xF885 0x0035      STRB     R0,[R5, #+53]
   4374          
   4375            HAL_TIM_TriggerCallback(htim);
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0x.... 0x....      BL       HAL_TIM_TriggerCallback
   4376          }
   \   00000012   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   4377          
   4378          /**
   4379            * @brief  Time Base configuration
   4380            * @param  TIMx: TIM periheral
   4381            * @param  Structure: TIM Base configuration structure
   4382            * @retval None
   4383            */

   \                                 In section .text, align 2, keep-with-next
   4384          static void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
   4385          {
   4386            uint32_t tmpcr1 = 0;
   \                     TIM_Base_SetConfig: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   4387            tmpcr1 = TIMx->CR1;
   \   00000002   0x6803             LDR      R3,[R0, #+0]
   \   00000004   0x001A             MOVS     R2,R3
   4388          
   4389            /* Set TIM Time Base Unit parameters ---------------------------------------*/
   4390            if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
   \   00000006   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \   0000000A   0xD005             BEQ.N    ??TIM_Base_SetConfig_0
   \   0000000C   0x....             LDR.N    R3,??DataTable7  ;; 0x40000400
   \   0000000E   0x4298             CMP      R0,R3
   \   00000010   0xD002             BEQ.N    ??TIM_Base_SetConfig_0
   \   00000012   0x....             LDR.N    R3,??DataTable7_1  ;; 0x40000800
   \   00000014   0x4298             CMP      R0,R3
   \   00000016   0xD103             BNE.N    ??TIM_Base_SetConfig_1
   4391            {
   4392              /* Select the Counter Mode */
   4393              tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
   \                     ??TIM_Base_SetConfig_0: (+1)
   \   00000018   0xF032 0x0270      BICS     R2,R2,#0x70
   4394              tmpcr1 |= Structure->CounterMode;
   \   0000001C   0x684B             LDR      R3,[R1, #+4]
   \   0000001E   0x431A             ORRS     R2,R3,R2
   4395            }
   4396          
   4397            if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   \                     ??TIM_Base_SetConfig_1: (+1)
   \   00000020   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \   00000024   0xD00E             BEQ.N    ??TIM_Base_SetConfig_2
   \   00000026   0x....             LDR.N    R3,??DataTable7  ;; 0x40000400
   \   00000028   0x4298             CMP      R0,R3
   \   0000002A   0xD00B             BEQ.N    ??TIM_Base_SetConfig_2
   \   0000002C   0x....             LDR.N    R3,??DataTable7_1  ;; 0x40000800
   \   0000002E   0x4298             CMP      R0,R3
   \   00000030   0xD008             BEQ.N    ??TIM_Base_SetConfig_2
   \   00000032   0x....             LDR.N    R3,??DataTable7_2  ;; 0x40010800
   \   00000034   0x4298             CMP      R0,R3
   \   00000036   0xD005             BEQ.N    ??TIM_Base_SetConfig_2
   \   00000038   0x....             LDR.N    R3,??DataTable7_3  ;; 0x40010c00
   \   0000003A   0x4298             CMP      R0,R3
   \   0000003C   0xD002             BEQ.N    ??TIM_Base_SetConfig_2
   \   0000003E   0x....             LDR.N    R3,??DataTable7_4  ;; 0x40011000
   \   00000040   0x4298             CMP      R0,R3
   \   00000042   0xD103             BNE.N    ??TIM_Base_SetConfig_3
   4398            {
   4399              /* Set the clock division */
   4400              tmpcr1 &= ~TIM_CR1_CKD;
   \                     ??TIM_Base_SetConfig_2: (+1)
   \   00000044   0xF432 0x7240      BICS     R2,R2,#0x300
   4401              tmpcr1 |= (uint32_t)Structure->ClockDivision;
   \   00000048   0x68CB             LDR      R3,[R1, #+12]
   \   0000004A   0x431A             ORRS     R2,R3,R2
   4402            }
   4403          
   4404            TIMx->CR1 = tmpcr1;
   \                     ??TIM_Base_SetConfig_3: (+1)
   \   0000004C   0x6002             STR      R2,[R0, #+0]
   4405          
   4406            /* Set the Autoreload value */
   4407            TIMx->ARR = (uint32_t)Structure->Period ;
   \   0000004E   0x688B             LDR      R3,[R1, #+8]
   \   00000050   0x62C3             STR      R3,[R0, #+44]
   4408          
   4409            /* Set the Prescaler value */
   4410            TIMx->PSC = (uint32_t)Structure->Prescaler;
   \   00000052   0x680B             LDR      R3,[R1, #+0]
   \   00000054   0x6283             STR      R3,[R0, #+40]
   4411          
   4412            /* Generate an update event to reload the Prescaler */
   4413            TIMx->EGR = TIM_EGR_UG;
   \   00000056   0x2301             MOVS     R3,#+1
   \   00000058   0x6143             STR      R3,[R0, #+20]
   4414          }
   \   0000005A   0x4770             BX       LR               ;; return
   4415          
   4416          /**
   4417            * @brief  Time Ouput Compare 1 configuration
   4418            * @param  TIMx to select the TIM peripheral
   4419            * @param  OC_Config: The ouput configuration structure
   4420            * @retval None
   4421            */

   \                                 In section .text, align 2, keep-with-next
   4422          static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4423          {
   \                     TIM_OC1_SetConfig: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   4424            uint32_t tmpccmrx = 0;
   \   00000002   0x2200             MOVS     R2,#+0
   4425            uint32_t tmpccer = 0;
   \   00000004   0x2300             MOVS     R3,#+0
   4426            uint32_t tmpcr2 = 0;
   \   00000006   0x2400             MOVS     R4,#+0
   4427          
   4428             /* Disable the Channel 1: Reset the CC1E Bit */
   4429            TIMx->CCER &= ~TIM_CCER_CC1E;
   \   00000008   0x6A05             LDR      R5,[R0, #+32]
   \   0000000A   0x086D             LSRS     R5,R5,#+1
   \   0000000C   0x006D             LSLS     R5,R5,#+1
   \   0000000E   0x6205             STR      R5,[R0, #+32]
   4430          
   4431            /* Get the TIMx CCER register value */
   4432            tmpccer = TIMx->CCER;
   \   00000010   0x6A05             LDR      R5,[R0, #+32]
   \   00000012   0x002B             MOVS     R3,R5
   4433            /* Get the TIMx CR2 register value */
   4434            tmpcr2 =  TIMx->CR2;
   \   00000014   0x6845             LDR      R5,[R0, #+4]
   \   00000016   0x002C             MOVS     R4,R5
   4435          
   4436            /* Get the TIMx CCMR1 register value */
   4437            tmpccmrx = TIMx->CCMR1;
   \   00000018   0x6985             LDR      R5,[R0, #+24]
   \   0000001A   0x002A             MOVS     R2,R5
   4438          
   4439            /* Reset the Output Compare Mode Bits */
   4440            tmpccmrx &= ~TIM_CCMR1_OC1M;
   \   0000001C   0xF032 0x0270      BICS     R2,R2,#0x70
   4441            tmpccmrx &= ~TIM_CCMR1_CC1S;
   \   00000020   0x0892             LSRS     R2,R2,#+2
   \   00000022   0x0092             LSLS     R2,R2,#+2
   4442            /* Select the Output Compare Mode */
   4443            tmpccmrx |= OC_Config->OCMode;
   \   00000024   0x680D             LDR      R5,[R1, #+0]
   \   00000026   0x432A             ORRS     R2,R5,R2
   4444          
   4445            /* Reset the Output Polarity level */
   4446            tmpccer &= ~TIM_CCER_CC1P;
   \   00000028   0xF033 0x0302      BICS     R3,R3,#0x2
   4447            /* Set the Output Compare Polarity */
   4448            tmpccer |= OC_Config->OCPolarity;
   \   0000002C   0x688D             LDR      R5,[R1, #+8]
   \   0000002E   0x432B             ORRS     R3,R5,R3
   4449          
   4450            /* Write to TIMx CR2 */
   4451            TIMx->CR2 = tmpcr2;
   \   00000030   0x6044             STR      R4,[R0, #+4]
   4452          
   4453            /* Write to TIMx CCMR1 */
   4454            TIMx->CCMR1 = tmpccmrx;
   \   00000032   0x6182             STR      R2,[R0, #+24]
   4455          
   4456            /* Set the Capture Compare Register value */
   4457            TIMx->CCR1 = OC_Config->Pulse;
   \   00000034   0x684D             LDR      R5,[R1, #+4]
   \   00000036   0x6345             STR      R5,[R0, #+52]
   4458          
   4459            /* Write to TIMx CCER */
   4460            TIMx->CCER = tmpccer;
   \   00000038   0x6203             STR      R3,[R0, #+32]
   4461          }
   \   0000003A   0xBC30             POP      {R4,R5}
   \   0000003C   0x4770             BX       LR               ;; return
   4462          
   4463          /**
   4464            * @brief  Time Ouput Compare 2 configuration
   4465            * @param  TIMx to select the TIM peripheral
   4466            * @param  OC_Config: The ouput configuration structure
   4467            * @retval None
   4468            */

   \                                 In section .text, align 2, keep-with-next
   4469          static void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4470          {
   \                     TIM_OC2_SetConfig: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   4471            uint32_t tmpccmrx = 0;
   \   00000002   0x2200             MOVS     R2,#+0
   4472            uint32_t tmpccer = 0;
   \   00000004   0x2300             MOVS     R3,#+0
   4473            uint32_t tmpcr2 = 0;
   \   00000006   0x2400             MOVS     R4,#+0
   4474          
   4475            /* Disable the Channel 2: Reset the CC2E Bit */
   4476            TIMx->CCER &= ~TIM_CCER_CC2E;
   \   00000008   0x6A05             LDR      R5,[R0, #+32]
   \   0000000A   0xF035 0x0510      BICS     R5,R5,#0x10
   \   0000000E   0x6205             STR      R5,[R0, #+32]
   4477          
   4478            /* Get the TIMx CCER register value */
   4479            tmpccer = TIMx->CCER;
   \   00000010   0x6A05             LDR      R5,[R0, #+32]
   \   00000012   0x002B             MOVS     R3,R5
   4480            /* Get the TIMx CR2 register value */
   4481            tmpcr2 =  TIMx->CR2;
   \   00000014   0x6845             LDR      R5,[R0, #+4]
   \   00000016   0x002C             MOVS     R4,R5
   4482          
   4483            /* Get the TIMx CCMR1 register value */
   4484            tmpccmrx = TIMx->CCMR1;
   \   00000018   0x6985             LDR      R5,[R0, #+24]
   \   0000001A   0x002A             MOVS     R2,R5
   4485          
   4486            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4487            tmpccmrx &= ~TIM_CCMR1_OC2M;
   \   0000001C   0xF432 0x42E0      BICS     R2,R2,#0x7000
   4488            tmpccmrx &= ~TIM_CCMR1_CC2S;
   \   00000020   0xF432 0x7240      BICS     R2,R2,#0x300
   4489          
   4490            /* Select the Output Compare Mode */
   4491            tmpccmrx |= (OC_Config->OCMode << 8);
   \   00000024   0x680D             LDR      R5,[R1, #+0]
   \   00000026   0xEA52 0x2205      ORRS     R2,R2,R5, LSL #+8
   4492          
   4493            /* Reset the Output Polarity level */
   4494            tmpccer &= ~TIM_CCER_CC2P;
   \   0000002A   0xF033 0x0320      BICS     R3,R3,#0x20
   4495            /* Set the Output Compare Polarity */
   4496            tmpccer |= (OC_Config->OCPolarity << 4);
   \   0000002E   0x688D             LDR      R5,[R1, #+8]
   \   00000030   0xEA53 0x1305      ORRS     R3,R3,R5, LSL #+4
   4497          
   4498            /* Write to TIMx CR2 */
   4499            TIMx->CR2 = tmpcr2;
   \   00000034   0x6044             STR      R4,[R0, #+4]
   4500          
   4501            /* Write to TIMx CCMR1 */
   4502            TIMx->CCMR1 = tmpccmrx;
   \   00000036   0x6182             STR      R2,[R0, #+24]
   4503          
   4504            /* Set the Capture Compare Register value */
   4505            TIMx->CCR2 = OC_Config->Pulse;
   \   00000038   0x684D             LDR      R5,[R1, #+4]
   \   0000003A   0x6385             STR      R5,[R0, #+56]
   4506          
   4507            /* Write to TIMx CCER */
   4508            TIMx->CCER = tmpccer;
   \   0000003C   0x6203             STR      R3,[R0, #+32]
   4509          }
   \   0000003E   0xBC30             POP      {R4,R5}
   \   00000040   0x4770             BX       LR               ;; return
   4510          
   4511          /**
   4512            * @brief  Time Ouput Compare 3 configuration
   4513            * @param  TIMx to select the TIM peripheral
   4514            * @param  OC_Config: The ouput configuration structure
   4515            * @retval None
   4516            */

   \                                 In section .text, align 2, keep-with-next
   4517          static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4518          {
   \                     TIM_OC3_SetConfig: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   4519            uint32_t tmpccmrx = 0;
   \   00000002   0x2200             MOVS     R2,#+0
   4520            uint32_t tmpccer = 0;
   \   00000004   0x2300             MOVS     R3,#+0
   4521            uint32_t tmpcr2 = 0;
   \   00000006   0x2400             MOVS     R4,#+0
   4522          
   4523            /* Disable the Channel 3: Reset the CC2E Bit */
   4524            TIMx->CCER &= ~TIM_CCER_CC3E;
   \   00000008   0x6A05             LDR      R5,[R0, #+32]
   \   0000000A   0xF435 0x7580      BICS     R5,R5,#0x100
   \   0000000E   0x6205             STR      R5,[R0, #+32]
   4525          
   4526            /* Get the TIMx CCER register value */
   4527            tmpccer = TIMx->CCER;
   \   00000010   0x6A05             LDR      R5,[R0, #+32]
   \   00000012   0x002B             MOVS     R3,R5
   4528            /* Get the TIMx CR2 register value */
   4529            tmpcr2 =  TIMx->CR2;
   \   00000014   0x6845             LDR      R5,[R0, #+4]
   \   00000016   0x002C             MOVS     R4,R5
   4530          
   4531            /* Get the TIMx CCMR2 register value */
   4532            tmpccmrx = TIMx->CCMR2;
   \   00000018   0x69C5             LDR      R5,[R0, #+28]
   \   0000001A   0x002A             MOVS     R2,R5
   4533          
   4534            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4535            tmpccmrx &= ~TIM_CCMR2_OC3M;
   \   0000001C   0xF032 0x0270      BICS     R2,R2,#0x70
   4536            tmpccmrx &= ~TIM_CCMR2_CC3S;
   \   00000020   0x0892             LSRS     R2,R2,#+2
   \   00000022   0x0092             LSLS     R2,R2,#+2
   4537            /* Select the Output Compare Mode */
   4538            tmpccmrx |= OC_Config->OCMode;
   \   00000024   0x680D             LDR      R5,[R1, #+0]
   \   00000026   0x432A             ORRS     R2,R5,R2
   4539          
   4540            /* Reset the Output Polarity level */
   4541            tmpccer &= ~TIM_CCER_CC3P;
   \   00000028   0xF433 0x7300      BICS     R3,R3,#0x200
   4542            /* Set the Output Compare Polarity */
   4543            tmpccer |= (OC_Config->OCPolarity << 8);
   \   0000002C   0x688D             LDR      R5,[R1, #+8]
   \   0000002E   0xEA53 0x2305      ORRS     R3,R3,R5, LSL #+8
   4544          
   4545            /* Write to TIMx CR2 */
   4546            TIMx->CR2 = tmpcr2;
   \   00000032   0x6044             STR      R4,[R0, #+4]
   4547          
   4548            /* Write to TIMx CCMR2 */
   4549            TIMx->CCMR2 = tmpccmrx;
   \   00000034   0x61C2             STR      R2,[R0, #+28]
   4550          
   4551            /* Set the Capture Compare Register value */
   4552            TIMx->CCR3 = OC_Config->Pulse;
   \   00000036   0x684D             LDR      R5,[R1, #+4]
   \   00000038   0x63C5             STR      R5,[R0, #+60]
   4553          
   4554            /* Write to TIMx CCER */
   4555            TIMx->CCER = tmpccer;
   \   0000003A   0x6203             STR      R3,[R0, #+32]
   4556          }
   \   0000003C   0xBC30             POP      {R4,R5}
   \   0000003E   0x4770             BX       LR               ;; return
   4557          
   4558          /**
   4559            * @brief  Time Ouput Compare 4 configuration
   4560            * @param  TIMx to select the TIM peripheral
   4561            * @param  OC_Config: The ouput configuration structure
   4562            * @retval None
   4563            */

   \                                 In section .text, align 2, keep-with-next
   4564          static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4565          {
   \                     TIM_OC4_SetConfig: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   4566            uint32_t tmpccmrx = 0;
   \   00000002   0x2200             MOVS     R2,#+0
   4567            uint32_t tmpccer = 0;
   \   00000004   0x2300             MOVS     R3,#+0
   4568            uint32_t tmpcr2 = 0;
   \   00000006   0x2400             MOVS     R4,#+0
   4569          
   4570            /* Disable the Channel 4: Reset the CC4E Bit */
   4571            TIMx->CCER &= ~TIM_CCER_CC4E;
   \   00000008   0x6A05             LDR      R5,[R0, #+32]
   \   0000000A   0xF435 0x5580      BICS     R5,R5,#0x1000
   \   0000000E   0x6205             STR      R5,[R0, #+32]
   4572          
   4573            /* Get the TIMx CCER register value */
   4574            tmpccer = TIMx->CCER;
   \   00000010   0x6A05             LDR      R5,[R0, #+32]
   \   00000012   0x002B             MOVS     R3,R5
   4575            /* Get the TIMx CR2 register value */
   4576            tmpcr2 =  TIMx->CR2;
   \   00000014   0x6845             LDR      R5,[R0, #+4]
   \   00000016   0x002C             MOVS     R4,R5
   4577          
   4578            /* Get the TIMx CCMR2 register value */
   4579            tmpccmrx = TIMx->CCMR2;
   \   00000018   0x69C5             LDR      R5,[R0, #+28]
   \   0000001A   0x002A             MOVS     R2,R5
   4580          
   4581            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4582            tmpccmrx &= ~TIM_CCMR2_OC4M;
   \   0000001C   0xF432 0x42E0      BICS     R2,R2,#0x7000
   4583            tmpccmrx &= ~TIM_CCMR2_CC4S;
   \   00000020   0xF432 0x7240      BICS     R2,R2,#0x300
   4584          
   4585            /* Select the Output Compare Mode */
   4586            tmpccmrx |= (OC_Config->OCMode << 8);
   \   00000024   0x680D             LDR      R5,[R1, #+0]
   \   00000026   0xEA52 0x2205      ORRS     R2,R2,R5, LSL #+8
   4587          
   4588            /* Reset the Output Polarity level */
   4589            tmpccer &= ~TIM_CCER_CC4P;
   \   0000002A   0xF433 0x5300      BICS     R3,R3,#0x2000
   4590            /* Set the Output Compare Polarity */
   4591            tmpccer |= (OC_Config->OCPolarity << 12);
   \   0000002E   0x688D             LDR      R5,[R1, #+8]
   \   00000030   0xEA53 0x3305      ORRS     R3,R3,R5, LSL #+12
   4592          
   4593            /* Write to TIMx CR2 */
   4594            TIMx->CR2 = tmpcr2;
   \   00000034   0x6044             STR      R4,[R0, #+4]
   4595          
   4596            /* Write to TIMx CCMR2 */
   4597            TIMx->CCMR2 = tmpccmrx;
   \   00000036   0x61C2             STR      R2,[R0, #+28]
   4598          
   4599            /* Set the Capture Compare Register value */
   4600            TIMx->CCR4 = OC_Config->Pulse;
   \   00000038   0x684D             LDR      R5,[R1, #+4]
   \   0000003A   0x6405             STR      R5,[R0, #+64]
   4601          
   4602            /* Write to TIMx CCER */
   4603            TIMx->CCER = tmpccer;
   \   0000003C   0x6203             STR      R3,[R0, #+32]
   4604          }
   \   0000003E   0xBC30             POP      {R4,R5}
   \   00000040   0x4770             BX       LR               ;; return
   4605          
   4606          
   4607          /**
   4608            * @brief  Time Slave configuration
   4609            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4610            *                the configuration information for TIM module.
   4611            * @param  sSlaveConfig: The slave configuration structure
   4612            * @retval None
   4613            */

   \                                 In section .text, align 2, keep-with-next
   4614          static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
   4615                                        TIM_SlaveConfigTypeDef * sSlaveConfig)
   4616          {
   \                     TIM_SlaveTimer_SetConfig: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   4617            uint32_t tmpsmcr = 0;
   \   00000008   0xF05F 0x0800      MOVS     R8,#+0
   4618            uint32_t tmpccmr1 = 0;
   \   0000000C   0x2600             MOVS     R6,#+0
   4619            uint32_t tmpccer = 0;
   \   0000000E   0x2700             MOVS     R7,#+0
   4620          
   4621           /* Get the TIMx SMCR register value */
   4622            tmpsmcr = htim->Instance->SMCR;
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x6880             LDR      R0,[R0, #+8]
   \   00000014   0x4680             MOV      R8,R0
   4623          
   4624            /* Reset the Trigger Selection Bits */
   4625            tmpsmcr &= ~TIM_SMCR_TS;
   \   00000016   0xF038 0x0870      BICS     R8,R8,#0x70
   4626            /* Set the Input Trigger source */
   4627            tmpsmcr |= sSlaveConfig->InputTrigger;
   \   0000001A   0x6868             LDR      R0,[R5, #+4]
   \   0000001C   0xEA50 0x0808      ORRS     R8,R0,R8
   4628          
   4629            /* Reset the slave mode Bits */
   4630            tmpsmcr &= ~TIM_SMCR_SMS;
   \   00000020   0xEA5F 0x08D8      LSRS     R8,R8,#+3
   \   00000024   0xEA5F 0x08C8      LSLS     R8,R8,#+3
   4631            /* Set the slave mode */
   4632            tmpsmcr |= sSlaveConfig->SlaveMode;
   \   00000028   0x6828             LDR      R0,[R5, #+0]
   \   0000002A   0xEA50 0x0808      ORRS     R8,R0,R8
   4633          
   4634            /* Write to TIMx SMCR */
   4635            htim->Instance->SMCR = tmpsmcr;
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0xF8C0 0x8008      STR      R8,[R0, #+8]
   4636            
   4637            /* Configure the trigger prescaler, filter, and polarity */
   4638            switch (sSlaveConfig->InputTrigger)
   \   00000034   0x6868             LDR      R0,[R5, #+4]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD036             BEQ.N    ??TIM_SlaveTimer_SetConfig_0
   \   0000003A   0x2810             CMP      R0,#+16
   \   0000003C   0xD035             BEQ.N    ??TIM_SlaveTimer_SetConfig_1
   \   0000003E   0x2820             CMP      R0,#+32
   \   00000040   0xD034             BEQ.N    ??TIM_SlaveTimer_SetConfig_2
   \   00000042   0x2830             CMP      R0,#+48
   \   00000044   0xD033             BEQ.N    ??TIM_SlaveTimer_SetConfig_3
   \   00000046   0x2840             CMP      R0,#+64
   \   00000048   0xD00C             BEQ.N    ??TIM_SlaveTimer_SetConfig_4
   \   0000004A   0x2850             CMP      R0,#+80
   \   0000004C   0xD020             BEQ.N    ??TIM_SlaveTimer_SetConfig_5
   \   0000004E   0x2860             CMP      R0,#+96
   \   00000050   0xD024             BEQ.N    ??TIM_SlaveTimer_SetConfig_6
   \   00000052   0x2870             CMP      R0,#+112
   \   00000054   0xD12C             BNE.N    ??TIM_SlaveTimer_SetConfig_7
   4639            {
   4640            case TIM_TS_ETRF:
   4641              {
   4642                /* Check the parameters */
   4643                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
   4644                assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
   4645                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   4646                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4647                /* Configure the ETR Trigger source */
   4648                TIM_ETR_SetConfig(htim->Instance, 
   4649                                  sSlaveConfig->TriggerPrescaler, 
   4650                                  sSlaveConfig->TriggerPolarity, 
   4651                                  sSlaveConfig->TriggerFilter);
   \                     ??TIM_SlaveTimer_SetConfig_8: (+1)
   \   00000056   0x692B             LDR      R3,[R5, #+16]
   \   00000058   0x68AA             LDR      R2,[R5, #+8]
   \   0000005A   0x68E9             LDR      R1,[R5, #+12]
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x.... 0x....      BL       TIM_ETR_SetConfig
   4652              }
   4653              break;
   \   00000062   0xE025             B.N      ??TIM_SlaveTimer_SetConfig_9
   4654              
   4655            case TIM_TS_TI1F_ED:
   4656              {
   4657                /* Check the parameters */
   4658                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4659                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4660                
   4661                /* Disable the Channel 1: Reset the CC1E Bit */
   4662                tmpccer = htim->Instance->CCER;
   \                     ??TIM_SlaveTimer_SetConfig_4: (+1)
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x6A00             LDR      R0,[R0, #+32]
   \   00000068   0x0007             MOVS     R7,R0
   4663                htim->Instance->CCER &= ~TIM_CCER_CC1E;
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x6A00             LDR      R0,[R0, #+32]
   \   0000006E   0x0840             LSRS     R0,R0,#+1
   \   00000070   0x0040             LSLS     R0,R0,#+1
   \   00000072   0x6821             LDR      R1,[R4, #+0]
   \   00000074   0x6208             STR      R0,[R1, #+32]
   4664                tmpccmr1 = htim->Instance->CCMR1;    
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x6980             LDR      R0,[R0, #+24]
   \   0000007A   0x0006             MOVS     R6,R0
   4665                
   4666                /* Set the filter */
   4667                tmpccmr1 &= ~TIM_CCMR1_IC1F;
   \   0000007C   0xF036 0x06F0      BICS     R6,R6,#0xF0
   4668                tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4);
   \   00000080   0x6928             LDR      R0,[R5, #+16]
   \   00000082   0xEA56 0x1600      ORRS     R6,R6,R0, LSL #+4
   4669                
   4670                /* Write to TIMx CCMR1 and CCER registers */
   4671                htim->Instance->CCMR1 = tmpccmr1;
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x6186             STR      R6,[R0, #+24]
   4672                htim->Instance->CCER = tmpccer;                               
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x6207             STR      R7,[R0, #+32]
   4673                                         
   4674              }
   4675              break;
   \   0000008E   0xE00F             B.N      ??TIM_SlaveTimer_SetConfig_9
   4676              
   4677            case TIM_TS_TI1FP1:
   4678              {
   4679                /* Check the parameters */
   4680                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4681                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   4682                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4683          
   4684                /* Configure TI1 Filter and Polarity */
   4685                TIM_TI1_ConfigInputStage(htim->Instance,
   4686                                         sSlaveConfig->TriggerPolarity,
   4687                                         sSlaveConfig->TriggerFilter);
   \                     ??TIM_SlaveTimer_SetConfig_5: (+1)
   \   00000090   0x692A             LDR      R2,[R5, #+16]
   \   00000092   0x68A9             LDR      R1,[R5, #+8]
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x.... 0x....      BL       TIM_TI1_ConfigInputStage
   4688              }
   4689              break;
   \   0000009A   0xE009             B.N      ??TIM_SlaveTimer_SetConfig_9
   4690              
   4691            case TIM_TS_TI2FP2:
   4692              {
   4693                /* Check the parameters */
   4694                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4695                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   4696                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4697                
   4698                /* Configure TI2 Filter and Polarity */
   4699                TIM_TI2_ConfigInputStage(htim->Instance,
   4700                                          sSlaveConfig->TriggerPolarity,
   4701                                          sSlaveConfig->TriggerFilter);
   \                     ??TIM_SlaveTimer_SetConfig_6: (+1)
   \   0000009C   0x692A             LDR      R2,[R5, #+16]
   \   0000009E   0x68A9             LDR      R1,[R5, #+8]
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x.... 0x....      BL       TIM_TI2_ConfigInputStage
   4702              }
   4703              break;
   \   000000A6   0xE003             B.N      ??TIM_SlaveTimer_SetConfig_9
   4704              
   4705            case TIM_TS_ITR0:
   4706              {
   4707                /* Check the parameter */
   4708                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4709              }
   4710              break;
   \                     ??TIM_SlaveTimer_SetConfig_0: (+1)
   \   000000A8   0xE002             B.N      ??TIM_SlaveTimer_SetConfig_9
   4711              
   4712            case TIM_TS_ITR1:
   4713              {
   4714                /* Check the parameter */
   4715                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4716              }
   4717              break;
   \                     ??TIM_SlaveTimer_SetConfig_1: (+1)
   \   000000AA   0xE001             B.N      ??TIM_SlaveTimer_SetConfig_9
   4718              
   4719            case TIM_TS_ITR2:
   4720              {
   4721                /* Check the parameter */
   4722                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4723              }
   4724              break;
   \                     ??TIM_SlaveTimer_SetConfig_2: (+1)
   \   000000AC   0xE000             B.N      ??TIM_SlaveTimer_SetConfig_9
   4725              
   4726            case TIM_TS_ITR3:
   4727              {
   4728                /* Check the parameter */
   4729                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4730              }
   4731              break;
   \                     ??TIM_SlaveTimer_SetConfig_3: (+1)
   \   000000AE   0xE7FF             B.N      ??TIM_SlaveTimer_SetConfig_9
   4732                 
   4733            default:
   4734              break;
   4735            }
   4736          }
   \                     ??TIM_SlaveTimer_SetConfig_7: (+1)
   \                     ??TIM_SlaveTimer_SetConfig_9: (+1)
   \   000000B0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   4737          
   4738          /**
   4739            * @brief  Configure the TI1 as Input.
   4740            * @param  TIMx to select the TIM peripheral.
   4741            * @param  TIM_ICPolarity : The Input Polarity.
   4742            *          This parameter can be one of the following values:
   4743            *            @arg TIM_ICPOLARITY_RISING
   4744            *            @arg TIM_ICPOLARITY_FALLING
   4745            *            @arg TIM_ICPOLARITY_BOTHEDGE
   4746            * @param  TIM_ICSelection: specifies the input to be used.
   4747            *          This parameter can be one of the following values:
   4748            *            @arg TIM_ICSELECTION_DIRECTTI:    TIM Input 1 is selected to be connected to IC1.
   4749            *            @arg TIM_ICSELECTION_INDIRECTTI:  TIM Input 1 is selected to be connected to IC2.
   4750            *            @arg TIM_ICSELECTION_TRC:         TIM Input 1 is selected to be connected to TRC.
   4751            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   4752            *          This parameter must be a value between 0x00 and 0x0F.
   4753            * @retval None
   4754            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI2FP1 
   4755            *       (on channel2 path) is used as the input signal. Therefore CCMR1 must be 
   4756            *        protected against un-initialized filter and polarity values.
   4757            */

   \                                 In section .text, align 2, keep-with-next
   4758          static void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   4759                                 uint32_t TIM_ICFilter)
   4760          {
   \                     TIM_TI1_SetConfig: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   4761            uint32_t tmpccmr1 = 0;
   \   00000002   0x2500             MOVS     R5,#+0
   4762            uint32_t tmpccer = 0;
   \   00000004   0x2400             MOVS     R4,#+0
   4763          
   4764            /* Disable the Channel 1: Reset the CC1E Bit */
   4765            TIMx->CCER &= ~TIM_CCER_CC1E;
   \   00000006   0x6A06             LDR      R6,[R0, #+32]
   \   00000008   0x0876             LSRS     R6,R6,#+1
   \   0000000A   0x0076             LSLS     R6,R6,#+1
   \   0000000C   0x6206             STR      R6,[R0, #+32]
   4766            tmpccmr1 = TIMx->CCMR1;
   \   0000000E   0x6986             LDR      R6,[R0, #+24]
   \   00000010   0x0035             MOVS     R5,R6
   4767            tmpccer = TIMx->CCER;
   \   00000012   0x6A06             LDR      R6,[R0, #+32]
   \   00000014   0x0034             MOVS     R4,R6
   4768          
   4769            /* Select the Input */
   4770            if(IS_TIM_CC2_INSTANCE(TIMx) != RESET)
   \   00000016   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \   0000001A   0xD008             BEQ.N    ??TIM_TI1_SetConfig_0
   \   0000001C   0x....             LDR.N    R6,??DataTable7  ;; 0x40000400
   \   0000001E   0x42B0             CMP      R0,R6
   \   00000020   0xD005             BEQ.N    ??TIM_TI1_SetConfig_0
   \   00000022   0x....             LDR.N    R6,??DataTable7_1  ;; 0x40000800
   \   00000024   0x42B0             CMP      R0,R6
   \   00000026   0xD002             BEQ.N    ??TIM_TI1_SetConfig_0
   \   00000028   0x....             LDR.N    R6,??DataTable7_2  ;; 0x40010800
   \   0000002A   0x42B0             CMP      R0,R6
   \   0000002C   0xD101             BNE.N    ??TIM_TI1_SetConfig_1
   \                     ??TIM_TI1_SetConfig_0: (+1)
   \   0000002E   0x2601             MOVS     R6,#+1
   \   00000030   0xE000             B.N      ??TIM_TI1_SetConfig_2
   \                     ??TIM_TI1_SetConfig_1: (+1)
   \   00000032   0x2600             MOVS     R6,#+0
   \                     ??TIM_TI1_SetConfig_2: (+1)
   \   00000034   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000036   0x2E00             CMP      R6,#+0
   \   00000038   0xD003             BEQ.N    ??TIM_TI1_SetConfig_3
   4771            {
   4772              tmpccmr1 &= ~TIM_CCMR1_CC1S;
   \   0000003A   0x08AD             LSRS     R5,R5,#+2
   \   0000003C   0x00AD             LSLS     R5,R5,#+2
   4773              tmpccmr1 |= TIM_ICSelection;
   \   0000003E   0x4315             ORRS     R5,R2,R5
   \   00000040   0xE001             B.N      ??TIM_TI1_SetConfig_4
   4774            }
   4775            else
   4776            {
   4777              tmpccmr1 |= TIM_CCMR1_CC1S_0;
   \                     ??TIM_TI1_SetConfig_3: (+1)
   \   00000042   0xF055 0x0501      ORRS     R5,R5,#0x1
   4778            }
   4779          
   4780            /* Set the filter */
   4781            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   \                     ??TIM_TI1_SetConfig_4: (+1)
   \   00000046   0xF035 0x05F0      BICS     R5,R5,#0xF0
   4782            tmpccmr1 |= ((TIM_ICFilter << 4) & TIM_CCMR1_IC1F);
   \   0000004A   0x011E             LSLS     R6,R3,#+4
   \   0000004C   0xF016 0x06F0      ANDS     R6,R6,#0xF0
   \   00000050   0x4335             ORRS     R5,R6,R5
   4783          
   4784            /* Select the Polarity and set the CC1E Bit */
   4785            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   \   00000052   0xF034 0x040A      BICS     R4,R4,#0xA
   4786            tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
   \   00000056   0xF011 0x060A      ANDS     R6,R1,#0xA
   \   0000005A   0x4334             ORRS     R4,R6,R4
   4787          
   4788            /* Write to TIMx CCMR1 and CCER registers */
   4789            TIMx->CCMR1 = tmpccmr1;
   \   0000005C   0x6185             STR      R5,[R0, #+24]
   4790            TIMx->CCER = tmpccer;
   \   0000005E   0x6204             STR      R4,[R0, #+32]
   4791          }
   \   00000060   0xBC70             POP      {R4-R6}
   \   00000062   0x4770             BX       LR               ;; return
   4792          
   4793          /**
   4794            * @brief  Configure the Polarity and Filter for TI1.
   4795            * @param  TIMx to select the TIM peripheral.
   4796            * @param  TIM_ICPolarity : The Input Polarity.
   4797            *          This parameter can be one of the following values:
   4798            *            @arg TIM_ICPOLARITY_RISING   
   4799            *            @arg TIM_ICPOLARITY_FALLING  
   4800            *            @arg TIM_ICPOLARITY_BOTHEDGE 
   4801            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   4802            *          This parameter must be a value between 0x00 and 0x0F.
   4803            * @retval None
   4804            */

   \                                 In section .text, align 2, keep-with-next
   4805          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   4806          {
   \                     TIM_TI1_ConfigInputStage: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   4807            uint32_t tmpccmr1 = 0;
   \   00000002   0x2300             MOVS     R3,#+0
   4808            uint32_t tmpccer = 0;
   \   00000004   0x2400             MOVS     R4,#+0
   4809          
   4810            /* Disable the Channel 1: Reset the CC1E Bit */
   4811            tmpccer = TIMx->CCER;
   \   00000006   0x6A05             LDR      R5,[R0, #+32]
   \   00000008   0x002C             MOVS     R4,R5
   4812            TIMx->CCER &= ~TIM_CCER_CC1E;
   \   0000000A   0x6A05             LDR      R5,[R0, #+32]
   \   0000000C   0x086D             LSRS     R5,R5,#+1
   \   0000000E   0x006D             LSLS     R5,R5,#+1
   \   00000010   0x6205             STR      R5,[R0, #+32]
   4813            tmpccmr1 = TIMx->CCMR1;
   \   00000012   0x6985             LDR      R5,[R0, #+24]
   \   00000014   0x002B             MOVS     R3,R5
   4814          
   4815            /* Set the filter */
   4816            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   \   00000016   0xF033 0x03F0      BICS     R3,R3,#0xF0
   4817            tmpccmr1 |= (TIM_ICFilter << 4);
   \   0000001A   0xEA53 0x1302      ORRS     R3,R3,R2, LSL #+4
   4818          
   4819            /* Select the Polarity and set the CC1E Bit */
   4820            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   \   0000001E   0xF034 0x040A      BICS     R4,R4,#0xA
   4821            tmpccer |= TIM_ICPolarity;
   \   00000022   0x430C             ORRS     R4,R1,R4
   4822          
   4823            /* Write to TIMx CCMR1 and CCER registers */
   4824            TIMx->CCMR1 = tmpccmr1;
   \   00000024   0x6183             STR      R3,[R0, #+24]
   4825            TIMx->CCER = tmpccer;
   \   00000026   0x6204             STR      R4,[R0, #+32]
   4826          }
   \   00000028   0xBC30             POP      {R4,R5}
   \   0000002A   0x4770             BX       LR               ;; return
   4827          
   4828          /**
   4829            * @brief  Configure the TI2 as Input.
   4830            * @param  TIMx to select the TIM peripheral
   4831            * @param  TIM_ICPolarity : The Input Polarity.
   4832            *          This parameter can be one of the following values:
   4833            *            @arg TIM_ICPOLARITY_RISING   
   4834            *            @arg TIM_ICPOLARITY_FALLING  
   4835            *            @arg TIM_ICPOLARITY_BOTHEDGE 
   4836            * @param  TIM_ICSelection: specifies the input to be used.
   4837            *          This parameter can be one of the following values:
   4838            *            @arg TIM_ICSELECTION_DIRECTTI:   TIM Input 2 is selected to be connected to IC2.
   4839            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 2 is selected to be connected to IC1.
   4840            *            @arg TIM_ICSELECTION_TRC:        TIM Input 2 is selected to be connected to TRC.
   4841            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   4842            *          This parameter must be a value between 0x00 and 0x0F.
   4843            * @retval None
   4844            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI1FP2 
   4845            *       (on channel1 path) is used as the input signal. Therefore CCMR1 must be 
   4846            *        protected against un-initialized filter and polarity values.
   4847            */

   \                                 In section .text, align 2, keep-with-next
   4848          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   4849                                 uint32_t TIM_ICFilter)
   4850          {
   \                     TIM_TI2_SetConfig: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   4851            uint32_t tmpccmr1 = 0;
   \   00000002   0x2400             MOVS     R4,#+0
   4852            uint32_t tmpccer = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   4853          
   4854            /* Disable the Channel 2: Reset the CC2E Bit */
   4855            TIMx->CCER &= ~TIM_CCER_CC2E;
   \   00000006   0x6A06             LDR      R6,[R0, #+32]
   \   00000008   0xF036 0x0610      BICS     R6,R6,#0x10
   \   0000000C   0x6206             STR      R6,[R0, #+32]
   4856            tmpccmr1 = TIMx->CCMR1;
   \   0000000E   0x6986             LDR      R6,[R0, #+24]
   \   00000010   0x0034             MOVS     R4,R6
   4857            tmpccer = TIMx->CCER;
   \   00000012   0x6A06             LDR      R6,[R0, #+32]
   \   00000014   0x0035             MOVS     R5,R6
   4858          
   4859            /* Select the Input */
   4860            tmpccmr1 &= ~TIM_CCMR1_CC2S;
   \   00000016   0xF434 0x7440      BICS     R4,R4,#0x300
   4861            tmpccmr1 |= (TIM_ICSelection << 8);
   \   0000001A   0xEA54 0x2402      ORRS     R4,R4,R2, LSL #+8
   4862          
   4863            /* Set the filter */
   4864            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   \   0000001E   0xF434 0x4470      BICS     R4,R4,#0xF000
   4865            tmpccmr1 |= ((TIM_ICFilter << 12) & TIM_CCMR1_IC2F);
   \   00000022   0x031E             LSLS     R6,R3,#+12
   \   00000024   0xF416 0x4670      ANDS     R6,R6,#0xF000
   \   00000028   0x4334             ORRS     R4,R6,R4
   4866          
   4867            /* Select the Polarity and set the CC2E Bit */
   4868            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   \   0000002A   0xF035 0x05A0      BICS     R5,R5,#0xA0
   4869            tmpccer |= ((TIM_ICPolarity << 4) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
   \   0000002E   0x010E             LSLS     R6,R1,#+4
   \   00000030   0xF016 0x06A0      ANDS     R6,R6,#0xA0
   \   00000034   0x4335             ORRS     R5,R6,R5
   4870          
   4871            /* Write to TIMx CCMR1 and CCER registers */
   4872            TIMx->CCMR1 = tmpccmr1 ;
   \   00000036   0x6184             STR      R4,[R0, #+24]
   4873            TIMx->CCER = tmpccer;
   \   00000038   0x6205             STR      R5,[R0, #+32]
   4874          }
   \   0000003A   0xBC70             POP      {R4-R6}
   \   0000003C   0x4770             BX       LR               ;; return
   4875          
   4876          /**
   4877            * @brief  Configure the Polarity and Filter for TI2.
   4878            * @param  TIMx to select the TIM peripheral.
   4879            * @param  TIM_ICPolarity : The Input Polarity.
   4880            *          This parameter can be one of the following values:
   4881            *            @arg TIM_ICPOLARITY_RISING  
   4882            *            @arg TIM_ICPOLARITY_FALLING 
   4883            *            @arg TIM_ICPOLARITY_BOTHEDGE
   4884            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   4885            *          This parameter must be a value between 0x00 and 0x0F.
   4886            * @retval None
   4887            */

   \                                 In section .text, align 2, keep-with-next
   4888          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   4889          {
   \                     TIM_TI2_ConfigInputStage: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   4890            uint32_t tmpccmr1 = 0;
   \   00000002   0x2300             MOVS     R3,#+0
   4891            uint32_t tmpccer = 0;
   \   00000004   0x2400             MOVS     R4,#+0
   4892          
   4893            /* Disable the Channel 2: Reset the CC2E Bit */
   4894            TIMx->CCER &= ~TIM_CCER_CC2E;
   \   00000006   0x6A05             LDR      R5,[R0, #+32]
   \   00000008   0xF035 0x0510      BICS     R5,R5,#0x10
   \   0000000C   0x6205             STR      R5,[R0, #+32]
   4895            tmpccmr1 = TIMx->CCMR1;
   \   0000000E   0x6985             LDR      R5,[R0, #+24]
   \   00000010   0x002B             MOVS     R3,R5
   4896            tmpccer = TIMx->CCER;
   \   00000012   0x6A05             LDR      R5,[R0, #+32]
   \   00000014   0x002C             MOVS     R4,R5
   4897          
   4898            /* Set the filter */
   4899            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   \   00000016   0xF433 0x4370      BICS     R3,R3,#0xF000
   4900            tmpccmr1 |= (TIM_ICFilter << 12);
   \   0000001A   0xEA53 0x3302      ORRS     R3,R3,R2, LSL #+12
   4901          
   4902            /* Select the Polarity and set the CC2E Bit */
   4903            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   \   0000001E   0xF034 0x04A0      BICS     R4,R4,#0xA0
   4904            tmpccer |= (TIM_ICPolarity << 4);
   \   00000022   0xEA54 0x1401      ORRS     R4,R4,R1, LSL #+4
   4905          
   4906            /* Write to TIMx CCMR1 and CCER registers */
   4907            TIMx->CCMR1 = tmpccmr1 ;
   \   00000026   0x6183             STR      R3,[R0, #+24]
   4908            TIMx->CCER = tmpccer;
   \   00000028   0x6204             STR      R4,[R0, #+32]
   4909          }
   \   0000002A   0xBC30             POP      {R4,R5}
   \   0000002C   0x4770             BX       LR               ;; return
   4910          
   4911          /**
   4912            * @brief  Configure the TI3 as Input.
   4913            * @param  TIMx to select the TIM peripheral
   4914            * @param  TIM_ICPolarity : The Input Polarity.
   4915            *          This parameter can be one of the following values:
   4916            *            @arg TIM_ICPOLARITY_RISING  
   4917            *            @arg TIM_ICPOLARITY_FALLING 
   4918            *            @arg TIM_ICPOLARITY_BOTHEDGE
   4919            * @param  TIM_ICSelection: specifies the input to be used.
   4920            *          This parameter can be one of the following values:
   4921            *            @arg TIM_ICSELECTION_DIRECTTI:   TIM Input 3 is selected to be connected to IC3.
   4922            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 3 is selected to be connected to IC4.
   4923            *            @arg TIM_ICSELECTION_TRC:        TIM Input 3 is selected to be connected to TRC.
   4924            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   4925            *          This parameter must be a value between 0x00 and 0x0F.
   4926            * @retval None
   4927            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI3FP4 
   4928            *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be 
   4929            *        protected against un-initialized filter and polarity values.
   4930            */

   \                                 In section .text, align 2, keep-with-next
   4931          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   4932                                 uint32_t TIM_ICFilter)
   4933          {
   \                     TIM_TI3_SetConfig: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   4934            uint32_t tmpccmr2 = 0;
   \   00000002   0x2400             MOVS     R4,#+0
   4935            uint32_t tmpccer = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   4936          
   4937            /* Disable the Channel 3: Reset the CC3E Bit */
   4938            TIMx->CCER &= ~TIM_CCER_CC3E;
   \   00000006   0x6A06             LDR      R6,[R0, #+32]
   \   00000008   0xF436 0x7680      BICS     R6,R6,#0x100
   \   0000000C   0x6206             STR      R6,[R0, #+32]
   4939            tmpccmr2 = TIMx->CCMR2;
   \   0000000E   0x69C6             LDR      R6,[R0, #+28]
   \   00000010   0x0034             MOVS     R4,R6
   4940            tmpccer = TIMx->CCER;
   \   00000012   0x6A06             LDR      R6,[R0, #+32]
   \   00000014   0x0035             MOVS     R5,R6
   4941          
   4942            /* Select the Input */
   4943            tmpccmr2 &= ~TIM_CCMR2_CC3S;
   \   00000016   0x08A4             LSRS     R4,R4,#+2
   \   00000018   0x00A4             LSLS     R4,R4,#+2
   4944            tmpccmr2 |= TIM_ICSelection;
   \   0000001A   0x4314             ORRS     R4,R2,R4
   4945          
   4946            /* Set the filter */
   4947            tmpccmr2 &= ~TIM_CCMR2_IC3F;
   \   0000001C   0xF034 0x04F0      BICS     R4,R4,#0xF0
   4948            tmpccmr2 |= ((TIM_ICFilter << 4) & TIM_CCMR2_IC3F);
   \   00000020   0x011E             LSLS     R6,R3,#+4
   \   00000022   0xF016 0x06F0      ANDS     R6,R6,#0xF0
   \   00000026   0x4334             ORRS     R4,R6,R4
   4949          
   4950            /* Select the Polarity and set the CC3E Bit */
   4951            tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
   \   00000028   0xF435 0x6520      BICS     R5,R5,#0xA00
   4952            tmpccer |= ((TIM_ICPolarity << 8) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
   \   0000002C   0x020E             LSLS     R6,R1,#+8
   \   0000002E   0xF416 0x6620      ANDS     R6,R6,#0xA00
   \   00000032   0x4335             ORRS     R5,R6,R5
   4953          
   4954            /* Write to TIMx CCMR2 and CCER registers */
   4955            TIMx->CCMR2 = tmpccmr2;
   \   00000034   0x61C4             STR      R4,[R0, #+28]
   4956            TIMx->CCER = tmpccer;
   \   00000036   0x6205             STR      R5,[R0, #+32]
   4957          }
   \   00000038   0xBC70             POP      {R4-R6}
   \   0000003A   0x4770             BX       LR               ;; return
   4958          
   4959          /**
   4960            * @brief  Configure the TI4 as Input.
   4961            * @param  TIMx to select the TIM peripheral
   4962            * @param  TIM_ICPolarity : The Input Polarity.
   4963            *          This parameter can be one of the following values:
   4964            *            @arg TIM_ICPOLARITY_RISING  
   4965            *            @arg TIM_ICPOLARITY_FALLING 
   4966            *            @arg TIM_ICPOLARITY_BOTHEDGE
   4967            * @param  TIM_ICSelection: specifies the input to be used.
   4968            *          This parameter can be one of the following values:
   4969            *            @arg TIM_ICSELECTION_DIRECTTI:   TIM Input 4 is selected to be connected to IC4.
   4970            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 4 is selected to be connected to IC3.
   4971            *            @arg TIM_ICSELECTION_TRC:        TIM Input 4 is selected to be connected to TRC.
   4972            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   4973            *          This parameter must be a value between 0x00 and 0x0F.
   4974            * @retval None
   4975            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI4FP3 
   4976            *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be 
   4977            *        protected against un-initialized filter and polarity values.
   4978            */

   \                                 In section .text, align 2, keep-with-next
   4979          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   4980                                 uint32_t TIM_ICFilter)
   4981          {
   \                     TIM_TI4_SetConfig: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   4982            uint32_t tmpccmr2 = 0;
   \   00000002   0x2400             MOVS     R4,#+0
   4983            uint32_t tmpccer = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   4984          
   4985            /* Disable the Channel 4: Reset the CC4E Bit */
   4986            TIMx->CCER &= ~TIM_CCER_CC4E;
   \   00000006   0x6A06             LDR      R6,[R0, #+32]
   \   00000008   0xF436 0x5680      BICS     R6,R6,#0x1000
   \   0000000C   0x6206             STR      R6,[R0, #+32]
   4987            tmpccmr2 = TIMx->CCMR2;
   \   0000000E   0x69C6             LDR      R6,[R0, #+28]
   \   00000010   0x0034             MOVS     R4,R6
   4988            tmpccer = TIMx->CCER;
   \   00000012   0x6A06             LDR      R6,[R0, #+32]
   \   00000014   0x0035             MOVS     R5,R6
   4989          
   4990            /* Select the Input */
   4991            tmpccmr2 &= ~TIM_CCMR2_CC4S;
   \   00000016   0xF434 0x7440      BICS     R4,R4,#0x300
   4992            tmpccmr2 |= (TIM_ICSelection << 8);
   \   0000001A   0xEA54 0x2402      ORRS     R4,R4,R2, LSL #+8
   4993          
   4994            /* Set the filter */
   4995            tmpccmr2 &= ~TIM_CCMR2_IC4F;
   \   0000001E   0xF434 0x4470      BICS     R4,R4,#0xF000
   4996            tmpccmr2 |= ((TIM_ICFilter << 12) & TIM_CCMR2_IC4F);
   \   00000022   0x031E             LSLS     R6,R3,#+12
   \   00000024   0xF416 0x4670      ANDS     R6,R6,#0xF000
   \   00000028   0x4334             ORRS     R4,R6,R4
   4997          
   4998            /* Select the Polarity and set the CC4E Bit */
   4999            tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
   \   0000002A   0xF435 0x4520      BICS     R5,R5,#0xA000
   5000            tmpccer |= ((TIM_ICPolarity << 12) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
   \   0000002E   0x030E             LSLS     R6,R1,#+12
   \   00000030   0xF416 0x4620      ANDS     R6,R6,#0xA000
   \   00000034   0x4335             ORRS     R5,R6,R5
   5001          
   5002            /* Write to TIMx CCMR2 and CCER registers */
   5003            TIMx->CCMR2 = tmpccmr2;
   \   00000036   0x61C4             STR      R4,[R0, #+28]
   5004            TIMx->CCER = tmpccer ;
   \   00000038   0x6205             STR      R5,[R0, #+32]
   5005          }
   \   0000003A   0xBC70             POP      {R4-R6}
   \   0000003C   0x4770             BX       LR               ;; return
   5006          
   5007          /**
   5008            * @brief  Selects the Input Trigger source
   5009            * @param  TIMx to select the TIM peripheral
   5010            * @param  InputTriggerSource: The Input Trigger source.
   5011            *          This parameter can be one of the following values:
   5012            *            @arg TIM_TS_ITR0: Internal Trigger 0
   5013            *            @arg TIM_TS_ITR1: Internal Trigger 1
   5014            *            @arg TIM_TS_ITR2: Internal Trigger 2
   5015            *            @arg TIM_TS_ITR3: Internal Trigger 3
   5016            *            @arg TIM_TS_TI1F_ED: TI1 Edge Detector
   5017            *            @arg TIM_TS_TI1FP1: Filtered Timer Input 1
   5018            *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
   5019            *            @arg TIM_TS_ETRF: External Trigger input
   5020            * @retval None
   5021            */

   \                                 In section .text, align 2, keep-with-next
   5022          static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t InputTriggerSource)
   5023          {
   5024            uint32_t tmpsmcr = 0;
   \                     TIM_ITRx_SetConfig: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   5025          
   5026             /* Get the TIMx SMCR register value */
   5027             tmpsmcr = TIMx->SMCR;
   \   00000002   0x6883             LDR      R3,[R0, #+8]
   \   00000004   0x001A             MOVS     R2,R3
   5028             /* Reset the TS Bits */
   5029             tmpsmcr &= ~TIM_SMCR_TS;
   \   00000006   0xF032 0x0270      BICS     R2,R2,#0x70
   5030             /* Set the Input Trigger source and the slave mode*/
   5031             tmpsmcr |= InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1;
   \   0000000A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000C   0xF051 0x0307      ORRS     R3,R1,#0x7
   \   00000010   0x431A             ORRS     R2,R3,R2
   5032             /* Write to TIMx SMCR */
   5033             TIMx->SMCR = tmpsmcr;
   \   00000012   0x6082             STR      R2,[R0, #+8]
   5034          }
   \   00000014   0x4770             BX       LR               ;; return
   5035          /**
   5036            * @brief  Configures the TIMx External Trigger (ETR).
   5037            * @param  TIMx to select the TIM peripheral
   5038            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   5039            *          This parameter can be one of the following values:
   5040            *            @arg TIM_ETRPRESCALER_DIV1: ETRP Prescaler OFF.
   5041            *            @arg TIM_ETRPRESCALER_DIV2: ETRP frequency divided by 2.
   5042            *            @arg TIM_ETRPRESCALER_DIV4: ETRP frequency divided by 4.
   5043            *            @arg TIM_ETRPRESCALER_DIV8: ETRP frequency divided by 8.
   5044            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   5045            *          This parameter can be one of the following values:
   5046            *            @arg TIM_ETRPOLARITY_INVERTED: active low or falling edge active.
   5047            *            @arg TIM_ETRPOLARITY_NONINVERTED: active high or rising edge active.
   5048            * @param  ExtTRGFilter: External Trigger Filter.
   5049            *          This parameter must be a value between 0x00 and 0x0F
   5050            * @retval None
   5051            */

   \                                 In section .text, align 2, keep-with-next
   5052          static void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
   5053                                 uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
   5054          {
   \                     TIM_ETR_SetConfig: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   5055            uint32_t tmpsmcr = 0;
   \   00000002   0x2400             MOVS     R4,#+0
   5056          
   5057            tmpsmcr = TIMx->SMCR;
   \   00000004   0x6885             LDR      R5,[R0, #+8]
   \   00000006   0x002C             MOVS     R4,R5
   5058          
   5059            /* Reset the ETR Bits */
   5060            tmpsmcr &= (uint32_t)(~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP));
   \   00000008   0xF434 0x447F      BICS     R4,R4,#0xFF00
   5061          
   5062            /* Set the Prescaler, the Filter value and the Polarity */
   5063            tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8)));
   \   0000000C   0xEA52 0x0501      ORRS     R5,R2,R1
   \   00000010   0xEA55 0x2503      ORRS     R5,R5,R3, LSL #+8
   \   00000014   0x432C             ORRS     R4,R5,R4
   5064          
   5065            /* Write to TIMx SMCR */
   5066            TIMx->SMCR = tmpsmcr;
   \   00000016   0x6084             STR      R4,[R0, #+8]
   5067          }
   \   00000018   0xBC30             POP      {R4,R5}
   \   0000001A   0x4770             BX       LR               ;; return
   5068          
   5069          /**
   5070            * @brief  Enables or disables the TIM Capture Compare Channel x.
   5071            * @param  TIMx to select the TIM peripheral
   5072            * @param  Channel: specifies the TIM Channel
   5073            *          This parameter can be one of the following values:
   5074            *            @arg TIM_CHANNEL_1: TIM Channel 1
   5075            *            @arg TIM_CHANNEL_2: TIM Channel 2
   5076            *            @arg TIM_CHANNEL_3: TIM Channel 3
   5077            *            @arg TIM_CHANNEL_4: TIM Channel 4
   5078            * @param  ChannelState: specifies the TIM Channel CCxE bit new state.
   5079            *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_Disable.
   5080            * @retval None
   5081            */

   \                                 In section .text, align 2, keep-with-next
   5082          static void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
   5083          {
   \                     TIM_CCxChannelCmd: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   5084            uint32_t tmp = 0;
   \   00000002   0x2300             MOVS     R3,#+0
   5085          
   5086            /* Check the parameters */
   5087            assert_param(IS_TIM_CC1_INSTANCE(TIMx));
   5088            assert_param(IS_TIM_CHANNELS(Channel));
   5089          
   5090            tmp = TIM_CCER_CC1E << Channel;
   \   00000004   0x2401             MOVS     R4,#+1
   \   00000006   0x408C             LSLS     R4,R4,R1
   \   00000008   0x0023             MOVS     R3,R4
   5091          
   5092            /* Reset the CCxE Bit */
   5093            TIMx->CCER &= ~tmp;
   \   0000000A   0x6A04             LDR      R4,[R0, #+32]
   \   0000000C   0x439C             BICS     R4,R4,R3
   \   0000000E   0x6204             STR      R4,[R0, #+32]
   5094          
   5095            /* Set or reset the CCxE Bit */
   5096            TIMx->CCER |=  (uint32_t)(ChannelState << Channel);
   \   00000010   0x6A04             LDR      R4,[R0, #+32]
   \   00000012   0xFA12 0xF501      LSLS     R5,R2,R1
   \   00000016   0x432C             ORRS     R4,R5,R4
   \   00000018   0x6204             STR      R4,[R0, #+32]
   5097          }
   \   0000001A   0xBC30             POP      {R4,R5}
   \   0000001C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     TIM_DMAPeriodElapsedCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     TIM_DMADelayPulseCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     TIM_DMACaptureCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0xFFFFFCFC         DC32     0xfffffcfc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0xFFFFF3F3         DC32     0xfffff3f3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0xFFFF0F0F         DC32     0xffff0f0f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x40000400         DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x40000800         DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x40011000         DC32     0x40011000
   5098          
   5099          /**
   5100            * @}
   5101            */
   5102          
   5103          #endif /* HAL_TIM_MODULE_ENABLED */
   5104          /**
   5105            * @}
   5106            */
   5107          
   5108          /**
   5109            * @}
   5110            */
   5111          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_TIM_Base_DeInit
         8   -> HAL_TIM_Base_MspDeInit
       0   HAL_TIM_Base_GetState
       8   HAL_TIM_Base_Init
         8   -> HAL_TIM_Base_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_Base_MspDeInit
       0   HAL_TIM_Base_MspInit
       0   HAL_TIM_Base_Start
      16   HAL_TIM_Base_Start_DMA
        16   -> HAL_DMA_Start_IT
       0   HAL_TIM_Base_Start_IT
       0   HAL_TIM_Base_Stop
       0   HAL_TIM_Base_Stop_DMA
       0   HAL_TIM_Base_Stop_IT
      16   HAL_TIM_ConfigClockSource
        16   -> TIM_ETR_SetConfig
        16   -> TIM_ITRx_SetConfig
        16   -> TIM_TI1_ConfigInputStage
        16   -> TIM_TI2_ConfigInputStage
      16   HAL_TIM_ConfigOCrefClear
        16   -> TIM_ETR_SetConfig
       0   HAL_TIM_ConfigTI1Input
      24   HAL_TIM_DMABurst_ReadStart
        24   -> HAL_DMA_Start_IT
      16   HAL_TIM_DMABurst_ReadStop
        16   -> HAL_DMA_Abort
      24   HAL_TIM_DMABurst_WriteStart
        24   -> HAL_DMA_Start_IT
      16   HAL_TIM_DMABurst_WriteStop
        16   -> HAL_DMA_Abort
       8   HAL_TIM_Encoder_DeInit
         8   -> HAL_TIM_Encoder_MspDeInit
       0   HAL_TIM_Encoder_GetState
      24   HAL_TIM_Encoder_Init
        24   -> HAL_TIM_Encoder_MspInit
        24   -> TIM_Base_SetConfig
       0   HAL_TIM_Encoder_MspDeInit
       0   HAL_TIM_Encoder_MspInit
      16   HAL_TIM_Encoder_Start
        16   -> TIM_CCxChannelCmd
      24   HAL_TIM_Encoder_Start_DMA
        24   -> HAL_DMA_Start_IT
        24   -> TIM_CCxChannelCmd
      16   HAL_TIM_Encoder_Start_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_Encoder_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_Encoder_Stop_DMA
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_Encoder_Stop_IT
        16   -> TIM_CCxChannelCmd
       0   HAL_TIM_ErrorCallback
       0   HAL_TIM_GenerateEvent
       0   HAL_TIM_IC_CaptureCallback
      16   HAL_TIM_IC_ConfigChannel
        16   -> TIM_TI1_SetConfig
        16   -> TIM_TI2_SetConfig
        16   -> TIM_TI3_SetConfig
        16   -> TIM_TI4_SetConfig
       8   HAL_TIM_IC_DeInit
         8   -> HAL_TIM_IC_MspDeInit
       0   HAL_TIM_IC_GetState
       8   HAL_TIM_IC_Init
         8   -> HAL_TIM_IC_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_IC_MspDeInit
       0   HAL_TIM_IC_MspInit
      16   HAL_TIM_IC_Start
        16   -> TIM_CCxChannelCmd
      24   HAL_TIM_IC_Start_DMA
        24   -> HAL_DMA_Start_IT
        24   -> TIM_CCxChannelCmd
      16   HAL_TIM_IC_Start_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_IC_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_IC_Stop_DMA
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_IC_Stop_IT
        16   -> TIM_CCxChannelCmd
       8   HAL_TIM_IRQHandler
         8   -> HAL_TIM_IC_CaptureCallback
         8   -> HAL_TIM_OC_DelayElapsedCallback
         8   -> HAL_TIM_PWM_PulseFinishedCallback
         8   -> HAL_TIM_PeriodElapsedCallback
         8   -> HAL_TIM_TriggerCallback
      16   HAL_TIM_OC_ConfigChannel
        16   -> TIM_OC1_SetConfig
        16   -> TIM_OC2_SetConfig
        16   -> TIM_OC3_SetConfig
        16   -> TIM_OC4_SetConfig
       8   HAL_TIM_OC_DeInit
         8   -> HAL_TIM_OC_MspDeInit
       0   HAL_TIM_OC_DelayElapsedCallback
       0   HAL_TIM_OC_GetState
       8   HAL_TIM_OC_Init
         8   -> HAL_TIM_OC_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_OC_MspDeInit
       0   HAL_TIM_OC_MspInit
      16   HAL_TIM_OC_Start
        16   -> TIM_CCxChannelCmd
      24   HAL_TIM_OC_Start_DMA
        24   -> HAL_DMA_Start_IT
        24   -> TIM_CCxChannelCmd
      16   HAL_TIM_OC_Start_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OC_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OC_Stop_DMA
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OC_Stop_IT
        16   -> TIM_CCxChannelCmd
      40   HAL_TIM_OnePulse_ConfigChannel
        40   -> TIM_OC1_SetConfig
        40   -> TIM_OC2_SetConfig
        40   -> TIM_TI1_SetConfig
        40   -> TIM_TI2_SetConfig
       8   HAL_TIM_OnePulse_DeInit
         8   -> HAL_TIM_OnePulse_MspDeInit
       0   HAL_TIM_OnePulse_GetState
      16   HAL_TIM_OnePulse_Init
        16   -> HAL_TIM_OnePulse_MspInit
        16   -> TIM_Base_SetConfig
       0   HAL_TIM_OnePulse_MspDeInit
       0   HAL_TIM_OnePulse_MspInit
      16   HAL_TIM_OnePulse_Start
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OnePulse_Start_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OnePulse_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OnePulse_Stop_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_ConfigChannel
        16   -> TIM_OC1_SetConfig
        16   -> TIM_OC2_SetConfig
        16   -> TIM_OC3_SetConfig
        16   -> TIM_OC4_SetConfig
       8   HAL_TIM_PWM_DeInit
         8   -> HAL_TIM_PWM_MspDeInit
       0   HAL_TIM_PWM_GetState
       8   HAL_TIM_PWM_Init
         8   -> HAL_TIM_PWM_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_PWM_MspDeInit
       0   HAL_TIM_PWM_MspInit
       0   HAL_TIM_PWM_PulseFinishedCallback
      16   HAL_TIM_PWM_Start
        16   -> TIM_CCxChannelCmd
      24   HAL_TIM_PWM_Start_DMA
        24   -> HAL_DMA_Start_IT
        24   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_Start_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_Stop_DMA
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_Stop_IT
        16   -> TIM_CCxChannelCmd
       0   HAL_TIM_PeriodElapsedCallback
       0   HAL_TIM_ReadCapturedValue
      16   HAL_TIM_SlaveConfigSynchronization
        16   -> TIM_SlaveTimer_SetConfig
      16   HAL_TIM_SlaveConfigSynchronization_IT
        16   -> TIM_SlaveTimer_SetConfig
       0   HAL_TIM_TriggerCallback
       0   TIM_Base_SetConfig
       8   TIM_CCxChannelCmd
      16   TIM_DMACaptureCplt
        16   -> HAL_TIM_IC_CaptureCallback
      16   TIM_DMADelayPulseCplt
        16   -> HAL_TIM_PWM_PulseFinishedCallback
      16   TIM_DMAError
        16   -> HAL_TIM_ErrorCallback
      16   TIM_DMAPeriodElapsedCplt
        16   -> HAL_TIM_PeriodElapsedCallback
      16   TIM_DMATriggerCplt
        16   -> HAL_TIM_TriggerCallback
       8   TIM_ETR_SetConfig
       0   TIM_ITRx_SetConfig
       8   TIM_OC1_SetConfig
       8   TIM_OC2_SetConfig
       8   TIM_OC3_SetConfig
       8   TIM_OC4_SetConfig
      24   TIM_SlaveTimer_SetConfig
        24   -> TIM_ETR_SetConfig
        24   -> TIM_TI1_ConfigInputStage
        24   -> TIM_TI2_ConfigInputStage
       8   TIM_TI1_ConfigInputStage
      12   TIM_TI1_SetConfig
       8   TIM_TI2_ConfigInputStage
      12   TIM_TI2_SetConfig
      12   TIM_TI3_SetConfig
      12   TIM_TI4_SetConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
      56  HAL_TIM_Base_DeInit
       6  HAL_TIM_Base_GetState
      56  HAL_TIM_Base_Init
       2  HAL_TIM_Base_MspDeInit
       2  HAL_TIM_Base_MspInit
      30  HAL_TIM_Base_Start
     114  HAL_TIM_Base_Start_DMA
      30  HAL_TIM_Base_Start_IT
      42  HAL_TIM_Base_Stop
      48  HAL_TIM_Base_Stop_DMA
      42  HAL_TIM_Base_Stop_IT
     286  HAL_TIM_ConfigClockSource
     284  HAL_TIM_ConfigOCrefClear
      24  HAL_TIM_ConfigTI1Input
     344  HAL_TIM_DMABurst_ReadStart
     108  HAL_TIM_DMABurst_ReadStop
     344  HAL_TIM_DMABurst_WriteStart
     108  HAL_TIM_DMABurst_WriteStop
      56  HAL_TIM_Encoder_DeInit
       6  HAL_TIM_Encoder_GetState
     188  HAL_TIM_Encoder_Init
       2  HAL_TIM_Encoder_MspDeInit
       2  HAL_TIM_Encoder_MspInit
      78  HAL_TIM_Encoder_Start
     338  HAL_TIM_Encoder_Start_DMA
     126  HAL_TIM_Encoder_Start_IT
      90  HAL_TIM_Encoder_Stop
     140  HAL_TIM_Encoder_Stop_DMA
     140  HAL_TIM_Encoder_Stop_IT
       2  HAL_TIM_ErrorCallback
      46  HAL_TIM_GenerateEvent
       2  HAL_TIM_IC_CaptureCallback
     214  HAL_TIM_IC_ConfigChannel
      56  HAL_TIM_IC_DeInit
       6  HAL_TIM_IC_GetState
      56  HAL_TIM_IC_Init
       2  HAL_TIM_IC_MspDeInit
       2  HAL_TIM_IC_MspInit
      32  HAL_TIM_IC_Start
     292  HAL_TIM_IC_Start_DMA
     108  HAL_TIM_IC_Start_IT
      44  HAL_TIM_IC_Stop
     126  HAL_TIM_IC_Stop_DMA
     120  HAL_TIM_IC_Stop_IT
     314  HAL_TIM_IRQHandler
     108  HAL_TIM_OC_ConfigChannel
      56  HAL_TIM_OC_DeInit
       2  HAL_TIM_OC_DelayElapsedCallback
       6  HAL_TIM_OC_GetState
      56  HAL_TIM_OC_Init
       2  HAL_TIM_OC_MspDeInit
       2  HAL_TIM_OC_MspInit
      32  HAL_TIM_OC_Start
     292  HAL_TIM_OC_Start_DMA
     108  HAL_TIM_OC_Start_IT
      44  HAL_TIM_OC_Stop
     126  HAL_TIM_OC_Stop_DMA
     120  HAL_TIM_OC_Stop_IT
     270  HAL_TIM_OnePulse_ConfigChannel
      56  HAL_TIM_OnePulse_DeInit
       6  HAL_TIM_OnePulse_GetState
      80  HAL_TIM_OnePulse_Init
       2  HAL_TIM_OnePulse_MspDeInit
       2  HAL_TIM_OnePulse_MspInit
      30  HAL_TIM_OnePulse_Start
      54  HAL_TIM_OnePulse_Start_IT
      54  HAL_TIM_OnePulse_Stop
      78  HAL_TIM_OnePulse_Stop_IT
     256  HAL_TIM_PWM_ConfigChannel
      56  HAL_TIM_PWM_DeInit
       6  HAL_TIM_PWM_GetState
      56  HAL_TIM_PWM_Init
       2  HAL_TIM_PWM_MspDeInit
       2  HAL_TIM_PWM_MspInit
       2  HAL_TIM_PWM_PulseFinishedCallback
      32  HAL_TIM_PWM_Start
     292  HAL_TIM_PWM_Start_DMA
     108  HAL_TIM_PWM_Start_IT
      50  HAL_TIM_PWM_Stop
     126  HAL_TIM_PWM_Stop_DMA
     120  HAL_TIM_PWM_Stop_IT
       2  HAL_TIM_PeriodElapsedCallback
      84  HAL_TIM_ReadCapturedValue
      78  HAL_TIM_SlaveConfigSynchronization
      78  HAL_TIM_SlaveConfigSynchronization_IT
       2  HAL_TIM_TriggerCallback
      92  TIM_Base_SetConfig
      30  TIM_CCxChannelCmd
      70  TIM_DMACaptureCplt
      70  TIM_DMADelayPulseCplt
      20  TIM_DMAError
      20  TIM_DMAPeriodElapsedCplt
      20  TIM_DMATriggerCplt
      28  TIM_ETR_SetConfig
      22  TIM_ITRx_SetConfig
      62  TIM_OC1_SetConfig
      66  TIM_OC2_SetConfig
      64  TIM_OC3_SetConfig
      66  TIM_OC4_SetConfig
     180  TIM_SlaveTimer_SetConfig
      44  TIM_TI1_ConfigInputStage
     100  TIM_TI1_SetConfig
      46  TIM_TI2_ConfigInputStage
      62  TIM_TI2_SetConfig
      60  TIM_TI3_SetConfig
      62  TIM_TI4_SetConfig

 
 8 688 bytes in section .text
 
 8 652 bytes of CODE memory (+ 36 bytes shared)

Errors: none
Warnings: none
