###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       29/Jan/2018  14:45:26
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_rcc_ex.c
#    Command line =  
#        "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_rcc_ex.c"
#        -D STM32L151xB -D STM32L1XX_XL -D USE_STM32L1XX_STEVAL_IDB00xV1 -D
#        USE_HAL_DRIVER -D HCLK_32MHZ=1 -D SYSCLK_MSI=1 -D ENABLE_USART -D
#        USER_DEFINED_PLATFORM=USER_EVAL_PLATFORM -D IRQ_RESET_PIN -D DTM_UART
#        -lC "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\List"
#        -o "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        D:\Software\IAR_BlueNRG\arm\INC\c\DLib_Config_Normal.h -I
#        "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\HAL\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\BSP\STM32L1xx_BlueNRG1\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\BSP\STM32L1xx_Nucleo\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\CMSIS\Device\ST\STM32L1xx\Include\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\STM32L1xx_HAL_BlueNRG1_Drivers\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\SimpleBlueNRG1_HCI\includes\"
#        -On --use_c++_inline -I D:\Software\IAR_BlueNRG\arm\CMSIS\Include\
#    Locale       =  Chinese (Simplified)_China.936
#    List file    =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\List\stm32l1xx_hal_rcc_ex.lst
#    Object file  =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\Obj\stm32l1xx_hal_rcc_ex.o
#
###############################################################################

C:\Users\Administrator\Desktop\Temporary Files\eeworld_project\Project_Test\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_rcc_ex.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_hal_rcc_ex.c
      4            * @author  MCD Application Team
      5            * @version V1.1.1
      6            * @date    31-March-2015
      7            * @brief   Extended RCC HAL module driver.
      8            *    
      9            *          This file provides firmware functions to manage the following 
     10            *          functionalities RCC extension peripheral:
     11            *           + Extended Peripheral Control functions
     12            *  
     13            ******************************************************************************
     14            * @attention
     15            *
     16            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     17            *
     18            * Redistribution and use in source and binary forms, with or without modification,
     19            * are permitted provided that the following conditions are met:
     20            *   1. Redistributions of source code must retain the above copyright notice,
     21            *      this list of conditions and the following disclaimer.
     22            *   2. Redistributions in binary form must reproduce the above copyright notice,
     23            *      this list of conditions and the following disclaimer in the documentation
     24            *      and/or other materials provided with the distribution.
     25            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     26            *      may be used to endorse or promote products derived from this software
     27            *      without specific prior written permission.
     28            *
     29            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     30            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     31            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     32            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     33            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     34            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     35            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     36            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     37            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     38            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     39            *
     40            ******************************************************************************  
     41            */ 
     42          
     43          /* Includes ------------------------------------------------------------------*/
     44          #include "stm32l1xx_hal.h"
     45          
     46          /** @addtogroup STM32L1xx_HAL_Driver
     47            * @{
     48            */
     49          
     50          #ifdef HAL_RCC_MODULE_ENABLED
     51          
     52          
     53          /** @defgroup RCCEx RCCEx
     54            * @brief RCC Extension HAL module driver
     55            * @{
     56            */
     57          
     58          /* Private typedef -----------------------------------------------------------*/
     59          /* Private define ------------------------------------------------------------*/
     60          /** @defgroup RCCEx_Private_Constants RCCEx Private Constants
     61            * @{
     62            */
     63          /**
     64            * @}
     65            */
     66            
     67          /* Private macro -------------------------------------------------------------*/
     68          /** @defgroup RCCEx_Private_Macros RCCEx Private Macros
     69            * @{
     70            */
     71          /**
     72            * @}
     73            */
     74          
     75          /* Private variables ---------------------------------------------------------*/
     76          /* Private function prototypes -----------------------------------------------*/
     77          /* Private functions ---------------------------------------------------------*/
     78          
     79          /** @defgroup RCCEx_Exported_Functions RCCEx Exported Functions
     80            * @{
     81            */
     82          
     83          /** @defgroup RCCEx_Exported_Functions_Group1 Extended Peripheral Control functions 
     84           *  @brief  Extended Peripheral Control functions  
     85           *
     86          @verbatim   
     87           ===============================================================================
     88                          ##### Extended Peripheral Control functions  #####
     89           ===============================================================================  
     90              [..]
     91              This subsection provides a set of functions allowing to control the RCC Clocks 
     92              frequencies.
     93              [..] 
     94              (@) Important note: Care must be taken when HAL_RCCEx_PeriphCLKConfig() is used to
     95                  select the RTC clock source; in this case the Backup domain will be reset in  
     96                  order to modify the RTC Clock source, as consequence RTC registers (including 
     97                  the backup registers) and RCC_BDCR register are set to their reset values.
     98                
     99          @endverbatim
    100            * @{
    101            */
    102          
    103          /**
    104            * @brief  Initializes the RCC extended peripherals clocks according to the specified parameters in the
    105            *         RCC_PeriphCLKInitTypeDef.
    106            * @param  PeriphClkInit: pointer to an RCC_PeriphCLKInitTypeDef structure that
    107            *         contains the configuration information for the Extended Peripherals clocks(RTC/LCD clock).
    108            * @retval HAL status
    109            */

   \                                 In section .text, align 2, keep-with-next
    110          HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
    111          {
   \                     HAL_RCCEx_PeriphCLKConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    112            uint32_t tickstart = 0;
   \   00000006   0x2500             MOVS     R5,#+0
    113            uint32_t tmp_reg = 0;
   \   00000008   0x2600             MOVS     R6,#+0
    114            
    115            /* Check the parameters */
    116            assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
    117            
    118            /*------------------------------- RTC/LCD Configuration ------------------------*/ 
    119            if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC) 
    120          #if defined(STM32L100xB) || defined(STM32L100xBA) || defined(STM32L100xC)\
    121           || defined(STM32L152xB) || defined(STM32L152xBA) || defined(STM32L152xC)\
    122           || defined(STM32L162xC) || defined(STM32L152xCA) || defined(STM32L152xD)\
    123           || defined(STM32L162xCA) || defined(STM32L162xD) || defined(STM32L152xE) || defined(STM32L152xDX)\
    124           || defined(STM32L162xE) || defined(STM32L162xDX)
    125                || (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LCD) == RCC_PERIPHCLK_LCD)
    126          #endif /* STM32L100xB || STM32L152xBA || ... || STM32L152xE || STM32L152xDX || STM32L162xE || STM32L162xDX */
    127              )
   \   0000000A   0x7820             LDRB     R0,[R4, #+0]
   \   0000000C   0x07C0             LSLS     R0,R0,#+31
   \   0000000E   0xF140 0x807F      BPL.W    ??HAL_RCCEx_PeriphCLKConfig_0
    128            {
    129              /* check for RTC Parameters used to output RTCCLK */
    130              if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
   \   00000012   0x7820             LDRB     R0,[R4, #+0]
   \   00000014   0x07C0             LSLS     R0,R0,#+31
    131              {
    132                assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
    133              }
    134          
    135          #if defined(STM32L100xB) || defined(STM32L100xBA) || defined(STM32L100xC)\
    136           || defined(STM32L152xB) || defined(STM32L152xBA) || defined(STM32L152xC)\
    137           || defined(STM32L162xC) || defined(STM32L152xCA) || defined(STM32L152xD)\
    138           || defined(STM32L162xCA) || defined(STM32L162xD) || defined(STM32L152xE) || defined(STM32L152xDX)\
    139           || defined(STM32L162xE) || defined(STM32L162xDX)
    140              if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LCD) == RCC_PERIPHCLK_LCD)
    141              {
    142                assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->LCDClockSelection));
    143              }
    144          #endif /* STM32L100xB || STM32L152xBA || ... || STM32L152xE || STM32L152xDX || STM32L162xE || STM32L162xDX */
    145          
    146              /* Enable Power Controller clock */
    147              __HAL_RCC_PWR_CLK_ENABLE();
   \                     ??HAL_RCCEx_PeriphCLKConfig_1: (+1)
   \   00000016   0x....             LDR.N    R0,??DataTable2  ;; 0x40023824
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   0000001E   0x....             LDR.N    R1,??DataTable2  ;; 0x40023824
   \   00000020   0x6008             STR      R0,[R1, #+0]
   \   00000022   0x....             LDR.N    R0,??DataTable2  ;; 0x40023824
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF010 0x5080      ANDS     R0,R0,#0x10000000
   \   0000002A   0x9000             STR      R0,[SP, #+0]
   \   0000002C   0x9800             LDR      R0,[SP, #+0]
    148              
    149              /* Enable write access to Backup domain */
    150              SET_BIT(PWR->CR, PWR_CR_DBP);
   \   0000002E   0x....             LDR.N    R0,??DataTable2_1  ;; 0x40007000
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000036   0x....             LDR.N    R1,??DataTable2_1  ;; 0x40007000
   \   00000038   0x6008             STR      R0,[R1, #+0]
    151              
    152              /* Wait for Backup domain Write protection disable */
    153              tickstart = HAL_GetTick();
   \   0000003A   0x.... 0x....      BL       HAL_GetTick
   \   0000003E   0x0005             MOVS     R5,R0
    154              
    155              while((PWR->CR & PWR_CR_DBP) == RESET)
   \                     ??HAL_RCCEx_PeriphCLKConfig_2: (+1)
   \   00000040   0x....             LDR.N    R0,??DataTable2_1  ;; 0x40007000
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x05C0             LSLS     R0,R0,#+23
   \   00000046   0xD406             BMI.N    ??HAL_RCCEx_PeriphCLKConfig_3
    156              {
    157                if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
   \   00000048   0x.... 0x....      BL       HAL_GetTick
   \   0000004C   0x1B40             SUBS     R0,R0,R5
   \   0000004E   0x2865             CMP      R0,#+101
   \   00000050   0xD3F6             BCC.N    ??HAL_RCCEx_PeriphCLKConfig_2
    158                {
    159                  return HAL_TIMEOUT;
   \   00000052   0x2003             MOVS     R0,#+3
   \   00000054   0xE05D             B.N      ??HAL_RCCEx_PeriphCLKConfig_4
    160                }
    161              }
    162              
    163              /* Reset the Backup domain only if the RTC Clock source selection is modified */ 
    164              tmp_reg = (RCC->CSR & RCC_CSR_RTCSEL);
   \                     ??HAL_RCCEx_PeriphCLKConfig_3: (+1)
   \   00000056   0x....             LDR.N    R0,??DataTable2_2  ;; 0x40023834
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0xF410 0x3040      ANDS     R0,R0,#0x30000
   \   0000005E   0x0006             MOVS     R6,R0
    165              
    166              if(((tmp_reg != (PeriphClkInit->RTCClockSelection & RCC_CSR_RTCSEL)) \
    167                && (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))
    168          #if defined(STM32L100xB) || defined(STM32L100xBA) || defined(STM32L100xC)\
    169           || defined(STM32L152xB) || defined(STM32L152xBA) || defined(STM32L152xC)\
    170           || defined(STM32L162xC) || defined(STM32L152xCA) || defined(STM32L152xD)\
    171           || defined(STM32L162xCA) || defined(STM32L162xD) || defined(STM32L152xE) || defined(STM32L152xDX)\
    172           || defined(STM32L162xE) || defined(STM32L162xDX)
    173                || ((tmp_reg != (PeriphClkInit->LCDClockSelection & RCC_CSR_RTCSEL)) \
    174                 && (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LCD) == RCC_PERIPHCLK_LCD))
    175          #endif /* STM32L100xB || STM32L152xBA || ... || STM32L152xE || STM32L152xDX || STM32L162xE || STM32L162xDX */
    176               )
   \   00000060   0x6860             LDR      R0,[R4, #+4]
   \   00000062   0xF410 0x3040      ANDS     R0,R0,#0x30000
   \   00000066   0x4286             CMP      R6,R0
   \   00000068   0xD01B             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_5
   \   0000006A   0x7820             LDRB     R0,[R4, #+0]
   \   0000006C   0x07C0             LSLS     R0,R0,#+31
   \   0000006E   0xD518             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_5
    177              {
    178                /* Store the content of CSR register before the reset of Backup Domain */
    179                tmp_reg = (RCC->CSR & ~(RCC_CSR_RTCSEL));
   \   00000070   0x....             LDR.N    R0,??DataTable2_2  ;; 0x40023834
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0xF430 0x3040      BICS     R0,R0,#0x30000
   \   00000078   0x0006             MOVS     R6,R0
    180                
    181                /* RTC Clock selection can be changed only if the Backup Domain is reset */
    182                __HAL_RCC_BACKUPRESET_FORCE();
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0xF44F 0x7180      MOV      R1,#+256
   \   00000080   0xFAB1 0xF181      CLZ      R1,R1
   \   00000084   0x....             LDR.N    R2,??DataTable2_3  ;; 0x42470680
   \   00000086   0xEB12 0x0181      ADDS     R1,R2,R1, LSL #+2
   \   0000008A   0x6008             STR      R0,[R1, #+0]
    183                __HAL_RCC_BACKUPRESET_RELEASE();
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xF44F 0x7180      MOV      R1,#+256
   \   00000092   0xFAB1 0xF181      CLZ      R1,R1
   \   00000096   0x....             LDR.N    R2,??DataTable2_3  ;; 0x42470680
   \   00000098   0xEB12 0x0181      ADDS     R1,R2,R1, LSL #+2
   \   0000009C   0x6008             STR      R0,[R1, #+0]
    184                
    185                /* Restore the Content of CSR register */
    186                RCC->CSR = tmp_reg;
   \   0000009E   0x....             LDR.N    R0,??DataTable2_2  ;; 0x40023834
   \   000000A0   0x6006             STR      R6,[R0, #+0]
    187              }
    188              
    189              /* If LSE is selected as RTC clock source, wait for LSE reactivation */
    190              if ((PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
    191          #if defined(STM32L100xB) || defined(STM32L100xBA) || defined(STM32L100xC)\
    192           || defined(STM32L152xB) || defined(STM32L152xBA) || defined(STM32L152xC)\
    193           || defined(STM32L162xC) || defined(STM32L152xCA) || defined(STM32L152xD)\
    194           || defined(STM32L162xCA) || defined(STM32L162xD) || defined(STM32L152xE) || defined(STM32L152xDX)\
    195           || defined(STM32L162xE) || defined(STM32L162xDX)
    196                || (PeriphClkInit->LCDClockSelection == RCC_RTCCLKSOURCE_LSE)
    197          #endif /* STM32L100xB || STM32L152xBA || ... || STM32L152xE || STM32L152xDX || STM32L162xE || STM32L162xDX */
    198                )
   \                     ??HAL_RCCEx_PeriphCLKConfig_5: (+1)
   \   000000A2   0x6860             LDR      R0,[R4, #+4]
   \   000000A4   0xF5B0 0x3F80      CMP      R0,#+65536
   \   000000A8   0xD11A             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_6
    199              {
    200                /* Get timeout */   
    201                tickstart = HAL_GetTick();
   \   000000AA   0x.... 0x....      BL       HAL_GetTick
   \   000000AE   0x0005             MOVS     R5,R0
    202                
    203                /* Wait till LSE is ready */  
    204                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
   \                     ??HAL_RCCEx_PeriphCLKConfig_7: (+1)
   \   000000B0   0xF45F 0x0080      MOVS     R0,#+4194304
   \   000000B4   0xFAB0 0xF080      CLZ      R0,R0
   \   000000B8   0x....             LDR.N    R0,??DataTable2_2  ;; 0x40023834
   \   000000BA   0x6800             LDR      R0,[R0, #+0]
   \   000000BC   0xF45F 0x0180      MOVS     R1,#+4194304
   \   000000C0   0xFAB1 0xF181      CLZ      R1,R1
   \   000000C4   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000000C8   0x40C8             LSRS     R0,R0,R1
   \   000000CA   0x07C0             LSLS     R0,R0,#+31
   \   000000CC   0xD408             BMI.N    ??HAL_RCCEx_PeriphCLKConfig_6
    205                {
    206                  if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
   \   000000CE   0x.... 0x....      BL       HAL_GetTick
   \   000000D2   0x1B40             SUBS     R0,R0,R5
   \   000000D4   0xF241 0x3189      MOVW     R1,#+5001
   \   000000D8   0x4288             CMP      R0,R1
   \   000000DA   0xD3E9             BCC.N    ??HAL_RCCEx_PeriphCLKConfig_7
    207                  {
    208                    return HAL_TIMEOUT;
   \   000000DC   0x2003             MOVS     R0,#+3
   \   000000DE   0xE018             B.N      ??HAL_RCCEx_PeriphCLKConfig_4
    209                  }
    210                }
    211              }
    212              
    213              __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
   \                     ??HAL_RCCEx_PeriphCLKConfig_6: (+1)
   \   000000E0   0x6860             LDR      R0,[R4, #+4]
   \   000000E2   0xF410 0x3040      ANDS     R0,R0,#0x30000
   \   000000E6   0xF5B0 0x3F40      CMP      R0,#+196608
   \   000000EA   0xD109             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_8
   \   000000EC   0x....             LDR.N    R0,??DataTable2_4  ;; 0x40023800
   \   000000EE   0x6800             LDR      R0,[R0, #+0]
   \   000000F0   0xF030 0x40C0      BICS     R0,R0,#0x60000000
   \   000000F4   0x6861             LDR      R1,[R4, #+4]
   \   000000F6   0xF011 0x41C0      ANDS     R1,R1,#0x60000000
   \   000000FA   0x4308             ORRS     R0,R1,R0
   \   000000FC   0x....             LDR.N    R1,??DataTable2_4  ;; 0x40023800
   \   000000FE   0x6008             STR      R0,[R1, #+0]
   \                     ??HAL_RCCEx_PeriphCLKConfig_8: (+1)
   \   00000100   0x....             LDR.N    R0,??DataTable2_2  ;; 0x40023834
   \   00000102   0x6800             LDR      R0,[R0, #+0]
   \   00000104   0x6861             LDR      R1,[R4, #+4]
   \   00000106   0xF411 0x3140      ANDS     R1,R1,#0x30000
   \   0000010A   0x4308             ORRS     R0,R1,R0
   \   0000010C   0x....             LDR.N    R1,??DataTable2_2  ;; 0x40023834
   \   0000010E   0x6008             STR      R0,[R1, #+0]
    214            }
    215            
    216            return HAL_OK;
   \                     ??HAL_RCCEx_PeriphCLKConfig_0: (+1)
   \   00000110   0x2000             MOVS     R0,#+0
   \                     ??HAL_RCCEx_PeriphCLKConfig_4: (+1)
   \   00000112   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    217          }
    218          
    219          /**
    220            * @brief  Get the PeriphClkInit according to the internal
    221            * RCC configuration registers.
    222            * @param  PeriphClkInit: pointer to an RCC_PeriphCLKInitTypeDef structure that 
    223            *         returns the configuration information for the Extended Peripherals clocks(RTC/LCD clocks).
    224            * @retval None
    225            */

   \                                 In section .text, align 2, keep-with-next
    226          void HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
    227          {
    228            uint32_t srcclk = 0;
   \                     HAL_RCCEx_GetPeriphCLKConfig: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    229            
    230            /* Set all possible values for the extended clock type parameter------------*/
    231            PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_RTC;
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x6002             STR      R2,[R0, #+0]
    232          #if defined(STM32L100xB) || defined(STM32L100xBA) || defined(STM32L100xC)\
    233           || defined(STM32L152xB) || defined(STM32L152xBA) || defined(STM32L152xC)\
    234           || defined(STM32L162xC) || defined(STM32L152xCA) || defined(STM32L152xD)\
    235           || defined(STM32L162xCA) || defined(STM32L162xD) || defined(STM32L152xE) || defined(STM32L152xDX)\
    236           || defined(STM32L162xE) || defined(STM32L162xDX)
    237            PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_LCD;
    238          #endif /* STM32L100xB || STM32L152xBA || ... || STM32L152xE || STM32L152xDX || STM32L162xE || STM32L162xDX */
    239          
    240            /* Get the RTC/LCD configuration -----------------------------------------------*/
    241            srcclk = __HAL_RCC_GET_RTC_SOURCE();
   \   00000006   0x....             LDR.N    R2,??DataTable2_2  ;; 0x40023834
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0xF412 0x3240      ANDS     R2,R2,#0x30000
   \   0000000E   0x0011             MOVS     R1,R2
    242            if (srcclk != RCC_RTCCLKSOURCE_HSE_DIV2)
   \   00000010   0xF5B1 0x3F40      CMP      R1,#+196608
   \   00000014   0xD001             BEQ.N    ??HAL_RCCEx_GetPeriphCLKConfig_0
    243            {
    244              /* Source clock is LSE or LSI*/
    245              PeriphClkInit->RTCClockSelection = srcclk;
   \   00000016   0x6041             STR      R1,[R0, #+4]
   \   00000018   0xE005             B.N      ??HAL_RCCEx_GetPeriphCLKConfig_1
    246            }
    247            else
    248            {
    249              /* Source clock is HSE. Need to get the prescaler value*/
    250              PeriphClkInit->RTCClockSelection = srcclk | (READ_BIT(RCC->CR, RCC_CR_RTCPRE));
   \                     ??HAL_RCCEx_GetPeriphCLKConfig_0: (+1)
   \   0000001A   0x....             LDR.N    R2,??DataTable2_4  ;; 0x40023800
   \   0000001C   0x6812             LDR      R2,[R2, #+0]
   \   0000001E   0xF012 0x42C0      ANDS     R2,R2,#0x60000000
   \   00000022   0x430A             ORRS     R2,R2,R1
   \   00000024   0x6042             STR      R2,[R0, #+4]
    251            }
    252          #if defined(STM32L100xB) || defined(STM32L100xBA) || defined(STM32L100xC)\
    253           || defined(STM32L152xB) || defined(STM32L152xBA) || defined(STM32L152xC)\
    254           || defined(STM32L162xC) || defined(STM32L152xCA) || defined(STM32L152xD)\
    255           || defined(STM32L162xCA) || defined(STM32L162xD) || defined(STM32L152xE) || defined(STM32L152xDX)\
    256           || defined(STM32L162xE) || defined(STM32L162xDX)
    257            PeriphClkInit->LCDClockSelection = PeriphClkInit->RTCClockSelection;
    258          #endif /* STM32L100xB || STM32L152xBA || ... || STM32L152xE || STM32L152xDX || STM32L162xE || STM32L162xDX */
    259          }
   \                     ??HAL_RCCEx_GetPeriphCLKConfig_1: (+1)
   \   00000026   0x4770             BX       LR               ;; return
    260          
    261          /**
    262            * @brief  Returns the peripheral clock frequency
    263            * @note   Returns 0 if peripheral clock is unknown
    264            * @param  PeriphClk: Peripheral clock identifier
    265            *         This parameter can be one of the following values:
    266            *            @arg RCC_PERIPHCLK_RTC:  RTC peripheral clock
    267            *            @arg RCC_PERIPHCLK_LCD:  LCD peripheral clock (depends on devices)
    268            * @retval Frequency in Hz (0: means that no available frequency for the peripheral)
    269            */

   \                                 In section .text, align 2, keep-with-next
    270          uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
    271          {
   \                     HAL_RCCEx_GetPeriphCLKFreq: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0001             MOVS     R1,R0
    272            uint32_t tmp_reg = 0, frequency = 0;
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2000             MOVS     R0,#+0
    273            uint32_t srcclk = 0;
   \   00000008   0x2300             MOVS     R3,#+0
    274          
    275            /* Check the parameters */
    276            assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));
    277            
    278            switch (PeriphClk)
   \   0000000A   0x2901             CMP      R1,#+1
   \   0000000C   0xD139             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_0
    279            {
    280            case RCC_PERIPHCLK_RTC:
    281          #if defined(STM32L100xB) || defined(STM32L100xBA) || defined(STM32L100xC)\
    282           || defined(STM32L152xB) || defined(STM32L152xBA) || defined(STM32L152xC)\
    283           || defined(STM32L162xC) || defined(STM32L152xCA) || defined(STM32L152xD)\
    284           || defined(STM32L162xCA) || defined(STM32L162xD) || defined(STM32L152xE) || defined(STM32L152xDX)\
    285           || defined(STM32L162xE) || defined(STM32L162xDX)
    286            case RCC_PERIPHCLK_LCD:
    287          #endif /* STM32L100xB || STM32L152xBA || ... || STM32L152xE || STM32L152xDX || STM32L162xE || STM32L162xDX */
    288              {
    289                /* Get RCC CSR configuration ------------------------------------------------------*/
    290                tmp_reg = RCC->CSR;
   \   0000000E   0x....             LDR.N    R4,??DataTable2_2  ;; 0x40023834
   \   00000010   0x6824             LDR      R4,[R4, #+0]
   \   00000012   0x0022             MOVS     R2,R4
    291          
    292                /* Get the current RTC source */
    293                srcclk = __HAL_RCC_GET_RTC_SOURCE();
   \   00000014   0x....             LDR.N    R4,??DataTable2_2  ;; 0x40023834
   \   00000016   0x6824             LDR      R4,[R4, #+0]
   \   00000018   0xF414 0x3440      ANDS     R4,R4,#0x30000
   \   0000001C   0x0023             MOVS     R3,R4
    294          
    295                /* Check if LSE is ready if RTC clock selection is LSE */
    296                if ((srcclk == RCC_RTCCLKSOURCE_LSE) && (HAL_IS_BIT_SET(tmp_reg, RCC_CSR_LSERDY)))
   \   0000001E   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000022   0xD105             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_1
   \   00000024   0x0594             LSLS     R4,R2,#+22
   \   00000026   0xD503             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_1
    297                {
    298                  frequency = LSE_VALUE;
   \   00000028   0xF44F 0x4400      MOV      R4,#+32768
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0xE027             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_2
    299                }
    300                /* Check if LSI is ready if RTC clock selection is LSI */
    301                else if ((srcclk == RCC_RTCCLKSOURCE_LSI) && (HAL_IS_BIT_SET(tmp_reg, RCC_CSR_LSIRDY)))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_1: (+1)
   \   00000030   0xF5B3 0x3F00      CMP      R3,#+131072
   \   00000034   0xD105             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_3
   \   00000036   0x0794             LSLS     R4,R2,#+30
   \   00000038   0xD503             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_3
    302                {
    303                  frequency = LSI_VALUE;
   \   0000003A   0xF249 0x0488      MOVW     R4,#+37000
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0xE01E             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_2
    304                }
    305                /* Check if HSE is ready */
    306                else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_3: (+1)
   \   00000042   0x....             LDR.N    R4,??DataTable2_4  ;; 0x40023800
   \   00000044   0x6824             LDR      R4,[R4, #+0]
   \   00000046   0x03A4             LSLS     R4,R4,#+14
   \   00000048   0xD518             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_4
    307                {
    308                  switch (READ_BIT(RCC->CR, RCC_CR_RTCPRE))
   \   0000004A   0x....             LDR.N    R4,??DataTable2_4  ;; 0x40023800
   \   0000004C   0x6824             LDR      R4,[R4, #+0]
   \   0000004E   0xF014 0x44C0      ANDS     R4,R4,#0x60000000
   \   00000052   0xF1B4 0x5F00      CMP      R4,#+536870912
   \   00000056   0xD00B             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_5
   \   00000058   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000005C   0xD005             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_6
   \   0000005E   0xF1B4 0x4FC0      CMP      R4,#+1610612736
   \   00000062   0xD108             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_7
    309                  {
    310                    case RCC_CR_RTCPRE:     /* HSE DIV16 has been selected */
    311                    {
    312                      frequency = HSE_VALUE / 16;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_8: (+1)
   \   00000064   0x....             LDR.N    R4,??DataTable2_5  ;; 0x7a120
   \   00000066   0x0020             MOVS     R0,R4
    313                      break;
   \   00000068   0xE00A             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_2
    314                    }
    315                    case RCC_CR_RTCPRE_1:   /* HSE DIV8 has been selected */
    316                    {
    317                      frequency = HSE_VALUE / 8;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_6: (+1)
   \   0000006A   0x....             LDR.N    R4,??DataTable2_6  ;; 0xf4240
   \   0000006C   0x0020             MOVS     R0,R4
    318                      break;
   \   0000006E   0xE007             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_2
    319                    }
    320                    case RCC_CR_RTCPRE_0:   /* HSE DIV4 has been selected */
    321                    {
    322                      frequency = HSE_VALUE / 4;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_5: (+1)
   \   00000070   0x....             LDR.N    R4,??DataTable2_7  ;; 0x1e8480
   \   00000072   0x0020             MOVS     R0,R4
    323                      break;
   \   00000074   0xE004             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_2
    324                    }
    325                    default:
    326                    {
    327                      frequency = HSE_VALUE / 2;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_7: (+1)
   \   00000076   0x....             LDR.N    R4,??DataTable2_8  ;; 0x3d0900
   \   00000078   0x0020             MOVS     R0,R4
    328                      break;
   \   0000007A   0xE001             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_2
    329                    }
    330                  }
    331                }
    332                /* Clock not enabled for RTC*/
    333                else
    334                {
    335                  frequency = 0;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_4: (+1)
   \   0000007C   0x2400             MOVS     R4,#+0
   \   0000007E   0x0020             MOVS     R0,R4
    336                }
    337                break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_2: (+1)
   \   00000080   0xE7FF             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_9
    338              }
    339            default: 
    340              {
    341                break;
    342              }
    343            }
    344            return(frequency);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_0: (+1)
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_9: (+1)
   \   00000082   0xBC10             POP      {R4}
   \   00000084   0x4770             BX       LR               ;; return
    345          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x40023824         DC32     0x40023824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x40007000         DC32     0x40007000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x40023834         DC32     0x40023834

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x42470680         DC32     0x42470680

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x40023800         DC32     0x40023800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x0007A120         DC32     0x7a120

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   0x001E8480         DC32     0x1e8480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \   00000000   0x003D0900         DC32     0x3d0900
    346          
    347          #if  (defined(STM32L100xBA) || defined(STM32L151xBA) || defined(STM32L152xBA) || defined(STM32L100xC) || defined(STM32L151xC) || defined(STM32L152xC) || defined(STM32L162xC) || defined(STM32L151xCA) || defined(STM32L151xD) || defined(STM32L152xCA) || defined(STM32L152xD) || defined(STM32L162xCA) || defined(STM32L162xD) || defined(STM32L151xE) || defined(STM32L151xDX) || defined(STM32L152xE) || defined(STM32L152xDX) || defined(STM32L162xE) || defined(STM32L162xDX))
    348          
    349          /**
    350            * @brief  Enables the LSE Clock Security System.
    351            * @note   If a failure is detected on the external 32 kHz oscillator, the LSE clock is no longer supplied
    352            *         to the RTC but no hardware action is made to the registers.
    353            *         In Standby mode a wakeup is generated. In other modes an interrupt can be sent to wakeup
    354            *         the software (see Section 5.3.4: Clock interrupt register (RCC_CIR) on page 104).
    355            *         The software MUST then disable the LSECSSON bit, stop the defective 32 kHz oscillator
    356            *         (disabling LSEON), and can change the RTC clock source (no clock or LSI or HSE, with
    357            *         RTCSEL), or take any required action to secure the application.  
    358            * @note   LSE CSS available only for high density and medium+ devices
    359            * @retval None
    360            */
    361          void HAL_RCCEx_EnableLSECSS(void)
    362          {
    363            *(__IO uint32_t *) CSR_LSECSSON_BB = (uint32_t)ENABLE;
    364          }
    365          
    366          /**
    367            * @brief  Disables the LSE Clock Security System.
    368            * @note   Once enabled this bit cannot be disabled, except after an LSE failure detection 
    369            *         (LSECSSD=1). In that case the software MUST disable the LSECSSON bit.
    370            *         Reset by power on reset and RTC software reset (RTCRST bit).
    371            * @note   LSE CSS available only for high density and medium+ devices
    372            * @retval None
    373            */
    374          void HAL_RCCEx_DisableLSECSS(void)
    375          {
    376            *(__IO uint32_t *) CSR_LSECSSON_BB = (uint32_t)DISABLE;
    377          }
    378          #endif /* STM32L100xBA || STM32L151xBA || STM32L152xBA || STM32L100xC || STM32L151xC || STM32L152xC || STM32L162xC || STM32L151xCA || STM32L151xD || STM32L152xCA || STM32L152xD || STM32L162xCA || STM32L162xD || STM32L151xE || STM32L152xE || STM32L152xDX || STM32L162xE || STM32L162xDX */
    379            
    380          /**
    381            * @}
    382            */
    383          
    384          /**
    385            * @}
    386            */
    387          
    388          /**
    389            * @}
    390            */
    391          
    392          #endif /* HAL_RCC_MODULE_ENABLED */
    393          /**
    394            * @}
    395            */
    396          
    397          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_RCCEx_GetPeriphCLKConfig
       4   HAL_RCCEx_GetPeriphCLKFreq
      24   HAL_RCCEx_PeriphCLKConfig
        24   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
      40  HAL_RCCEx_GetPeriphCLKConfig
     134  HAL_RCCEx_GetPeriphCLKFreq
     276  HAL_RCCEx_PeriphCLKConfig

 
 486 bytes in section .text
 
 486 bytes of CODE memory

Errors: none
Warnings: none
