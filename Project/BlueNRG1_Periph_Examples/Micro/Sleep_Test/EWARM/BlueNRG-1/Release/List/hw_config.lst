###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       29/Nov/2017  10:11:20
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\hw_config.c
#    Command line =  
#        "D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\hw_config.c"
#        -D HS_SPEED_XTAL=HS_SPEED_XTAL_16MHZ -D
#        LS_SOURCE=LS_SOURCE_EXTERNAL_32KHZ -D SMPS_INDUCTOR=SMPS_INDUCTOR_10uH
#        --preprocess=cl "D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2
#        DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\Release\List"
#        -lCN "D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\Release\List"
#        -lb "D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\Release\List"
#        --diag_suppress Pe1665 -o "D:\Program Files
#        (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\Release\Obj"
#        --debug --endian=little --cpu=Cortex-M0 --diag_warning Pe1665
#        --diag_suppress Pe1665 -e --fpu=None --dlib_config
#        D:\Software\IAR_BlueNRG\arm\INC\c\DLib_Config_Normal.h -I "D:\Program
#        Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\..\..\"
#        -I "D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\..\..\..\..\..\..\Library\BlueNRG1_Periph_Driver\inc\"
#        -I "D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\..\..\..\..\..\..\Library\CMSIS\Device\ST\BlueNRG1\Include\"
#        -I "D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\..\..\..\..\..\..\Library\SDK_Eval_BlueNRG1\inc\"
#        -I "D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\..\..\..\..\..\..\Library\CMSIS\Include\"
#        -I "D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\..\..\..\..\..\..\Library\hal\inc\"
#        -I "D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\..\..\..\..\..\..\Library\Bluetooth_LE\inc\"
#        -Ohz
#    Locale       =  Chinese (Simplified)_China.936
#    List file    =  
#        D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\Release\List\hw_config.lst
#    Object file  =  
#        D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\Release\Obj\hw_config.o
#
###############################################################################

D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK 2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\hw_config.c
      1          /**
      2          ******************************************************************************
      3          * @file    hw_config.c
      4          * @author  VMA RF Application Team
      5          * @version V1.0.0
      6          * @date    September-2015
      7          * @brief   HW configuration
      8          ******************************************************************************
      9          * @attention
     10          *
     11          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13          * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14          * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15          * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16          * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17          *
     18          * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     19          ******************************************************************************
     20          */ 
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          
     24          #include "BlueNRG_x_device.h"
     25          #include "BlueNRG1_it.h"
     26          #include "BlueNRG1_conf.h"
     27          #include "SDK_EVAL_Led.h"
     28          
     29          /** @addtogroup BlueNRG1_StdPeriph_Examples
     30          * @{
     31          */
     32          
     33          /** @addtogroup UART Interrupt Example
     34          * @{
     35          */
     36          
     37          /* Private typedef -----------------------------------------------------------*/
     38          /* Private define ------------------------------------------------------------*/
     39          /* Private macro -------------------------------------------------------------*/
     40          /* Private variables ---------------------------------------------------------*/
     41          /* Private function prototypes -----------------------------------------------*/
     42          void NVIC_Configuration(uint8_t enable);
     43          void GPIO_Configuration(void);
     44          void UART_Configuration(void);
     45          
     46          /* Private functions ---------------------------------------------------------*/
     47          
     48          /**
     49          * @brief  Configures the nested vectored interrupt controller.
     50          * @param  None
     51          * @retval None
     52          */

   \                                 In section .text, align 2, keep-with-next
     53          void NVIC_Configuration(uint8_t enable)
     54          {
   \                     NVIC_Configuration: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     55            NVIC_InitType NVIC_InitStructure;
     56          
     57            /* Enable the UART Interrupt */
     58            NVIC_InitStructure.NVIC_IRQChannel = UART_IRQn;
   \   00000002   0x4669             MOV      R1,SP
   \   00000004   0x2204             MOVS     R2,#+4
   \   00000006   0x700A             STRB     R2,[R1, #+0]
     59            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0x704A             STRB     R2,[R1, #+1]
     60            if (enable)
   \   0000000C   0x0002             MOVS     R2,R0
   \   0000000E   0xD000             BEQ      ??NVIC_Configuration_0
   \   00000010   0x2201             MOVS     R2,#+1
   \                     ??NVIC_Configuration_0: (+1)
   \   00000012   0x708A             STRB     R2,[R1, #+2]
     61              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
     62            else
     63              NVIC_InitStructure.NVIC_IRQChannelCmd = DISABLE;
     64            NVIC_Init(&NVIC_InitStructure);
   \   00000014   0x4668             MOV      R0,SP
   \   00000016   0x.... 0x....      BL       NVIC_Init
     65          }
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return
     66          
     67          /**
     68          * @brief  GPIO Configuration.
     69          *	  Configure outputs GPIO pins.
     70          * @param  None
     71          * @retval None
     72          */

   \                                 In section .text, align 2, keep-with-next
     73          void GPIO_Configuration(void)
     74          {
   \                     GPIO_Configuration: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
     75            GPIO_InitType GPIO_InitStructure;
     76            
     77            /** GPIO Periph clock enable */
     78            SysCtrl_PeripheralClockCmd(CLOCK_PERIPH_GPIO, ENABLE);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x.... 0x....      BL       SysCtrl_PeripheralClockCmd
     79            
     80            /** Init Structure */
     81            GPIO_StructInit(&GPIO_InitStructure);
   \   0000000C   0x4668             MOV      R0,SP
   \   0000000E   0x.... 0x....      BL       GPIO_StructInit
     82          
     83            /** Configure GPIO_Pin_8 and GPIO_Pin_11 as UART_TXD and UART_RXD*/
     84            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_11;
   \   00000012   0x2090             MOVS     R0,#+144
   \   00000014   0x0100             LSLS     R0,R0,#+4        ;; #+2304
   \   00000016   0x9000             STR      R0,[SP, #+0]
     85            GPIO_InitStructure.GPIO_Mode = Serial1_Mode;
   \   00000018   0x4668             MOV      R0,SP
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x7101             STRB     R1,[R0, #+4]
     86            GPIO_InitStructure.GPIO_Pull = DISABLE;
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x7181             STRB     R1,[R0, #+6]
     87            GPIO_InitStructure.GPIO_HighPwr = DISABLE;
   \   00000022   0x7141             STRB     R1,[R0, #+5]
     88          
     89            GPIO_Init(&GPIO_InitStructure);
   \   00000024   0x.... 0x....      BL       GPIO_Init
     90          }
   \   00000028   0xBD07             POP      {R0-R2,PC}       ;; return
     91          
     92          /**
     93          * @brief  UART Configuration.
     94          *	  Configure UART peripheral.
     95          * @param  None
     96          * @retval None
     97          */

   \                                 In section .text, align 2, keep-with-next
     98          void UART_Configuration(void)
     99          {
   \                     UART_Configuration: (+1)
   \   00000000   0xB5E0             PUSH     {R5-R7,LR}
    100            UART_InitType UART_InitStructure;
    101            
    102            /** Enable UART clock */
    103            SysCtrl_PeripheralClockCmd(CLOCK_PERIPH_UART, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2008             MOVS     R0,#+8
   \   00000006   0x.... 0x....      BL       SysCtrl_PeripheralClockCmd
    104            
    105            /** Init Structure */
    106            UART_StructInit(&UART_InitStructure);
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       UART_StructInit
    107            
    108            /** Configure UART */
    109            UART_InitStructure.UART_BaudRate = 115200;
   \   00000010   0x20E1             MOVS     R0,#+225
   \   00000012   0x0240             LSLS     R0,R0,#+9        ;; #+115200
   \   00000014   0x9000             STR      R0,[SP, #+0]
    110            UART_InitStructure.UART_WordLengthTransmit = UART_WordLength_8b;
   \   00000016   0x2003             MOVS     R0,#+3
   \   00000018   0x4669             MOV      R1,SP
   \   0000001A   0x7108             STRB     R0,[R1, #+4]
    111            UART_InitStructure.UART_WordLengthReceive = UART_WordLength_8b;
   \   0000001C   0x7148             STRB     R0,[R1, #+5]
    112            UART_InitStructure.UART_StopBits = UART_StopBits_1;
   \   0000001E   0x2200             MOVS     R2,#+0
   \   00000020   0x80CA             STRH     R2,[R1, #+6]
    113            UART_InitStructure.UART_Parity = UART_Parity_No;
    114            UART_InitStructure.UART_HardwareFlowControl = UART_HardwareFlowControl_None;
   \   00000022   0x724A             STRB     R2,[R1, #+9]
    115            UART_InitStructure.UART_Mode = UART_Mode_Rx | UART_Mode_Tx;
   \   00000024   0x7208             STRB     R0,[R1, #+8]
    116            UART_InitStructure.UART_FifoEnable = DISABLE;
   \   00000026   0x728A             STRB     R2,[R1, #+10]
    117            UART_Init(&UART_InitStructure);
   \   00000028   0x4668             MOV      R0,SP
   \   0000002A   0x.... 0x....      BL       UART_Init
    118          }
   \   0000002E   0xBD07             POP      {R0-R2,PC}       ;; return
    119          

   \                                 In section .text, align 2, keep-with-next
    120          void PUSH1_EXT_IO_Config(void)
    121          {
   \                     PUSH1_EXT_IO_Config: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    122            GPIO_InitType GPIO_InitStructure;
    123            GPIO_EXTIConfigType exti_config;
    124            NVIC_InitType NVIC_InitStructure;
    125           
    126            SysCtrl_PeripheralClockCmd(CLOCK_PERIPH_GPIO, ENABLE);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x.... 0x....      BL       SysCtrl_PeripheralClockCmd
    127            
    128            /** Init Structure */
    129            GPIO_StructInit(&GPIO_InitStructure);
   \   0000000C   0xA801             ADD      R0,SP,#+4
   \   0000000E   0x.... 0x....      BL       GPIO_StructInit
    130          
    131            /** Configure Wakeup IO pin */
    132            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
   \   00000012   0x2680             MOVS     R6,#+128
   \   00000014   0x01B6             LSLS     R6,R6,#+6        ;; #+8192
   \   00000016   0x9601             STR      R6,[SP, #+4]
    133            GPIO_InitStructure.GPIO_Mode = GPIO_Input;
   \   00000018   0x2400             MOVS     R4,#+0
   \   0000001A   0xA801             ADD      R0,SP,#+4
   \   0000001C   0x8084             STRH     R4,[R0, #+4]
    134            GPIO_InitStructure.GPIO_Pull = DISABLE;
   \   0000001E   0x7184             STRB     R4,[R0, #+6]
    135            GPIO_InitStructure.GPIO_HighPwr = DISABLE;
    136          
    137            GPIO_Init(&GPIO_InitStructure);
   \   00000020   0x.... 0x....      BL       GPIO_Init
    138          
    139            /** Configure the Interrupt */
    140            exti_config.GPIO_Pin = GPIO_Pin_13;
   \   00000024   0x9603             STR      R6,[SP, #+12]
    141            exti_config.GPIO_IrqSense = GPIO_IrqSense_Edge;
   \   00000026   0x9404             STR      R4,[SP, #+16]
    142            exti_config.GPIO_Event = GPIO_Event_High;
   \   00000028   0x2501             MOVS     R5,#+1
   \   0000002A   0x9505             STR      R5,[SP, #+20]
    143            GPIO_EXTIConfig(&exti_config);
   \   0000002C   0xA803             ADD      R0,SP,#+12
   \   0000002E   0x.... 0x....      BL       GPIO_EXTIConfig
    144          
    145            GPIO_EXTICmd(GPIO_Pin_13, ENABLE);
   \   00000032   0x2101             MOVS     R1,#+1
   \   00000034   0x0030             MOVS     R0,R6
   \   00000036   0x.... 0x....      BL       GPIO_EXTICmd
    146          
    147            NVIC_InitStructure.NVIC_IRQChannel = GPIO_IRQn;
   \   0000003A   0x4668             MOV      R0,SP
   \   0000003C   0x7004             STRB     R4,[R0, #+0]
    148            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
   \   0000003E   0x7045             STRB     R5,[R0, #+1]
    149            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000040   0x7085             STRB     R5,[R0, #+2]
    150            NVIC_Init(&NVIC_InitStructure);
   \   00000042   0x.... 0x....      BL       NVIC_Init
    151          
    152          }
   \   00000046   0xB006             ADD      SP,SP,#+24
   \   00000048   0xBD70             POP      {R4-R6,PC}       ;; return
    153          
    154          /**
    155          * @brief  HW Configuration.
    156          * @param  None
    157          * @retval None
    158          */

   \                                 In section .text, align 2, keep-with-next
    159          void HW_Config(void)
    160          {
   \                     HW_Config: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    161            /** GPIO configuration */
    162            GPIO_Configuration();
   \   00000002   0x.... 0x....      BL       GPIO_Configuration
    163            
    164            /** UART configuration */
    165            UART_Configuration();
   \   00000006   0x.... 0x....      BL       UART_Configuration
    166            
    167            /** Enable UART */
    168            UART_Cmd(ENABLE);
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x.... 0x....      BL       UART_Cmd
    169            
    170            /* Configure the PUSH1 button */
    171            PUSH1_EXT_IO_Config(); 
   \   00000010   0x.... 0x....      BL       PUSH1_EXT_IO_Config
    172          
    173            /* Led DL1 configuration */
    174            SdkEvalLedInit(LED1);
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x.... 0x....      BL       SdkEvalLedInit
    175            SdkEvalLedOff(LED1);
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x.... 0x....      BL       SdkEvalLedOff
    176            
    177          }
   \   00000020   0xBD01             POP      {R0,PC}          ;; return
    178          

   \                                 In section .text, align 2, keep-with-next
    179          void transportSendData(uint8_t data)
    180          {
   \                     transportSendData: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    181            UART_SendData(data);
   \   00000002   0x.... 0x....      BL       UART_SendData
    182            while(UART_GetFlagStatus(UART_FLAG_TXFE) == RESET) {}
   \                     ??transportSendData_0: (+1)
   \   00000006   0x2080             MOVS     R0,#+128
   \   00000008   0x.... 0x....      BL       UART_GetFlagStatus
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD0FA             BEQ      ??transportSendData_0
    183            while(UART_GetFlagStatus(UART_FLAG_BUSY) == SET) {}
   \                     ??transportSendData_1: (+1)
   \   00000010   0x2008             MOVS     R0,#+8
   \   00000012   0x.... 0x....      BL       UART_GetFlagStatus
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD0FA             BEQ      ??transportSendData_1
    184          }
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return
    185          
    186          #ifdef __ICCARM__
    187          #include <yfuns.h>
    188          

   \                                 In section .text, align 2, keep-with-next
    189          size_t __write(int handle, const unsigned char * buffer, size_t size)
    190          {
   \                     __write: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x000C             MOVS     R4,R1
   \   00000004   0x0015             MOVS     R5,R2
    191            size_t nChars = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    192          
    193            if (handle != _LLIO_STDOUT && handle != _LLIO_STDERR) {
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD004             BEQ      ??__write_0
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD002             BEQ      ??__write_0
    194              return _LLIO_ERROR;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000014   0xBD70             POP      {R4-R6,PC}
    195            }
    196          
    197            if (buffer == 0) {
   \                     ??__write_0: (+1)
   \   00000016   0x2C00             CMP      R4,#+0
   \   00000018   0xD106             BNE      ??__write_1
    198              // This means that we should flush internal buffers.
    199              //spin until TX complete (TX is idle)
    200              return 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD70             POP      {R4-R6,PC}
    201            }
    202          
    203            while(size--) {
    204              transportSendData(*buffer++);
   \                     ??__write_2: (+1)
   \   0000001E   0x7820             LDRB     R0,[R4, #+0]
   \   00000020   0x.... 0x....      BL       transportSendData
   \   00000024   0x1C64             ADDS     R4,R4,#+1
    205              ++nChars;
   \   00000026   0x1C76             ADDS     R6,R6,#+1
    206            }
   \                     ??__write_1: (+1)
   \   00000028   0x0028             MOVS     R0,R5
   \   0000002A   0x1E45             SUBS     R5,R0,#+1
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD1F6             BNE      ??__write_2
    207          
    208            return nChars;
   \   00000030   0x0030             MOVS     R0,R6
   \   00000032   0xBD70             POP      {R4-R6,PC}       ;; return
    209          }
    210          
    211          #else
    212          
    213          #include <stdio.h>
    214          /* keil debug port defines */
    215          #define ITM_Port8(n)    (*((volatile unsigned char *)(0xE0000000+4*n)))
    216          #define ITM_Port16(n)   (*((volatile unsigned short*)(0xE0000000+4*n)))
    217          #define ITM_Port32(n)   (*((volatile unsigned long *)(0xE0000000+4*n)))
    218          #define DEMCR           (*((volatile unsigned long *)(0xE000EDFC)))
    219          #define TRCENA          0x01000000
    220          
    221          struct __FILE { int handle; /* Add whatever needed */ };
    222          FILE __stdout;
    223          FILE __stdin;
    224          
    225          /* KEIL fputc implementation template allowing to redirect printf output towards serial port (USART/USB) */
    226          int fputc(int c, FILE *f) {
    227          
    228            transportSendData((uint8_t) c);
    229            
    230            return 1;
    231            
    232          }
    233          #endif
    234          

   \                                 In section .text, align 2, keep-with-next
    235          uint8_t noBlockingRead(uint8_t *c)
    236          {
   \                     noBlockingRead: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    237            uint8_t len=0;
   \   00000004   0x2500             MOVS     R5,#+0
    238            
    239            if (UART_GetFlagStatus(UART_FLAG_RXFF) == SET) { // RX data received
   \   00000006   0x2040             MOVS     R0,#+64
   \   00000008   0x.... 0x....      BL       UART_GetFlagStatus
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD103             BNE      ??noBlockingRead_0
    240              *c = UART_ReceiveData() & 0xFF;
   \   00000010   0x.... 0x....      BL       UART_ReceiveData
   \   00000014   0x7020             STRB     R0,[R4, #+0]
    241              len = 1;
   \   00000016   0x2501             MOVS     R5,#+1
    242            }
    243            return len;
   \                     ??noBlockingRead_0: (+1)
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    244          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   GPIO_Configuration
        16   -> GPIO_Init
        16   -> GPIO_StructInit
        16   -> SysCtrl_PeripheralClockCmd
       8   HW_Config
         8   -> GPIO_Configuration
         8   -> PUSH1_EXT_IO_Config
         8   -> SdkEvalLedInit
         8   -> SdkEvalLedOff
         8   -> UART_Cmd
         8   -> UART_Configuration
       8   NVIC_Configuration
         8   -> NVIC_Init
      40   PUSH1_EXT_IO_Config
        40   -> GPIO_EXTICmd
        40   -> GPIO_EXTIConfig
        40   -> GPIO_Init
        40   -> GPIO_StructInit
        40   -> NVIC_Init
        40   -> SysCtrl_PeripheralClockCmd
      16   UART_Configuration
        16   -> SysCtrl_PeripheralClockCmd
        16   -> UART_Init
        16   -> UART_StructInit
      16   __write
        16   -> transportSendData
      16   noBlockingRead
        16   -> UART_GetFlagStatus
        16   -> UART_ReceiveData
       8   transportSendData
         8   -> UART_GetFlagStatus
         8   -> UART_SendData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      42  GPIO_Configuration
      34  HW_Config
      28  NVIC_Configuration
      74  PUSH1_EXT_IO_Config
      48  UART_Configuration
      52  __write
      28  noBlockingRead
      28  transportSendData

 
 334 bytes in section .text
 
 334 bytes of CODE memory

Errors: none
Warnings: none
