###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       29/Jan/2018  14:45:19
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\SimpleBlueNRG1_HCI\hci\controller\bluenrg1_gap_aci.c
#    Command line =  
#        "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\SimpleBlueNRG1_HCI\hci\controller\bluenrg1_gap_aci.c"
#        -D STM32L151xB -D STM32L1XX_XL -D USE_STM32L1XX_STEVAL_IDB00xV1 -D
#        USE_HAL_DRIVER -D HCLK_32MHZ=1 -D SYSCLK_MSI=1 -D ENABLE_USART -D
#        USER_DEFINED_PLATFORM=USER_EVAL_PLATFORM -D IRQ_RESET_PIN -D DTM_UART
#        -lC "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\List"
#        -o "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        D:\Software\IAR_BlueNRG\arm\INC\c\DLib_Config_Normal.h -I
#        "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\HAL\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\BSP\STM32L1xx_BlueNRG1\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\BSP\STM32L1xx_Nucleo\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\CMSIS\Device\ST\STM32L1xx\Include\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\STM32L1xx_HAL_BlueNRG1_Drivers\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\SimpleBlueNRG1_HCI\includes\"
#        -On --use_c++_inline -I D:\Software\IAR_BlueNRG\arm\CMSIS\Include\
#    Locale       =  Chinese (Simplified)_China.936
#    List file    =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\List\bluenrg1_gap_aci.lst
#    Object file  =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\Obj\bluenrg1_gap_aci.o
#
###############################################################################

C:\Users\Administrator\Desktop\Temporary Files\eeworld_project\Project_Test\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\SimpleBlueNRG1_HCI\hci\controller\bluenrg1_gap_aci.c
      1          
      2          
      3          /**
      4            ******************************************************************************
      5            * @file    bluenrg1_gap_aci.c
      6            * @author  AMG - RF Application team
      7            * @version V1.0.0
      8            * @date    22 June 2017
      9            * @brief   Source file for external uC - BlueNRG-x in network coprocessor mode (gap_aci)
     10            *          Autogenerated files, do not edit!!
     11            ******************************************************************************
     12            * @attention
     13            *
     14            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     15            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     16            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     17            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     18            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     19            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     20            *
     21            * <h2><center>&copy; COPYRIGHT STMicroelectronics</center></h2>
     22            ******************************************************************************
     23            */
     24          #include "bluenrg1_gap_aci.h"
     25          #include "osal.h"

   \                                 In section .text, align 2, keep-with-next
     26          tBleStatus aci_gap_set_non_discoverable(void)
     27          {
   \                     aci_gap_set_non_discoverable: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
     28            struct hci_request rq;
     29            tBleStatus status = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
     30            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000000A   0x2218             MOVS     R2,#+24
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0xA801             ADD      R0,SP,#+4
   \   00000010   0x.... 0x....      BL       Osal_MemSet
     31            rq.ogf = 0x3f;
   \   00000014   0x203F             MOVS     R0,#+63
   \   00000016   0xF8AD 0x0004      STRH     R0,[SP, #+4]
     32            rq.ocf = 0x081;
   \   0000001A   0x2081             MOVS     R0,#+129
   \   0000001C   0xF8AD 0x0006      STRH     R0,[SP, #+6]
     33            rq.rparam = &status;
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x9005             STR      R0,[SP, #+20]
     34            rq.rlen = 1;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x9006             STR      R0,[SP, #+24]
     35            if (hci_send_req(&rq, FALSE) < 0)
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0xA801             ADD      R0,SP,#+4
   \   0000002C   0x.... 0x....      BL       hci_send_req
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD501             BPL.N    ??aci_gap_set_non_discoverable_0
     36              return BLE_STATUS_TIMEOUT;
   \   00000034   0x20FF             MOVS     R0,#+255
   \   00000036   0xE007             B.N      ??aci_gap_set_non_discoverable_1
     37            if (status) {
   \                     ??aci_gap_set_non_discoverable_0: (+1)
   \   00000038   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD002             BEQ.N    ??aci_gap_set_non_discoverable_2
     38              return status;
   \   00000040   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000044   0xE000             B.N      ??aci_gap_set_non_discoverable_1
     39            }
     40            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_set_non_discoverable_2: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_set_non_discoverable_1: (+1)
   \   00000048   0xB007             ADD      SP,SP,#+28
   \   0000004A   0xBD00             POP      {PC}             ;; return
     41          }

   \                                 In section .text, align 2, keep-with-next
     42          tBleStatus aci_gap_set_limited_discoverable(uint8_t Advertising_Type,
     43                                                      uint16_t Advertising_Interval_Min,
     44                                                      uint16_t Advertising_Interval_Max,
     45                                                      uint8_t Own_Address_Type,
     46                                                      uint8_t Advertising_Filter_Policy,
     47                                                      uint8_t Local_Name_Length,
     48                                                      uint8_t Local_Name[],
     49                                                      uint8_t Service_Uuid_length,
     50                                                      uint8_t Service_Uuid_List[],
     51                                                      uint16_t Slave_Conn_Interval_Min,
     52                                                      uint16_t Slave_Conn_Interval_Max)
     53          {
   \                     aci_gap_set_limited_discoverable: (+1)
   \   00000000   0xE92D 0x4FFF      PUSH     {R0-R11,LR}
   \   00000004   0xB0C9             SUB      SP,SP,#+292
   \   00000006   0x9C57             LDR      R4,[SP, #+348]
   \   00000008   0x9D59             LDR      R5,[SP, #+356]
   \   0000000A   0xF8DD 0x8168      LDR      R8,[SP, #+360]
   \   0000000E   0x9E5B             LDR      R6,[SP, #+364]
   \   00000010   0x9F5C             LDR      R7,[SP, #+368]
     54            struct hci_request rq;
     55            uint8_t cmd_buffer[258];
     56            aci_gap_set_limited_discoverable_cp0 *cp0 = (aci_gap_set_limited_discoverable_cp0*)(cmd_buffer);
   \   00000012   0xF10D 0x0920      ADD      R9,SP,#+32
     57            aci_gap_set_limited_discoverable_cp1 *cp1 = (aci_gap_set_limited_discoverable_cp1*)(cmd_buffer + 1 + 2 + 2 + 1 + 1 + 1 + Local_Name_Length * (sizeof(uint8_t)));
   \   00000016   0xA808             ADD      R0,SP,#+32
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0x4420             ADD      R0,R0,R4
   \   0000001C   0x3008             ADDS     R0,R0,#+8
   \   0000001E   0x9001             STR      R0,[SP, #+4]
     58            aci_gap_set_limited_discoverable_cp2 *cp2 = (aci_gap_set_limited_discoverable_cp2*)(cmd_buffer + 1 + 2 + 2 + 1 + 1 + 1 + Local_Name_Length * (sizeof(uint8_t)) + 1 + Service_Uuid_length * (sizeof(uint8_t)));
   \   00000020   0xA808             ADD      R0,SP,#+32
   \   00000022   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000024   0x4420             ADD      R0,R0,R4
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0x4428             ADD      R0,R0,R5
   \   0000002A   0xF110 0x0A09      ADDS     R10,R0,#+9
     59            tBleStatus status = 0;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF88D 0x0000      STRB     R0,[SP, #+0]
     60            uint8_t index_input = 0;
   \   00000034   0xF05F 0x0B00      MOVS     R11,#+0
     61            cp0->Advertising_Type = htob(Advertising_Type, 1);
   \   00000038   0xF89D 0x0124      LDRB     R0,[SP, #+292]
   \   0000003C   0xF889 0x0000      STRB     R0,[R9, #+0]
     62            index_input += 1;
   \   00000040   0xF11B 0x0B01      ADDS     R11,R11,#+1
     63            cp0->Advertising_Interval_Min = htob(Advertising_Interval_Min, 2);
   \   00000044   0xF8BD 0x0128      LDRH     R0,[SP, #+296]
   \   00000048   0xF8A9 0x0001      STRH     R0,[R9, #+1]
     64            index_input += 2;
   \   0000004C   0xF11B 0x0B02      ADDS     R11,R11,#+2
     65            cp0->Advertising_Interval_Max = htob(Advertising_Interval_Max, 2);
   \   00000050   0xF8BD 0x012C      LDRH     R0,[SP, #+300]
   \   00000054   0xF8A9 0x0003      STRH     R0,[R9, #+3]
     66            index_input += 2;
   \   00000058   0xF11B 0x0B02      ADDS     R11,R11,#+2
     67            cp0->Own_Address_Type = htob(Own_Address_Type, 1);
   \   0000005C   0xF89D 0x0130      LDRB     R0,[SP, #+304]
   \   00000060   0xF889 0x0005      STRB     R0,[R9, #+5]
     68            index_input += 1;
   \   00000064   0xF11B 0x0B01      ADDS     R11,R11,#+1
     69            cp0->Advertising_Filter_Policy = htob(Advertising_Filter_Policy, 1);
   \   00000068   0xF89D 0x0158      LDRB     R0,[SP, #+344]
   \   0000006C   0xF889 0x0006      STRB     R0,[R9, #+6]
     70            index_input += 1;
   \   00000070   0xF11B 0x0B01      ADDS     R11,R11,#+1
     71            cp0->Local_Name_Length = htob(Local_Name_Length, 1);
   \   00000074   0xF889 0x4007      STRB     R4,[R9, #+7]
     72            index_input += 1;
   \   00000078   0xF11B 0x0B01      ADDS     R11,R11,#+1
     73            /* var_len_data input */
     74            {
     75              Osal_MemCpy((void *) &cp0->Local_Name, (const void *) Local_Name, Local_Name_Length);
   \   0000007C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007E   0x0022             MOVS     R2,R4
   \   00000080   0x9958             LDR      R1,[SP, #+352]
   \   00000082   0xF119 0x0008      ADDS     R0,R9,#+8
   \   00000086   0x.... 0x....      BL       Osal_MemCpy
     76              index_input += Local_Name_Length;
   \   0000008A   0xEB14 0x0B0B      ADDS     R11,R4,R11
     77              {
     78                cp1->Service_Uuid_length = htob(Service_Uuid_length, 1);
   \   0000008E   0x9801             LDR      R0,[SP, #+4]
   \   00000090   0x7005             STRB     R5,[R0, #+0]
     79              }
     80              index_input += 1;
   \   00000092   0xF11B 0x0B01      ADDS     R11,R11,#+1
     81              Osal_MemCpy((void *) &cp1->Service_Uuid_List, (const void *) Service_Uuid_List, Service_Uuid_length);
   \   00000096   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000098   0x002A             MOVS     R2,R5
   \   0000009A   0x4641             MOV      R1,R8
   \   0000009C   0x9801             LDR      R0,[SP, #+4]
   \   0000009E   0x1C40             ADDS     R0,R0,#+1
   \   000000A0   0x.... 0x....      BL       Osal_MemCpy
     82              index_input += Service_Uuid_length;
   \   000000A4   0xEB15 0x0B0B      ADDS     R11,R5,R11
     83              {
     84                cp2->Slave_Conn_Interval_Min = htob(Slave_Conn_Interval_Min, 2);
   \   000000A8   0xF8AA 0x6000      STRH     R6,[R10, #+0]
     85              }
     86              index_input += 2;
   \   000000AC   0xF11B 0x0B02      ADDS     R11,R11,#+2
     87              {
     88                cp2->Slave_Conn_Interval_Max = htob(Slave_Conn_Interval_Max, 2);
   \   000000B0   0xF8AA 0x7002      STRH     R7,[R10, #+2]
     89              }
     90              index_input += 2;
   \   000000B4   0xF11B 0x0B02      ADDS     R11,R11,#+2
     91            }
     92            Osal_MemSet(&rq, 0, sizeof(rq));
   \   000000B8   0x2218             MOVS     R2,#+24
   \   000000BA   0x2100             MOVS     R1,#+0
   \   000000BC   0xA802             ADD      R0,SP,#+8
   \   000000BE   0x.... 0x....      BL       Osal_MemSet
     93            rq.ogf = 0x3f;
   \   000000C2   0x203F             MOVS     R0,#+63
   \   000000C4   0xF8AD 0x0008      STRH     R0,[SP, #+8]
     94            rq.ocf = 0x082;
   \   000000C8   0x2082             MOVS     R0,#+130
   \   000000CA   0xF8AD 0x000A      STRH     R0,[SP, #+10]
     95            rq.event = 0x0F;
   \   000000CE   0x200F             MOVS     R0,#+15
   \   000000D0   0x9003             STR      R0,[SP, #+12]
     96            rq.cparam = cmd_buffer;
   \   000000D2   0xA808             ADD      R0,SP,#+32
   \   000000D4   0x9004             STR      R0,[SP, #+16]
     97            rq.clen = index_input;
   \   000000D6   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000DA   0xF8CD 0xB014      STR      R11,[SP, #+20]
     98            rq.rparam = &status;
   \   000000DE   0x4668             MOV      R0,SP
   \   000000E0   0x9006             STR      R0,[SP, #+24]
     99            rq.rlen = 1;
   \   000000E2   0x2001             MOVS     R0,#+1
   \   000000E4   0x9007             STR      R0,[SP, #+28]
    100            if (hci_send_req(&rq, FALSE) < 0)
   \   000000E6   0x2100             MOVS     R1,#+0
   \   000000E8   0xA802             ADD      R0,SP,#+8
   \   000000EA   0x.... 0x....      BL       hci_send_req
   \   000000EE   0x2800             CMP      R0,#+0
   \   000000F0   0xD501             BPL.N    ??aci_gap_set_limited_discoverable_0
    101              return BLE_STATUS_TIMEOUT;
   \   000000F2   0x20FF             MOVS     R0,#+255
   \   000000F4   0xE007             B.N      ??aci_gap_set_limited_discoverable_1
    102            if (status) {
   \                     ??aci_gap_set_limited_discoverable_0: (+1)
   \   000000F6   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000FA   0x2800             CMP      R0,#+0
   \   000000FC   0xD002             BEQ.N    ??aci_gap_set_limited_discoverable_2
    103              return status;
   \   000000FE   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000102   0xE000             B.N      ??aci_gap_set_limited_discoverable_1
    104            }
    105            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_set_limited_discoverable_2: (+1)
   \   00000104   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_set_limited_discoverable_1: (+1)
   \   00000106   0xB04D             ADD      SP,SP,#+308
   \   00000108   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    106          }

   \                                 In section .text, align 2, keep-with-next
    107          tBleStatus aci_gap_set_discoverable(uint8_t Advertising_Type,
    108                                              uint16_t Advertising_Interval_Min,
    109                                              uint16_t Advertising_Interval_Max,
    110                                              uint8_t Own_Address_Type,
    111                                              uint8_t Advertising_Filter_Policy,
    112                                              uint8_t Local_Name_Length,
    113                                              uint8_t Local_Name[],
    114                                              uint8_t Service_Uuid_length,
    115                                              uint8_t Service_Uuid_List[],
    116                                              uint16_t Slave_Conn_Interval_Min,
    117                                              uint16_t Slave_Conn_Interval_Max)
    118          {
   \                     aci_gap_set_discoverable: (+1)
   \   00000000   0xE92D 0x4FFF      PUSH     {R0-R11,LR}
   \   00000004   0xB0C9             SUB      SP,SP,#+292
   \   00000006   0x9C57             LDR      R4,[SP, #+348]
   \   00000008   0x9D59             LDR      R5,[SP, #+356]
   \   0000000A   0xF8DD 0x8168      LDR      R8,[SP, #+360]
   \   0000000E   0x9E5B             LDR      R6,[SP, #+364]
   \   00000010   0x9F5C             LDR      R7,[SP, #+368]
    119            struct hci_request rq;
    120            uint8_t cmd_buffer[258];
    121            aci_gap_set_discoverable_cp0 *cp0 = (aci_gap_set_discoverable_cp0*)(cmd_buffer);
   \   00000012   0xF10D 0x0920      ADD      R9,SP,#+32
    122            aci_gap_set_discoverable_cp1 *cp1 = (aci_gap_set_discoverable_cp1*)(cmd_buffer + 1 + 2 + 2 + 1 + 1 + 1 + Local_Name_Length * (sizeof(uint8_t)));
   \   00000016   0xA808             ADD      R0,SP,#+32
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0x4420             ADD      R0,R0,R4
   \   0000001C   0x3008             ADDS     R0,R0,#+8
   \   0000001E   0x9001             STR      R0,[SP, #+4]
    123            aci_gap_set_discoverable_cp2 *cp2 = (aci_gap_set_discoverable_cp2*)(cmd_buffer + 1 + 2 + 2 + 1 + 1 + 1 + Local_Name_Length * (sizeof(uint8_t)) + 1 + Service_Uuid_length * (sizeof(uint8_t)));
   \   00000020   0xA808             ADD      R0,SP,#+32
   \   00000022   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000024   0x4420             ADD      R0,R0,R4
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0x4428             ADD      R0,R0,R5
   \   0000002A   0xF110 0x0A09      ADDS     R10,R0,#+9
    124            tBleStatus status = 0;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF88D 0x0000      STRB     R0,[SP, #+0]
    125            uint8_t index_input = 0;
   \   00000034   0xF05F 0x0B00      MOVS     R11,#+0
    126            cp0->Advertising_Type = htob(Advertising_Type, 1);
   \   00000038   0xF89D 0x0124      LDRB     R0,[SP, #+292]
   \   0000003C   0xF889 0x0000      STRB     R0,[R9, #+0]
    127            index_input += 1;
   \   00000040   0xF11B 0x0B01      ADDS     R11,R11,#+1
    128            cp0->Advertising_Interval_Min = htob(Advertising_Interval_Min, 2);
   \   00000044   0xF8BD 0x0128      LDRH     R0,[SP, #+296]
   \   00000048   0xF8A9 0x0001      STRH     R0,[R9, #+1]
    129            index_input += 2;
   \   0000004C   0xF11B 0x0B02      ADDS     R11,R11,#+2
    130            cp0->Advertising_Interval_Max = htob(Advertising_Interval_Max, 2);
   \   00000050   0xF8BD 0x012C      LDRH     R0,[SP, #+300]
   \   00000054   0xF8A9 0x0003      STRH     R0,[R9, #+3]
    131            index_input += 2;
   \   00000058   0xF11B 0x0B02      ADDS     R11,R11,#+2
    132            cp0->Own_Address_Type = htob(Own_Address_Type, 1);
   \   0000005C   0xF89D 0x0130      LDRB     R0,[SP, #+304]
   \   00000060   0xF889 0x0005      STRB     R0,[R9, #+5]
    133            index_input += 1;
   \   00000064   0xF11B 0x0B01      ADDS     R11,R11,#+1
    134            cp0->Advertising_Filter_Policy = htob(Advertising_Filter_Policy, 1);
   \   00000068   0xF89D 0x0158      LDRB     R0,[SP, #+344]
   \   0000006C   0xF889 0x0006      STRB     R0,[R9, #+6]
    135            index_input += 1;
   \   00000070   0xF11B 0x0B01      ADDS     R11,R11,#+1
    136            cp0->Local_Name_Length = htob(Local_Name_Length, 1);
   \   00000074   0xF889 0x4007      STRB     R4,[R9, #+7]
    137            index_input += 1;
   \   00000078   0xF11B 0x0B01      ADDS     R11,R11,#+1
    138            /* var_len_data input */
    139            {
    140              Osal_MemCpy((void *) &cp0->Local_Name, (const void *) Local_Name, Local_Name_Length);
   \   0000007C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007E   0x0022             MOVS     R2,R4
   \   00000080   0x9958             LDR      R1,[SP, #+352]
   \   00000082   0xF119 0x0008      ADDS     R0,R9,#+8
   \   00000086   0x.... 0x....      BL       Osal_MemCpy
    141              index_input += Local_Name_Length;
   \   0000008A   0xEB14 0x0B0B      ADDS     R11,R4,R11
    142              {
    143                cp1->Service_Uuid_length = htob(Service_Uuid_length, 1);
   \   0000008E   0x9801             LDR      R0,[SP, #+4]
   \   00000090   0x7005             STRB     R5,[R0, #+0]
    144              }
    145              index_input += 1;
   \   00000092   0xF11B 0x0B01      ADDS     R11,R11,#+1
    146              Osal_MemCpy((void *) &cp1->Service_Uuid_List, (const void *) Service_Uuid_List, Service_Uuid_length);
   \   00000096   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000098   0x002A             MOVS     R2,R5
   \   0000009A   0x4641             MOV      R1,R8
   \   0000009C   0x9801             LDR      R0,[SP, #+4]
   \   0000009E   0x1C40             ADDS     R0,R0,#+1
   \   000000A0   0x.... 0x....      BL       Osal_MemCpy
    147              index_input += Service_Uuid_length;
   \   000000A4   0xEB15 0x0B0B      ADDS     R11,R5,R11
    148              {
    149                cp2->Slave_Conn_Interval_Min = htob(Slave_Conn_Interval_Min, 2);
   \   000000A8   0xF8AA 0x6000      STRH     R6,[R10, #+0]
    150              }
    151              index_input += 2;
   \   000000AC   0xF11B 0x0B02      ADDS     R11,R11,#+2
    152              {
    153                cp2->Slave_Conn_Interval_Max = htob(Slave_Conn_Interval_Max, 2);
   \   000000B0   0xF8AA 0x7002      STRH     R7,[R10, #+2]
    154              }
    155              index_input += 2;
   \   000000B4   0xF11B 0x0B02      ADDS     R11,R11,#+2
    156            }
    157            Osal_MemSet(&rq, 0, sizeof(rq));
   \   000000B8   0x2218             MOVS     R2,#+24
   \   000000BA   0x2100             MOVS     R1,#+0
   \   000000BC   0xA802             ADD      R0,SP,#+8
   \   000000BE   0x.... 0x....      BL       Osal_MemSet
    158            rq.ogf = 0x3f;
   \   000000C2   0x203F             MOVS     R0,#+63
   \   000000C4   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    159            rq.ocf = 0x083;
   \   000000C8   0x2083             MOVS     R0,#+131
   \   000000CA   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    160            rq.cparam = cmd_buffer;
   \   000000CE   0xA808             ADD      R0,SP,#+32
   \   000000D0   0x9004             STR      R0,[SP, #+16]
    161            rq.clen = index_input;
   \   000000D2   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000D6   0xF8CD 0xB014      STR      R11,[SP, #+20]
    162            rq.rparam = &status;
   \   000000DA   0x4668             MOV      R0,SP
   \   000000DC   0x9006             STR      R0,[SP, #+24]
    163            rq.rlen = 1;
   \   000000DE   0x2001             MOVS     R0,#+1
   \   000000E0   0x9007             STR      R0,[SP, #+28]
    164            if (hci_send_req(&rq, FALSE) < 0)
   \   000000E2   0x2100             MOVS     R1,#+0
   \   000000E4   0xA802             ADD      R0,SP,#+8
   \   000000E6   0x.... 0x....      BL       hci_send_req
   \   000000EA   0x2800             CMP      R0,#+0
   \   000000EC   0xD501             BPL.N    ??aci_gap_set_discoverable_0
    165              return BLE_STATUS_TIMEOUT;
   \   000000EE   0x20FF             MOVS     R0,#+255
   \   000000F0   0xE007             B.N      ??aci_gap_set_discoverable_1
    166            if (status) {
   \                     ??aci_gap_set_discoverable_0: (+1)
   \   000000F2   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000F6   0x2800             CMP      R0,#+0
   \   000000F8   0xD002             BEQ.N    ??aci_gap_set_discoverable_2
    167              return status;
   \   000000FA   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000FE   0xE000             B.N      ??aci_gap_set_discoverable_1
    168            }
    169            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_set_discoverable_2: (+1)
   \   00000100   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_set_discoverable_1: (+1)
   \   00000102   0xB04D             ADD      SP,SP,#+308
   \   00000104   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    170          }

   \                                 In section .text, align 2, keep-with-next
    171          tBleStatus aci_gap_set_direct_connectable(uint8_t Own_Address_Type,
    172                                                    uint8_t Directed_Advertising_Type,
    173                                                    uint8_t Direct_Address_Type,
    174                                                    uint8_t Direct_Address[6],
    175                                                    uint16_t Advertising_Interval_Min,
    176                                                    uint16_t Advertising_Interval_Max)
    177          {
   \                     aci_gap_set_direct_connectable: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB0C9             SUB      SP,SP,#+292
   \   00000006   0x0006             MOVS     R6,R0
   \   00000008   0x000F             MOVS     R7,R1
   \   0000000A   0x4690             MOV      R8,R2
   \   0000000C   0x4699             MOV      R9,R3
   \   0000000E   0x9C52             LDR      R4,[SP, #+328]
   \   00000010   0x9D53             LDR      R5,[SP, #+332]
    178            struct hci_request rq;
    179            uint8_t cmd_buffer[258];
    180            aci_gap_set_direct_connectable_cp0 *cp0 = (aci_gap_set_direct_connectable_cp0*)(cmd_buffer);
   \   00000012   0xF10D 0x0A1C      ADD      R10,SP,#+28
    181            tBleStatus status = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF88D 0x0000      STRB     R0,[SP, #+0]
    182            uint8_t index_input = 0;
   \   0000001C   0xF05F 0x0B00      MOVS     R11,#+0
    183            cp0->Own_Address_Type = htob(Own_Address_Type, 1);
   \   00000020   0xF88A 0x6000      STRB     R6,[R10, #+0]
    184            index_input += 1;
   \   00000024   0xF11B 0x0B01      ADDS     R11,R11,#+1
    185            cp0->Directed_Advertising_Type = htob(Directed_Advertising_Type, 1);
   \   00000028   0xF88A 0x7001      STRB     R7,[R10, #+1]
    186            index_input += 1;
   \   0000002C   0xF11B 0x0B01      ADDS     R11,R11,#+1
    187            cp0->Direct_Address_Type = htob(Direct_Address_Type, 1);
   \   00000030   0xF88A 0x8002      STRB     R8,[R10, #+2]
    188            index_input += 1;
   \   00000034   0xF11B 0x0B01      ADDS     R11,R11,#+1
    189            Osal_MemCpy((void *) &cp0->Direct_Address, (const void *) Direct_Address, 6);
   \   00000038   0x2206             MOVS     R2,#+6
   \   0000003A   0x4649             MOV      R1,R9
   \   0000003C   0xF11A 0x0003      ADDS     R0,R10,#+3
   \   00000040   0x.... 0x....      BL       Osal_MemCpy
    190            index_input += 6;
   \   00000044   0xF11B 0x0B06      ADDS     R11,R11,#+6
    191            cp0->Advertising_Interval_Min = htob(Advertising_Interval_Min, 2);
   \   00000048   0xF8AA 0x4009      STRH     R4,[R10, #+9]
    192            index_input += 2;
   \   0000004C   0xF11B 0x0B02      ADDS     R11,R11,#+2
    193            cp0->Advertising_Interval_Max = htob(Advertising_Interval_Max, 2);
   \   00000050   0xF8AA 0x500B      STRH     R5,[R10, #+11]
    194            index_input += 2;
   \   00000054   0xF11B 0x0B02      ADDS     R11,R11,#+2
    195            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000058   0x2218             MOVS     R2,#+24
   \   0000005A   0x2100             MOVS     R1,#+0
   \   0000005C   0xA801             ADD      R0,SP,#+4
   \   0000005E   0x.... 0x....      BL       Osal_MemSet
    196            rq.ogf = 0x3f;
   \   00000062   0x203F             MOVS     R0,#+63
   \   00000064   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    197            rq.ocf = 0x084;
   \   00000068   0x2084             MOVS     R0,#+132
   \   0000006A   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    198            rq.cparam = cmd_buffer;
   \   0000006E   0xA807             ADD      R0,SP,#+28
   \   00000070   0x9003             STR      R0,[SP, #+12]
    199            rq.clen = index_input;
   \   00000072   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000076   0xF8CD 0xB010      STR      R11,[SP, #+16]
    200            rq.rparam = &status;
   \   0000007A   0x4668             MOV      R0,SP
   \   0000007C   0x9005             STR      R0,[SP, #+20]
    201            rq.rlen = 1;
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0x9006             STR      R0,[SP, #+24]
    202            if (hci_send_req(&rq, FALSE) < 0)
   \   00000082   0x2100             MOVS     R1,#+0
   \   00000084   0xA801             ADD      R0,SP,#+4
   \   00000086   0x.... 0x....      BL       hci_send_req
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD501             BPL.N    ??aci_gap_set_direct_connectable_0
    203              return BLE_STATUS_TIMEOUT;
   \   0000008E   0x20FF             MOVS     R0,#+255
   \   00000090   0xE007             B.N      ??aci_gap_set_direct_connectable_1
    204            if (status) {
   \                     ??aci_gap_set_direct_connectable_0: (+1)
   \   00000092   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD002             BEQ.N    ??aci_gap_set_direct_connectable_2
    205              return status;
   \   0000009A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000009E   0xE000             B.N      ??aci_gap_set_direct_connectable_1
    206            }
    207            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_set_direct_connectable_2: (+1)
   \   000000A0   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_set_direct_connectable_1: (+1)
   \   000000A2   0xB049             ADD      SP,SP,#+292
   \   000000A4   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    208          }

   \                                 In section .text, align 2, keep-with-next
    209          tBleStatus aci_gap_set_io_capability(uint8_t IO_Capability)
    210          {
   \                     aci_gap_set_io_capability: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB0C8             SUB      SP,SP,#+288
   \   00000004   0x0004             MOVS     R4,R0
    211            struct hci_request rq;
    212            uint8_t cmd_buffer[258];
    213            aci_gap_set_io_capability_cp0 *cp0 = (aci_gap_set_io_capability_cp0*)(cmd_buffer);
   \   00000006   0xAD07             ADD      R5,SP,#+28
    214            tBleStatus status = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    215            uint8_t index_input = 0;
   \   0000000E   0x2600             MOVS     R6,#+0
    216            cp0->IO_Capability = htob(IO_Capability, 1);
   \   00000010   0x702C             STRB     R4,[R5, #+0]
    217            index_input += 1;
   \   00000012   0x1C76             ADDS     R6,R6,#+1
    218            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000014   0x2218             MOVS     R2,#+24
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0xA801             ADD      R0,SP,#+4
   \   0000001A   0x.... 0x....      BL       Osal_MemSet
    219            rq.ogf = 0x3f;
   \   0000001E   0x203F             MOVS     R0,#+63
   \   00000020   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    220            rq.ocf = 0x085;
   \   00000024   0x2085             MOVS     R0,#+133
   \   00000026   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    221            rq.cparam = cmd_buffer;
   \   0000002A   0xA807             ADD      R0,SP,#+28
   \   0000002C   0x9003             STR      R0,[SP, #+12]
    222            rq.clen = index_input;
   \   0000002E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000030   0x9604             STR      R6,[SP, #+16]
    223            rq.rparam = &status;
   \   00000032   0x4668             MOV      R0,SP
   \   00000034   0x9005             STR      R0,[SP, #+20]
    224            rq.rlen = 1;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x9006             STR      R0,[SP, #+24]
    225            if (hci_send_req(&rq, FALSE) < 0)
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0xA801             ADD      R0,SP,#+4
   \   0000003E   0x.... 0x....      BL       hci_send_req
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD501             BPL.N    ??aci_gap_set_io_capability_0
    226              return BLE_STATUS_TIMEOUT;
   \   00000046   0x20FF             MOVS     R0,#+255
   \   00000048   0xE007             B.N      ??aci_gap_set_io_capability_1
    227            if (status) {
   \                     ??aci_gap_set_io_capability_0: (+1)
   \   0000004A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD002             BEQ.N    ??aci_gap_set_io_capability_2
    228              return status;
   \   00000052   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000056   0xE000             B.N      ??aci_gap_set_io_capability_1
    229            }
    230            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_set_io_capability_2: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_set_io_capability_1: (+1)
   \   0000005A   0xB048             ADD      SP,SP,#+288
   \   0000005C   0xBD70             POP      {R4-R6,PC}       ;; return
    231          }

   \                                 In section .text, align 2, keep-with-next
    232          tBleStatus aci_gap_set_authentication_requirement(uint8_t Bonding_Mode,
    233                                                            uint8_t MITM_Mode,
    234                                                            uint8_t SC_Support,
    235                                                            uint8_t KeyPress_Notification_Support,
    236                                                            uint8_t Min_Encryption_Key_Size,
    237                                                            uint8_t Max_Encryption_Key_Size,
    238                                                            uint8_t Use_Fixed_Pin,
    239                                                            uint32_t Fixed_Pin,
    240                                                            uint8_t Identity_Address_Type)
    241          {
   \                     aci_gap_set_authentication_requirement: (+1)
   \   00000000   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \   00000004   0xB0C8             SUB      SP,SP,#+288
   \   00000006   0x4698             MOV      R8,R3
   \   00000008   0x9C54             LDR      R4,[SP, #+336]
   \   0000000A   0x9D55             LDR      R5,[SP, #+340]
   \   0000000C   0x9E56             LDR      R6,[SP, #+344]
   \   0000000E   0xF8DD 0x915C      LDR      R9,[SP, #+348]
   \   00000012   0x9F58             LDR      R7,[SP, #+352]
    242            struct hci_request rq;
    243            uint8_t cmd_buffer[258];
    244            aci_gap_set_authentication_requirement_cp0 *cp0 = (aci_gap_set_authentication_requirement_cp0*)(cmd_buffer);
   \   00000014   0xF10D 0x0A1C      ADD      R10,SP,#+28
    245            tBleStatus status = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    246            uint8_t index_input = 0;
   \   0000001E   0xF05F 0x0B00      MOVS     R11,#+0
    247            cp0->Bonding_Mode = htob(Bonding_Mode, 1);
   \   00000022   0xF89D 0x0120      LDRB     R0,[SP, #+288]
   \   00000026   0xF88A 0x0000      STRB     R0,[R10, #+0]
    248            index_input += 1;
   \   0000002A   0xF11B 0x0B01      ADDS     R11,R11,#+1
    249            cp0->MITM_Mode = htob(MITM_Mode, 1);
   \   0000002E   0xF89D 0x0124      LDRB     R0,[SP, #+292]
   \   00000032   0xF88A 0x0001      STRB     R0,[R10, #+1]
    250            index_input += 1;
   \   00000036   0xF11B 0x0B01      ADDS     R11,R11,#+1
    251            cp0->SC_Support = htob(SC_Support, 1);
   \   0000003A   0xF89D 0x0128      LDRB     R0,[SP, #+296]
   \   0000003E   0xF88A 0x0002      STRB     R0,[R10, #+2]
    252            index_input += 1;
   \   00000042   0xF11B 0x0B01      ADDS     R11,R11,#+1
    253            cp0->KeyPress_Notification_Support = htob(KeyPress_Notification_Support, 1);
   \   00000046   0xF88A 0x8003      STRB     R8,[R10, #+3]
    254            index_input += 1;
   \   0000004A   0xF11B 0x0B01      ADDS     R11,R11,#+1
    255            cp0->Min_Encryption_Key_Size = htob(Min_Encryption_Key_Size, 1);
   \   0000004E   0xF88A 0x4004      STRB     R4,[R10, #+4]
    256            index_input += 1;
   \   00000052   0xF11B 0x0B01      ADDS     R11,R11,#+1
    257            cp0->Max_Encryption_Key_Size = htob(Max_Encryption_Key_Size, 1);
   \   00000056   0xF88A 0x5005      STRB     R5,[R10, #+5]
    258            index_input += 1;
   \   0000005A   0xF11B 0x0B01      ADDS     R11,R11,#+1
    259            cp0->Use_Fixed_Pin = htob(Use_Fixed_Pin, 1);
   \   0000005E   0xF88A 0x6006      STRB     R6,[R10, #+6]
    260            index_input += 1;
   \   00000062   0xF11B 0x0B01      ADDS     R11,R11,#+1
    261            cp0->Fixed_Pin = htob(Fixed_Pin, 4);
   \   00000066   0xF8CA 0x9007      STR      R9,[R10, #+7]
    262            index_input += 4;
   \   0000006A   0xF11B 0x0B04      ADDS     R11,R11,#+4
    263            cp0->Identity_Address_Type = htob(Identity_Address_Type, 1);
   \   0000006E   0xF88A 0x700B      STRB     R7,[R10, #+11]
    264            index_input += 1;
   \   00000072   0xF11B 0x0B01      ADDS     R11,R11,#+1
    265            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000076   0x2218             MOVS     R2,#+24
   \   00000078   0x2100             MOVS     R1,#+0
   \   0000007A   0xA801             ADD      R0,SP,#+4
   \   0000007C   0x.... 0x....      BL       Osal_MemSet
    266            rq.ogf = 0x3f;
   \   00000080   0x203F             MOVS     R0,#+63
   \   00000082   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    267            rq.ocf = 0x086;
   \   00000086   0x2086             MOVS     R0,#+134
   \   00000088   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    268            rq.cparam = cmd_buffer;
   \   0000008C   0xA807             ADD      R0,SP,#+28
   \   0000008E   0x9003             STR      R0,[SP, #+12]
    269            rq.clen = index_input;
   \   00000090   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000094   0xF8CD 0xB010      STR      R11,[SP, #+16]
    270            rq.rparam = &status;
   \   00000098   0x4668             MOV      R0,SP
   \   0000009A   0x9005             STR      R0,[SP, #+20]
    271            rq.rlen = 1;
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0x9006             STR      R0,[SP, #+24]
    272            if (hci_send_req(&rq, FALSE) < 0)
   \   000000A0   0x2100             MOVS     R1,#+0
   \   000000A2   0xA801             ADD      R0,SP,#+4
   \   000000A4   0x.... 0x....      BL       hci_send_req
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD501             BPL.N    ??aci_gap_set_authentication_requirement_0
    273              return BLE_STATUS_TIMEOUT;
   \   000000AC   0x20FF             MOVS     R0,#+255
   \   000000AE   0xE007             B.N      ??aci_gap_set_authentication_requirement_1
    274            if (status) {
   \                     ??aci_gap_set_authentication_requirement_0: (+1)
   \   000000B0   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD002             BEQ.N    ??aci_gap_set_authentication_requirement_2
    275              return status;
   \   000000B8   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000BC   0xE000             B.N      ??aci_gap_set_authentication_requirement_1
    276            }
    277            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_set_authentication_requirement_2: (+1)
   \   000000BE   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_set_authentication_requirement_1: (+1)
   \   000000C0   0xB04B             ADD      SP,SP,#+300
   \   000000C2   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    278          }

   \                                 In section .text, align 2, keep-with-next
    279          tBleStatus aci_gap_set_authorization_requirement(uint16_t Connection_Handle,
    280                                                           uint8_t Authorization_Enable)
    281          {
   \                     aci_gap_set_authorization_requirement: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB0C9             SUB      SP,SP,#+292
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    282            struct hci_request rq;
    283            uint8_t cmd_buffer[258];
    284            aci_gap_set_authorization_requirement_cp0 *cp0 = (aci_gap_set_authorization_requirement_cp0*)(cmd_buffer);
   \   00000008   0xAE07             ADD      R6,SP,#+28
    285            tBleStatus status = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    286            uint8_t index_input = 0;
   \   00000010   0x2700             MOVS     R7,#+0
    287            cp0->Connection_Handle = htob(Connection_Handle, 2);
   \   00000012   0x8034             STRH     R4,[R6, #+0]
    288            index_input += 2;
   \   00000014   0x1CBF             ADDS     R7,R7,#+2
    289            cp0->Authorization_Enable = htob(Authorization_Enable, 1);
   \   00000016   0x70B5             STRB     R5,[R6, #+2]
    290            index_input += 1;
   \   00000018   0x1C7F             ADDS     R7,R7,#+1
    291            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000001A   0x2218             MOVS     R2,#+24
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0xA801             ADD      R0,SP,#+4
   \   00000020   0x.... 0x....      BL       Osal_MemSet
    292            rq.ogf = 0x3f;
   \   00000024   0x203F             MOVS     R0,#+63
   \   00000026   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    293            rq.ocf = 0x087;
   \   0000002A   0x2087             MOVS     R0,#+135
   \   0000002C   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    294            rq.cparam = cmd_buffer;
   \   00000030   0xA807             ADD      R0,SP,#+28
   \   00000032   0x9003             STR      R0,[SP, #+12]
    295            rq.clen = index_input;
   \   00000034   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000036   0x9704             STR      R7,[SP, #+16]
    296            rq.rparam = &status;
   \   00000038   0x4668             MOV      R0,SP
   \   0000003A   0x9005             STR      R0,[SP, #+20]
    297            rq.rlen = 1;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x9006             STR      R0,[SP, #+24]
    298            if (hci_send_req(&rq, FALSE) < 0)
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0xA801             ADD      R0,SP,#+4
   \   00000044   0x.... 0x....      BL       hci_send_req
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD501             BPL.N    ??aci_gap_set_authorization_requirement_0
    299              return BLE_STATUS_TIMEOUT;
   \   0000004C   0x20FF             MOVS     R0,#+255
   \   0000004E   0xE007             B.N      ??aci_gap_set_authorization_requirement_1
    300            if (status) {
   \                     ??aci_gap_set_authorization_requirement_0: (+1)
   \   00000050   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD002             BEQ.N    ??aci_gap_set_authorization_requirement_2
    301              return status;
   \   00000058   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005C   0xE000             B.N      ??aci_gap_set_authorization_requirement_1
    302            }
    303            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_set_authorization_requirement_2: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_set_authorization_requirement_1: (+1)
   \   00000060   0xB049             ADD      SP,SP,#+292
   \   00000062   0xBDF0             POP      {R4-R7,PC}       ;; return
    304          }

   \                                 In section .text, align 2, keep-with-next
    305          tBleStatus aci_gap_pass_key_resp(uint16_t Connection_Handle,
    306                                           uint32_t Pass_Key)
    307          {
   \                     aci_gap_pass_key_resp: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB0C9             SUB      SP,SP,#+292
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    308            struct hci_request rq;
    309            uint8_t cmd_buffer[258];
    310            aci_gap_pass_key_resp_cp0 *cp0 = (aci_gap_pass_key_resp_cp0*)(cmd_buffer);
   \   00000008   0xAE07             ADD      R6,SP,#+28
    311            tBleStatus status = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    312            uint8_t index_input = 0;
   \   00000010   0x2700             MOVS     R7,#+0
    313            cp0->Connection_Handle = htob(Connection_Handle, 2);
   \   00000012   0x8034             STRH     R4,[R6, #+0]
    314            index_input += 2;
   \   00000014   0x1CBF             ADDS     R7,R7,#+2
    315            cp0->Pass_Key = htob(Pass_Key, 4);
   \   00000016   0xF8C6 0x5002      STR      R5,[R6, #+2]
    316            index_input += 4;
   \   0000001A   0x1D3F             ADDS     R7,R7,#+4
    317            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000001C   0x2218             MOVS     R2,#+24
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0xA801             ADD      R0,SP,#+4
   \   00000022   0x.... 0x....      BL       Osal_MemSet
    318            rq.ogf = 0x3f;
   \   00000026   0x203F             MOVS     R0,#+63
   \   00000028   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    319            rq.ocf = 0x088;
   \   0000002C   0x2088             MOVS     R0,#+136
   \   0000002E   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    320            rq.cparam = cmd_buffer;
   \   00000032   0xA807             ADD      R0,SP,#+28
   \   00000034   0x9003             STR      R0,[SP, #+12]
    321            rq.clen = index_input;
   \   00000036   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000038   0x9704             STR      R7,[SP, #+16]
    322            rq.rparam = &status;
   \   0000003A   0x4668             MOV      R0,SP
   \   0000003C   0x9005             STR      R0,[SP, #+20]
    323            rq.rlen = 1;
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x9006             STR      R0,[SP, #+24]
    324            if (hci_send_req(&rq, FALSE) < 0)
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0xA801             ADD      R0,SP,#+4
   \   00000046   0x.... 0x....      BL       hci_send_req
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD501             BPL.N    ??aci_gap_pass_key_resp_0
    325              return BLE_STATUS_TIMEOUT;
   \   0000004E   0x20FF             MOVS     R0,#+255
   \   00000050   0xE007             B.N      ??aci_gap_pass_key_resp_1
    326            if (status) {
   \                     ??aci_gap_pass_key_resp_0: (+1)
   \   00000052   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD002             BEQ.N    ??aci_gap_pass_key_resp_2
    327              return status;
   \   0000005A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005E   0xE000             B.N      ??aci_gap_pass_key_resp_1
    328            }
    329            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_pass_key_resp_2: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_pass_key_resp_1: (+1)
   \   00000062   0xB049             ADD      SP,SP,#+292
   \   00000064   0xBDF0             POP      {R4-R7,PC}       ;; return
    330          }

   \                                 In section .text, align 2, keep-with-next
    331          tBleStatus aci_gap_authorization_resp(uint16_t Connection_Handle,
    332                                                uint8_t Authorize)
    333          {
   \                     aci_gap_authorization_resp: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB0C9             SUB      SP,SP,#+292
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    334            struct hci_request rq;
    335            uint8_t cmd_buffer[258];
    336            aci_gap_authorization_resp_cp0 *cp0 = (aci_gap_authorization_resp_cp0*)(cmd_buffer);
   \   00000008   0xAE07             ADD      R6,SP,#+28
    337            tBleStatus status = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    338            uint8_t index_input = 0;
   \   00000010   0x2700             MOVS     R7,#+0
    339            cp0->Connection_Handle = htob(Connection_Handle, 2);
   \   00000012   0x8034             STRH     R4,[R6, #+0]
    340            index_input += 2;
   \   00000014   0x1CBF             ADDS     R7,R7,#+2
    341            cp0->Authorize = htob(Authorize, 1);
   \   00000016   0x70B5             STRB     R5,[R6, #+2]
    342            index_input += 1;
   \   00000018   0x1C7F             ADDS     R7,R7,#+1
    343            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000001A   0x2218             MOVS     R2,#+24
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0xA801             ADD      R0,SP,#+4
   \   00000020   0x.... 0x....      BL       Osal_MemSet
    344            rq.ogf = 0x3f;
   \   00000024   0x203F             MOVS     R0,#+63
   \   00000026   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    345            rq.ocf = 0x089;
   \   0000002A   0x2089             MOVS     R0,#+137
   \   0000002C   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    346            rq.cparam = cmd_buffer;
   \   00000030   0xA807             ADD      R0,SP,#+28
   \   00000032   0x9003             STR      R0,[SP, #+12]
    347            rq.clen = index_input;
   \   00000034   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000036   0x9704             STR      R7,[SP, #+16]
    348            rq.rparam = &status;
   \   00000038   0x4668             MOV      R0,SP
   \   0000003A   0x9005             STR      R0,[SP, #+20]
    349            rq.rlen = 1;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x9006             STR      R0,[SP, #+24]
    350            if (hci_send_req(&rq, FALSE) < 0)
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0xA801             ADD      R0,SP,#+4
   \   00000044   0x.... 0x....      BL       hci_send_req
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD501             BPL.N    ??aci_gap_authorization_resp_0
    351              return BLE_STATUS_TIMEOUT;
   \   0000004C   0x20FF             MOVS     R0,#+255
   \   0000004E   0xE007             B.N      ??aci_gap_authorization_resp_1
    352            if (status) {
   \                     ??aci_gap_authorization_resp_0: (+1)
   \   00000050   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD002             BEQ.N    ??aci_gap_authorization_resp_2
    353              return status;
   \   00000058   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005C   0xE000             B.N      ??aci_gap_authorization_resp_1
    354            }
    355            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_authorization_resp_2: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_authorization_resp_1: (+1)
   \   00000060   0xB049             ADD      SP,SP,#+292
   \   00000062   0xBDF0             POP      {R4-R7,PC}       ;; return
    356          }

   \                                 In section .text, align 2, keep-with-next
    357          tBleStatus aci_gap_init(uint8_t Role,
    358                                  uint8_t privacy_enabled,
    359                                  uint8_t device_name_char_len,
    360                                  uint16_t *Service_Handle,
    361                                  uint16_t *Dev_Name_Char_Handle,
    362                                  uint16_t *Appearance_Char_Handle)
    363          {
   \                     aci_gap_init: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB0C9             SUB      SP,SP,#+292
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8148      LDR      R8,[SP, #+328]
   \   00000012   0xF8DD 0x914C      LDR      R9,[SP, #+332]
    364            struct hci_request rq;
    365            uint8_t cmd_buffer[258];
    366            aci_gap_init_cp0 *cp0 = (aci_gap_init_cp0*)(cmd_buffer);
   \   00000016   0xF10D 0x0A20      ADD      R10,SP,#+32
    367            aci_gap_init_rp0 resp;
    368            Osal_MemSet(&resp, 0, sizeof(resp));
   \   0000001A   0x2207             MOVS     R2,#+7
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x4668             MOV      R0,SP
   \   00000020   0x.... 0x....      BL       Osal_MemSet
    369            uint8_t index_input = 0;
   \   00000024   0xF05F 0x0B00      MOVS     R11,#+0
    370            cp0->Role = htob(Role, 1);
   \   00000028   0xF88A 0x4000      STRB     R4,[R10, #+0]
    371            index_input += 1;
   \   0000002C   0xF11B 0x0B01      ADDS     R11,R11,#+1
    372            cp0->privacy_enabled = htob(privacy_enabled, 1);
   \   00000030   0xF88A 0x5001      STRB     R5,[R10, #+1]
    373            index_input += 1;
   \   00000034   0xF11B 0x0B01      ADDS     R11,R11,#+1
    374            cp0->device_name_char_len = htob(device_name_char_len, 1);
   \   00000038   0xF88A 0x6002      STRB     R6,[R10, #+2]
    375            index_input += 1;
   \   0000003C   0xF11B 0x0B01      ADDS     R11,R11,#+1
    376            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000040   0x2218             MOVS     R2,#+24
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0xA802             ADD      R0,SP,#+8
   \   00000046   0x.... 0x....      BL       Osal_MemSet
    377            rq.ogf = 0x3f;
   \   0000004A   0x203F             MOVS     R0,#+63
   \   0000004C   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    378            rq.ocf = 0x08a;
   \   00000050   0x208A             MOVS     R0,#+138
   \   00000052   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    379            rq.cparam = cmd_buffer;
   \   00000056   0xA808             ADD      R0,SP,#+32
   \   00000058   0x9004             STR      R0,[SP, #+16]
    380            rq.clen = index_input;
   \   0000005A   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   0000005E   0xF8CD 0xB014      STR      R11,[SP, #+20]
    381            rq.rparam = &resp;
   \   00000062   0x4668             MOV      R0,SP
   \   00000064   0x9006             STR      R0,[SP, #+24]
    382            rq.rlen = sizeof(resp);
   \   00000066   0x2007             MOVS     R0,#+7
   \   00000068   0x9007             STR      R0,[SP, #+28]
    383            if (hci_send_req(&rq, FALSE) < 0)
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0xA802             ADD      R0,SP,#+8
   \   0000006E   0x.... 0x....      BL       hci_send_req
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD501             BPL.N    ??aci_gap_init_0
    384              return BLE_STATUS_TIMEOUT;
   \   00000076   0x20FF             MOVS     R0,#+255
   \   00000078   0xE012             B.N      ??aci_gap_init_1
    385            if (resp.Status) {
   \                     ??aci_gap_init_0: (+1)
   \   0000007A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD002             BEQ.N    ??aci_gap_init_2
    386              return resp.Status;
   \   00000082   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000086   0xE00B             B.N      ??aci_gap_init_1
    387            }
    388            *Service_Handle = btoh(resp.Service_Handle, 2);
   \                     ??aci_gap_init_2: (+1)
   \   00000088   0xF8BD 0x0001      LDRH     R0,[SP, #+1]
   \   0000008C   0x8038             STRH     R0,[R7, #+0]
    389            *Dev_Name_Char_Handle = btoh(resp.Dev_Name_Char_Handle, 2);
   \   0000008E   0xF8BD 0x0003      LDRH     R0,[SP, #+3]
   \   00000092   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    390            *Appearance_Char_Handle = btoh(resp.Appearance_Char_Handle, 2);
   \   00000096   0xF8BD 0x0005      LDRH     R0,[SP, #+5]
   \   0000009A   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    391            return BLE_STATUS_SUCCESS;
   \   0000009E   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_init_1: (+1)
   \   000000A0   0xB049             ADD      SP,SP,#+292
   \   000000A2   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    392          }

   \                                 In section .text, align 2, keep-with-next
    393          tBleStatus aci_gap_set_non_connectable(uint8_t Advertising_Event_Type,
    394                                                 uint8_t Own_Address_Type)
    395          {
   \                     aci_gap_set_non_connectable: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB0C9             SUB      SP,SP,#+292
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    396            struct hci_request rq;
    397            uint8_t cmd_buffer[258];
    398            aci_gap_set_non_connectable_cp0 *cp0 = (aci_gap_set_non_connectable_cp0*)(cmd_buffer);
   \   00000008   0xAE07             ADD      R6,SP,#+28
    399            tBleStatus status = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    400            uint8_t index_input = 0;
   \   00000010   0x2700             MOVS     R7,#+0
    401            cp0->Advertising_Event_Type = htob(Advertising_Event_Type, 1);
   \   00000012   0x7034             STRB     R4,[R6, #+0]
    402            index_input += 1;
   \   00000014   0x1C7F             ADDS     R7,R7,#+1
    403            cp0->Own_Address_Type = htob(Own_Address_Type, 1);
   \   00000016   0x7075             STRB     R5,[R6, #+1]
    404            index_input += 1;
   \   00000018   0x1C7F             ADDS     R7,R7,#+1
    405            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000001A   0x2218             MOVS     R2,#+24
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0xA801             ADD      R0,SP,#+4
   \   00000020   0x.... 0x....      BL       Osal_MemSet
    406            rq.ogf = 0x3f;
   \   00000024   0x203F             MOVS     R0,#+63
   \   00000026   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    407            rq.ocf = 0x08b;
   \   0000002A   0x208B             MOVS     R0,#+139
   \   0000002C   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    408            rq.cparam = cmd_buffer;
   \   00000030   0xA807             ADD      R0,SP,#+28
   \   00000032   0x9003             STR      R0,[SP, #+12]
    409            rq.clen = index_input;
   \   00000034   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000036   0x9704             STR      R7,[SP, #+16]
    410            rq.rparam = &status;
   \   00000038   0x4668             MOV      R0,SP
   \   0000003A   0x9005             STR      R0,[SP, #+20]
    411            rq.rlen = 1;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x9006             STR      R0,[SP, #+24]
    412            if (hci_send_req(&rq, FALSE) < 0)
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0xA801             ADD      R0,SP,#+4
   \   00000044   0x.... 0x....      BL       hci_send_req
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD501             BPL.N    ??aci_gap_set_non_connectable_0
    413              return BLE_STATUS_TIMEOUT;
   \   0000004C   0x20FF             MOVS     R0,#+255
   \   0000004E   0xE007             B.N      ??aci_gap_set_non_connectable_1
    414            if (status) {
   \                     ??aci_gap_set_non_connectable_0: (+1)
   \   00000050   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD002             BEQ.N    ??aci_gap_set_non_connectable_2
    415              return status;
   \   00000058   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005C   0xE000             B.N      ??aci_gap_set_non_connectable_1
    416            }
    417            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_set_non_connectable_2: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_set_non_connectable_1: (+1)
   \   00000060   0xB049             ADD      SP,SP,#+292
   \   00000062   0xBDF0             POP      {R4-R7,PC}       ;; return
    418          }

   \                                 In section .text, align 2, keep-with-next
    419          tBleStatus aci_gap_set_undirected_connectable(uint16_t Advertising_Interval_Min,
    420                                                        uint16_t Advertising_Interval_Max,
    421                                                        uint8_t Own_Address_Type,
    422                                                        uint8_t Adv_Filter_Policy)
    423          {
   \                     aci_gap_set_undirected_connectable: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB0C9             SUB      SP,SP,#+292
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
    424            struct hci_request rq;
    425            uint8_t cmd_buffer[258];
    426            aci_gap_set_undirected_connectable_cp0 *cp0 = (aci_gap_set_undirected_connectable_cp0*)(cmd_buffer);
   \   0000000E   0xF10D 0x081C      ADD      R8,SP,#+28
    427            tBleStatus status = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF88D 0x0000      STRB     R0,[SP, #+0]
    428            uint8_t index_input = 0;
   \   00000018   0xF05F 0x0900      MOVS     R9,#+0
    429            cp0->Advertising_Interval_Min = htob(Advertising_Interval_Min, 2);
   \   0000001C   0xF8A8 0x4000      STRH     R4,[R8, #+0]
    430            index_input += 2;
   \   00000020   0xF119 0x0902      ADDS     R9,R9,#+2
    431            cp0->Advertising_Interval_Max = htob(Advertising_Interval_Max, 2);
   \   00000024   0xF8A8 0x5002      STRH     R5,[R8, #+2]
    432            index_input += 2;
   \   00000028   0xF119 0x0902      ADDS     R9,R9,#+2
    433            cp0->Own_Address_Type = htob(Own_Address_Type, 1);
   \   0000002C   0xF888 0x6004      STRB     R6,[R8, #+4]
    434            index_input += 1;
   \   00000030   0xF119 0x0901      ADDS     R9,R9,#+1
    435            cp0->Adv_Filter_Policy = htob(Adv_Filter_Policy, 1);
   \   00000034   0xF888 0x7005      STRB     R7,[R8, #+5]
    436            index_input += 1;
   \   00000038   0xF119 0x0901      ADDS     R9,R9,#+1
    437            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000003C   0x2218             MOVS     R2,#+24
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0xA801             ADD      R0,SP,#+4
   \   00000042   0x.... 0x....      BL       Osal_MemSet
    438            rq.ogf = 0x3f;
   \   00000046   0x203F             MOVS     R0,#+63
   \   00000048   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    439            rq.ocf = 0x08c;
   \   0000004C   0x208C             MOVS     R0,#+140
   \   0000004E   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    440            rq.cparam = cmd_buffer;
   \   00000052   0xA807             ADD      R0,SP,#+28
   \   00000054   0x9003             STR      R0,[SP, #+12]
    441            rq.clen = index_input;
   \   00000056   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000005A   0xF8CD 0x9010      STR      R9,[SP, #+16]
    442            rq.rparam = &status;
   \   0000005E   0x4668             MOV      R0,SP
   \   00000060   0x9005             STR      R0,[SP, #+20]
    443            rq.rlen = 1;
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0x9006             STR      R0,[SP, #+24]
    444            if (hci_send_req(&rq, FALSE) < 0)
   \   00000066   0x2100             MOVS     R1,#+0
   \   00000068   0xA801             ADD      R0,SP,#+4
   \   0000006A   0x.... 0x....      BL       hci_send_req
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD501             BPL.N    ??aci_gap_set_undirected_connectable_0
    445              return BLE_STATUS_TIMEOUT;
   \   00000072   0x20FF             MOVS     R0,#+255
   \   00000074   0xE007             B.N      ??aci_gap_set_undirected_connectable_1
    446            if (status) {
   \                     ??aci_gap_set_undirected_connectable_0: (+1)
   \   00000076   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD002             BEQ.N    ??aci_gap_set_undirected_connectable_2
    447              return status;
   \   0000007E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000082   0xE000             B.N      ??aci_gap_set_undirected_connectable_1
    448            }
    449            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_set_undirected_connectable_2: (+1)
   \   00000084   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_set_undirected_connectable_1: (+1)
   \   00000086   0xB049             ADD      SP,SP,#+292
   \   00000088   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    450          }

   \                                 In section .text, align 2, keep-with-next
    451          tBleStatus aci_gap_slave_security_req(uint16_t Connection_Handle)
    452          {
   \                     aci_gap_slave_security_req: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB0C8             SUB      SP,SP,#+288
   \   00000004   0x0004             MOVS     R4,R0
    453            struct hci_request rq;
    454            uint8_t cmd_buffer[258];
    455            aci_gap_slave_security_req_cp0 *cp0 = (aci_gap_slave_security_req_cp0*)(cmd_buffer);
   \   00000006   0xAD07             ADD      R5,SP,#+28
    456            tBleStatus status = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    457            uint8_t index_input = 0;
   \   0000000E   0x2600             MOVS     R6,#+0
    458            cp0->Connection_Handle = htob(Connection_Handle, 2);
   \   00000010   0x802C             STRH     R4,[R5, #+0]
    459            index_input += 2;
   \   00000012   0x1CB6             ADDS     R6,R6,#+2
    460            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000014   0x2218             MOVS     R2,#+24
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0xA801             ADD      R0,SP,#+4
   \   0000001A   0x.... 0x....      BL       Osal_MemSet
    461            rq.ogf = 0x3f;
   \   0000001E   0x203F             MOVS     R0,#+63
   \   00000020   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    462            rq.ocf = 0x08d;
   \   00000024   0x208D             MOVS     R0,#+141
   \   00000026   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    463            rq.event = 0x0F;
   \   0000002A   0x200F             MOVS     R0,#+15
   \   0000002C   0x9002             STR      R0,[SP, #+8]
    464            rq.cparam = cmd_buffer;
   \   0000002E   0xA807             ADD      R0,SP,#+28
   \   00000030   0x9003             STR      R0,[SP, #+12]
    465            rq.clen = index_input;
   \   00000032   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000034   0x9604             STR      R6,[SP, #+16]
    466            rq.rparam = &status;
   \   00000036   0x4668             MOV      R0,SP
   \   00000038   0x9005             STR      R0,[SP, #+20]
    467            rq.rlen = 1;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x9006             STR      R0,[SP, #+24]
    468            if (hci_send_req(&rq, FALSE) < 0)
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0xA801             ADD      R0,SP,#+4
   \   00000042   0x.... 0x....      BL       hci_send_req
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD501             BPL.N    ??aci_gap_slave_security_req_0
    469              return BLE_STATUS_TIMEOUT;
   \   0000004A   0x20FF             MOVS     R0,#+255
   \   0000004C   0xE007             B.N      ??aci_gap_slave_security_req_1
    470            if (status) {
   \                     ??aci_gap_slave_security_req_0: (+1)
   \   0000004E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD002             BEQ.N    ??aci_gap_slave_security_req_2
    471              return status;
   \   00000056   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005A   0xE000             B.N      ??aci_gap_slave_security_req_1
    472            }
    473            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_slave_security_req_2: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_slave_security_req_1: (+1)
   \   0000005E   0xB048             ADD      SP,SP,#+288
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return
    474          }

   \                                 In section .text, align 2, keep-with-next
    475          tBleStatus aci_gap_update_adv_data(uint8_t AdvDataLen,
    476                                             uint8_t AdvData[])
    477          {
   \                     aci_gap_update_adv_data: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB0C9             SUB      SP,SP,#+292
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    478            struct hci_request rq;
    479            uint8_t cmd_buffer[258];
    480            aci_gap_update_adv_data_cp0 *cp0 = (aci_gap_update_adv_data_cp0*)(cmd_buffer);
   \   00000008   0xAE07             ADD      R6,SP,#+28
    481            tBleStatus status = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    482            uint8_t index_input = 0;
   \   00000010   0x2700             MOVS     R7,#+0
    483            cp0->AdvDataLen = htob(AdvDataLen, 1);
   \   00000012   0x7034             STRB     R4,[R6, #+0]
    484            index_input += 1;
   \   00000014   0x1C7F             ADDS     R7,R7,#+1
    485            Osal_MemCpy((void *) &cp0->AdvData, (const void *) AdvData, AdvDataLen);
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x0022             MOVS     R2,R4
   \   0000001A   0x0029             MOVS     R1,R5
   \   0000001C   0x1C70             ADDS     R0,R6,#+1
   \   0000001E   0x.... 0x....      BL       Osal_MemCpy
    486            index_input += AdvDataLen;
   \   00000022   0x19E7             ADDS     R7,R4,R7
    487            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000024   0x2218             MOVS     R2,#+24
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0xA801             ADD      R0,SP,#+4
   \   0000002A   0x.... 0x....      BL       Osal_MemSet
    488            rq.ogf = 0x3f;
   \   0000002E   0x203F             MOVS     R0,#+63
   \   00000030   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    489            rq.ocf = 0x08e;
   \   00000034   0x208E             MOVS     R0,#+142
   \   00000036   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    490            rq.cparam = cmd_buffer;
   \   0000003A   0xA807             ADD      R0,SP,#+28
   \   0000003C   0x9003             STR      R0,[SP, #+12]
    491            rq.clen = index_input;
   \   0000003E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000040   0x9704             STR      R7,[SP, #+16]
    492            rq.rparam = &status;
   \   00000042   0x4668             MOV      R0,SP
   \   00000044   0x9005             STR      R0,[SP, #+20]
    493            rq.rlen = 1;
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x9006             STR      R0,[SP, #+24]
    494            if (hci_send_req(&rq, FALSE) < 0)
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0xA801             ADD      R0,SP,#+4
   \   0000004E   0x.... 0x....      BL       hci_send_req
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD501             BPL.N    ??aci_gap_update_adv_data_0
    495              return BLE_STATUS_TIMEOUT;
   \   00000056   0x20FF             MOVS     R0,#+255
   \   00000058   0xE007             B.N      ??aci_gap_update_adv_data_1
    496            if (status) {
   \                     ??aci_gap_update_adv_data_0: (+1)
   \   0000005A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD002             BEQ.N    ??aci_gap_update_adv_data_2
    497              return status;
   \   00000062   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000066   0xE000             B.N      ??aci_gap_update_adv_data_1
    498            }
    499            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_update_adv_data_2: (+1)
   \   00000068   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_update_adv_data_1: (+1)
   \   0000006A   0xB049             ADD      SP,SP,#+292
   \   0000006C   0xBDF0             POP      {R4-R7,PC}       ;; return
    500          }

   \                                 In section .text, align 2, keep-with-next
    501          tBleStatus aci_gap_delete_ad_type(uint8_t ADType)
    502          {
   \                     aci_gap_delete_ad_type: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB0C8             SUB      SP,SP,#+288
   \   00000004   0x0004             MOVS     R4,R0
    503            struct hci_request rq;
    504            uint8_t cmd_buffer[258];
    505            aci_gap_delete_ad_type_cp0 *cp0 = (aci_gap_delete_ad_type_cp0*)(cmd_buffer);
   \   00000006   0xAD07             ADD      R5,SP,#+28
    506            tBleStatus status = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    507            uint8_t index_input = 0;
   \   0000000E   0x2600             MOVS     R6,#+0
    508            cp0->ADType = htob(ADType, 1);
   \   00000010   0x702C             STRB     R4,[R5, #+0]
    509            index_input += 1;
   \   00000012   0x1C76             ADDS     R6,R6,#+1
    510            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000014   0x2218             MOVS     R2,#+24
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0xA801             ADD      R0,SP,#+4
   \   0000001A   0x.... 0x....      BL       Osal_MemSet
    511            rq.ogf = 0x3f;
   \   0000001E   0x203F             MOVS     R0,#+63
   \   00000020   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    512            rq.ocf = 0x08f;
   \   00000024   0x208F             MOVS     R0,#+143
   \   00000026   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    513            rq.cparam = cmd_buffer;
   \   0000002A   0xA807             ADD      R0,SP,#+28
   \   0000002C   0x9003             STR      R0,[SP, #+12]
    514            rq.clen = index_input;
   \   0000002E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000030   0x9604             STR      R6,[SP, #+16]
    515            rq.rparam = &status;
   \   00000032   0x4668             MOV      R0,SP
   \   00000034   0x9005             STR      R0,[SP, #+20]
    516            rq.rlen = 1;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x9006             STR      R0,[SP, #+24]
    517            if (hci_send_req(&rq, FALSE) < 0)
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0xA801             ADD      R0,SP,#+4
   \   0000003E   0x.... 0x....      BL       hci_send_req
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD501             BPL.N    ??aci_gap_delete_ad_type_0
    518              return BLE_STATUS_TIMEOUT;
   \   00000046   0x20FF             MOVS     R0,#+255
   \   00000048   0xE007             B.N      ??aci_gap_delete_ad_type_1
    519            if (status) {
   \                     ??aci_gap_delete_ad_type_0: (+1)
   \   0000004A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD002             BEQ.N    ??aci_gap_delete_ad_type_2
    520              return status;
   \   00000052   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000056   0xE000             B.N      ??aci_gap_delete_ad_type_1
    521            }
    522            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_delete_ad_type_2: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_delete_ad_type_1: (+1)
   \   0000005A   0xB048             ADD      SP,SP,#+288
   \   0000005C   0xBD70             POP      {R4-R6,PC}       ;; return
    523          }

   \                                 In section .text, align 2, keep-with-next
    524          tBleStatus aci_gap_get_security_level(uint16_t Connection_Handle,
    525                                                uint8_t *Security_Mode,
    526                                                uint8_t *Security_Level)
    527          {
   \                     aci_gap_get_security_level: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB0C8             SUB      SP,SP,#+288
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    528            struct hci_request rq;
    529            uint8_t cmd_buffer[258];
    530            aci_gap_get_security_level_cp0 *cp0 = (aci_gap_get_security_level_cp0*)(cmd_buffer);
   \   0000000C   0xAF07             ADD      R7,SP,#+28
    531            aci_gap_get_security_level_rp0 resp;
    532            Osal_MemSet(&resp, 0, sizeof(resp));
   \   0000000E   0x2203             MOVS     R2,#+3
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x4668             MOV      R0,SP
   \   00000014   0x.... 0x....      BL       Osal_MemSet
    533            uint8_t index_input = 0;
   \   00000018   0xF05F 0x0800      MOVS     R8,#+0
    534            cp0->Connection_Handle = htob(Connection_Handle, 2);
   \   0000001C   0x803C             STRH     R4,[R7, #+0]
    535            index_input += 2;
   \   0000001E   0xF118 0x0802      ADDS     R8,R8,#+2
    536            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000022   0x2218             MOVS     R2,#+24
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0xA801             ADD      R0,SP,#+4
   \   00000028   0x.... 0x....      BL       Osal_MemSet
    537            rq.ogf = 0x3f;
   \   0000002C   0x203F             MOVS     R0,#+63
   \   0000002E   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    538            rq.ocf = 0x090;
   \   00000032   0x2090             MOVS     R0,#+144
   \   00000034   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    539            rq.cparam = cmd_buffer;
   \   00000038   0xA807             ADD      R0,SP,#+28
   \   0000003A   0x9003             STR      R0,[SP, #+12]
    540            rq.clen = index_input;
   \   0000003C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000040   0xF8CD 0x8010      STR      R8,[SP, #+16]
    541            rq.rparam = &resp;
   \   00000044   0x4668             MOV      R0,SP
   \   00000046   0x9005             STR      R0,[SP, #+20]
    542            rq.rlen = sizeof(resp);
   \   00000048   0x2003             MOVS     R0,#+3
   \   0000004A   0x9006             STR      R0,[SP, #+24]
    543            if (hci_send_req(&rq, FALSE) < 0)
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0xA801             ADD      R0,SP,#+4
   \   00000050   0x.... 0x....      BL       hci_send_req
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD501             BPL.N    ??aci_gap_get_security_level_0
    544              return BLE_STATUS_TIMEOUT;
   \   00000058   0x20FF             MOVS     R0,#+255
   \   0000005A   0xE00D             B.N      ??aci_gap_get_security_level_1
    545            if (resp.Status) {
   \                     ??aci_gap_get_security_level_0: (+1)
   \   0000005C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD002             BEQ.N    ??aci_gap_get_security_level_2
    546              return resp.Status;
   \   00000064   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000068   0xE006             B.N      ??aci_gap_get_security_level_1
    547            }
    548            *Security_Mode = btoh(resp.Security_Mode, 1);
   \                     ??aci_gap_get_security_level_2: (+1)
   \   0000006A   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000006E   0x7028             STRB     R0,[R5, #+0]
    549            *Security_Level = btoh(resp.Security_Level, 1);
   \   00000070   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000074   0x7030             STRB     R0,[R6, #+0]
    550            return BLE_STATUS_SUCCESS;
   \   00000076   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_get_security_level_1: (+1)
   \   00000078   0xB048             ADD      SP,SP,#+288
   \   0000007A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    551          }

   \                                 In section .text, align 2, keep-with-next
    552          tBleStatus aci_gap_set_event_mask(uint16_t GAP_Evt_Mask)
    553          {
   \                     aci_gap_set_event_mask: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB0C8             SUB      SP,SP,#+288
   \   00000004   0x0004             MOVS     R4,R0
    554            struct hci_request rq;
    555            uint8_t cmd_buffer[258];
    556            aci_gap_set_event_mask_cp0 *cp0 = (aci_gap_set_event_mask_cp0*)(cmd_buffer);
   \   00000006   0xAD07             ADD      R5,SP,#+28
    557            tBleStatus status = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    558            uint8_t index_input = 0;
   \   0000000E   0x2600             MOVS     R6,#+0
    559            cp0->GAP_Evt_Mask = htob(GAP_Evt_Mask, 2);
   \   00000010   0x802C             STRH     R4,[R5, #+0]
    560            index_input += 2;
   \   00000012   0x1CB6             ADDS     R6,R6,#+2
    561            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000014   0x2218             MOVS     R2,#+24
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0xA801             ADD      R0,SP,#+4
   \   0000001A   0x.... 0x....      BL       Osal_MemSet
    562            rq.ogf = 0x3f;
   \   0000001E   0x203F             MOVS     R0,#+63
   \   00000020   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    563            rq.ocf = 0x091;
   \   00000024   0x2091             MOVS     R0,#+145
   \   00000026   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    564            rq.cparam = cmd_buffer;
   \   0000002A   0xA807             ADD      R0,SP,#+28
   \   0000002C   0x9003             STR      R0,[SP, #+12]
    565            rq.clen = index_input;
   \   0000002E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000030   0x9604             STR      R6,[SP, #+16]
    566            rq.rparam = &status;
   \   00000032   0x4668             MOV      R0,SP
   \   00000034   0x9005             STR      R0,[SP, #+20]
    567            rq.rlen = 1;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x9006             STR      R0,[SP, #+24]
    568            if (hci_send_req(&rq, FALSE) < 0)
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0xA801             ADD      R0,SP,#+4
   \   0000003E   0x.... 0x....      BL       hci_send_req
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD501             BPL.N    ??aci_gap_set_event_mask_0
    569              return BLE_STATUS_TIMEOUT;
   \   00000046   0x20FF             MOVS     R0,#+255
   \   00000048   0xE007             B.N      ??aci_gap_set_event_mask_1
    570            if (status) {
   \                     ??aci_gap_set_event_mask_0: (+1)
   \   0000004A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD002             BEQ.N    ??aci_gap_set_event_mask_2
    571              return status;
   \   00000052   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000056   0xE000             B.N      ??aci_gap_set_event_mask_1
    572            }
    573            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_set_event_mask_2: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_set_event_mask_1: (+1)
   \   0000005A   0xB048             ADD      SP,SP,#+288
   \   0000005C   0xBD70             POP      {R4-R6,PC}       ;; return
    574          }

   \                                 In section .text, align 2, keep-with-next
    575          tBleStatus aci_gap_configure_whitelist(void)
    576          {
   \                     aci_gap_configure_whitelist: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    577            struct hci_request rq;
    578            tBleStatus status = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
    579            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000000A   0x2218             MOVS     R2,#+24
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0xA801             ADD      R0,SP,#+4
   \   00000010   0x.... 0x....      BL       Osal_MemSet
    580            rq.ogf = 0x3f;
   \   00000014   0x203F             MOVS     R0,#+63
   \   00000016   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    581            rq.ocf = 0x092;
   \   0000001A   0x2092             MOVS     R0,#+146
   \   0000001C   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    582            rq.rparam = &status;
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x9005             STR      R0,[SP, #+20]
    583            rq.rlen = 1;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x9006             STR      R0,[SP, #+24]
    584            if (hci_send_req(&rq, FALSE) < 0)
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0xA801             ADD      R0,SP,#+4
   \   0000002C   0x.... 0x....      BL       hci_send_req
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD501             BPL.N    ??aci_gap_configure_whitelist_0
    585              return BLE_STATUS_TIMEOUT;
   \   00000034   0x20FF             MOVS     R0,#+255
   \   00000036   0xE007             B.N      ??aci_gap_configure_whitelist_1
    586            if (status) {
   \                     ??aci_gap_configure_whitelist_0: (+1)
   \   00000038   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD002             BEQ.N    ??aci_gap_configure_whitelist_2
    587              return status;
   \   00000040   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000044   0xE000             B.N      ??aci_gap_configure_whitelist_1
    588            }
    589            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_configure_whitelist_2: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_configure_whitelist_1: (+1)
   \   00000048   0xB007             ADD      SP,SP,#+28
   \   0000004A   0xBD00             POP      {PC}             ;; return
    590          }

   \                                 In section .text, align 2, keep-with-next
    591          tBleStatus aci_gap_terminate(uint16_t Connection_Handle,
    592                                       uint8_t Reason)
    593          {
   \                     aci_gap_terminate: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB0C9             SUB      SP,SP,#+292
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    594            struct hci_request rq;
    595            uint8_t cmd_buffer[258];
    596            aci_gap_terminate_cp0 *cp0 = (aci_gap_terminate_cp0*)(cmd_buffer);
   \   00000008   0xAE07             ADD      R6,SP,#+28
    597            tBleStatus status = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    598            uint8_t index_input = 0;
   \   00000010   0x2700             MOVS     R7,#+0
    599            cp0->Connection_Handle = htob(Connection_Handle, 2);
   \   00000012   0x8034             STRH     R4,[R6, #+0]
    600            index_input += 2;
   \   00000014   0x1CBF             ADDS     R7,R7,#+2
    601            cp0->Reason = htob(Reason, 1);
   \   00000016   0x70B5             STRB     R5,[R6, #+2]
    602            index_input += 1;
   \   00000018   0x1C7F             ADDS     R7,R7,#+1
    603            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000001A   0x2218             MOVS     R2,#+24
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0xA801             ADD      R0,SP,#+4
   \   00000020   0x.... 0x....      BL       Osal_MemSet
    604            rq.ogf = 0x3f;
   \   00000024   0x203F             MOVS     R0,#+63
   \   00000026   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    605            rq.ocf = 0x093;
   \   0000002A   0x2093             MOVS     R0,#+147
   \   0000002C   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    606            rq.event = 0x0F;
   \   00000030   0x200F             MOVS     R0,#+15
   \   00000032   0x9002             STR      R0,[SP, #+8]
    607            rq.cparam = cmd_buffer;
   \   00000034   0xA807             ADD      R0,SP,#+28
   \   00000036   0x9003             STR      R0,[SP, #+12]
    608            rq.clen = index_input;
   \   00000038   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003A   0x9704             STR      R7,[SP, #+16]
    609            rq.rparam = &status;
   \   0000003C   0x4668             MOV      R0,SP
   \   0000003E   0x9005             STR      R0,[SP, #+20]
    610            rq.rlen = 1;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x9006             STR      R0,[SP, #+24]
    611            if (hci_send_req(&rq, FALSE) < 0)
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0xA801             ADD      R0,SP,#+4
   \   00000048   0x.... 0x....      BL       hci_send_req
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD501             BPL.N    ??aci_gap_terminate_0
    612              return BLE_STATUS_TIMEOUT;
   \   00000050   0x20FF             MOVS     R0,#+255
   \   00000052   0xE007             B.N      ??aci_gap_terminate_1
    613            if (status) {
   \                     ??aci_gap_terminate_0: (+1)
   \   00000054   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD002             BEQ.N    ??aci_gap_terminate_2
    614              return status;
   \   0000005C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000060   0xE000             B.N      ??aci_gap_terminate_1
    615            }
    616            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_terminate_2: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_terminate_1: (+1)
   \   00000064   0xB049             ADD      SP,SP,#+292
   \   00000066   0xBDF0             POP      {R4-R7,PC}       ;; return
    617          }

   \                                 In section .text, align 2, keep-with-next
    618          tBleStatus aci_gap_clear_security_db(void)
    619          {
   \                     aci_gap_clear_security_db: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    620            struct hci_request rq;
    621            tBleStatus status = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
    622            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000000A   0x2218             MOVS     R2,#+24
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0xA801             ADD      R0,SP,#+4
   \   00000010   0x.... 0x....      BL       Osal_MemSet
    623            rq.ogf = 0x3f;
   \   00000014   0x203F             MOVS     R0,#+63
   \   00000016   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    624            rq.ocf = 0x094;
   \   0000001A   0x2094             MOVS     R0,#+148
   \   0000001C   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    625            rq.rparam = &status;
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x9005             STR      R0,[SP, #+20]
    626            rq.rlen = 1;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x9006             STR      R0,[SP, #+24]
    627            if (hci_send_req(&rq, FALSE) < 0)
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0xA801             ADD      R0,SP,#+4
   \   0000002C   0x.... 0x....      BL       hci_send_req
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD501             BPL.N    ??aci_gap_clear_security_db_0
    628              return BLE_STATUS_TIMEOUT;
   \   00000034   0x20FF             MOVS     R0,#+255
   \   00000036   0xE007             B.N      ??aci_gap_clear_security_db_1
    629            if (status) {
   \                     ??aci_gap_clear_security_db_0: (+1)
   \   00000038   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD002             BEQ.N    ??aci_gap_clear_security_db_2
    630              return status;
   \   00000040   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000044   0xE000             B.N      ??aci_gap_clear_security_db_1
    631            }
    632            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_clear_security_db_2: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_clear_security_db_1: (+1)
   \   00000048   0xB007             ADD      SP,SP,#+28
   \   0000004A   0xBD00             POP      {PC}             ;; return
    633          }

   \                                 In section .text, align 2, keep-with-next
    634          tBleStatus aci_gap_allow_rebond(uint16_t Connection_Handle)
    635          {
   \                     aci_gap_allow_rebond: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB0C8             SUB      SP,SP,#+288
   \   00000004   0x0004             MOVS     R4,R0
    636            struct hci_request rq;
    637            uint8_t cmd_buffer[258];
    638            aci_gap_allow_rebond_cp0 *cp0 = (aci_gap_allow_rebond_cp0*)(cmd_buffer);
   \   00000006   0xAD07             ADD      R5,SP,#+28
    639            tBleStatus status = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    640            uint8_t index_input = 0;
   \   0000000E   0x2600             MOVS     R6,#+0
    641            cp0->Connection_Handle = htob(Connection_Handle, 2);
   \   00000010   0x802C             STRH     R4,[R5, #+0]
    642            index_input += 2;
   \   00000012   0x1CB6             ADDS     R6,R6,#+2
    643            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000014   0x2218             MOVS     R2,#+24
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0xA801             ADD      R0,SP,#+4
   \   0000001A   0x.... 0x....      BL       Osal_MemSet
    644            rq.ogf = 0x3f;
   \   0000001E   0x203F             MOVS     R0,#+63
   \   00000020   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    645            rq.ocf = 0x095;
   \   00000024   0x2095             MOVS     R0,#+149
   \   00000026   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    646            rq.cparam = cmd_buffer;
   \   0000002A   0xA807             ADD      R0,SP,#+28
   \   0000002C   0x9003             STR      R0,[SP, #+12]
    647            rq.clen = index_input;
   \   0000002E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000030   0x9604             STR      R6,[SP, #+16]
    648            rq.rparam = &status;
   \   00000032   0x4668             MOV      R0,SP
   \   00000034   0x9005             STR      R0,[SP, #+20]
    649            rq.rlen = 1;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x9006             STR      R0,[SP, #+24]
    650            if (hci_send_req(&rq, FALSE) < 0)
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0xA801             ADD      R0,SP,#+4
   \   0000003E   0x.... 0x....      BL       hci_send_req
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD501             BPL.N    ??aci_gap_allow_rebond_0
    651              return BLE_STATUS_TIMEOUT;
   \   00000046   0x20FF             MOVS     R0,#+255
   \   00000048   0xE007             B.N      ??aci_gap_allow_rebond_1
    652            if (status) {
   \                     ??aci_gap_allow_rebond_0: (+1)
   \   0000004A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD002             BEQ.N    ??aci_gap_allow_rebond_2
    653              return status;
   \   00000052   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000056   0xE000             B.N      ??aci_gap_allow_rebond_1
    654            }
    655            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_allow_rebond_2: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_allow_rebond_1: (+1)
   \   0000005A   0xB048             ADD      SP,SP,#+288
   \   0000005C   0xBD70             POP      {R4-R6,PC}       ;; return
    656          }

   \                                 In section .text, align 2, keep-with-next
    657          tBleStatus aci_gap_start_limited_discovery_proc(uint16_t LE_Scan_Interval,
    658                                                          uint16_t LE_Scan_Window,
    659                                                          uint8_t Own_Address_Type,
    660                                                          uint8_t Filter_Duplicates)
    661          {
   \                     aci_gap_start_limited_discovery_proc: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB0C9             SUB      SP,SP,#+292
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
    662            struct hci_request rq;
    663            uint8_t cmd_buffer[258];
    664            aci_gap_start_limited_discovery_proc_cp0 *cp0 = (aci_gap_start_limited_discovery_proc_cp0*)(cmd_buffer);
   \   0000000E   0xF10D 0x081C      ADD      R8,SP,#+28
    665            tBleStatus status = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF88D 0x0000      STRB     R0,[SP, #+0]
    666            uint8_t index_input = 0;
   \   00000018   0xF05F 0x0900      MOVS     R9,#+0
    667            cp0->LE_Scan_Interval = htob(LE_Scan_Interval, 2);
   \   0000001C   0xF8A8 0x4000      STRH     R4,[R8, #+0]
    668            index_input += 2;
   \   00000020   0xF119 0x0902      ADDS     R9,R9,#+2
    669            cp0->LE_Scan_Window = htob(LE_Scan_Window, 2);
   \   00000024   0xF8A8 0x5002      STRH     R5,[R8, #+2]
    670            index_input += 2;
   \   00000028   0xF119 0x0902      ADDS     R9,R9,#+2
    671            cp0->Own_Address_Type = htob(Own_Address_Type, 1);
   \   0000002C   0xF888 0x6004      STRB     R6,[R8, #+4]
    672            index_input += 1;
   \   00000030   0xF119 0x0901      ADDS     R9,R9,#+1
    673            cp0->Filter_Duplicates = htob(Filter_Duplicates, 1);
   \   00000034   0xF888 0x7005      STRB     R7,[R8, #+5]
    674            index_input += 1;
   \   00000038   0xF119 0x0901      ADDS     R9,R9,#+1
    675            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000003C   0x2218             MOVS     R2,#+24
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0xA801             ADD      R0,SP,#+4
   \   00000042   0x.... 0x....      BL       Osal_MemSet
    676            rq.ogf = 0x3f;
   \   00000046   0x203F             MOVS     R0,#+63
   \   00000048   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    677            rq.ocf = 0x096;
   \   0000004C   0x2096             MOVS     R0,#+150
   \   0000004E   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    678            rq.event = 0x0F;
   \   00000052   0x200F             MOVS     R0,#+15
   \   00000054   0x9002             STR      R0,[SP, #+8]
    679            rq.cparam = cmd_buffer;
   \   00000056   0xA807             ADD      R0,SP,#+28
   \   00000058   0x9003             STR      R0,[SP, #+12]
    680            rq.clen = index_input;
   \   0000005A   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000005E   0xF8CD 0x9010      STR      R9,[SP, #+16]
    681            rq.rparam = &status;
   \   00000062   0x4668             MOV      R0,SP
   \   00000064   0x9005             STR      R0,[SP, #+20]
    682            rq.rlen = 1;
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0x9006             STR      R0,[SP, #+24]
    683            if (hci_send_req(&rq, FALSE) < 0)
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0xA801             ADD      R0,SP,#+4
   \   0000006E   0x.... 0x....      BL       hci_send_req
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD501             BPL.N    ??aci_gap_start_limited_discovery_proc_0
    684              return BLE_STATUS_TIMEOUT;
   \   00000076   0x20FF             MOVS     R0,#+255
   \   00000078   0xE007             B.N      ??aci_gap_start_limited_discovery_proc_1
    685            if (status) {
   \                     ??aci_gap_start_limited_discovery_proc_0: (+1)
   \   0000007A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD002             BEQ.N    ??aci_gap_start_limited_discovery_proc_2
    686              return status;
   \   00000082   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000086   0xE000             B.N      ??aci_gap_start_limited_discovery_proc_1
    687            }
    688            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_start_limited_discovery_proc_2: (+1)
   \   00000088   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_start_limited_discovery_proc_1: (+1)
   \   0000008A   0xB049             ADD      SP,SP,#+292
   \   0000008C   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    689          }

   \                                 In section .text, align 2, keep-with-next
    690          tBleStatus aci_gap_start_general_discovery_proc(uint16_t LE_Scan_Interval,
    691                                                          uint16_t LE_Scan_Window,
    692                                                          uint8_t Own_Address_Type,
    693                                                          uint8_t Filter_Duplicates)
    694          {
   \                     aci_gap_start_general_discovery_proc: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB0C9             SUB      SP,SP,#+292
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
    695            struct hci_request rq;
    696            uint8_t cmd_buffer[258];
    697            aci_gap_start_general_discovery_proc_cp0 *cp0 = (aci_gap_start_general_discovery_proc_cp0*)(cmd_buffer);
   \   0000000E   0xF10D 0x081C      ADD      R8,SP,#+28
    698            tBleStatus status = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF88D 0x0000      STRB     R0,[SP, #+0]
    699            uint8_t index_input = 0;
   \   00000018   0xF05F 0x0900      MOVS     R9,#+0
    700            cp0->LE_Scan_Interval = htob(LE_Scan_Interval, 2);
   \   0000001C   0xF8A8 0x4000      STRH     R4,[R8, #+0]
    701            index_input += 2;
   \   00000020   0xF119 0x0902      ADDS     R9,R9,#+2
    702            cp0->LE_Scan_Window = htob(LE_Scan_Window, 2);
   \   00000024   0xF8A8 0x5002      STRH     R5,[R8, #+2]
    703            index_input += 2;
   \   00000028   0xF119 0x0902      ADDS     R9,R9,#+2
    704            cp0->Own_Address_Type = htob(Own_Address_Type, 1);
   \   0000002C   0xF888 0x6004      STRB     R6,[R8, #+4]
    705            index_input += 1;
   \   00000030   0xF119 0x0901      ADDS     R9,R9,#+1
    706            cp0->Filter_Duplicates = htob(Filter_Duplicates, 1);
   \   00000034   0xF888 0x7005      STRB     R7,[R8, #+5]
    707            index_input += 1;
   \   00000038   0xF119 0x0901      ADDS     R9,R9,#+1
    708            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000003C   0x2218             MOVS     R2,#+24
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0xA801             ADD      R0,SP,#+4
   \   00000042   0x.... 0x....      BL       Osal_MemSet
    709            rq.ogf = 0x3f;
   \   00000046   0x203F             MOVS     R0,#+63
   \   00000048   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    710            rq.ocf = 0x097;
   \   0000004C   0x2097             MOVS     R0,#+151
   \   0000004E   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    711            rq.event = 0x0F;
   \   00000052   0x200F             MOVS     R0,#+15
   \   00000054   0x9002             STR      R0,[SP, #+8]
    712            rq.cparam = cmd_buffer;
   \   00000056   0xA807             ADD      R0,SP,#+28
   \   00000058   0x9003             STR      R0,[SP, #+12]
    713            rq.clen = index_input;
   \   0000005A   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000005E   0xF8CD 0x9010      STR      R9,[SP, #+16]
    714            rq.rparam = &status;
   \   00000062   0x4668             MOV      R0,SP
   \   00000064   0x9005             STR      R0,[SP, #+20]
    715            rq.rlen = 1;
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0x9006             STR      R0,[SP, #+24]
    716            if (hci_send_req(&rq, FALSE) < 0)
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0xA801             ADD      R0,SP,#+4
   \   0000006E   0x.... 0x....      BL       hci_send_req
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD501             BPL.N    ??aci_gap_start_general_discovery_proc_0
    717              return BLE_STATUS_TIMEOUT;
   \   00000076   0x20FF             MOVS     R0,#+255
   \   00000078   0xE007             B.N      ??aci_gap_start_general_discovery_proc_1
    718            if (status) {
   \                     ??aci_gap_start_general_discovery_proc_0: (+1)
   \   0000007A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD002             BEQ.N    ??aci_gap_start_general_discovery_proc_2
    719              return status;
   \   00000082   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000086   0xE000             B.N      ??aci_gap_start_general_discovery_proc_1
    720            }
    721            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_start_general_discovery_proc_2: (+1)
   \   00000088   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_start_general_discovery_proc_1: (+1)
   \   0000008A   0xB049             ADD      SP,SP,#+292
   \   0000008C   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    722          }

   \                                 In section .text, align 2, keep-with-next
    723          tBleStatus aci_gap_start_name_discovery_proc(uint16_t LE_Scan_Interval,
    724                                                       uint16_t LE_Scan_Window,
    725                                                       uint8_t Peer_Address_Type,
    726                                                       uint8_t Peer_Address[6],
    727                                                       uint8_t Own_Address_Type,
    728                                                       uint16_t Conn_Interval_Min,
    729                                                       uint16_t Conn_Interval_Max,
    730                                                       uint16_t Conn_Latency,
    731                                                       uint16_t Supervision_Timeout,
    732                                                       uint16_t Minimum_CE_Length,
    733                                                       uint16_t Maximum_CE_Length)
    734          {
   \                     aci_gap_start_name_discovery_proc: (+1)
   \   00000000   0xE92D 0x4FFF      PUSH     {R0-R11,LR}
   \   00000004   0xB0C9             SUB      SP,SP,#+292
   \   00000006   0x9C57             LDR      R4,[SP, #+348]
   \   00000008   0x9D58             LDR      R5,[SP, #+352]
   \   0000000A   0x9E59             LDR      R6,[SP, #+356]
   \   0000000C   0x9F5A             LDR      R7,[SP, #+360]
   \   0000000E   0xF8DD 0x816C      LDR      R8,[SP, #+364]
   \   00000012   0xF8DD 0x9170      LDR      R9,[SP, #+368]
    735            struct hci_request rq;
    736            uint8_t cmd_buffer[258];
    737            aci_gap_start_name_discovery_proc_cp0 *cp0 = (aci_gap_start_name_discovery_proc_cp0*)(cmd_buffer);
   \   00000016   0xF10D 0x0A1C      ADD      R10,SP,#+28
    738            tBleStatus status = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    739            uint8_t index_input = 0;
   \   00000020   0xF05F 0x0B00      MOVS     R11,#+0
    740            cp0->LE_Scan_Interval = htob(LE_Scan_Interval, 2);
   \   00000024   0xF8BD 0x0124      LDRH     R0,[SP, #+292]
   \   00000028   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    741            index_input += 2;
   \   0000002C   0xF11B 0x0B02      ADDS     R11,R11,#+2
    742            cp0->LE_Scan_Window = htob(LE_Scan_Window, 2);
   \   00000030   0xF8BD 0x0128      LDRH     R0,[SP, #+296]
   \   00000034   0xF8AA 0x0002      STRH     R0,[R10, #+2]
    743            index_input += 2;
   \   00000038   0xF11B 0x0B02      ADDS     R11,R11,#+2
    744            cp0->Peer_Address_Type = htob(Peer_Address_Type, 1);
   \   0000003C   0xF89D 0x012C      LDRB     R0,[SP, #+300]
   \   00000040   0xF88A 0x0004      STRB     R0,[R10, #+4]
    745            index_input += 1;
   \   00000044   0xF11B 0x0B01      ADDS     R11,R11,#+1
    746            Osal_MemCpy((void *) &cp0->Peer_Address, (const void *) Peer_Address, 6);
   \   00000048   0x2206             MOVS     R2,#+6
   \   0000004A   0x994C             LDR      R1,[SP, #+304]
   \   0000004C   0xF11A 0x0005      ADDS     R0,R10,#+5
   \   00000050   0x.... 0x....      BL       Osal_MemCpy
    747            index_input += 6;
   \   00000054   0xF11B 0x0B06      ADDS     R11,R11,#+6
    748            cp0->Own_Address_Type = htob(Own_Address_Type, 1);
   \   00000058   0xF89D 0x0158      LDRB     R0,[SP, #+344]
   \   0000005C   0xF88A 0x000B      STRB     R0,[R10, #+11]
    749            index_input += 1;
   \   00000060   0xF11B 0x0B01      ADDS     R11,R11,#+1
    750            cp0->Conn_Interval_Min = htob(Conn_Interval_Min, 2);
   \   00000064   0xF8AA 0x400C      STRH     R4,[R10, #+12]
    751            index_input += 2;
   \   00000068   0xF11B 0x0B02      ADDS     R11,R11,#+2
    752            cp0->Conn_Interval_Max = htob(Conn_Interval_Max, 2);
   \   0000006C   0xF8AA 0x500E      STRH     R5,[R10, #+14]
    753            index_input += 2;
   \   00000070   0xF11B 0x0B02      ADDS     R11,R11,#+2
    754            cp0->Conn_Latency = htob(Conn_Latency, 2);
   \   00000074   0xF8AA 0x6010      STRH     R6,[R10, #+16]
    755            index_input += 2;
   \   00000078   0xF11B 0x0B02      ADDS     R11,R11,#+2
    756            cp0->Supervision_Timeout = htob(Supervision_Timeout, 2);
   \   0000007C   0xF8AA 0x7012      STRH     R7,[R10, #+18]
    757            index_input += 2;
   \   00000080   0xF11B 0x0B02      ADDS     R11,R11,#+2
    758            cp0->Minimum_CE_Length = htob(Minimum_CE_Length, 2);
   \   00000084   0xF8AA 0x8014      STRH     R8,[R10, #+20]
    759            index_input += 2;
   \   00000088   0xF11B 0x0B02      ADDS     R11,R11,#+2
    760            cp0->Maximum_CE_Length = htob(Maximum_CE_Length, 2);
   \   0000008C   0xF8AA 0x9016      STRH     R9,[R10, #+22]
    761            index_input += 2;
   \   00000090   0xF11B 0x0B02      ADDS     R11,R11,#+2
    762            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000094   0x2218             MOVS     R2,#+24
   \   00000096   0x2100             MOVS     R1,#+0
   \   00000098   0xA801             ADD      R0,SP,#+4
   \   0000009A   0x.... 0x....      BL       Osal_MemSet
    763            rq.ogf = 0x3f;
   \   0000009E   0x203F             MOVS     R0,#+63
   \   000000A0   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    764            rq.ocf = 0x098;
   \   000000A4   0x2098             MOVS     R0,#+152
   \   000000A6   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    765            rq.event = 0x0F;
   \   000000AA   0x200F             MOVS     R0,#+15
   \   000000AC   0x9002             STR      R0,[SP, #+8]
    766            rq.cparam = cmd_buffer;
   \   000000AE   0xA807             ADD      R0,SP,#+28
   \   000000B0   0x9003             STR      R0,[SP, #+12]
    767            rq.clen = index_input;
   \   000000B2   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000B6   0xF8CD 0xB010      STR      R11,[SP, #+16]
    768            rq.rparam = &status;
   \   000000BA   0x4668             MOV      R0,SP
   \   000000BC   0x9005             STR      R0,[SP, #+20]
    769            rq.rlen = 1;
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0x9006             STR      R0,[SP, #+24]
    770            if (hci_send_req(&rq, FALSE) < 0)
   \   000000C2   0x2100             MOVS     R1,#+0
   \   000000C4   0xA801             ADD      R0,SP,#+4
   \   000000C6   0x.... 0x....      BL       hci_send_req
   \   000000CA   0x2800             CMP      R0,#+0
   \   000000CC   0xD501             BPL.N    ??aci_gap_start_name_discovery_proc_0
    771              return BLE_STATUS_TIMEOUT;
   \   000000CE   0x20FF             MOVS     R0,#+255
   \   000000D0   0xE007             B.N      ??aci_gap_start_name_discovery_proc_1
    772            if (status) {
   \                     ??aci_gap_start_name_discovery_proc_0: (+1)
   \   000000D2   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000D6   0x2800             CMP      R0,#+0
   \   000000D8   0xD002             BEQ.N    ??aci_gap_start_name_discovery_proc_2
    773              return status;
   \   000000DA   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000DE   0xE000             B.N      ??aci_gap_start_name_discovery_proc_1
    774            }
    775            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_start_name_discovery_proc_2: (+1)
   \   000000E0   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_start_name_discovery_proc_1: (+1)
   \   000000E2   0xB04D             ADD      SP,SP,#+308
   \   000000E4   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    776          }

   \                                 In section .text, align 2, keep-with-next
    777          tBleStatus aci_gap_start_auto_connection_establish_proc(uint16_t LE_Scan_Interval,
    778                                                                  uint16_t LE_Scan_Window,
    779                                                                  uint8_t Own_Address_Type,
    780                                                                  uint16_t Conn_Interval_Min,
    781                                                                  uint16_t Conn_Interval_Max,
    782                                                                  uint16_t Conn_Latency,
    783                                                                  uint16_t Supervision_Timeout,
    784                                                                  uint16_t Minimum_CE_Length,
    785                                                                  uint16_t Maximum_CE_Length,
    786                                                                  uint8_t Num_of_Whitelist_Entries,
    787                                                                  Whitelist_Entry_t Whitelist_Entry[])
    788          {
   \                     aci_gap_start_auto_connection_establish_proc: (+1)
   \   00000000   0xE92D 0x4FFF      PUSH     {R0-R11,LR}
   \   00000004   0xB0C9             SUB      SP,SP,#+292
   \   00000006   0x9C57             LDR      R4,[SP, #+348]
   \   00000008   0x9D58             LDR      R5,[SP, #+352]
   \   0000000A   0x9E59             LDR      R6,[SP, #+356]
   \   0000000C   0x9F5A             LDR      R7,[SP, #+360]
   \   0000000E   0xF8DD 0x816C      LDR      R8,[SP, #+364]
   \   00000012   0xF8DD 0x9170      LDR      R9,[SP, #+368]
    789            struct hci_request rq;
    790            uint8_t cmd_buffer[258];
    791            aci_gap_start_auto_connection_establish_proc_cp0 *cp0 = (aci_gap_start_auto_connection_establish_proc_cp0*)(cmd_buffer);
   \   00000016   0xF10D 0x0A1C      ADD      R10,SP,#+28
    792            tBleStatus status = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    793            uint8_t index_input = 0;
   \   00000020   0xF05F 0x0B00      MOVS     R11,#+0
    794            cp0->LE_Scan_Interval = htob(LE_Scan_Interval, 2);
   \   00000024   0xF8BD 0x0124      LDRH     R0,[SP, #+292]
   \   00000028   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    795            index_input += 2;
   \   0000002C   0xF11B 0x0B02      ADDS     R11,R11,#+2
    796            cp0->LE_Scan_Window = htob(LE_Scan_Window, 2);
   \   00000030   0xF8BD 0x0128      LDRH     R0,[SP, #+296]
   \   00000034   0xF8AA 0x0002      STRH     R0,[R10, #+2]
    797            index_input += 2;
   \   00000038   0xF11B 0x0B02      ADDS     R11,R11,#+2
    798            cp0->Own_Address_Type = htob(Own_Address_Type, 1);
   \   0000003C   0xF89D 0x012C      LDRB     R0,[SP, #+300]
   \   00000040   0xF88A 0x0004      STRB     R0,[R10, #+4]
    799            index_input += 1;
   \   00000044   0xF11B 0x0B01      ADDS     R11,R11,#+1
    800            cp0->Conn_Interval_Min = htob(Conn_Interval_Min, 2);
   \   00000048   0xF8BD 0x0130      LDRH     R0,[SP, #+304]
   \   0000004C   0xF8AA 0x0005      STRH     R0,[R10, #+5]
    801            index_input += 2;
   \   00000050   0xF11B 0x0B02      ADDS     R11,R11,#+2
    802            cp0->Conn_Interval_Max = htob(Conn_Interval_Max, 2);
   \   00000054   0xF8BD 0x0158      LDRH     R0,[SP, #+344]
   \   00000058   0xF8AA 0x0007      STRH     R0,[R10, #+7]
    803            index_input += 2;
   \   0000005C   0xF11B 0x0B02      ADDS     R11,R11,#+2
    804            cp0->Conn_Latency = htob(Conn_Latency, 2);
   \   00000060   0xF8AA 0x4009      STRH     R4,[R10, #+9]
    805            index_input += 2;
   \   00000064   0xF11B 0x0B02      ADDS     R11,R11,#+2
    806            cp0->Supervision_Timeout = htob(Supervision_Timeout, 2);
   \   00000068   0xF8AA 0x500B      STRH     R5,[R10, #+11]
    807            index_input += 2;
   \   0000006C   0xF11B 0x0B02      ADDS     R11,R11,#+2
    808            cp0->Minimum_CE_Length = htob(Minimum_CE_Length, 2);
   \   00000070   0xF8AA 0x600D      STRH     R6,[R10, #+13]
    809            index_input += 2;
   \   00000074   0xF11B 0x0B02      ADDS     R11,R11,#+2
    810            cp0->Maximum_CE_Length = htob(Maximum_CE_Length, 2);
   \   00000078   0xF8AA 0x700F      STRH     R7,[R10, #+15]
    811            index_input += 2;
   \   0000007C   0xF11B 0x0B02      ADDS     R11,R11,#+2
    812            cp0->Num_of_Whitelist_Entries = htob(Num_of_Whitelist_Entries, 1);
   \   00000080   0xF88A 0x8011      STRB     R8,[R10, #+17]
    813            index_input += 1;
   \   00000084   0xF11B 0x0B01      ADDS     R11,R11,#+1
    814            Osal_MemCpy((void *) &cp0->Whitelist_Entry, (const void *) Whitelist_Entry, Num_of_Whitelist_Entries);
   \   00000088   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000008C   0x4642             MOV      R2,R8
   \   0000008E   0x4649             MOV      R1,R9
   \   00000090   0xF11A 0x0012      ADDS     R0,R10,#+18
   \   00000094   0x.... 0x....      BL       Osal_MemCpy
    815            index_input += 7;
   \   00000098   0xF11B 0x0B07      ADDS     R11,R11,#+7
    816            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000009C   0x2218             MOVS     R2,#+24
   \   0000009E   0x2100             MOVS     R1,#+0
   \   000000A0   0xA801             ADD      R0,SP,#+4
   \   000000A2   0x.... 0x....      BL       Osal_MemSet
    817            rq.ogf = 0x3f;
   \   000000A6   0x203F             MOVS     R0,#+63
   \   000000A8   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    818            rq.ocf = 0x099;
   \   000000AC   0x2099             MOVS     R0,#+153
   \   000000AE   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    819            rq.event = 0x0F;
   \   000000B2   0x200F             MOVS     R0,#+15
   \   000000B4   0x9002             STR      R0,[SP, #+8]
    820            rq.cparam = cmd_buffer;
   \   000000B6   0xA807             ADD      R0,SP,#+28
   \   000000B8   0x9003             STR      R0,[SP, #+12]
    821            rq.clen = index_input;
   \   000000BA   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000BE   0xF8CD 0xB010      STR      R11,[SP, #+16]
    822            rq.rparam = &status;
   \   000000C2   0x4668             MOV      R0,SP
   \   000000C4   0x9005             STR      R0,[SP, #+20]
    823            rq.rlen = 1;
   \   000000C6   0x2001             MOVS     R0,#+1
   \   000000C8   0x9006             STR      R0,[SP, #+24]
    824            if (hci_send_req(&rq, FALSE) < 0)
   \   000000CA   0x2100             MOVS     R1,#+0
   \   000000CC   0xA801             ADD      R0,SP,#+4
   \   000000CE   0x.... 0x....      BL       hci_send_req
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD501             BPL.N    ??aci_gap_start_auto_connection_establish_proc_0
    825              return BLE_STATUS_TIMEOUT;
   \   000000D6   0x20FF             MOVS     R0,#+255
   \   000000D8   0xE007             B.N      ??aci_gap_start_auto_connection_establish_proc_1
    826            if (status) {
   \                     ??aci_gap_start_auto_connection_establish_proc_0: (+1)
   \   000000DA   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xD002             BEQ.N    ??aci_gap_start_auto_connection_establish_proc_2
    827              return status;
   \   000000E2   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000E6   0xE000             B.N      ??aci_gap_start_auto_connection_establish_proc_1
    828            }
    829            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_start_auto_connection_establish_proc_2: (+1)
   \   000000E8   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_start_auto_connection_establish_proc_1: (+1)
   \   000000EA   0xB04D             ADD      SP,SP,#+308
   \   000000EC   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    830          }

   \                                 In section .text, align 2, keep-with-next
    831          tBleStatus aci_gap_start_general_connection_establish_proc(uint8_t LE_Scan_Type,
    832                                                                     uint16_t LE_Scan_Interval,
    833                                                                     uint16_t LE_Scan_Window,
    834                                                                     uint8_t Own_Address_Type,
    835                                                                     uint8_t Scanning_Filter_Policy,
    836                                                                     uint8_t Filter_Duplicates)
    837          {
   \                     aci_gap_start_general_connection_establish_proc: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB0C9             SUB      SP,SP,#+292
   \   00000006   0x0006             MOVS     R6,R0
   \   00000008   0x000F             MOVS     R7,R1
   \   0000000A   0x4690             MOV      R8,R2
   \   0000000C   0x4699             MOV      R9,R3
   \   0000000E   0x9C52             LDR      R4,[SP, #+328]
   \   00000010   0x9D53             LDR      R5,[SP, #+332]
    838            struct hci_request rq;
    839            uint8_t cmd_buffer[258];
    840            aci_gap_start_general_connection_establish_proc_cp0 *cp0 = (aci_gap_start_general_connection_establish_proc_cp0*)(cmd_buffer);
   \   00000012   0xF10D 0x0A1C      ADD      R10,SP,#+28
    841            tBleStatus status = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF88D 0x0000      STRB     R0,[SP, #+0]
    842            uint8_t index_input = 0;
   \   0000001C   0xF05F 0x0B00      MOVS     R11,#+0
    843            cp0->LE_Scan_Type = htob(LE_Scan_Type, 1);
   \   00000020   0xF88A 0x6000      STRB     R6,[R10, #+0]
    844            index_input += 1;
   \   00000024   0xF11B 0x0B01      ADDS     R11,R11,#+1
    845            cp0->LE_Scan_Interval = htob(LE_Scan_Interval, 2);
   \   00000028   0xF8AA 0x7001      STRH     R7,[R10, #+1]
    846            index_input += 2;
   \   0000002C   0xF11B 0x0B02      ADDS     R11,R11,#+2
    847            cp0->LE_Scan_Window = htob(LE_Scan_Window, 2);
   \   00000030   0xF8AA 0x8003      STRH     R8,[R10, #+3]
    848            index_input += 2;
   \   00000034   0xF11B 0x0B02      ADDS     R11,R11,#+2
    849            cp0->Own_Address_Type = htob(Own_Address_Type, 1);
   \   00000038   0xF88A 0x9005      STRB     R9,[R10, #+5]
    850            index_input += 1;
   \   0000003C   0xF11B 0x0B01      ADDS     R11,R11,#+1
    851            cp0->Scanning_Filter_Policy = htob(Scanning_Filter_Policy, 1);
   \   00000040   0xF88A 0x4006      STRB     R4,[R10, #+6]
    852            index_input += 1;
   \   00000044   0xF11B 0x0B01      ADDS     R11,R11,#+1
    853            cp0->Filter_Duplicates = htob(Filter_Duplicates, 1);
   \   00000048   0xF88A 0x5007      STRB     R5,[R10, #+7]
    854            index_input += 1;
   \   0000004C   0xF11B 0x0B01      ADDS     R11,R11,#+1
    855            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000050   0x2218             MOVS     R2,#+24
   \   00000052   0x2100             MOVS     R1,#+0
   \   00000054   0xA801             ADD      R0,SP,#+4
   \   00000056   0x.... 0x....      BL       Osal_MemSet
    856            rq.ogf = 0x3f;
   \   0000005A   0x203F             MOVS     R0,#+63
   \   0000005C   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    857            rq.ocf = 0x09a;
   \   00000060   0x209A             MOVS     R0,#+154
   \   00000062   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    858            rq.event = 0x0F;
   \   00000066   0x200F             MOVS     R0,#+15
   \   00000068   0x9002             STR      R0,[SP, #+8]
    859            rq.cparam = cmd_buffer;
   \   0000006A   0xA807             ADD      R0,SP,#+28
   \   0000006C   0x9003             STR      R0,[SP, #+12]
    860            rq.clen = index_input;
   \   0000006E   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000072   0xF8CD 0xB010      STR      R11,[SP, #+16]
    861            rq.rparam = &status;
   \   00000076   0x4668             MOV      R0,SP
   \   00000078   0x9005             STR      R0,[SP, #+20]
    862            rq.rlen = 1;
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0x9006             STR      R0,[SP, #+24]
    863            if (hci_send_req(&rq, FALSE) < 0)
   \   0000007E   0x2100             MOVS     R1,#+0
   \   00000080   0xA801             ADD      R0,SP,#+4
   \   00000082   0x.... 0x....      BL       hci_send_req
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD501             BPL.N    ??aci_gap_start_general_connection_establish_pr_0
    864              return BLE_STATUS_TIMEOUT;
   \   0000008A   0x20FF             MOVS     R0,#+255
   \   0000008C   0xE007             B.N      ??aci_gap_start_general_connection_establish_pr_1
    865            if (status) {
   \                     ??aci_gap_start_general_connection_establish_pr_0: (+1)
   \   0000008E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD002             BEQ.N    ??aci_gap_start_general_connection_establish_pr_2
    866              return status;
   \   00000096   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000009A   0xE000             B.N      ??aci_gap_start_general_connection_establish_pr_1
    867            }
    868            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_start_general_connection_establish_pr_2: (+1)
   \   0000009C   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_start_general_connection_establish_pr_1: (+1)
   \   0000009E   0xB049             ADD      SP,SP,#+292
   \   000000A0   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    869          }

   \                                 In section .text, align 2, keep-with-next
    870          tBleStatus aci_gap_start_selective_connection_establish_proc(uint8_t LE_Scan_Type,
    871                                                                       uint16_t LE_Scan_Interval,
    872                                                                       uint16_t LE_Scan_Window,
    873                                                                       uint8_t Own_Address_Type,
    874                                                                       uint8_t Scanning_Filter_Policy,
    875                                                                       uint8_t Filter_Duplicates,
    876                                                                       uint8_t Num_of_Whitelist_Entries,
    877                                                                       Whitelist_Entry_t Whitelist_Entry[])
    878          {
   \                     aci_gap_start_selective_connection_establish_proc: (+1)
   \   00000000   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \   00000004   0xB0C9             SUB      SP,SP,#+292
   \   00000006   0x0017             MOVS     R7,R2
   \   00000008   0x4698             MOV      R8,R3
   \   0000000A   0x9C54             LDR      R4,[SP, #+336]
   \   0000000C   0x9D55             LDR      R5,[SP, #+340]
   \   0000000E   0x9E56             LDR      R6,[SP, #+344]
   \   00000010   0xF8DD 0x915C      LDR      R9,[SP, #+348]
    879            struct hci_request rq;
    880            uint8_t cmd_buffer[258];
    881            aci_gap_start_selective_connection_establish_proc_cp0 *cp0 = (aci_gap_start_selective_connection_establish_proc_cp0*)(cmd_buffer);
   \   00000014   0xF10D 0x0A1C      ADD      R10,SP,#+28
    882            tBleStatus status = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    883            uint8_t index_input = 0;
   \   0000001E   0xF05F 0x0B00      MOVS     R11,#+0
    884            cp0->LE_Scan_Type = htob(LE_Scan_Type, 1);
   \   00000022   0xF89D 0x0124      LDRB     R0,[SP, #+292]
   \   00000026   0xF88A 0x0000      STRB     R0,[R10, #+0]
    885            index_input += 1;
   \   0000002A   0xF11B 0x0B01      ADDS     R11,R11,#+1
    886            cp0->LE_Scan_Interval = htob(LE_Scan_Interval, 2);
   \   0000002E   0xF8BD 0x0128      LDRH     R0,[SP, #+296]
   \   00000032   0xF8AA 0x0001      STRH     R0,[R10, #+1]
    887            index_input += 2;
   \   00000036   0xF11B 0x0B02      ADDS     R11,R11,#+2
    888            cp0->LE_Scan_Window = htob(LE_Scan_Window, 2);
   \   0000003A   0xF8AA 0x7003      STRH     R7,[R10, #+3]
    889            index_input += 2;
   \   0000003E   0xF11B 0x0B02      ADDS     R11,R11,#+2
    890            cp0->Own_Address_Type = htob(Own_Address_Type, 1);
   \   00000042   0xF88A 0x8005      STRB     R8,[R10, #+5]
    891            index_input += 1;
   \   00000046   0xF11B 0x0B01      ADDS     R11,R11,#+1
    892            cp0->Scanning_Filter_Policy = htob(Scanning_Filter_Policy, 1);
   \   0000004A   0xF88A 0x4006      STRB     R4,[R10, #+6]
    893            index_input += 1;
   \   0000004E   0xF11B 0x0B01      ADDS     R11,R11,#+1
    894            cp0->Filter_Duplicates = htob(Filter_Duplicates, 1);
   \   00000052   0xF88A 0x5007      STRB     R5,[R10, #+7]
    895            index_input += 1;
   \   00000056   0xF11B 0x0B01      ADDS     R11,R11,#+1
    896            cp0->Num_of_Whitelist_Entries = htob(Num_of_Whitelist_Entries, 1);
   \   0000005A   0xF88A 0x6008      STRB     R6,[R10, #+8]
    897            index_input += 1;
   \   0000005E   0xF11B 0x0B01      ADDS     R11,R11,#+1
    898            Osal_MemCpy((void *) &cp0->Whitelist_Entry, (const void *) Whitelist_Entry, Num_of_Whitelist_Entries);
   \   00000062   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000064   0x0032             MOVS     R2,R6
   \   00000066   0x4649             MOV      R1,R9
   \   00000068   0xF11A 0x0009      ADDS     R0,R10,#+9
   \   0000006C   0x.... 0x....      BL       Osal_MemCpy
    899            index_input += 7;
   \   00000070   0xF11B 0x0B07      ADDS     R11,R11,#+7
    900            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000074   0x2218             MOVS     R2,#+24
   \   00000076   0x2100             MOVS     R1,#+0
   \   00000078   0xA801             ADD      R0,SP,#+4
   \   0000007A   0x.... 0x....      BL       Osal_MemSet
    901            rq.ogf = 0x3f;
   \   0000007E   0x203F             MOVS     R0,#+63
   \   00000080   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    902            rq.ocf = 0x09b;
   \   00000084   0x209B             MOVS     R0,#+155
   \   00000086   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    903            rq.event = 0x0F;
   \   0000008A   0x200F             MOVS     R0,#+15
   \   0000008C   0x9002             STR      R0,[SP, #+8]
    904            rq.cparam = cmd_buffer;
   \   0000008E   0xA807             ADD      R0,SP,#+28
   \   00000090   0x9003             STR      R0,[SP, #+12]
    905            rq.clen = index_input;
   \   00000092   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000096   0xF8CD 0xB010      STR      R11,[SP, #+16]
    906            rq.rparam = &status;
   \   0000009A   0x4668             MOV      R0,SP
   \   0000009C   0x9005             STR      R0,[SP, #+20]
    907            rq.rlen = 1;
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0x9006             STR      R0,[SP, #+24]
    908            if (hci_send_req(&rq, FALSE) < 0)
   \   000000A2   0x2100             MOVS     R1,#+0
   \   000000A4   0xA801             ADD      R0,SP,#+4
   \   000000A6   0x.... 0x....      BL       hci_send_req
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD501             BPL.N    ??aci_gap_start_selective_connection_establish__0
    909              return BLE_STATUS_TIMEOUT;
   \   000000AE   0x20FF             MOVS     R0,#+255
   \   000000B0   0xE007             B.N      ??aci_gap_start_selective_connection_establish__1
    910            if (status) {
   \                     ??aci_gap_start_selective_connection_establish__0: (+1)
   \   000000B2   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD002             BEQ.N    ??aci_gap_start_selective_connection_establish__2
    911              return status;
   \   000000BA   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000BE   0xE000             B.N      ??aci_gap_start_selective_connection_establish__1
    912            }
    913            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_start_selective_connection_establish__2: (+1)
   \   000000C0   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_start_selective_connection_establish__1: (+1)
   \   000000C2   0xB04B             ADD      SP,SP,#+300
   \   000000C4   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    914          }

   \                                 In section .text, align 2, keep-with-next
    915          tBleStatus aci_gap_create_connection(uint16_t LE_Scan_Interval,
    916                                               uint16_t LE_Scan_Window,
    917                                               uint8_t Peer_Address_Type,
    918                                               uint8_t Peer_Address[6],
    919                                               uint8_t Own_Address_Type,
    920                                               uint16_t Conn_Interval_Min,
    921                                               uint16_t Conn_Interval_Max,
    922                                               uint16_t Conn_Latency,
    923                                               uint16_t Supervision_Timeout,
    924                                               uint16_t Minimum_CE_Length,
    925                                               uint16_t Maximum_CE_Length)
    926          {
   \                     aci_gap_create_connection: (+1)
   \   00000000   0xE92D 0x4FFF      PUSH     {R0-R11,LR}
   \   00000004   0xB0C9             SUB      SP,SP,#+292
   \   00000006   0x9C57             LDR      R4,[SP, #+348]
   \   00000008   0x9D58             LDR      R5,[SP, #+352]
   \   0000000A   0x9E59             LDR      R6,[SP, #+356]
   \   0000000C   0x9F5A             LDR      R7,[SP, #+360]
   \   0000000E   0xF8DD 0x816C      LDR      R8,[SP, #+364]
   \   00000012   0xF8DD 0x9170      LDR      R9,[SP, #+368]
    927            struct hci_request rq;
    928            uint8_t cmd_buffer[258];
    929            aci_gap_create_connection_cp0 *cp0 = (aci_gap_create_connection_cp0*)(cmd_buffer);
   \   00000016   0xF10D 0x0A1C      ADD      R10,SP,#+28
    930            tBleStatus status = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    931            uint8_t index_input = 0;
   \   00000020   0xF05F 0x0B00      MOVS     R11,#+0
    932            cp0->LE_Scan_Interval = htob(LE_Scan_Interval, 2);
   \   00000024   0xF8BD 0x0124      LDRH     R0,[SP, #+292]
   \   00000028   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    933            index_input += 2;
   \   0000002C   0xF11B 0x0B02      ADDS     R11,R11,#+2
    934            cp0->LE_Scan_Window = htob(LE_Scan_Window, 2);
   \   00000030   0xF8BD 0x0128      LDRH     R0,[SP, #+296]
   \   00000034   0xF8AA 0x0002      STRH     R0,[R10, #+2]
    935            index_input += 2;
   \   00000038   0xF11B 0x0B02      ADDS     R11,R11,#+2
    936            cp0->Peer_Address_Type = htob(Peer_Address_Type, 1);
   \   0000003C   0xF89D 0x012C      LDRB     R0,[SP, #+300]
   \   00000040   0xF88A 0x0004      STRB     R0,[R10, #+4]
    937            index_input += 1;
   \   00000044   0xF11B 0x0B01      ADDS     R11,R11,#+1
    938            Osal_MemCpy((void *) &cp0->Peer_Address, (const void *) Peer_Address, 6);
   \   00000048   0x2206             MOVS     R2,#+6
   \   0000004A   0x994C             LDR      R1,[SP, #+304]
   \   0000004C   0xF11A 0x0005      ADDS     R0,R10,#+5
   \   00000050   0x.... 0x....      BL       Osal_MemCpy
    939            index_input += 6;
   \   00000054   0xF11B 0x0B06      ADDS     R11,R11,#+6
    940            cp0->Own_Address_Type = htob(Own_Address_Type, 1);
   \   00000058   0xF89D 0x0158      LDRB     R0,[SP, #+344]
   \   0000005C   0xF88A 0x000B      STRB     R0,[R10, #+11]
    941            index_input += 1;
   \   00000060   0xF11B 0x0B01      ADDS     R11,R11,#+1
    942            cp0->Conn_Interval_Min = htob(Conn_Interval_Min, 2);
   \   00000064   0xF8AA 0x400C      STRH     R4,[R10, #+12]
    943            index_input += 2;
   \   00000068   0xF11B 0x0B02      ADDS     R11,R11,#+2
    944            cp0->Conn_Interval_Max = htob(Conn_Interval_Max, 2);
   \   0000006C   0xF8AA 0x500E      STRH     R5,[R10, #+14]
    945            index_input += 2;
   \   00000070   0xF11B 0x0B02      ADDS     R11,R11,#+2
    946            cp0->Conn_Latency = htob(Conn_Latency, 2);
   \   00000074   0xF8AA 0x6010      STRH     R6,[R10, #+16]
    947            index_input += 2;
   \   00000078   0xF11B 0x0B02      ADDS     R11,R11,#+2
    948            cp0->Supervision_Timeout = htob(Supervision_Timeout, 2);
   \   0000007C   0xF8AA 0x7012      STRH     R7,[R10, #+18]
    949            index_input += 2;
   \   00000080   0xF11B 0x0B02      ADDS     R11,R11,#+2
    950            cp0->Minimum_CE_Length = htob(Minimum_CE_Length, 2);
   \   00000084   0xF8AA 0x8014      STRH     R8,[R10, #+20]
    951            index_input += 2;
   \   00000088   0xF11B 0x0B02      ADDS     R11,R11,#+2
    952            cp0->Maximum_CE_Length = htob(Maximum_CE_Length, 2);
   \   0000008C   0xF8AA 0x9016      STRH     R9,[R10, #+22]
    953            index_input += 2;
   \   00000090   0xF11B 0x0B02      ADDS     R11,R11,#+2
    954            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000094   0x2218             MOVS     R2,#+24
   \   00000096   0x2100             MOVS     R1,#+0
   \   00000098   0xA801             ADD      R0,SP,#+4
   \   0000009A   0x.... 0x....      BL       Osal_MemSet
    955            rq.ogf = 0x3f;
   \   0000009E   0x203F             MOVS     R0,#+63
   \   000000A0   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    956            rq.ocf = 0x09c;
   \   000000A4   0x209C             MOVS     R0,#+156
   \   000000A6   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    957            rq.event = 0x0F;
   \   000000AA   0x200F             MOVS     R0,#+15
   \   000000AC   0x9002             STR      R0,[SP, #+8]
    958            rq.cparam = cmd_buffer;
   \   000000AE   0xA807             ADD      R0,SP,#+28
   \   000000B0   0x9003             STR      R0,[SP, #+12]
    959            rq.clen = index_input;
   \   000000B2   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000B6   0xF8CD 0xB010      STR      R11,[SP, #+16]
    960            rq.rparam = &status;
   \   000000BA   0x4668             MOV      R0,SP
   \   000000BC   0x9005             STR      R0,[SP, #+20]
    961            rq.rlen = 1;
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0x9006             STR      R0,[SP, #+24]
    962            if (hci_send_req(&rq, FALSE) < 0)
   \   000000C2   0x2100             MOVS     R1,#+0
   \   000000C4   0xA801             ADD      R0,SP,#+4
   \   000000C6   0x.... 0x....      BL       hci_send_req
   \   000000CA   0x2800             CMP      R0,#+0
   \   000000CC   0xD501             BPL.N    ??aci_gap_create_connection_0
    963              return BLE_STATUS_TIMEOUT;
   \   000000CE   0x20FF             MOVS     R0,#+255
   \   000000D0   0xE007             B.N      ??aci_gap_create_connection_1
    964            if (status) {
   \                     ??aci_gap_create_connection_0: (+1)
   \   000000D2   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000D6   0x2800             CMP      R0,#+0
   \   000000D8   0xD002             BEQ.N    ??aci_gap_create_connection_2
    965              return status;
   \   000000DA   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000DE   0xE000             B.N      ??aci_gap_create_connection_1
    966            }
    967            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_create_connection_2: (+1)
   \   000000E0   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_create_connection_1: (+1)
   \   000000E2   0xB04D             ADD      SP,SP,#+308
   \   000000E4   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    968          }

   \                                 In section .text, align 2, keep-with-next
    969          tBleStatus aci_gap_terminate_gap_proc(uint8_t Procedure_Code)
    970          {
   \                     aci_gap_terminate_gap_proc: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB0C8             SUB      SP,SP,#+288
   \   00000004   0x0004             MOVS     R4,R0
    971            struct hci_request rq;
    972            uint8_t cmd_buffer[258];
    973            aci_gap_terminate_gap_proc_cp0 *cp0 = (aci_gap_terminate_gap_proc_cp0*)(cmd_buffer);
   \   00000006   0xAD07             ADD      R5,SP,#+28
    974            tBleStatus status = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    975            uint8_t index_input = 0;
   \   0000000E   0x2600             MOVS     R6,#+0
    976            cp0->Procedure_Code = htob(Procedure_Code, 1);
   \   00000010   0x702C             STRB     R4,[R5, #+0]
    977            index_input += 1;
   \   00000012   0x1C76             ADDS     R6,R6,#+1
    978            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000014   0x2218             MOVS     R2,#+24
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0xA801             ADD      R0,SP,#+4
   \   0000001A   0x.... 0x....      BL       Osal_MemSet
    979            rq.ogf = 0x3f;
   \   0000001E   0x203F             MOVS     R0,#+63
   \   00000020   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    980            rq.ocf = 0x09d;
   \   00000024   0x209D             MOVS     R0,#+157
   \   00000026   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    981            rq.cparam = cmd_buffer;
   \   0000002A   0xA807             ADD      R0,SP,#+28
   \   0000002C   0x9003             STR      R0,[SP, #+12]
    982            rq.clen = index_input;
   \   0000002E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000030   0x9604             STR      R6,[SP, #+16]
    983            rq.rparam = &status;
   \   00000032   0x4668             MOV      R0,SP
   \   00000034   0x9005             STR      R0,[SP, #+20]
    984            rq.rlen = 1;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x9006             STR      R0,[SP, #+24]
    985            if (hci_send_req(&rq, FALSE) < 0)
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0xA801             ADD      R0,SP,#+4
   \   0000003E   0x.... 0x....      BL       hci_send_req
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD501             BPL.N    ??aci_gap_terminate_gap_proc_0
    986              return BLE_STATUS_TIMEOUT;
   \   00000046   0x20FF             MOVS     R0,#+255
   \   00000048   0xE007             B.N      ??aci_gap_terminate_gap_proc_1
    987            if (status) {
   \                     ??aci_gap_terminate_gap_proc_0: (+1)
   \   0000004A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD002             BEQ.N    ??aci_gap_terminate_gap_proc_2
    988              return status;
   \   00000052   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000056   0xE000             B.N      ??aci_gap_terminate_gap_proc_1
    989            }
    990            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_terminate_gap_proc_2: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_terminate_gap_proc_1: (+1)
   \   0000005A   0xB048             ADD      SP,SP,#+288
   \   0000005C   0xBD70             POP      {R4-R6,PC}       ;; return
    991          }

   \                                 In section .text, align 2, keep-with-next
    992          tBleStatus aci_gap_start_connection_update(uint16_t Connection_Handle,
    993                                                     uint16_t Conn_Interval_Min,
    994                                                     uint16_t Conn_Interval_Max,
    995                                                     uint16_t Conn_Latency,
    996                                                     uint16_t Supervision_Timeout,
    997                                                     uint16_t Minimum_CE_Length,
    998                                                     uint16_t Maximum_CE_Length)
    999          {
   \                     aci_gap_start_connection_update: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB0C8             SUB      SP,SP,#+288
   \   00000006   0x000F             MOVS     R7,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x4699             MOV      R9,R3
   \   0000000C   0x9C52             LDR      R4,[SP, #+328]
   \   0000000E   0x9D53             LDR      R5,[SP, #+332]
   \   00000010   0x9E54             LDR      R6,[SP, #+336]
   1000            struct hci_request rq;
   1001            uint8_t cmd_buffer[258];
   1002            aci_gap_start_connection_update_cp0 *cp0 = (aci_gap_start_connection_update_cp0*)(cmd_buffer);
   \   00000012   0xF10D 0x0A1C      ADD      R10,SP,#+28
   1003            tBleStatus status = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1004            uint8_t index_input = 0;
   \   0000001C   0xF05F 0x0B00      MOVS     R11,#+0
   1005            cp0->Connection_Handle = htob(Connection_Handle, 2);
   \   00000020   0xF8BD 0x0120      LDRH     R0,[SP, #+288]
   \   00000024   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   1006            index_input += 2;
   \   00000028   0xF11B 0x0B02      ADDS     R11,R11,#+2
   1007            cp0->Conn_Interval_Min = htob(Conn_Interval_Min, 2);
   \   0000002C   0xF8AA 0x7002      STRH     R7,[R10, #+2]
   1008            index_input += 2;
   \   00000030   0xF11B 0x0B02      ADDS     R11,R11,#+2
   1009            cp0->Conn_Interval_Max = htob(Conn_Interval_Max, 2);
   \   00000034   0xF8AA 0x8004      STRH     R8,[R10, #+4]
   1010            index_input += 2;
   \   00000038   0xF11B 0x0B02      ADDS     R11,R11,#+2
   1011            cp0->Conn_Latency = htob(Conn_Latency, 2);
   \   0000003C   0xF8AA 0x9006      STRH     R9,[R10, #+6]
   1012            index_input += 2;
   \   00000040   0xF11B 0x0B02      ADDS     R11,R11,#+2
   1013            cp0->Supervision_Timeout = htob(Supervision_Timeout, 2);
   \   00000044   0xF8AA 0x4008      STRH     R4,[R10, #+8]
   1014            index_input += 2;
   \   00000048   0xF11B 0x0B02      ADDS     R11,R11,#+2
   1015            cp0->Minimum_CE_Length = htob(Minimum_CE_Length, 2);
   \   0000004C   0xF8AA 0x500A      STRH     R5,[R10, #+10]
   1016            index_input += 2;
   \   00000050   0xF11B 0x0B02      ADDS     R11,R11,#+2
   1017            cp0->Maximum_CE_Length = htob(Maximum_CE_Length, 2);
   \   00000054   0xF8AA 0x600C      STRH     R6,[R10, #+12]
   1018            index_input += 2;
   \   00000058   0xF11B 0x0B02      ADDS     R11,R11,#+2
   1019            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000005C   0x2218             MOVS     R2,#+24
   \   0000005E   0x2100             MOVS     R1,#+0
   \   00000060   0xA801             ADD      R0,SP,#+4
   \   00000062   0x.... 0x....      BL       Osal_MemSet
   1020            rq.ogf = 0x3f;
   \   00000066   0x203F             MOVS     R0,#+63
   \   00000068   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1021            rq.ocf = 0x09e;
   \   0000006C   0x209E             MOVS     R0,#+158
   \   0000006E   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1022            rq.event = 0x0F;
   \   00000072   0x200F             MOVS     R0,#+15
   \   00000074   0x9002             STR      R0,[SP, #+8]
   1023            rq.cparam = cmd_buffer;
   \   00000076   0xA807             ADD      R0,SP,#+28
   \   00000078   0x9003             STR      R0,[SP, #+12]
   1024            rq.clen = index_input;
   \   0000007A   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   0000007E   0xF8CD 0xB010      STR      R11,[SP, #+16]
   1025            rq.rparam = &status;
   \   00000082   0x4668             MOV      R0,SP
   \   00000084   0x9005             STR      R0,[SP, #+20]
   1026            rq.rlen = 1;
   \   00000086   0x2001             MOVS     R0,#+1
   \   00000088   0x9006             STR      R0,[SP, #+24]
   1027            if (hci_send_req(&rq, FALSE) < 0)
   \   0000008A   0x2100             MOVS     R1,#+0
   \   0000008C   0xA801             ADD      R0,SP,#+4
   \   0000008E   0x.... 0x....      BL       hci_send_req
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD501             BPL.N    ??aci_gap_start_connection_update_0
   1028              return BLE_STATUS_TIMEOUT;
   \   00000096   0x20FF             MOVS     R0,#+255
   \   00000098   0xE007             B.N      ??aci_gap_start_connection_update_1
   1029            if (status) {
   \                     ??aci_gap_start_connection_update_0: (+1)
   \   0000009A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD002             BEQ.N    ??aci_gap_start_connection_update_2
   1030              return status;
   \   000000A2   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000A6   0xE000             B.N      ??aci_gap_start_connection_update_1
   1031            }
   1032            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_start_connection_update_2: (+1)
   \   000000A8   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_start_connection_update_1: (+1)
   \   000000AA   0xB049             ADD      SP,SP,#+292
   \   000000AC   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1033          }

   \                                 In section .text, align 2, keep-with-next
   1034          tBleStatus aci_gap_send_pairing_req(uint16_t Connection_Handle,
   1035                                              uint8_t Force_Rebond)
   1036          {
   \                     aci_gap_send_pairing_req: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB0C9             SUB      SP,SP,#+292
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1037            struct hci_request rq;
   1038            uint8_t cmd_buffer[258];
   1039            aci_gap_send_pairing_req_cp0 *cp0 = (aci_gap_send_pairing_req_cp0*)(cmd_buffer);
   \   00000008   0xAE07             ADD      R6,SP,#+28
   1040            tBleStatus status = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1041            uint8_t index_input = 0;
   \   00000010   0x2700             MOVS     R7,#+0
   1042            cp0->Connection_Handle = htob(Connection_Handle, 2);
   \   00000012   0x8034             STRH     R4,[R6, #+0]
   1043            index_input += 2;
   \   00000014   0x1CBF             ADDS     R7,R7,#+2
   1044            cp0->Force_Rebond = htob(Force_Rebond, 1);
   \   00000016   0x70B5             STRB     R5,[R6, #+2]
   1045            index_input += 1;
   \   00000018   0x1C7F             ADDS     R7,R7,#+1
   1046            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000001A   0x2218             MOVS     R2,#+24
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0xA801             ADD      R0,SP,#+4
   \   00000020   0x.... 0x....      BL       Osal_MemSet
   1047            rq.ogf = 0x3f;
   \   00000024   0x203F             MOVS     R0,#+63
   \   00000026   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1048            rq.ocf = 0x09f;
   \   0000002A   0x209F             MOVS     R0,#+159
   \   0000002C   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1049            rq.event = 0x0F;
   \   00000030   0x200F             MOVS     R0,#+15
   \   00000032   0x9002             STR      R0,[SP, #+8]
   1050            rq.cparam = cmd_buffer;
   \   00000034   0xA807             ADD      R0,SP,#+28
   \   00000036   0x9003             STR      R0,[SP, #+12]
   1051            rq.clen = index_input;
   \   00000038   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003A   0x9704             STR      R7,[SP, #+16]
   1052            rq.rparam = &status;
   \   0000003C   0x4668             MOV      R0,SP
   \   0000003E   0x9005             STR      R0,[SP, #+20]
   1053            rq.rlen = 1;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x9006             STR      R0,[SP, #+24]
   1054            if (hci_send_req(&rq, FALSE) < 0)
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0xA801             ADD      R0,SP,#+4
   \   00000048   0x.... 0x....      BL       hci_send_req
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD501             BPL.N    ??aci_gap_send_pairing_req_0
   1055              return BLE_STATUS_TIMEOUT;
   \   00000050   0x20FF             MOVS     R0,#+255
   \   00000052   0xE007             B.N      ??aci_gap_send_pairing_req_1
   1056            if (status) {
   \                     ??aci_gap_send_pairing_req_0: (+1)
   \   00000054   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD002             BEQ.N    ??aci_gap_send_pairing_req_2
   1057              return status;
   \   0000005C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000060   0xE000             B.N      ??aci_gap_send_pairing_req_1
   1058            }
   1059            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_send_pairing_req_2: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_send_pairing_req_1: (+1)
   \   00000064   0xB049             ADD      SP,SP,#+292
   \   00000066   0xBDF0             POP      {R4-R7,PC}       ;; return
   1060          }

   \                                 In section .text, align 2, keep-with-next
   1061          tBleStatus aci_gap_resolve_private_addr(uint8_t Address[6],
   1062                                                  uint8_t Actual_Address[6])
   1063          {
   \                     aci_gap_resolve_private_addr: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB0C9             SUB      SP,SP,#+292
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1064            struct hci_request rq;
   1065            uint8_t cmd_buffer[258];
   1066            aci_gap_resolve_private_addr_cp0 *cp0 = (aci_gap_resolve_private_addr_cp0*)(cmd_buffer);
   \   00000008   0xAE08             ADD      R6,SP,#+32
   1067            aci_gap_resolve_private_addr_rp0 resp;
   1068            Osal_MemSet(&resp, 0, sizeof(resp));
   \   0000000A   0x2207             MOVS     R2,#+7
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x4668             MOV      R0,SP
   \   00000010   0x.... 0x....      BL       Osal_MemSet
   1069            uint8_t index_input = 0;
   \   00000014   0x2700             MOVS     R7,#+0
   1070            Osal_MemCpy((void *) &cp0->Address, (const void *) Address, 6);
   \   00000016   0x2206             MOVS     R2,#+6
   \   00000018   0x0021             MOVS     R1,R4
   \   0000001A   0x0030             MOVS     R0,R6
   \   0000001C   0x.... 0x....      BL       Osal_MemCpy
   1071            index_input += 6;
   \   00000020   0x1DBF             ADDS     R7,R7,#+6
   1072            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000022   0x2218             MOVS     R2,#+24
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0xA802             ADD      R0,SP,#+8
   \   00000028   0x.... 0x....      BL       Osal_MemSet
   1073            rq.ogf = 0x3f;
   \   0000002C   0x203F             MOVS     R0,#+63
   \   0000002E   0xF8AD 0x0008      STRH     R0,[SP, #+8]
   1074            rq.ocf = 0x0a0;
   \   00000032   0x20A0             MOVS     R0,#+160
   \   00000034   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   1075            rq.cparam = cmd_buffer;
   \   00000038   0xA808             ADD      R0,SP,#+32
   \   0000003A   0x9004             STR      R0,[SP, #+16]
   1076            rq.clen = index_input;
   \   0000003C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003E   0x9705             STR      R7,[SP, #+20]
   1077            rq.rparam = &resp;
   \   00000040   0x4668             MOV      R0,SP
   \   00000042   0x9006             STR      R0,[SP, #+24]
   1078            rq.rlen = sizeof(resp);
   \   00000044   0x2007             MOVS     R0,#+7
   \   00000046   0x9007             STR      R0,[SP, #+28]
   1079            if (hci_send_req(&rq, FALSE) < 0)
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0xA802             ADD      R0,SP,#+8
   \   0000004C   0x.... 0x....      BL       hci_send_req
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD501             BPL.N    ??aci_gap_resolve_private_addr_0
   1080              return BLE_STATUS_TIMEOUT;
   \   00000054   0x20FF             MOVS     R0,#+255
   \   00000056   0xE00D             B.N      ??aci_gap_resolve_private_addr_1
   1081            if (resp.Status) {
   \                     ??aci_gap_resolve_private_addr_0: (+1)
   \   00000058   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD002             BEQ.N    ??aci_gap_resolve_private_addr_2
   1082              return resp.Status;
   \   00000060   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000064   0xE006             B.N      ??aci_gap_resolve_private_addr_1
   1083            }
   1084            Osal_MemCpy((void *) Actual_Address, (const void *) resp.Actual_Address, 6);
   \                     ??aci_gap_resolve_private_addr_2: (+1)
   \   00000066   0x2206             MOVS     R2,#+6
   \   00000068   0xF10D 0x0101      ADD      R1,SP,#+1
   \   0000006C   0x0028             MOVS     R0,R5
   \   0000006E   0x.... 0x....      BL       Osal_MemCpy
   1085            return BLE_STATUS_SUCCESS;
   \   00000072   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_resolve_private_addr_1: (+1)
   \   00000074   0xB049             ADD      SP,SP,#+292
   \   00000076   0xBDF0             POP      {R4-R7,PC}       ;; return
   1086          }

   \                                 In section .text, align 2, keep-with-next
   1087          tBleStatus aci_gap_set_broadcast_mode(uint16_t Advertising_Interval_Min,
   1088                                                uint16_t Advertising_Interval_Max,
   1089                                                uint8_t Advertising_Type,
   1090                                                uint8_t Own_Address_Type,
   1091                                                uint8_t Adv_Data_Length,
   1092                                                uint8_t Adv_Data[],
   1093                                                uint8_t Num_of_Whitelist_Entries,
   1094                                                Whitelist_Entry_t Whitelist_Entry[])
   1095          {
   \                     aci_gap_set_broadcast_mode: (+1)
   \   00000000   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \   00000004   0xB0C9             SUB      SP,SP,#+292
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
   \   0000000A   0x9C54             LDR      R4,[SP, #+336]
   \   0000000C   0xF8DD 0x8154      LDR      R8,[SP, #+340]
   \   00000010   0x9D56             LDR      R5,[SP, #+344]
   \   00000012   0xF8DD 0x915C      LDR      R9,[SP, #+348]
   1096            struct hci_request rq;
   1097            uint8_t cmd_buffer[258];
   1098            aci_gap_set_broadcast_mode_cp0 *cp0 = (aci_gap_set_broadcast_mode_cp0*)(cmd_buffer);
   \   00000016   0xF10D 0x0A20      ADD      R10,SP,#+32
   1099            aci_gap_set_broadcast_mode_cp1 *cp1 = (aci_gap_set_broadcast_mode_cp1*)(cmd_buffer + 2 + 2 + 1 + 1 + 1 + Adv_Data_Length * (sizeof(uint8_t)));
   \   0000001A   0xA808             ADD      R0,SP,#+32
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x4420             ADD      R0,R0,R4
   \   00000020   0x1DC0             ADDS     R0,R0,#+7
   \   00000022   0x9001             STR      R0,[SP, #+4]
   1100            tBleStatus status = 0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1101            uint8_t index_input = 0;
   \   0000002A   0xF05F 0x0B00      MOVS     R11,#+0
   1102            cp0->Advertising_Interval_Min = htob(Advertising_Interval_Min, 2);
   \   0000002E   0xF8BD 0x0124      LDRH     R0,[SP, #+292]
   \   00000032   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   1103            index_input += 2;
   \   00000036   0xF11B 0x0B02      ADDS     R11,R11,#+2
   1104            cp0->Advertising_Interval_Max = htob(Advertising_Interval_Max, 2);
   \   0000003A   0xF8BD 0x0128      LDRH     R0,[SP, #+296]
   \   0000003E   0xF8AA 0x0002      STRH     R0,[R10, #+2]
   1105            index_input += 2;
   \   00000042   0xF11B 0x0B02      ADDS     R11,R11,#+2
   1106            cp0->Advertising_Type = htob(Advertising_Type, 1);
   \   00000046   0xF88A 0x6004      STRB     R6,[R10, #+4]
   1107            index_input += 1;
   \   0000004A   0xF11B 0x0B01      ADDS     R11,R11,#+1
   1108            cp0->Own_Address_Type = htob(Own_Address_Type, 1);
   \   0000004E   0xF88A 0x7005      STRB     R7,[R10, #+5]
   1109            index_input += 1;
   \   00000052   0xF11B 0x0B01      ADDS     R11,R11,#+1
   1110            cp0->Adv_Data_Length = htob(Adv_Data_Length, 1);
   \   00000056   0xF88A 0x4006      STRB     R4,[R10, #+6]
   1111            index_input += 1;
   \   0000005A   0xF11B 0x0B01      ADDS     R11,R11,#+1
   1112            /* var_len_data input */
   1113            {
   1114              Osal_MemCpy((void *) &cp0->Adv_Data, (const void *) Adv_Data, Adv_Data_Length);
   \   0000005E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000060   0x0022             MOVS     R2,R4
   \   00000062   0x4641             MOV      R1,R8
   \   00000064   0xF11A 0x0007      ADDS     R0,R10,#+7
   \   00000068   0x.... 0x....      BL       Osal_MemCpy
   1115              index_input += Adv_Data_Length;
   \   0000006C   0xEB14 0x0B0B      ADDS     R11,R4,R11
   1116              {
   1117                cp1->Num_of_Whitelist_Entries = htob(Num_of_Whitelist_Entries, 1);
   \   00000070   0x9801             LDR      R0,[SP, #+4]
   \   00000072   0x7005             STRB     R5,[R0, #+0]
   1118              }
   1119              index_input += 1;
   \   00000074   0xF11B 0x0B01      ADDS     R11,R11,#+1
   1120              Osal_MemCpy((void *) &cp1->Whitelist_Entry, (const void *) Whitelist_Entry, Num_of_Whitelist_Entries);
   \   00000078   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007A   0x002A             MOVS     R2,R5
   \   0000007C   0x4649             MOV      R1,R9
   \   0000007E   0x9801             LDR      R0,[SP, #+4]
   \   00000080   0x1C40             ADDS     R0,R0,#+1
   \   00000082   0x.... 0x....      BL       Osal_MemCpy
   1121              index_input += Num_of_Whitelist_Entries;
   \   00000086   0xEB15 0x0B0B      ADDS     R11,R5,R11
   1122            }
   1123            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000008A   0x2218             MOVS     R2,#+24
   \   0000008C   0x2100             MOVS     R1,#+0
   \   0000008E   0xA802             ADD      R0,SP,#+8
   \   00000090   0x.... 0x....      BL       Osal_MemSet
   1124            rq.ogf = 0x3f;
   \   00000094   0x203F             MOVS     R0,#+63
   \   00000096   0xF8AD 0x0008      STRH     R0,[SP, #+8]
   1125            rq.ocf = 0x0a1;
   \   0000009A   0x20A1             MOVS     R0,#+161
   \   0000009C   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   1126            rq.cparam = cmd_buffer;
   \   000000A0   0xA808             ADD      R0,SP,#+32
   \   000000A2   0x9004             STR      R0,[SP, #+16]
   1127            rq.clen = index_input;
   \   000000A4   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000A8   0xF8CD 0xB014      STR      R11,[SP, #+20]
   1128            rq.rparam = &status;
   \   000000AC   0x4668             MOV      R0,SP
   \   000000AE   0x9006             STR      R0,[SP, #+24]
   1129            rq.rlen = 1;
   \   000000B0   0x2001             MOVS     R0,#+1
   \   000000B2   0x9007             STR      R0,[SP, #+28]
   1130            if (hci_send_req(&rq, FALSE) < 0)
   \   000000B4   0x2100             MOVS     R1,#+0
   \   000000B6   0xA802             ADD      R0,SP,#+8
   \   000000B8   0x.... 0x....      BL       hci_send_req
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD501             BPL.N    ??aci_gap_set_broadcast_mode_0
   1131              return BLE_STATUS_TIMEOUT;
   \   000000C0   0x20FF             MOVS     R0,#+255
   \   000000C2   0xE007             B.N      ??aci_gap_set_broadcast_mode_1
   1132            if (status) {
   \                     ??aci_gap_set_broadcast_mode_0: (+1)
   \   000000C4   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD002             BEQ.N    ??aci_gap_set_broadcast_mode_2
   1133              return status;
   \   000000CC   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000D0   0xE000             B.N      ??aci_gap_set_broadcast_mode_1
   1134            }
   1135            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_set_broadcast_mode_2: (+1)
   \   000000D2   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_set_broadcast_mode_1: (+1)
   \   000000D4   0xB04B             ADD      SP,SP,#+300
   \   000000D6   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1136          }

   \                                 In section .text, align 2, keep-with-next
   1137          tBleStatus aci_gap_start_observation_proc(uint16_t LE_Scan_Interval,
   1138                                                    uint16_t LE_Scan_Window,
   1139                                                    uint8_t LE_Scan_Type,
   1140                                                    uint8_t Own_Address_Type,
   1141                                                    uint8_t Filter_Duplicates,
   1142                                                    uint8_t Scanning_Filter_Policy)
   1143          {
   \                     aci_gap_start_observation_proc: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB0C9             SUB      SP,SP,#+292
   \   00000006   0x0006             MOVS     R6,R0
   \   00000008   0x000F             MOVS     R7,R1
   \   0000000A   0x4690             MOV      R8,R2
   \   0000000C   0x4699             MOV      R9,R3
   \   0000000E   0x9C52             LDR      R4,[SP, #+328]
   \   00000010   0x9D53             LDR      R5,[SP, #+332]
   1144            struct hci_request rq;
   1145            uint8_t cmd_buffer[258];
   1146            aci_gap_start_observation_proc_cp0 *cp0 = (aci_gap_start_observation_proc_cp0*)(cmd_buffer);
   \   00000012   0xF10D 0x0A1C      ADD      R10,SP,#+28
   1147            tBleStatus status = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1148            uint8_t index_input = 0;
   \   0000001C   0xF05F 0x0B00      MOVS     R11,#+0
   1149            cp0->LE_Scan_Interval = htob(LE_Scan_Interval, 2);
   \   00000020   0xF8AA 0x6000      STRH     R6,[R10, #+0]
   1150            index_input += 2;
   \   00000024   0xF11B 0x0B02      ADDS     R11,R11,#+2
   1151            cp0->LE_Scan_Window = htob(LE_Scan_Window, 2);
   \   00000028   0xF8AA 0x7002      STRH     R7,[R10, #+2]
   1152            index_input += 2;
   \   0000002C   0xF11B 0x0B02      ADDS     R11,R11,#+2
   1153            cp0->LE_Scan_Type = htob(LE_Scan_Type, 1);
   \   00000030   0xF88A 0x8004      STRB     R8,[R10, #+4]
   1154            index_input += 1;
   \   00000034   0xF11B 0x0B01      ADDS     R11,R11,#+1
   1155            cp0->Own_Address_Type = htob(Own_Address_Type, 1);
   \   00000038   0xF88A 0x9005      STRB     R9,[R10, #+5]
   1156            index_input += 1;
   \   0000003C   0xF11B 0x0B01      ADDS     R11,R11,#+1
   1157            cp0->Filter_Duplicates = htob(Filter_Duplicates, 1);
   \   00000040   0xF88A 0x4006      STRB     R4,[R10, #+6]
   1158            index_input += 1;
   \   00000044   0xF11B 0x0B01      ADDS     R11,R11,#+1
   1159            cp0->Scanning_Filter_Policy = htob(Scanning_Filter_Policy, 1);
   \   00000048   0xF88A 0x5007      STRB     R5,[R10, #+7]
   1160            index_input += 1;
   \   0000004C   0xF11B 0x0B01      ADDS     R11,R11,#+1
   1161            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000050   0x2218             MOVS     R2,#+24
   \   00000052   0x2100             MOVS     R1,#+0
   \   00000054   0xA801             ADD      R0,SP,#+4
   \   00000056   0x.... 0x....      BL       Osal_MemSet
   1162            rq.ogf = 0x3f;
   \   0000005A   0x203F             MOVS     R0,#+63
   \   0000005C   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1163            rq.ocf = 0x0a2;
   \   00000060   0x20A2             MOVS     R0,#+162
   \   00000062   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1164            rq.event = 0x0F;
   \   00000066   0x200F             MOVS     R0,#+15
   \   00000068   0x9002             STR      R0,[SP, #+8]
   1165            rq.cparam = cmd_buffer;
   \   0000006A   0xA807             ADD      R0,SP,#+28
   \   0000006C   0x9003             STR      R0,[SP, #+12]
   1166            rq.clen = index_input;
   \   0000006E   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000072   0xF8CD 0xB010      STR      R11,[SP, #+16]
   1167            rq.rparam = &status;
   \   00000076   0x4668             MOV      R0,SP
   \   00000078   0x9005             STR      R0,[SP, #+20]
   1168            rq.rlen = 1;
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0x9006             STR      R0,[SP, #+24]
   1169            if (hci_send_req(&rq, FALSE) < 0)
   \   0000007E   0x2100             MOVS     R1,#+0
   \   00000080   0xA801             ADD      R0,SP,#+4
   \   00000082   0x.... 0x....      BL       hci_send_req
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD501             BPL.N    ??aci_gap_start_observation_proc_0
   1170              return BLE_STATUS_TIMEOUT;
   \   0000008A   0x20FF             MOVS     R0,#+255
   \   0000008C   0xE007             B.N      ??aci_gap_start_observation_proc_1
   1171            if (status) {
   \                     ??aci_gap_start_observation_proc_0: (+1)
   \   0000008E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD002             BEQ.N    ??aci_gap_start_observation_proc_2
   1172              return status;
   \   00000096   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000009A   0xE000             B.N      ??aci_gap_start_observation_proc_1
   1173            }
   1174            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_start_observation_proc_2: (+1)
   \   0000009C   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_start_observation_proc_1: (+1)
   \   0000009E   0xB049             ADD      SP,SP,#+292
   \   000000A0   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1175          }

   \                                 In section .text, align 2, keep-with-next
   1176          tBleStatus aci_gap_get_bonded_devices(uint8_t *Num_of_Addresses,
   1177                                                Bonded_Device_Entry_t Bonded_Device_Entry[])
   1178          {
   \                     aci_gap_get_bonded_devices: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB0A7             SUB      SP,SP,#+156
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1179            struct hci_request rq;
   1180            aci_gap_get_bonded_devices_rp0 resp;
   1181            Osal_MemSet(&resp, 0, sizeof(resp));
   \   00000008   0x2280             MOVS     R2,#+128
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0xA806             ADD      R0,SP,#+24
   \   0000000E   0x.... 0x....      BL       Osal_MemSet
   1182            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000012   0x2218             MOVS     R2,#+24
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x4668             MOV      R0,SP
   \   00000018   0x.... 0x....      BL       Osal_MemSet
   1183            rq.ogf = 0x3f;
   \   0000001C   0x203F             MOVS     R0,#+63
   \   0000001E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1184            rq.ocf = 0x0a3;
   \   00000022   0x20A3             MOVS     R0,#+163
   \   00000024   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   1185            rq.rparam = &resp;
   \   00000028   0xA806             ADD      R0,SP,#+24
   \   0000002A   0x9004             STR      R0,[SP, #+16]
   1186            rq.rlen = sizeof(resp);
   \   0000002C   0x2080             MOVS     R0,#+128
   \   0000002E   0x9005             STR      R0,[SP, #+20]
   1187            if (hci_send_req(&rq, FALSE) < 0)
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x4668             MOV      R0,SP
   \   00000034   0x.... 0x....      BL       hci_send_req
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD501             BPL.N    ??aci_gap_get_bonded_devices_0
   1188              return BLE_STATUS_TIMEOUT;
   \   0000003C   0x20FF             MOVS     R0,#+255
   \   0000003E   0xE010             B.N      ??aci_gap_get_bonded_devices_1
   1189            if (resp.Status) {
   \                     ??aci_gap_get_bonded_devices_0: (+1)
   \   00000040   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD002             BEQ.N    ??aci_gap_get_bonded_devices_2
   1190              return resp.Status;
   \   00000048   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \   0000004C   0xE009             B.N      ??aci_gap_get_bonded_devices_1
   1191            }
   1192            *Num_of_Addresses = btoh(resp.Num_of_Addresses, 1);
   \                     ??aci_gap_get_bonded_devices_2: (+1)
   \   0000004E   0xF89D 0x0019      LDRB     R0,[SP, #+25]
   \   00000052   0x7020             STRB     R0,[R4, #+0]
   1193            Osal_MemCpy((void *) Bonded_Device_Entry, (const void *) resp.Bonded_Device_Entry, *Num_of_Addresses);
   \   00000054   0x7822             LDRB     R2,[R4, #+0]
   \   00000056   0xF10D 0x011A      ADD      R1,SP,#+26
   \   0000005A   0x0028             MOVS     R0,R5
   \   0000005C   0x.... 0x....      BL       Osal_MemCpy
   1194            return BLE_STATUS_SUCCESS;
   \   00000060   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_get_bonded_devices_1: (+1)
   \   00000062   0xB027             ADD      SP,SP,#+156
   \   00000064   0xBD30             POP      {R4,R5,PC}       ;; return
   1195          }

   \                                 In section .text, align 2, keep-with-next
   1196          tBleStatus aci_gap_is_device_bonded(uint8_t Peer_Address_Type,
   1197                                              uint8_t Peer_Address[6])
   1198          {
   \                     aci_gap_is_device_bonded: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB0C9             SUB      SP,SP,#+292
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1199            struct hci_request rq;
   1200            uint8_t cmd_buffer[258];
   1201            aci_gap_is_device_bonded_cp0 *cp0 = (aci_gap_is_device_bonded_cp0*)(cmd_buffer);
   \   00000008   0xAE07             ADD      R6,SP,#+28
   1202            tBleStatus status = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1203            uint8_t index_input = 0;
   \   00000010   0x2700             MOVS     R7,#+0
   1204            cp0->Peer_Address_Type = htob(Peer_Address_Type, 1);
   \   00000012   0x7034             STRB     R4,[R6, #+0]
   1205            index_input += 1;
   \   00000014   0x1C7F             ADDS     R7,R7,#+1
   1206            Osal_MemCpy((void *) &cp0->Peer_Address, (const void *) Peer_Address, 6);
   \   00000016   0x2206             MOVS     R2,#+6
   \   00000018   0x0029             MOVS     R1,R5
   \   0000001A   0x1C70             ADDS     R0,R6,#+1
   \   0000001C   0x.... 0x....      BL       Osal_MemCpy
   1207            index_input += 6;
   \   00000020   0x1DBF             ADDS     R7,R7,#+6
   1208            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000022   0x2218             MOVS     R2,#+24
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0xA801             ADD      R0,SP,#+4
   \   00000028   0x.... 0x....      BL       Osal_MemSet
   1209            rq.ogf = 0x3f;
   \   0000002C   0x203F             MOVS     R0,#+63
   \   0000002E   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1210            rq.ocf = 0x0a4;
   \   00000032   0x20A4             MOVS     R0,#+164
   \   00000034   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1211            rq.cparam = cmd_buffer;
   \   00000038   0xA807             ADD      R0,SP,#+28
   \   0000003A   0x9003             STR      R0,[SP, #+12]
   1212            rq.clen = index_input;
   \   0000003C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003E   0x9704             STR      R7,[SP, #+16]
   1213            rq.rparam = &status;
   \   00000040   0x4668             MOV      R0,SP
   \   00000042   0x9005             STR      R0,[SP, #+20]
   1214            rq.rlen = 1;
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x9006             STR      R0,[SP, #+24]
   1215            if (hci_send_req(&rq, FALSE) < 0)
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0xA801             ADD      R0,SP,#+4
   \   0000004C   0x.... 0x....      BL       hci_send_req
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD501             BPL.N    ??aci_gap_is_device_bonded_0
   1216              return BLE_STATUS_TIMEOUT;
   \   00000054   0x20FF             MOVS     R0,#+255
   \   00000056   0xE007             B.N      ??aci_gap_is_device_bonded_1
   1217            if (status) {
   \                     ??aci_gap_is_device_bonded_0: (+1)
   \   00000058   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD002             BEQ.N    ??aci_gap_is_device_bonded_2
   1218              return status;
   \   00000060   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000064   0xE000             B.N      ??aci_gap_is_device_bonded_1
   1219            }
   1220            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_is_device_bonded_2: (+1)
   \   00000066   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_is_device_bonded_1: (+1)
   \   00000068   0xB049             ADD      SP,SP,#+292
   \   0000006A   0xBDF0             POP      {R4-R7,PC}       ;; return
   1221          }

   \                                 In section .text, align 2, keep-with-next
   1222          tBleStatus aci_gap_numeric_comparison_value_confirm_yesno(uint16_t Connection_Handle,
   1223                                                                    uint8_t Confirm_Yes_No)
   1224          {
   \                     aci_gap_numeric_comparison_value_confirm_yesno: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB0C9             SUB      SP,SP,#+292
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1225            struct hci_request rq;
   1226            uint8_t cmd_buffer[258];
   1227            aci_gap_numeric_comparison_value_confirm_yesno_cp0 *cp0 = (aci_gap_numeric_comparison_value_confirm_yesno_cp0*)(cmd_buffer);
   \   00000008   0xAE07             ADD      R6,SP,#+28
   1228            tBleStatus status = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1229            uint8_t index_input = 0;
   \   00000010   0x2700             MOVS     R7,#+0
   1230            cp0->Connection_Handle = htob(Connection_Handle, 2);
   \   00000012   0x8034             STRH     R4,[R6, #+0]
   1231            index_input += 2;
   \   00000014   0x1CBF             ADDS     R7,R7,#+2
   1232            cp0->Confirm_Yes_No = htob(Confirm_Yes_No, 1);
   \   00000016   0x70B5             STRB     R5,[R6, #+2]
   1233            index_input += 1;
   \   00000018   0x1C7F             ADDS     R7,R7,#+1
   1234            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000001A   0x2218             MOVS     R2,#+24
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0xA801             ADD      R0,SP,#+4
   \   00000020   0x.... 0x....      BL       Osal_MemSet
   1235            rq.ogf = 0x3f;
   \   00000024   0x203F             MOVS     R0,#+63
   \   00000026   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1236            rq.ocf = 0x0a5;
   \   0000002A   0x20A5             MOVS     R0,#+165
   \   0000002C   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1237            rq.cparam = cmd_buffer;
   \   00000030   0xA807             ADD      R0,SP,#+28
   \   00000032   0x9003             STR      R0,[SP, #+12]
   1238            rq.clen = index_input;
   \   00000034   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000036   0x9704             STR      R7,[SP, #+16]
   1239            rq.rparam = &status;
   \   00000038   0x4668             MOV      R0,SP
   \   0000003A   0x9005             STR      R0,[SP, #+20]
   1240            rq.rlen = 1;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x9006             STR      R0,[SP, #+24]
   1241            if (hci_send_req(&rq, FALSE) < 0)
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0xA801             ADD      R0,SP,#+4
   \   00000044   0x.... 0x....      BL       hci_send_req
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD501             BPL.N    ??aci_gap_numeric_comparison_value_confirm_yesn_0
   1242              return BLE_STATUS_TIMEOUT;
   \   0000004C   0x20FF             MOVS     R0,#+255
   \   0000004E   0xE007             B.N      ??aci_gap_numeric_comparison_value_confirm_yesn_1
   1243            if (status) {
   \                     ??aci_gap_numeric_comparison_value_confirm_yesn_0: (+1)
   \   00000050   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD002             BEQ.N    ??aci_gap_numeric_comparison_value_confirm_yesn_2
   1244              return status;
   \   00000058   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005C   0xE000             B.N      ??aci_gap_numeric_comparison_value_confirm_yesn_1
   1245            }
   1246            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_numeric_comparison_value_confirm_yesn_2: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_numeric_comparison_value_confirm_yesn_1: (+1)
   \   00000060   0xB049             ADD      SP,SP,#+292
   \   00000062   0xBDF0             POP      {R4-R7,PC}       ;; return
   1247          }

   \                                 In section .text, align 2, keep-with-next
   1248          tBleStatus aci_gap_passkey_input(uint16_t Connection_Handle,
   1249                                           uint8_t Input_Type)
   1250          {
   \                     aci_gap_passkey_input: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB0C9             SUB      SP,SP,#+292
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1251            struct hci_request rq;
   1252            uint8_t cmd_buffer[258];
   1253            aci_gap_passkey_input_cp0 *cp0 = (aci_gap_passkey_input_cp0*)(cmd_buffer);
   \   00000008   0xAE07             ADD      R6,SP,#+28
   1254            tBleStatus status = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1255            uint8_t index_input = 0;
   \   00000010   0x2700             MOVS     R7,#+0
   1256            cp0->Connection_Handle = htob(Connection_Handle, 2);
   \   00000012   0x8034             STRH     R4,[R6, #+0]
   1257            index_input += 2;
   \   00000014   0x1CBF             ADDS     R7,R7,#+2
   1258            cp0->Input_Type = htob(Input_Type, 1);
   \   00000016   0x70B5             STRB     R5,[R6, #+2]
   1259            index_input += 1;
   \   00000018   0x1C7F             ADDS     R7,R7,#+1
   1260            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000001A   0x2218             MOVS     R2,#+24
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0xA801             ADD      R0,SP,#+4
   \   00000020   0x.... 0x....      BL       Osal_MemSet
   1261            rq.ogf = 0x3f;
   \   00000024   0x203F             MOVS     R0,#+63
   \   00000026   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1262            rq.ocf = 0x0a6;
   \   0000002A   0x20A6             MOVS     R0,#+166
   \   0000002C   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1263            rq.cparam = cmd_buffer;
   \   00000030   0xA807             ADD      R0,SP,#+28
   \   00000032   0x9003             STR      R0,[SP, #+12]
   1264            rq.clen = index_input;
   \   00000034   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000036   0x9704             STR      R7,[SP, #+16]
   1265            rq.rparam = &status;
   \   00000038   0x4668             MOV      R0,SP
   \   0000003A   0x9005             STR      R0,[SP, #+20]
   1266            rq.rlen = 1;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x9006             STR      R0,[SP, #+24]
   1267            if (hci_send_req(&rq, FALSE) < 0)
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0xA801             ADD      R0,SP,#+4
   \   00000044   0x.... 0x....      BL       hci_send_req
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD501             BPL.N    ??aci_gap_passkey_input_0
   1268              return BLE_STATUS_TIMEOUT;
   \   0000004C   0x20FF             MOVS     R0,#+255
   \   0000004E   0xE007             B.N      ??aci_gap_passkey_input_1
   1269            if (status) {
   \                     ??aci_gap_passkey_input_0: (+1)
   \   00000050   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD002             BEQ.N    ??aci_gap_passkey_input_2
   1270              return status;
   \   00000058   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005C   0xE000             B.N      ??aci_gap_passkey_input_1
   1271            }
   1272            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_passkey_input_2: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_passkey_input_1: (+1)
   \   00000060   0xB049             ADD      SP,SP,#+292
   \   00000062   0xBDF0             POP      {R4-R7,PC}       ;; return
   1273          }

   \                                 In section .text, align 2, keep-with-next
   1274          tBleStatus aci_gap_get_oob_data(uint8_t OOB_Data_Type,
   1275                                          uint8_t *Address_Type,
   1276                                          uint8_t Address[6],
   1277                                          uint8_t *OOB_Data_Len,
   1278                                          uint8_t OOB_Data[16])
   1279          {
   \                     aci_gap_get_oob_data: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB0CE             SUB      SP,SP,#+312
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8158      LDR      R8,[SP, #+344]
   1280            struct hci_request rq;
   1281            uint8_t cmd_buffer[258];
   1282            aci_gap_get_oob_data_cp0 *cp0 = (aci_gap_get_oob_data_cp0*)(cmd_buffer);
   \   00000012   0xF10D 0x0934      ADD      R9,SP,#+52
   1283            aci_gap_get_oob_data_rp0 resp;
   1284            Osal_MemSet(&resp, 0, sizeof(resp));
   \   00000016   0x221A             MOVS     R2,#+26
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0xA806             ADD      R0,SP,#+24
   \   0000001C   0x.... 0x....      BL       Osal_MemSet
   1285            uint8_t index_input = 0;
   \   00000020   0xF05F 0x0A00      MOVS     R10,#+0
   1286            cp0->OOB_Data_Type = htob(OOB_Data_Type, 1);
   \   00000024   0xF889 0x4000      STRB     R4,[R9, #+0]
   1287            index_input += 1;
   \   00000028   0xF11A 0x0A01      ADDS     R10,R10,#+1
   1288            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000002C   0x2218             MOVS     R2,#+24
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x4668             MOV      R0,SP
   \   00000032   0x.... 0x....      BL       Osal_MemSet
   1289            rq.ogf = 0x3f;
   \   00000036   0x203F             MOVS     R0,#+63
   \   00000038   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1290            rq.ocf = 0x0a7;
   \   0000003C   0x20A7             MOVS     R0,#+167
   \   0000003E   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   1291            rq.cparam = cmd_buffer;
   \   00000042   0xA80D             ADD      R0,SP,#+52
   \   00000044   0x9002             STR      R0,[SP, #+8]
   1292            rq.clen = index_input;
   \   00000046   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000004A   0xF8CD 0xA00C      STR      R10,[SP, #+12]
   1293            rq.rparam = &resp;
   \   0000004E   0xA806             ADD      R0,SP,#+24
   \   00000050   0x9004             STR      R0,[SP, #+16]
   1294            rq.rlen = sizeof(resp);
   \   00000052   0x201A             MOVS     R0,#+26
   \   00000054   0x9005             STR      R0,[SP, #+20]
   1295            if (hci_send_req(&rq, FALSE) < 0)
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0x4668             MOV      R0,SP
   \   0000005A   0x.... 0x....      BL       hci_send_req
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD501             BPL.N    ??aci_gap_get_oob_data_0
   1296              return BLE_STATUS_TIMEOUT;
   \   00000062   0x20FF             MOVS     R0,#+255
   \   00000064   0xE019             B.N      ??aci_gap_get_oob_data_1
   1297            if (resp.Status) {
   \                     ??aci_gap_get_oob_data_0: (+1)
   \   00000066   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD002             BEQ.N    ??aci_gap_get_oob_data_2
   1298              return resp.Status;
   \   0000006E   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \   00000072   0xE012             B.N      ??aci_gap_get_oob_data_1
   1299            }
   1300            *Address_Type = btoh(resp.Address_Type, 1);
   \                     ??aci_gap_get_oob_data_2: (+1)
   \   00000074   0xF89D 0x0019      LDRB     R0,[SP, #+25]
   \   00000078   0x7028             STRB     R0,[R5, #+0]
   1301            Osal_MemCpy((void *) Address, (const void *) resp.Address, 6);
   \   0000007A   0x2206             MOVS     R2,#+6
   \   0000007C   0xF10D 0x011A      ADD      R1,SP,#+26
   \   00000080   0x0030             MOVS     R0,R6
   \   00000082   0x.... 0x....      BL       Osal_MemCpy
   1302            *OOB_Data_Len = btoh(resp.OOB_Data_Len, 1);
   \   00000086   0xF89D 0x0021      LDRB     R0,[SP, #+33]
   \   0000008A   0x7038             STRB     R0,[R7, #+0]
   1303            Osal_MemCpy((void *) OOB_Data, (const void *) resp.OOB_Data, 16);
   \   0000008C   0x2210             MOVS     R2,#+16
   \   0000008E   0xF10D 0x0122      ADD      R1,SP,#+34
   \   00000092   0x4640             MOV      R0,R8
   \   00000094   0x.... 0x....      BL       Osal_MemCpy
   1304            return BLE_STATUS_SUCCESS;
   \   00000098   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_get_oob_data_1: (+1)
   \   0000009A   0xB04E             ADD      SP,SP,#+312
   \   0000009C   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1305          }

   \                                 In section .text, align 2, keep-with-next
   1306          tBleStatus aci_gap_set_oob_data(uint8_t Device_Type,
   1307                                          uint8_t Address_Type,
   1308                                          uint8_t Address[6],
   1309                                          uint8_t OOB_Data_Type,
   1310                                          uint8_t OOB_Data_Len,
   1311                                          uint8_t OOB_Data[16])
   1312          {
   \                     aci_gap_set_oob_data: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB0C9             SUB      SP,SP,#+292
   \   00000006   0x0005             MOVS     R5,R0
   \   00000008   0x000E             MOVS     R6,R1
   \   0000000A   0x0017             MOVS     R7,R2
   \   0000000C   0x4698             MOV      R8,R3
   \   0000000E   0x9C52             LDR      R4,[SP, #+328]
   \   00000010   0xF8DD 0x914C      LDR      R9,[SP, #+332]
   1313            struct hci_request rq;
   1314            uint8_t cmd_buffer[258];
   1315            aci_gap_set_oob_data_cp0 *cp0 = (aci_gap_set_oob_data_cp0*)(cmd_buffer);
   \   00000014   0xF10D 0x0A1C      ADD      R10,SP,#+28
   1316            tBleStatus status = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1317            uint8_t index_input = 0;
   \   0000001E   0xF05F 0x0B00      MOVS     R11,#+0
   1318            cp0->Device_Type = htob(Device_Type, 1);
   \   00000022   0xF88A 0x5000      STRB     R5,[R10, #+0]
   1319            index_input += 1;
   \   00000026   0xF11B 0x0B01      ADDS     R11,R11,#+1
   1320            cp0->Address_Type = htob(Address_Type, 1);
   \   0000002A   0xF88A 0x6001      STRB     R6,[R10, #+1]
   1321            index_input += 1;
   \   0000002E   0xF11B 0x0B01      ADDS     R11,R11,#+1
   1322            Osal_MemCpy((void *) &cp0->Address, (const void *) Address, 6);
   \   00000032   0x2206             MOVS     R2,#+6
   \   00000034   0x0039             MOVS     R1,R7
   \   00000036   0xF11A 0x0002      ADDS     R0,R10,#+2
   \   0000003A   0x.... 0x....      BL       Osal_MemCpy
   1323            index_input += 6;
   \   0000003E   0xF11B 0x0B06      ADDS     R11,R11,#+6
   1324            cp0->OOB_Data_Type = htob(OOB_Data_Type, 1);
   \   00000042   0xF88A 0x8008      STRB     R8,[R10, #+8]
   1325            index_input += 1;
   \   00000046   0xF11B 0x0B01      ADDS     R11,R11,#+1
   1326            cp0->OOB_Data_Len = htob(OOB_Data_Len, 1);
   \   0000004A   0xF88A 0x4009      STRB     R4,[R10, #+9]
   1327            index_input += 1;
   \   0000004E   0xF11B 0x0B01      ADDS     R11,R11,#+1
   1328            Osal_MemCpy((void *) &cp0->OOB_Data, (const void *) OOB_Data, 16);
   \   00000052   0x2210             MOVS     R2,#+16
   \   00000054   0x4649             MOV      R1,R9
   \   00000056   0xF11A 0x000A      ADDS     R0,R10,#+10
   \   0000005A   0x.... 0x....      BL       Osal_MemCpy
   1329            index_input += 16;
   \   0000005E   0xF11B 0x0B10      ADDS     R11,R11,#+16
   1330            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000062   0x2218             MOVS     R2,#+24
   \   00000064   0x2100             MOVS     R1,#+0
   \   00000066   0xA801             ADD      R0,SP,#+4
   \   00000068   0x.... 0x....      BL       Osal_MemSet
   1331            rq.ogf = 0x3f;
   \   0000006C   0x203F             MOVS     R0,#+63
   \   0000006E   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1332            rq.ocf = 0x0a8;
   \   00000072   0x20A8             MOVS     R0,#+168
   \   00000074   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1333            rq.cparam = cmd_buffer;
   \   00000078   0xA807             ADD      R0,SP,#+28
   \   0000007A   0x9003             STR      R0,[SP, #+12]
   1334            rq.clen = index_input;
   \   0000007C   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000080   0xF8CD 0xB010      STR      R11,[SP, #+16]
   1335            rq.rparam = &status;
   \   00000084   0x4668             MOV      R0,SP
   \   00000086   0x9005             STR      R0,[SP, #+20]
   1336            rq.rlen = 1;
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0x9006             STR      R0,[SP, #+24]
   1337            if (hci_send_req(&rq, FALSE) < 0)
   \   0000008C   0x2100             MOVS     R1,#+0
   \   0000008E   0xA801             ADD      R0,SP,#+4
   \   00000090   0x.... 0x....      BL       hci_send_req
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD501             BPL.N    ??aci_gap_set_oob_data_0
   1338              return BLE_STATUS_TIMEOUT;
   \   00000098   0x20FF             MOVS     R0,#+255
   \   0000009A   0xE007             B.N      ??aci_gap_set_oob_data_1
   1339            if (status) {
   \                     ??aci_gap_set_oob_data_0: (+1)
   \   0000009C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD002             BEQ.N    ??aci_gap_set_oob_data_2
   1340              return status;
   \   000000A4   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000A8   0xE000             B.N      ??aci_gap_set_oob_data_1
   1341            }
   1342            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_set_oob_data_2: (+1)
   \   000000AA   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_set_oob_data_1: (+1)
   \   000000AC   0xB049             ADD      SP,SP,#+292
   \   000000AE   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1343          }

   \                                 In section .text, align 2, keep-with-next
   1344          tBleStatus aci_gap_add_devices_to_resolving_list(uint8_t Num_of_Resolving_list_Entries,
   1345                                                           Whitelist_Identity_Entry_t Whitelist_Identity_Entry[],
   1346                                                           uint8_t Clear_Resolving_List)
   1347          {
   \                     aci_gap_add_devices_to_resolving_list: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB0C9             SUB      SP,SP,#+292
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   1348            struct hci_request rq;
   1349            uint8_t cmd_buffer[258];
   1350            aci_gap_add_devices_to_resolving_list_cp0 *cp0 = (aci_gap_add_devices_to_resolving_list_cp0*)(cmd_buffer);
   \   0000000C   0xAF07             ADD      R7,SP,#+28
   1351            aci_gap_add_devices_to_resolving_list_cp1 *cp1 = (aci_gap_add_devices_to_resolving_list_cp1*)(cmd_buffer + 1 + Num_of_Resolving_list_Entries * (sizeof(Whitelist_Identity_Entry_t)));
   \   0000000E   0xA807             ADD      R0,SP,#+28
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2107             MOVS     R1,#+7
   \   00000014   0xFB01 0xF104      MUL      R1,R1,R4
   \   00000018   0x4408             ADD      R0,R0,R1
   \   0000001A   0xF110 0x0801      ADDS     R8,R0,#+1
   1352            tBleStatus status = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1353            uint8_t index_input = 0;
   \   00000024   0xF05F 0x0900      MOVS     R9,#+0
   1354            cp0->Num_of_Resolving_list_Entries = htob(Num_of_Resolving_list_Entries, 1);
   \   00000028   0x703C             STRB     R4,[R7, #+0]
   1355            index_input += 1;
   \   0000002A   0xF119 0x0901      ADDS     R9,R9,#+1
   1356            /* var_len_data input */
   1357            {
   1358              Osal_MemCpy((void *) &cp0->Whitelist_Identity_Entry, (const void *) Whitelist_Identity_Entry, Num_of_Resolving_list_Entries);
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0x0022             MOVS     R2,R4
   \   00000032   0x0029             MOVS     R1,R5
   \   00000034   0x1C78             ADDS     R0,R7,#+1
   \   00000036   0x.... 0x....      BL       Osal_MemCpy
   1359              index_input += Num_of_Resolving_list_Entries;
   \   0000003A   0xEB14 0x0909      ADDS     R9,R4,R9
   1360              {
   1361                cp1->Clear_Resolving_List = htob(Clear_Resolving_List, 1);
   \   0000003E   0xF888 0x6000      STRB     R6,[R8, #+0]
   1362              }
   1363              index_input += 1;
   \   00000042   0xF119 0x0901      ADDS     R9,R9,#+1
   1364            }
   1365            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000046   0x2218             MOVS     R2,#+24
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0xA801             ADD      R0,SP,#+4
   \   0000004C   0x.... 0x....      BL       Osal_MemSet
   1366            rq.ogf = 0x3f;
   \   00000050   0x203F             MOVS     R0,#+63
   \   00000052   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1367            rq.ocf = 0x0a9;
   \   00000056   0x20A9             MOVS     R0,#+169
   \   00000058   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1368            rq.cparam = cmd_buffer;
   \   0000005C   0xA807             ADD      R0,SP,#+28
   \   0000005E   0x9003             STR      R0,[SP, #+12]
   1369            rq.clen = index_input;
   \   00000060   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000064   0xF8CD 0x9010      STR      R9,[SP, #+16]
   1370            rq.rparam = &status;
   \   00000068   0x4668             MOV      R0,SP
   \   0000006A   0x9005             STR      R0,[SP, #+20]
   1371            rq.rlen = 1;
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0x9006             STR      R0,[SP, #+24]
   1372            if (hci_send_req(&rq, FALSE) < 0)
   \   00000070   0x2100             MOVS     R1,#+0
   \   00000072   0xA801             ADD      R0,SP,#+4
   \   00000074   0x.... 0x....      BL       hci_send_req
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD501             BPL.N    ??aci_gap_add_devices_to_resolving_list_0
   1373              return BLE_STATUS_TIMEOUT;
   \   0000007C   0x20FF             MOVS     R0,#+255
   \   0000007E   0xE007             B.N      ??aci_gap_add_devices_to_resolving_list_1
   1374            if (status) {
   \                     ??aci_gap_add_devices_to_resolving_list_0: (+1)
   \   00000080   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD002             BEQ.N    ??aci_gap_add_devices_to_resolving_list_2
   1375              return status;
   \   00000088   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000008C   0xE000             B.N      ??aci_gap_add_devices_to_resolving_list_1
   1376            }
   1377            return BLE_STATUS_SUCCESS;
   \                     ??aci_gap_add_devices_to_resolving_list_2: (+1)
   \   0000008E   0x2000             MOVS     R0,#+0
   \                     ??aci_gap_add_devices_to_resolving_list_1: (+1)
   \   00000090   0xB049             ADD      SP,SP,#+292
   \   00000092   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   1378          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     320   aci_gap_add_devices_to_resolving_list
       320   -> Osal_MemCpy
       320   -> Osal_MemSet
       320   -> hci_send_req
     304   aci_gap_allow_rebond
       304   -> Osal_MemSet
       304   -> hci_send_req
     312   aci_gap_authorization_resp
       312   -> Osal_MemSet
       312   -> hci_send_req
      32   aci_gap_clear_security_db
        32   -> Osal_MemSet
        32   -> hci_send_req
      32   aci_gap_configure_whitelist
        32   -> Osal_MemSet
        32   -> hci_send_req
     344   aci_gap_create_connection
       344   -> Osal_MemCpy
       344   -> Osal_MemSet
       344   -> hci_send_req
     304   aci_gap_delete_ad_type
       304   -> Osal_MemSet
       304   -> hci_send_req
     168   aci_gap_get_bonded_devices
       168   -> Osal_MemCpy
       168   -> Osal_MemSet
       168   -> hci_send_req
     344   aci_gap_get_oob_data
       344   -> Osal_MemCpy
       344   -> Osal_MemSet
       344   -> hci_send_req
     312   aci_gap_get_security_level
       312   -> Osal_MemSet
       312   -> hci_send_req
     328   aci_gap_init
       328   -> Osal_MemSet
       328   -> hci_send_req
     312   aci_gap_is_device_bonded
       312   -> Osal_MemCpy
       312   -> Osal_MemSet
       312   -> hci_send_req
     312   aci_gap_numeric_comparison_value_confirm_yesno
       312   -> Osal_MemSet
       312   -> hci_send_req
     312   aci_gap_pass_key_resp
       312   -> Osal_MemSet
       312   -> hci_send_req
     312   aci_gap_passkey_input
       312   -> Osal_MemSet
       312   -> hci_send_req
     312   aci_gap_resolve_private_addr
       312   -> Osal_MemCpy
       312   -> Osal_MemSet
       312   -> hci_send_req
     312   aci_gap_send_pairing_req
       312   -> Osal_MemSet
       312   -> hci_send_req
     336   aci_gap_set_authentication_requirement
       336   -> Osal_MemSet
       336   -> hci_send_req
     312   aci_gap_set_authorization_requirement
       312   -> Osal_MemSet
       312   -> hci_send_req
     336   aci_gap_set_broadcast_mode
       336   -> Osal_MemCpy
       336   -> Osal_MemSet
       336   -> hci_send_req
     328   aci_gap_set_direct_connectable
       328   -> Osal_MemCpy
       328   -> Osal_MemSet
       328   -> hci_send_req
     344   aci_gap_set_discoverable
       344   -> Osal_MemCpy
       344   -> Osal_MemSet
       344   -> hci_send_req
     304   aci_gap_set_event_mask
       304   -> Osal_MemSet
       304   -> hci_send_req
     304   aci_gap_set_io_capability
       304   -> Osal_MemSet
       304   -> hci_send_req
     344   aci_gap_set_limited_discoverable
       344   -> Osal_MemCpy
       344   -> Osal_MemSet
       344   -> hci_send_req
     312   aci_gap_set_non_connectable
       312   -> Osal_MemSet
       312   -> hci_send_req
      32   aci_gap_set_non_discoverable
        32   -> Osal_MemSet
        32   -> hci_send_req
     328   aci_gap_set_oob_data
       328   -> Osal_MemCpy
       328   -> Osal_MemSet
       328   -> hci_send_req
     320   aci_gap_set_undirected_connectable
       320   -> Osal_MemSet
       320   -> hci_send_req
     304   aci_gap_slave_security_req
       304   -> Osal_MemSet
       304   -> hci_send_req
     344   aci_gap_start_auto_connection_establish_proc
       344   -> Osal_MemCpy
       344   -> Osal_MemSet
       344   -> hci_send_req
     328   aci_gap_start_connection_update
       328   -> Osal_MemSet
       328   -> hci_send_req
     328   aci_gap_start_general_connection_establish_proc
       328   -> Osal_MemSet
       328   -> hci_send_req
     320   aci_gap_start_general_discovery_proc
       320   -> Osal_MemSet
       320   -> hci_send_req
     320   aci_gap_start_limited_discovery_proc
       320   -> Osal_MemSet
       320   -> hci_send_req
     344   aci_gap_start_name_discovery_proc
       344   -> Osal_MemCpy
       344   -> Osal_MemSet
       344   -> hci_send_req
     328   aci_gap_start_observation_proc
       328   -> Osal_MemSet
       328   -> hci_send_req
     336   aci_gap_start_selective_connection_establish_proc
       336   -> Osal_MemCpy
       336   -> Osal_MemSet
       336   -> hci_send_req
     312   aci_gap_terminate
       312   -> Osal_MemSet
       312   -> hci_send_req
     304   aci_gap_terminate_gap_proc
       304   -> Osal_MemSet
       304   -> hci_send_req
     312   aci_gap_update_adv_data
       312   -> Osal_MemCpy
       312   -> Osal_MemSet
       312   -> hci_send_req


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     150  aci_gap_add_devices_to_resolving_list
      94  aci_gap_allow_rebond
     100  aci_gap_authorization_resp
      76  aci_gap_clear_security_db
      76  aci_gap_configure_whitelist
     232  aci_gap_create_connection
      94  aci_gap_delete_ad_type
     102  aci_gap_get_bonded_devices
     160  aci_gap_get_oob_data
     126  aci_gap_get_security_level
     166  aci_gap_init
     108  aci_gap_is_device_bonded
     100  aci_gap_numeric_comparison_value_confirm_yesno
     102  aci_gap_pass_key_resp
     100  aci_gap_passkey_input
     120  aci_gap_resolve_private_addr
     104  aci_gap_send_pairing_req
     198  aci_gap_set_authentication_requirement
     100  aci_gap_set_authorization_requirement
     218  aci_gap_set_broadcast_mode
     168  aci_gap_set_direct_connectable
     264  aci_gap_set_discoverable
      94  aci_gap_set_event_mask
      94  aci_gap_set_io_capability
     268  aci_gap_set_limited_discoverable
     100  aci_gap_set_non_connectable
      76  aci_gap_set_non_discoverable
     178  aci_gap_set_oob_data
     140  aci_gap_set_undirected_connectable
      98  aci_gap_slave_security_req
     240  aci_gap_start_auto_connection_establish_proc
     176  aci_gap_start_connection_update
     164  aci_gap_start_general_connection_establish_proc
     144  aci_gap_start_general_discovery_proc
     144  aci_gap_start_limited_discovery_proc
     232  aci_gap_start_name_discovery_proc
     164  aci_gap_start_observation_proc
     200  aci_gap_start_selective_connection_establish_proc
     104  aci_gap_terminate
      94  aci_gap_terminate_gap_proc
     110  aci_gap_update_adv_data

 
 5 778 bytes in section .text
 
 5 778 bytes of CODE memory

Errors: none
Warnings: none
