###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       29/Jan/2018  14:45:28
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_usart.c
#    Command line =  
#        "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_usart.c"
#        -D STM32L151xB -D STM32L1XX_XL -D USE_STM32L1XX_STEVAL_IDB00xV1 -D
#        USE_HAL_DRIVER -D HCLK_32MHZ=1 -D SYSCLK_MSI=1 -D ENABLE_USART -D
#        USER_DEFINED_PLATFORM=USER_EVAL_PLATFORM -D IRQ_RESET_PIN -D DTM_UART
#        -lC "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\List"
#        -o "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        D:\Software\IAR_BlueNRG\arm\INC\c\DLib_Config_Normal.h -I
#        "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\HAL\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\BSP\STM32L1xx_BlueNRG1\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\BSP\STM32L1xx_Nucleo\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\CMSIS\Device\ST\STM32L1xx\Include\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\STM32L1xx_HAL_BlueNRG1_Drivers\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\SimpleBlueNRG1_HCI\includes\"
#        -On --use_c++_inline -I D:\Software\IAR_BlueNRG\arm\CMSIS\Include\
#    Locale       =  Chinese (Simplified)_China.936
#    List file    =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\List\stm32l1xx_hal_usart.lst
#    Object file  =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\Obj\stm32l1xx_hal_usart.o
#
###############################################################################

C:\Users\Administrator\Desktop\Temporary Files\eeworld_project\Project_Test\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_usart.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_hal_usart.c
      4            * @author  MCD Application Team
      5            * @version V1.1.1
      6            * @date    31-March-2015
      7            * @brief   USART HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Universal Synchronous Asynchronous Receiver Transmitter (USART) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral Control functions 
     13            *           + Peripheral State and Errors functions  
     14            @verbatim
     15            ==============================================================================
     16                                  ##### How to use this driver #####
     17            ==============================================================================
     18            [..]
     19              The USART HAL driver can be used as follows:
     20          
     21              (#) Declare a USART_HandleTypeDef handle structure.
     22              (#) Initialize the USART low level resources by implementing the HAL_USART_MspInit() API:
     23                  (##) Enable the USARTx interface clock.
     24                  (##) USART pins configuration:
     25                       (+++) Enable the clock for the USART GPIOs.
     26                       (+++) Configure the USART pins as alternate function pull-up.
     27                  (##) NVIC configuration if you need to use interrupt process (HAL_USART_Transmit_IT(),
     28                       HAL_USART_Receive_IT() and HAL_USART_TransmitReceive_IT() APIs):
     29                       (+++) Configure the USARTx interrupt priority.
     30                       (+++) Enable the NVIC USART IRQ handle.
     31                  (##) DMA Configuration if you need to use DMA process (HAL_USART_Transmit_DMA()
     32                       HAL_USART_Receive_DMA() and HAL_USART_TransmitReceive_DMA() APIs):
     33                       (+++) Declare a DMA handle structure for the Tx/Rx channel.
     34                       (+++) Enable the DMAx interface clock.
     35                       (+++) Configure the declared DMA handle structure with the required Tx/Rx parameters.
     36                       (+++) Configure the DMA Tx/Rx channel.
     37                       (+++) Associate the initilalized DMA handle to the USART DMA Tx/Rx handle.
     38                       (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on the DMA Tx/Rx channel.
     39                      (+++) Configure the USARTx interrupt priority and enable the NVIC USART IRQ handle
     40          			      (used for last byte sending completion detection in DMA non circular mode)
     41          
     42              (#) Program the Baud Rate, Word Length, Stop Bit, Parity, Hardware 
     43                  flow control and Mode(Receiver/Transmitter) in the husart Init structure.
     44          
     45              (#) Initialize the USART registers by calling the HAL_USART_Init() API:
     46                  (++) These APIs configures also the low level Hardware GPIO, CLOCK, CORTEX...etc)
     47                       by calling the customed HAL_USART_MspInit(&husart) API.
     48                              
     49                  -@@- The specific USART interrupts (Transmission complete interrupt, 
     50                       RXNE interrupt and Error Interrupts) will be managed using the macros
     51                       __HAL_USART_ENABLE_IT() and __HAL_USART_DISABLE_IT() inside the transmit and receive process.
     52                    
     53              (#) Three operation modes are available within this driver :     
     54            
     55               *** Polling mode IO operation ***
     56               =================================
     57               [..]    
     58                 (+) Send an amount of data in blocking mode using HAL_USART_Transmit() 
     59                 (+) Receive an amount of data in blocking mode using HAL_USART_Receive()
     60                 
     61               *** Interrupt mode IO operation ***    
     62               ===================================
     63               [..]    
     64                 (+) Send an amount of data in non blocking mode using HAL_USART_Transmit_IT() 
     65                 (+) At transmission end of transfer HAL_USART_TxCpltCallback is executed and user can 
     66                      add his own code by customization of function pointer HAL_USART_TxCpltCallback
     67                 (+) Receive an amount of data in non blocking mode using HAL_USART_Receive_IT() 
     68                 (+) At reception end of transfer HAL_USART_RxCpltCallback is executed and user can 
     69                      add his own code by customization of function pointer HAL_USART_RxCpltCallback                                      
     70                 (+) In case of transfer Error, HAL_USART_ErrorCallback() function is executed and user can 
     71                      add his own code by customization of function pointer HAL_USART_ErrorCallback
     72              
     73               *** DMA mode IO operation ***    
     74               ==============================
     75               [..] 
     76                 (+) Send an amount of data in non blocking mode (DMA) using HAL_USART_Transmit_DMA() 
     77                 (+) At transmission end of half transfer HAL_USART_TxHalfCpltCallback is executed and user can 
     78                      add his own code by customization of function pointer HAL_USART_TxHalfCpltCallback 
     79                 (+) At transmission end of transfer HAL_USART_TxCpltCallback is executed and user can 
     80                      add his own code by customization of function pointer HAL_USART_TxCpltCallback
     81                 (+) Receive an amount of data in non blocking mode (DMA) using HAL_USART_Receive_DMA() 
     82                 (+) At reception end of half transfer HAL_USART_RxHalfCpltCallback is executed and user can 
     83                      add his own code by customization of function pointer HAL_USART_RxHalfCpltCallback 
     84                 (+) At reception end of transfer HAL_USART_RxCpltCallback is executed and user can 
     85                      add his own code by customization of function pointer HAL_USART_RxCpltCallback                                      
     86                 (+) In case of transfer Error, HAL_USART_ErrorCallback() function is executed and user can 
     87                      add his own code by customization of function pointer HAL_USART_ErrorCallback
     88                 (+) Pause the DMA Transfer using HAL_USART_DMAPause()      
     89                 (+) Resume the DMA Transfer using HAL_USART_DMAResume()  
     90                 (+) Stop the DMA Transfer using HAL_USART_DMAStop()      
     91               
     92               *** USART HAL driver macros list ***
     93               ============================================= 
     94               [..]
     95                 Below the list of most used macros in USART HAL driver.
     96                 
     97                 (+) __HAL_USART_ENABLE: Enable the USART peripheral 
     98                 (+) __HAL_USART_DISABLE: Disable the USART peripheral     
     99                 (+) __HAL_USART_GET_FLAG : Check whether the specified USART flag is set or not
    100                 (+) __HAL_USART_CLEAR_FLAG : Clear the specified USART pending flag
    101                 (+) __HAL_USART_ENABLE_IT: Enable the specified USART interrupt
    102                 (+) __HAL_USART_DISABLE_IT: Disable the specified USART interrupt
    103                 (+) __HAL_USART_GET_IT_SOURCE: Check whether the specified USART interrupt has occurred or not
    104                
    105               [..] 
    106                 (@) You can refer to the USART HAL driver header file for more useful macros
    107          
    108            @endverbatim
    109            ******************************************************************************
    110            * @attention
    111            *
    112            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
    113            *
    114            * Redistribution and use in source and binary forms, with or without modification,
    115            * are permitted provided that the following conditions are met:
    116            *   1. Redistributions of source code must retain the above copyright notice,
    117            *      this list of conditions and the following disclaimer.
    118            *   2. Redistributions in binary form must reproduce the above copyright notice,
    119            *      this list of conditions and the following disclaimer in the documentation
    120            *      and/or other materials provided with the distribution.
    121            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    122            *      may be used to endorse or promote products derived from this software
    123            *      without specific prior written permission.
    124            *
    125            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    126            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    127            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    128            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    129            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    130            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    131            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    132            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    133            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    134            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    135            *
    136            ******************************************************************************
    137            */
    138          
    139          /* Includes ------------------------------------------------------------------*/
    140          #include "stm32l1xx_hal.h"
    141          
    142          /** @addtogroup STM32L1xx_HAL_Driver
    143            * @{
    144            */
    145          
    146          /** @defgroup USART USART
    147            * @brief HAL USART Synchronous module driver
    148            * @{
    149            */
    150          #ifdef HAL_USART_MODULE_ENABLED
    151          /* Private typedef -----------------------------------------------------------*/
    152          /* Private define ------------------------------------------------------------*/
    153          /** @defgroup USART_Private_Constants   USART Private Constants
    154            * @{
    155            */
    156          #define DUMMY_DATA      0xFFFF
    157          /**
    158            * @}
    159            */
    160          
    161          /* Private macros ------------------------------------------------------------*/
    162          /* Private variables ---------------------------------------------------------*/
    163          /* Private function prototypes -----------------------------------------------*/
    164          /** @addtogroup USART_Private_Functions   USART Private Functions
    165            * @{
    166            */
    167          static HAL_StatusTypeDef USART_Transmit_IT(USART_HandleTypeDef *husart);
    168          static HAL_StatusTypeDef USART_EndTransmit_IT(USART_HandleTypeDef *husart);
    169          static HAL_StatusTypeDef USART_Receive_IT(USART_HandleTypeDef *husart);
    170          static HAL_StatusTypeDef USART_TransmitReceive_IT(USART_HandleTypeDef *husart);
    171          static void USART_SetConfig (USART_HandleTypeDef *husart);
    172          static void USART_DMATransmitCplt(DMA_HandleTypeDef *hdma);
    173          static void USART_DMATxHalfCplt(DMA_HandleTypeDef *hdma);
    174          static void USART_DMAReceiveCplt(DMA_HandleTypeDef *hdma);
    175          static void USART_DMARxHalfCplt(DMA_HandleTypeDef *hdma);
    176          static void USART_DMAError(DMA_HandleTypeDef *hdma); 
    177          static HAL_StatusTypeDef USART_WaitOnFlagUntilTimeout(USART_HandleTypeDef *husart, uint32_t Flag, FlagStatus Status, uint32_t Timeout);
    178          /**
    179            * @}
    180            */
    181          
    182          /* Exported functions ---------------------------------------------------------*/
    183          
    184          
    185          /** @defgroup USART_Exported_Functions USART Exported Functions
    186            * @{
    187            */
    188          
    189          /** @defgroup USART_Exported_Functions_Group1 Initialization and de-initialization functions 
    190            *  @brief    Initialization and Configuration functions 
    191            *
    192          @verbatim
    193            ==============================================================================
    194                        ##### Initialization and Configuration functions #####
    195            ==============================================================================
    196            [..]
    197            This subsection provides a set of functions allowing to initialize the USART 
    198            in asynchronous and in synchronous modes.
    199            (+) For the asynchronous mode only these parameters can be configured: 
    200                (++) Baud Rate
    201                (++) Word Length 
    202                (++) Stop Bit
    203                (++) Parity: If the parity is enabled, then the MSB bit of the data written
    204                     in the data register is transmitted but is changed by the parity bit.
    205                     Depending on the frame length defined by the M bit (8-bits or 9-bits),
    206                     the possible USART frame formats are as listed in the following table:
    207                (+++)    +-------------------------------------------------------------+
    208                (+++)    |   M bit |  PCE bit  |            USART frame                |
    209                (+++)    |---------------------|---------------------------------------|
    210                (+++)    |    0    |    0      |    | SB | 8 bit data | STB |          |
    211                (+++)    |---------|-----------|---------------------------------------|
    212                (+++)    |    0    |    1      |    | SB | 7 bit data | PB | STB |     |
    213                (+++)    |---------|-----------|---------------------------------------|
    214                (+++)    |    1    |    0      |    | SB | 9 bit data | STB |          |
    215                (+++)    |---------|-----------|---------------------------------------|
    216                (+++)    |    1    |    1      |    | SB | 8 bit data | PB | STB |     |
    217                (+++)    +-------------------------------------------------------------+
    218                (++) USART polarity
    219                (++) USART phase
    220                (++) USART LastBit
    221                (++) Receiver/transmitter modes
    222          
    223            [..]
    224              The HAL_USART_Init() function follows the USART  synchronous configuration 
    225              procedure (details for the procedure are available in reference manual (RM0038)).
    226          
    227          @endverbatim
    228            * @{
    229            */
    230          
    231          /**
    232            * @brief  Initializes the USART mode according to the specified
    233            *         parameters in the USART_InitTypeDef and create the associated handle.
    234            * @param  husart: Pointer to a USART_HandleTypeDef structure that contains
    235            *                 the configuration information for the specified USART module.
    236            * @retval HAL status
    237            */

   \                                 In section .text, align 2, keep-with-next
    238          HAL_StatusTypeDef HAL_USART_Init(USART_HandleTypeDef *husart)
    239          {
   \                     HAL_USART_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    240            /* Check the USART handle allocation */
    241            if(husart == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_USART_Init_0
    242            {
    243              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE027             B.N      ??HAL_USART_Init_1
    244            }
    245          
    246            /* Check the parameters */
    247            assert_param(IS_USART_INSTANCE(husart->Instance));
    248          
    249            if(husart->State == HAL_USART_STATE_RESET)
   \                     ??HAL_USART_Init_0: (+1)
   \   0000000C   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD105             BNE.N    ??HAL_USART_Init_2
    250            {
    251              /* Allocate lock resource and initialize it */
    252              husart->Lock = HAL_UNLOCKED;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF884 0x003C      STRB     R0,[R4, #+60]
    253          
    254              /* Init the low level hardware */
    255              HAL_USART_MspInit(husart);
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_USART_MspInit
    256            }
    257            
    258            husart->State = HAL_USART_STATE_BUSY;
   \                     ??HAL_USART_Init_2: (+1)
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xF884 0x003D      STRB     R0,[R4, #+61]
    259          
    260            /* Set the USART Communication parameters */
    261            USART_SetConfig(husart);
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       USART_SetConfig
    262          
    263            /* In USART mode, the following bits must be kept cleared: 
    264               - LINEN bit in the USART_CR2 register
    265               - HDSEL, SCEN and IREN bits in the USART_CR3 register */
    266            CLEAR_BIT(husart->Instance->CR2, USART_CR2_LINEN);
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x6900             LDR      R0,[R0, #+16]
   \   00000030   0xF430 0x4080      BICS     R0,R0,#0x4000
   \   00000034   0x6821             LDR      R1,[R4, #+0]
   \   00000036   0x6108             STR      R0,[R1, #+16]
    267            CLEAR_BIT(husart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN | USART_CR3_HDSEL));
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x6940             LDR      R0,[R0, #+20]
   \   0000003C   0xF030 0x002A      BICS     R0,R0,#0x2A
   \   00000040   0x6821             LDR      R1,[R4, #+0]
   \   00000042   0x6148             STR      R0,[R1, #+20]
    268          
    269            /* Enable the Peripheral */
    270            __HAL_USART_ENABLE(husart);
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x68C0             LDR      R0,[R0, #+12]
   \   00000048   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x60C8             STR      R0,[R1, #+12]
    271          
    272            /* Initialize the USART state */
    273            husart->ErrorCode = HAL_USART_ERROR_NONE;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x6420             STR      R0,[R4, #+64]
    274            husart->State= HAL_USART_STATE_READY;
   \   00000054   0x2001             MOVS     R0,#+1
   \   00000056   0xF884 0x003D      STRB     R0,[R4, #+61]
    275          
    276            return HAL_OK;
   \   0000005A   0x2000             MOVS     R0,#+0
   \                     ??HAL_USART_Init_1: (+1)
   \   0000005C   0xBD10             POP      {R4,PC}          ;; return
    277          }
    278          
    279          /**
    280            * @brief  DeInitializes the USART peripheral.
    281            * @param  husart: Pointer to a USART_HandleTypeDef structure that contains
    282            *                 the configuration information for the specified USART module.
    283            * @retval HAL status
    284            */

   \                                 In section .text, align 2, keep-with-next
    285          HAL_StatusTypeDef HAL_USART_DeInit(USART_HandleTypeDef *husart)
    286          {
   \                     HAL_USART_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    287             /* Check the USART handle allocation */
    288            if(husart == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_USART_DeInit_0
    289            {
    290              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE014             B.N      ??HAL_USART_DeInit_1
    291            }
    292          
    293            /* Check the parameters */
    294            assert_param(IS_USART_INSTANCE(husart->Instance));
    295          
    296            husart->State = HAL_USART_STATE_BUSY;
   \                     ??HAL_USART_DeInit_0: (+1)
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xF884 0x003D      STRB     R0,[R4, #+61]
    297          
    298            /* Disable the Peripheral */
    299            __HAL_USART_DISABLE(husart);
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x68C0             LDR      R0,[R0, #+12]
   \   00000016   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   0000001A   0x6821             LDR      R1,[R4, #+0]
   \   0000001C   0x60C8             STR      R0,[R1, #+12]
    300          
    301            /* DeInit the low level hardware */
    302            HAL_USART_MspDeInit(husart);
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       HAL_USART_MspDeInit
    303          
    304            husart->ErrorCode = HAL_USART_ERROR_NONE;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x6420             STR      R0,[R4, #+64]
    305            husart->State = HAL_USART_STATE_RESET;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF884 0x003D      STRB     R0,[R4, #+61]
    306          
    307            /* Release Lock */
    308            __HAL_UNLOCK(husart);
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x003C      STRB     R0,[R4, #+60]
    309          
    310            return HAL_OK;
   \   00000034   0x2000             MOVS     R0,#+0
   \                     ??HAL_USART_DeInit_1: (+1)
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
    311          }
    312          
    313          /**
    314            * @brief  USART MSP Init.
    315            * @param  husart: Pointer to a USART_HandleTypeDef structure that contains
    316            *                 the configuration information for the specified USART module.
    317            * @retval None
    318            */

   \                                 In section .text, align 2
    319           __weak void HAL_USART_MspInit(USART_HandleTypeDef *husart)
    320          {
    321            /* NOTE: This function should not be modified, when the callback is needed,
    322                     the HAL_USART_MspInit can be implemented in the user file
    323             */ 
    324          }
   \                     HAL_USART_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    325          
    326          /**
    327            * @brief  USART MSP DeInit.
    328            * @param  husart: Pointer to a USART_HandleTypeDef structure that contains
    329            *                 the configuration information for the specified USART module.
    330            * @retval None
    331            */

   \                                 In section .text, align 2
    332           __weak void HAL_USART_MspDeInit(USART_HandleTypeDef *husart)
    333          {
    334            /* NOTE: This function should not be modified, when the callback is needed,
    335                     the HAL_USART_MspDeInit can be implemented in the user file
    336             */ 
    337          }
   \                     HAL_USART_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    338          
    339          /**
    340            * @}
    341            */
    342          
    343          /** @defgroup USART_Exported_Functions_Group2 IO operation functions 
    344            *  @brief   USART Transmit and Receive functions 
    345            *
    346          @verbatim
    347            ==============================================================================
    348                                   ##### IO operation functions #####
    349            ==============================================================================
    350            [..]
    351              This subsection provides a set of functions allowing to manage the USART synchronous
    352              data transfers.
    353                
    354            [..] 
    355              The USART supports master mode only: it cannot receive or send data related to an input
    356              clock (SCLK is always an output).
    357          
    358              (#) There are two modes of transfer:
    359                  (++) Blocking mode: The communication is performed in polling mode. 
    360                       The HAL status of all data processing is returned by the same function 
    361                       after finishing transfer.  
    362                  (++) No-Blocking mode: The communication is performed using Interrupts 
    363                       or DMA, These API's return the HAL status.
    364                       The end of the data processing will be indicated through the 
    365                       dedicated USART IRQ when using Interrupt mode or the DMA IRQ when 
    366                       using DMA mode.
    367                       The HAL_USART_TxCpltCallback(), HAL_USART_RxCpltCallback() and HAL_USART_TxRxCpltCallback() 
    368                       user callbacks 
    369                       will be executed respectively at the end of the transmit or Receive process
    370                       The HAL_USART_ErrorCallback() user callback will be executed when a communication 
    371                       error is detected
    372          
    373              (#) Blocking mode APIs are :
    374                  (++) HAL_USART_Transmit() in simplex mode
    375                  (++) HAL_USART_Receive() in full duplex receive only
    376                  (++) HAL_USART_TransmitReceive() in full duplex mode
    377          
    378              (#) Non Blocking mode APIs with Interrupt are :
    379                  (++) HAL_USART_Transmit_IT()in simplex mode
    380                  (++) HAL_USART_Receive_IT() in full duplex receive only
    381                  (++) HAL_USART_TransmitReceive_IT() in full duplex mode
    382                  (++) HAL_USART_IRQHandler()
    383          
    384              (#) Non Blocking mode functions with DMA are :
    385                  (++) HAL_USART_Transmit_DMA()in simplex mode
    386                  (++) HAL_USART_Receive_DMA() in full duplex receive only
    387                  (++) HAL_USART_TransmitReceive_DMA() in full duplex mode
    388                  (++) HAL_USART_DMAPause()
    389                  (++) HAL_USART_DMAResume()
    390                  (++) HAL_USART_DMAStop()
    391          
    392              (#) A set of Transfer Complete Callbacks are provided in non Blocking mode:
    393                  (++) HAL_USART_TxHalfCpltCallback()
    394                  (++) HAL_USART_TxCpltCallback()
    395                  (++) HAL_USART_RxHalfCpltCallback()
    396                  (++) HAL_USART_RxCpltCallback()
    397                  (++) HAL_USART_ErrorCallback()
    398                  (++) HAL_USART_TxRxCpltCallback()
    399          
    400          @endverbatim
    401            * @{
    402            */
    403          
    404          /**
    405            * @brief  Simplex Send an amount of data in blocking mode. 
    406            * @param  husart: Pointer to a USART_HandleTypeDef structure that contains
    407            *                 the configuration information for the specified USART module.
    408            * @param  pTxData: Pointer to data buffer
    409            * @param  Size: Amount of data to be sent
    410            * @param  Timeout: Timeout duration
    411            * @retval HAL status
    412            */

   \                                 In section .text, align 2, keep-with-next
    413          HAL_StatusTypeDef HAL_USART_Transmit(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size, uint32_t Timeout)
    414          {
   \                     HAL_USART_Transmit: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    415            uint16_t* tmp=0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
    416          
    417            if(husart->State == HAL_USART_STATE_READY)
   \   00000010   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD159             BNE.N    ??HAL_USART_Transmit_0
    418            {
    419              if((pTxData == NULL) || (Size == 0)) 
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD002             BEQ.N    ??HAL_USART_Transmit_1
   \   0000001C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000001E   0x2E00             CMP      R6,#+0
   \   00000020   0xD101             BNE.N    ??HAL_USART_Transmit_2
    420              {
    421                return  HAL_ERROR;
   \                     ??HAL_USART_Transmit_1: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xE053             B.N      ??HAL_USART_Transmit_3
    422              }
    423          
    424              /* Process Locked */
    425              __HAL_LOCK(husart);
   \                     ??HAL_USART_Transmit_2: (+1)
   \   00000026   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \   0000002A   0x2801             CMP      R0,#+1
   \   0000002C   0xD101             BNE.N    ??HAL_USART_Transmit_4
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0xE04D             B.N      ??HAL_USART_Transmit_3
   \                     ??HAL_USART_Transmit_4: (+1)
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xF884 0x003C      STRB     R0,[R4, #+60]
    426          
    427              husart->ErrorCode = HAL_USART_ERROR_NONE;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x6420             STR      R0,[R4, #+64]
    428              husart->State = HAL_USART_STATE_BUSY_TX;
   \   0000003C   0x2012             MOVS     R0,#+18
   \   0000003E   0xF884 0x003D      STRB     R0,[R4, #+61]
    429          
    430              husart->TxXferSize = Size;
   \   00000042   0x8526             STRH     R6,[R4, #+40]
    431              husart->TxXferCount = Size;
   \   00000044   0x8566             STRH     R6,[R4, #+42]
    432              while(husart->TxXferCount > 0)
   \                     ??HAL_USART_Transmit_5: (+1)
   \   00000046   0x8D60             LDRH     R0,[R4, #+42]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD02D             BEQ.N    ??HAL_USART_Transmit_6
    433              {
    434                husart->TxXferCount--;
   \   0000004C   0x8D60             LDRH     R0,[R4, #+42]
   \   0000004E   0x1E40             SUBS     R0,R0,#+1
   \   00000050   0x8560             STRH     R0,[R4, #+42]
    435                if(husart->Init.WordLength == USART_WORDLENGTH_9B)
   \   00000052   0x68A0             LDR      R0,[R4, #+8]
   \   00000054   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000058   0xD117             BNE.N    ??HAL_USART_Transmit_7
    436                {
    437                  /* Wait for TC flag in order to write data in DR */
    438                  if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, Timeout) != HAL_OK)
   \   0000005A   0x003B             MOVS     R3,R7
   \   0000005C   0x2200             MOVS     R2,#+0
   \   0000005E   0x2180             MOVS     R1,#+128
   \   00000060   0x0020             MOVS     R0,R4
   \   00000062   0x.... 0x....      BL       USART_WaitOnFlagUntilTimeout
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD001             BEQ.N    ??HAL_USART_Transmit_8
    439                  {
    440                    return HAL_TIMEOUT;
   \   0000006A   0x2003             MOVS     R0,#+3
   \   0000006C   0xE02F             B.N      ??HAL_USART_Transmit_3
    441                  }
    442                  tmp = (uint16_t*) pTxData;
   \                     ??HAL_USART_Transmit_8: (+1)
   \   0000006E   0x46A8             MOV      R8,R5
    443                  WRITE_REG(husart->Instance->DR, (*tmp & (uint16_t)0x01FF));
   \   00000070   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   00000074   0x05C0             LSLS     R0,R0,#+23       ;; ZeroExtS R0,R0,#+23,#+23
   \   00000076   0x0DC0             LSRS     R0,R0,#+23
   \   00000078   0x6821             LDR      R1,[R4, #+0]
   \   0000007A   0x6048             STR      R0,[R1, #+4]
    444                  if(husart->Init.Parity == USART_PARITY_NONE)
   \   0000007C   0x6920             LDR      R0,[R4, #+16]
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD101             BNE.N    ??HAL_USART_Transmit_9
    445                  {
    446                    pTxData += 2;
   \   00000082   0x1CAD             ADDS     R5,R5,#+2
   \   00000084   0xE7DF             B.N      ??HAL_USART_Transmit_5
    447                  }
    448                  else
    449                  {
    450                    pTxData += 1;
   \                     ??HAL_USART_Transmit_9: (+1)
   \   00000086   0x1C6D             ADDS     R5,R5,#+1
   \   00000088   0xE7DD             B.N      ??HAL_USART_Transmit_5
    451                  }
    452                }
    453                else
    454                {
    455                  if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, Timeout) != HAL_OK)
   \                     ??HAL_USART_Transmit_7: (+1)
   \   0000008A   0x003B             MOVS     R3,R7
   \   0000008C   0x2200             MOVS     R2,#+0
   \   0000008E   0x2180             MOVS     R1,#+128
   \   00000090   0x0020             MOVS     R0,R4
   \   00000092   0x.... 0x....      BL       USART_WaitOnFlagUntilTimeout
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD001             BEQ.N    ??HAL_USART_Transmit_10
    456                  {
    457                    return HAL_TIMEOUT;
   \   0000009A   0x2003             MOVS     R0,#+3
   \   0000009C   0xE017             B.N      ??HAL_USART_Transmit_3
    458                  }
    459                  WRITE_REG(husart->Instance->DR, (*pTxData++ & (uint8_t)0xFF));
   \                     ??HAL_USART_Transmit_10: (+1)
   \   0000009E   0x7828             LDRB     R0,[R5, #+0]
   \   000000A0   0x6821             LDR      R1,[R4, #+0]
   \   000000A2   0x6048             STR      R0,[R1, #+4]
   \   000000A4   0x1C6D             ADDS     R5,R5,#+1
   \   000000A6   0xE7CE             B.N      ??HAL_USART_Transmit_5
    460                }
    461              }
    462          
    463              if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TC, RESET, Timeout) != HAL_OK)
   \                     ??HAL_USART_Transmit_6: (+1)
   \   000000A8   0x003B             MOVS     R3,R7
   \   000000AA   0x2200             MOVS     R2,#+0
   \   000000AC   0x2140             MOVS     R1,#+64
   \   000000AE   0x0020             MOVS     R0,R4
   \   000000B0   0x.... 0x....      BL       USART_WaitOnFlagUntilTimeout
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD001             BEQ.N    ??HAL_USART_Transmit_11
    464              { 
    465                return HAL_TIMEOUT;
   \   000000B8   0x2003             MOVS     R0,#+3
   \   000000BA   0xE008             B.N      ??HAL_USART_Transmit_3
    466              }
    467          
    468              husart->State = HAL_USART_STATE_READY;
   \                     ??HAL_USART_Transmit_11: (+1)
   \   000000BC   0x2001             MOVS     R0,#+1
   \   000000BE   0xF884 0x003D      STRB     R0,[R4, #+61]
    469          
    470              /* Process Unlocked */
    471              __HAL_UNLOCK(husart);
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0xF884 0x003C      STRB     R0,[R4, #+60]
    472          
    473              return HAL_OK;
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0xE000             B.N      ??HAL_USART_Transmit_3
    474            }
    475            else
    476            {
    477              return HAL_BUSY;
   \                     ??HAL_USART_Transmit_0: (+1)
   \   000000CC   0x2002             MOVS     R0,#+2
   \                     ??HAL_USART_Transmit_3: (+1)
   \   000000CE   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    478            }
    479          }
    480          
    481          /**
    482            * @brief  Full-Duplex Receive an amount of data in blocking mode. 
    483            * @param  husart: Pointer to a USART_HandleTypeDef structure that contains
    484            *                 the configuration information for the specified USART module.
    485            * @param  pRxData: Pointer to data buffer
    486            * @param  Size: Amount of data to be received
    487            * @param  Timeout: Timeout duration
    488            * @retval HAL status
    489            */

   \                                 In section .text, align 2, keep-with-next
    490          HAL_StatusTypeDef HAL_USART_Receive(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
    491          {
   \                     HAL_USART_Receive: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    492            uint16_t* tmp=0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
    493          
    494            if(husart->State == HAL_USART_STATE_READY)
   \   00000010   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD17A             BNE.N    ??HAL_USART_Receive_0
    495            {
    496              if((pRxData == NULL) || (Size == 0)) 
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD002             BEQ.N    ??HAL_USART_Receive_1
   \   0000001C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000001E   0x2E00             CMP      R6,#+0
   \   00000020   0xD101             BNE.N    ??HAL_USART_Receive_2
    497              {
    498                return  HAL_ERROR;
   \                     ??HAL_USART_Receive_1: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xE074             B.N      ??HAL_USART_Receive_3
    499              }
    500              
    501              /* Process Locked */
    502              __HAL_LOCK(husart);
   \                     ??HAL_USART_Receive_2: (+1)
   \   00000026   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \   0000002A   0x2801             CMP      R0,#+1
   \   0000002C   0xD101             BNE.N    ??HAL_USART_Receive_4
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0xE06E             B.N      ??HAL_USART_Receive_3
   \                     ??HAL_USART_Receive_4: (+1)
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xF884 0x003C      STRB     R0,[R4, #+60]
    503          
    504              husart->ErrorCode = HAL_USART_ERROR_NONE;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x6420             STR      R0,[R4, #+64]
    505              husart->State = HAL_USART_STATE_BUSY_RX;
   \   0000003C   0x2022             MOVS     R0,#+34
   \   0000003E   0xF884 0x003D      STRB     R0,[R4, #+61]
    506          
    507              husart->RxXferSize = Size;
   \   00000042   0x8626             STRH     R6,[R4, #+48]
    508              husart->RxXferCount = Size;
   \   00000044   0x8666             STRH     R6,[R4, #+50]
    509              /* Check the remain data to be received */
    510              while(husart->RxXferCount > 0)
   \                     ??HAL_USART_Receive_5: (+1)
   \   00000046   0x8E60             LDRH     R0,[R4, #+50]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD058             BEQ.N    ??HAL_USART_Receive_6
    511              {
    512                husart->RxXferCount--;
   \   0000004C   0x8E60             LDRH     R0,[R4, #+50]
   \   0000004E   0x1E40             SUBS     R0,R0,#+1
   \   00000050   0x8660             STRH     R0,[R4, #+50]
    513                if(husart->Init.WordLength == USART_WORDLENGTH_9B)
   \   00000052   0x68A0             LDR      R0,[R4, #+8]
   \   00000054   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000058   0xD12B             BNE.N    ??HAL_USART_Receive_7
    514                {
    515                  /* Wait until TXE flag is set to send dummy byte in order to generate the clock for the slave to send data */
    516                  if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, Timeout) != HAL_OK)
   \   0000005A   0x003B             MOVS     R3,R7
   \   0000005C   0x2200             MOVS     R2,#+0
   \   0000005E   0x2180             MOVS     R1,#+128
   \   00000060   0x0020             MOVS     R0,R4
   \   00000062   0x.... 0x....      BL       USART_WaitOnFlagUntilTimeout
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD001             BEQ.N    ??HAL_USART_Receive_8
    517                  { 
    518                    return HAL_TIMEOUT;
   \   0000006A   0x2003             MOVS     R0,#+3
   \   0000006C   0xE050             B.N      ??HAL_USART_Receive_3
    519                  }
    520                  /* Send dummy byte in order to generate clock */
    521                  WRITE_REG(husart->Instance->DR, (DUMMY_DATA & (uint16_t)0x01FF));
   \                     ??HAL_USART_Receive_8: (+1)
   \   0000006E   0xF240 0x10FF      MOVW     R0,#+511
   \   00000072   0x6821             LDR      R1,[R4, #+0]
   \   00000074   0x6048             STR      R0,[R1, #+4]
    522                  
    523                  /* Wait for RXNE Flag */
    524                  if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \   00000076   0x003B             MOVS     R3,R7
   \   00000078   0x2200             MOVS     R2,#+0
   \   0000007A   0x2120             MOVS     R1,#+32
   \   0000007C   0x0020             MOVS     R0,R4
   \   0000007E   0x.... 0x....      BL       USART_WaitOnFlagUntilTimeout
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD001             BEQ.N    ??HAL_USART_Receive_9
    525                  { 
    526                    return HAL_TIMEOUT;
   \   00000086   0x2003             MOVS     R0,#+3
   \   00000088   0xE042             B.N      ??HAL_USART_Receive_3
    527                  }
    528                  tmp = (uint16_t*) pRxData ;
   \                     ??HAL_USART_Receive_9: (+1)
   \   0000008A   0x46A8             MOV      R8,R5
    529                  if(husart->Init.Parity == USART_PARITY_NONE)
   \   0000008C   0x6920             LDR      R0,[R4, #+16]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD107             BNE.N    ??HAL_USART_Receive_10
    530                  {
    531                    *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x01FF);
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x6840             LDR      R0,[R0, #+4]
   \   00000096   0x05C0             LSLS     R0,R0,#+23       ;; ZeroExtS R0,R0,#+23,#+23
   \   00000098   0x0DC0             LSRS     R0,R0,#+23
   \   0000009A   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    532                    pRxData +=2;
   \   0000009E   0x1CAD             ADDS     R5,R5,#+2
   \   000000A0   0xE7D1             B.N      ??HAL_USART_Receive_5
    533                  }
    534                  else
    535                  {
    536                    *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x00FF);
   \                     ??HAL_USART_Receive_10: (+1)
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x6840             LDR      R0,[R0, #+4]
   \   000000A6   0xF000 0x00FF      AND      R0,R0,#0xFF
   \   000000AA   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    537                    pRxData +=1;
   \   000000AE   0x1C6D             ADDS     R5,R5,#+1
   \   000000B0   0xE7C9             B.N      ??HAL_USART_Receive_5
    538                  }
    539                }
    540                else
    541                {
    542                  /* Wait until TXE flag is set to send dummy byte in order to generate the clock for the slave to send data */
    543                  if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, Timeout) != HAL_OK)
   \                     ??HAL_USART_Receive_7: (+1)
   \   000000B2   0x003B             MOVS     R3,R7
   \   000000B4   0x2200             MOVS     R2,#+0
   \   000000B6   0x2180             MOVS     R1,#+128
   \   000000B8   0x0020             MOVS     R0,R4
   \   000000BA   0x.... 0x....      BL       USART_WaitOnFlagUntilTimeout
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xD001             BEQ.N    ??HAL_USART_Receive_11
    544                  { 
    545                    return HAL_TIMEOUT;
   \   000000C2   0x2003             MOVS     R0,#+3
   \   000000C4   0xE024             B.N      ??HAL_USART_Receive_3
    546                  }
    547          
    548                  /* Send Dummy Byte in order to generate clock */
    549                  WRITE_REG(husart->Instance->DR, (DUMMY_DATA & (uint16_t)0x00FF));
   \                     ??HAL_USART_Receive_11: (+1)
   \   000000C6   0x20FF             MOVS     R0,#+255
   \   000000C8   0x6821             LDR      R1,[R4, #+0]
   \   000000CA   0x6048             STR      R0,[R1, #+4]
    550          
    551                  /* Wait until RXNE flag is set to receive the byte */
    552                  if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \   000000CC   0x003B             MOVS     R3,R7
   \   000000CE   0x2200             MOVS     R2,#+0
   \   000000D0   0x2120             MOVS     R1,#+32
   \   000000D2   0x0020             MOVS     R0,R4
   \   000000D4   0x.... 0x....      BL       USART_WaitOnFlagUntilTimeout
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD001             BEQ.N    ??HAL_USART_Receive_12
    553                  {
    554                    return HAL_TIMEOUT;
   \   000000DC   0x2003             MOVS     R0,#+3
   \   000000DE   0xE017             B.N      ??HAL_USART_Receive_3
    555                  }
    556                  if(husart->Init.Parity == USART_PARITY_NONE)
   \                     ??HAL_USART_Receive_12: (+1)
   \   000000E0   0x6920             LDR      R0,[R4, #+16]
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD104             BNE.N    ??HAL_USART_Receive_13
    557                  {
    558                    /* Receive data */
    559                    *pRxData++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x00FF);
   \   000000E6   0x6820             LDR      R0,[R4, #+0]
   \   000000E8   0x6840             LDR      R0,[R0, #+4]
   \   000000EA   0x7028             STRB     R0,[R5, #+0]
   \   000000EC   0x1C6D             ADDS     R5,R5,#+1
   \   000000EE   0xE7AA             B.N      ??HAL_USART_Receive_5
    560                  }
    561                  else
    562                  {
    563                    /* Receive data */
    564                    *pRxData++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x007F);
   \                     ??HAL_USART_Receive_13: (+1)
   \   000000F0   0x6820             LDR      R0,[R4, #+0]
   \   000000F2   0x6840             LDR      R0,[R0, #+4]
   \   000000F4   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   000000F8   0x7028             STRB     R0,[R5, #+0]
   \   000000FA   0x1C6D             ADDS     R5,R5,#+1
   \   000000FC   0xE7A3             B.N      ??HAL_USART_Receive_5
    565                  }
    566                  
    567                }
    568              }
    569          
    570              husart->State = HAL_USART_STATE_READY;
   \                     ??HAL_USART_Receive_6: (+1)
   \   000000FE   0x2001             MOVS     R0,#+1
   \   00000100   0xF884 0x003D      STRB     R0,[R4, #+61]
    571          
    572              /* Process Unlocked */
    573              __HAL_UNLOCK(husart);
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0xF884 0x003C      STRB     R0,[R4, #+60]
    574          
    575              return HAL_OK;
   \   0000010A   0x2000             MOVS     R0,#+0
   \   0000010C   0xE000             B.N      ??HAL_USART_Receive_3
    576            }
    577            else
    578            {
    579              return HAL_BUSY;
   \                     ??HAL_USART_Receive_0: (+1)
   \   0000010E   0x2002             MOVS     R0,#+2
   \                     ??HAL_USART_Receive_3: (+1)
   \   00000110   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    580            }
    581          }
    582          
    583          /**
    584            * @brief  Full-Duplex Send receive an amount of data in full-duplex mode (blocking mode). 
    585            * @param  husart: Pointer to a USART_HandleTypeDef structure that contains
    586            *                 the configuration information for the specified USART module.
    587            * @param  pTxData: Pointer to data transmitted buffer
    588            * @param  pRxData: Pointer to data received buffer  
    589            * @param  Size: Amount of data to be sent
    590            * @param  Timeout: Timeout duration
    591            * @retval HAL status
    592            */

   \                                 In section .text, align 2, keep-with-next
    593          HAL_StatusTypeDef HAL_USART_TransmitReceive(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
    594          {
   \                     HAL_USART_TransmitReceive: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0xF8DD 0x8020      LDR      R8,[SP, #+32]
    595            uint16_t* tmp=0;
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
    596          
    597            if(husart->State == HAL_USART_STATE_READY)
   \   00000014   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xF040 0x808C      BNE.W    ??HAL_USART_TransmitReceive_0
    598            {
    599              if((pTxData == NULL) || (pRxData == NULL) || (Size == 0)) 
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD004             BEQ.N    ??HAL_USART_TransmitReceive_1
   \   00000022   0x2E00             CMP      R6,#+0
   \   00000024   0xD002             BEQ.N    ??HAL_USART_TransmitReceive_1
   \   00000026   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000028   0x2F00             CMP      R7,#+0
   \   0000002A   0xD101             BNE.N    ??HAL_USART_TransmitReceive_2
    600              {
    601                return  HAL_ERROR;
   \                     ??HAL_USART_TransmitReceive_1: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xE083             B.N      ??HAL_USART_TransmitReceive_3
    602              }
    603              /* Process Locked */
    604              __HAL_LOCK(husart);
   \                     ??HAL_USART_TransmitReceive_2: (+1)
   \   00000030   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD101             BNE.N    ??HAL_USART_TransmitReceive_4
   \   00000038   0x2002             MOVS     R0,#+2
   \   0000003A   0xE07D             B.N      ??HAL_USART_TransmitReceive_3
   \                     ??HAL_USART_TransmitReceive_4: (+1)
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xF884 0x003C      STRB     R0,[R4, #+60]
    605          
    606              husart->ErrorCode = HAL_USART_ERROR_NONE;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x6420             STR      R0,[R4, #+64]
    607              husart->State = HAL_USART_STATE_BUSY_RX;
   \   00000046   0x2022             MOVS     R0,#+34
   \   00000048   0xF884 0x003D      STRB     R0,[R4, #+61]
    608          
    609              husart->RxXferSize = Size;
   \   0000004C   0x8627             STRH     R7,[R4, #+48]
    610              husart->TxXferSize = Size;
   \   0000004E   0x8527             STRH     R7,[R4, #+40]
    611              husart->TxXferCount = Size;
   \   00000050   0x8567             STRH     R7,[R4, #+42]
    612              husart->RxXferCount = Size;
   \   00000052   0x8667             STRH     R7,[R4, #+50]
    613          
    614              /* Check the remain data to be received */
    615              while(husart->TxXferCount > 0)
   \                     ??HAL_USART_TransmitReceive_5: (+1)
   \   00000054   0x8D60             LDRH     R0,[R4, #+42]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD065             BEQ.N    ??HAL_USART_TransmitReceive_6
    616              {
    617                husart->TxXferCount--;
   \   0000005A   0x8D60             LDRH     R0,[R4, #+42]
   \   0000005C   0x1E40             SUBS     R0,R0,#+1
   \   0000005E   0x8560             STRH     R0,[R4, #+42]
    618                husart->RxXferCount--;
   \   00000060   0x8E60             LDRH     R0,[R4, #+50]
   \   00000062   0x1E40             SUBS     R0,R0,#+1
   \   00000064   0x8660             STRH     R0,[R4, #+50]
    619                if(husart->Init.WordLength == USART_WORDLENGTH_9B)
   \   00000066   0x68A0             LDR      R0,[R4, #+8]
   \   00000068   0xF5B0 0x5F80      CMP      R0,#+4096
   \   0000006C   0xD134             BNE.N    ??HAL_USART_TransmitReceive_7
    620                {
    621                  /* Wait for TC flag in order to write data in DR */
    622                  if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, Timeout) != HAL_OK)
   \   0000006E   0x4643             MOV      R3,R8
   \   00000070   0x2200             MOVS     R2,#+0
   \   00000072   0x2180             MOVS     R1,#+128
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0x.... 0x....      BL       USART_WaitOnFlagUntilTimeout
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD001             BEQ.N    ??HAL_USART_TransmitReceive_8
    623                  {
    624                    return HAL_TIMEOUT;
   \   0000007E   0x2003             MOVS     R0,#+3
   \   00000080   0xE05A             B.N      ??HAL_USART_TransmitReceive_3
    625                  }
    626                  tmp = (uint16_t*) pTxData;
   \                     ??HAL_USART_TransmitReceive_8: (+1)
   \   00000082   0x46A9             MOV      R9,R5
    627                  WRITE_REG(husart->Instance->DR, (*tmp & (uint16_t)0x01FF));
   \   00000084   0xF8B9 0x0000      LDRH     R0,[R9, #+0]
   \   00000088   0x05C0             LSLS     R0,R0,#+23       ;; ZeroExtS R0,R0,#+23,#+23
   \   0000008A   0x0DC0             LSRS     R0,R0,#+23
   \   0000008C   0x6821             LDR      R1,[R4, #+0]
   \   0000008E   0x6048             STR      R0,[R1, #+4]
    628                  if(husart->Init.Parity == USART_PARITY_NONE)
   \   00000090   0x6920             LDR      R0,[R4, #+16]
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD101             BNE.N    ??HAL_USART_TransmitReceive_9
    629                  {
    630                    pTxData += 2;
   \   00000096   0x1CAD             ADDS     R5,R5,#+2
   \   00000098   0xE000             B.N      ??HAL_USART_TransmitReceive_10
    631                  }
    632                  else
    633                  {
    634                    pTxData += 1;
   \                     ??HAL_USART_TransmitReceive_9: (+1)
   \   0000009A   0x1C6D             ADDS     R5,R5,#+1
    635                  }
    636                  
    637                  /* Wait for RXNE Flag */
    638                  if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \                     ??HAL_USART_TransmitReceive_10: (+1)
   \   0000009C   0x4643             MOV      R3,R8
   \   0000009E   0x2200             MOVS     R2,#+0
   \   000000A0   0x2120             MOVS     R1,#+32
   \   000000A2   0x0020             MOVS     R0,R4
   \   000000A4   0x.... 0x....      BL       USART_WaitOnFlagUntilTimeout
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD001             BEQ.N    ??HAL_USART_TransmitReceive_11
    639                  {
    640                    return HAL_TIMEOUT;
   \   000000AC   0x2003             MOVS     R0,#+3
   \   000000AE   0xE043             B.N      ??HAL_USART_TransmitReceive_3
    641                  }
    642                  tmp = (uint16_t*) pRxData ;
   \                     ??HAL_USART_TransmitReceive_11: (+1)
   \   000000B0   0x46B1             MOV      R9,R6
    643                  if(husart->Init.Parity == USART_PARITY_NONE)
   \   000000B2   0x6920             LDR      R0,[R4, #+16]
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD107             BNE.N    ??HAL_USART_TransmitReceive_12
    644                  {
    645                    *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x01FF);
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0x6840             LDR      R0,[R0, #+4]
   \   000000BC   0x05C0             LSLS     R0,R0,#+23       ;; ZeroExtS R0,R0,#+23,#+23
   \   000000BE   0x0DC0             LSRS     R0,R0,#+23
   \   000000C0   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    646                    pRxData += 2;
   \   000000C4   0x1CB6             ADDS     R6,R6,#+2
   \   000000C6   0xE7C5             B.N      ??HAL_USART_TransmitReceive_5
    647                  }
    648                  else
    649                  {
    650                    *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x00FF);
   \                     ??HAL_USART_TransmitReceive_12: (+1)
   \   000000C8   0x6820             LDR      R0,[R4, #+0]
   \   000000CA   0x6840             LDR      R0,[R0, #+4]
   \   000000CC   0xF000 0x00FF      AND      R0,R0,#0xFF
   \   000000D0   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    651                    pRxData += 1;
   \   000000D4   0x1C76             ADDS     R6,R6,#+1
   \   000000D6   0xE7BD             B.N      ??HAL_USART_TransmitReceive_5
    652                  }
    653                } 
    654                else
    655                {
    656                  /* Wait for TC flag in order to write data in DR */
    657                  if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, Timeout) != HAL_OK)
   \                     ??HAL_USART_TransmitReceive_7: (+1)
   \   000000D8   0x4643             MOV      R3,R8
   \   000000DA   0x2200             MOVS     R2,#+0
   \   000000DC   0x2180             MOVS     R1,#+128
   \   000000DE   0x0020             MOVS     R0,R4
   \   000000E0   0x.... 0x....      BL       USART_WaitOnFlagUntilTimeout
   \   000000E4   0x2800             CMP      R0,#+0
   \   000000E6   0xD001             BEQ.N    ??HAL_USART_TransmitReceive_13
    658                  {
    659                    return HAL_TIMEOUT;
   \   000000E8   0x2003             MOVS     R0,#+3
   \   000000EA   0xE025             B.N      ??HAL_USART_TransmitReceive_3
    660                  }
    661                  WRITE_REG(husart->Instance->DR, (*pTxData++ & (uint8_t)0x00FF));
   \                     ??HAL_USART_TransmitReceive_13: (+1)
   \   000000EC   0x7828             LDRB     R0,[R5, #+0]
   \   000000EE   0x6821             LDR      R1,[R4, #+0]
   \   000000F0   0x6048             STR      R0,[R1, #+4]
   \   000000F2   0x1C6D             ADDS     R5,R5,#+1
    662          
    663                  /* Wait for RXNE Flag */
    664                  if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \   000000F4   0x4643             MOV      R3,R8
   \   000000F6   0x2200             MOVS     R2,#+0
   \   000000F8   0x2120             MOVS     R1,#+32
   \   000000FA   0x0020             MOVS     R0,R4
   \   000000FC   0x.... 0x....      BL       USART_WaitOnFlagUntilTimeout
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xD001             BEQ.N    ??HAL_USART_TransmitReceive_14
    665                  {
    666                    return HAL_TIMEOUT;
   \   00000104   0x2003             MOVS     R0,#+3
   \   00000106   0xE017             B.N      ??HAL_USART_TransmitReceive_3
    667                  }
    668                  if(husart->Init.Parity == USART_PARITY_NONE)
   \                     ??HAL_USART_TransmitReceive_14: (+1)
   \   00000108   0x6920             LDR      R0,[R4, #+16]
   \   0000010A   0x2800             CMP      R0,#+0
   \   0000010C   0xD104             BNE.N    ??HAL_USART_TransmitReceive_15
    669                  {
    670                    /* Receive data */
    671                    *pRxData++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x00FF);
   \   0000010E   0x6820             LDR      R0,[R4, #+0]
   \   00000110   0x6840             LDR      R0,[R0, #+4]
   \   00000112   0x7030             STRB     R0,[R6, #+0]
   \   00000114   0x1C76             ADDS     R6,R6,#+1
   \   00000116   0xE79D             B.N      ??HAL_USART_TransmitReceive_5
    672                  }
    673                  else
    674                  {
    675                    /* Receive data */
    676                    *pRxData++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x007F);
   \                     ??HAL_USART_TransmitReceive_15: (+1)
   \   00000118   0x6820             LDR      R0,[R4, #+0]
   \   0000011A   0x6840             LDR      R0,[R0, #+4]
   \   0000011C   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   00000120   0x7030             STRB     R0,[R6, #+0]
   \   00000122   0x1C76             ADDS     R6,R6,#+1
   \   00000124   0xE796             B.N      ??HAL_USART_TransmitReceive_5
    677                  }
    678                }
    679              }
    680          
    681              husart->State = HAL_USART_STATE_READY;
   \                     ??HAL_USART_TransmitReceive_6: (+1)
   \   00000126   0x2001             MOVS     R0,#+1
   \   00000128   0xF884 0x003D      STRB     R0,[R4, #+61]
    682          
    683              /* Process Unlocked */
    684              __HAL_UNLOCK(husart);
   \   0000012C   0x2000             MOVS     R0,#+0
   \   0000012E   0xF884 0x003C      STRB     R0,[R4, #+60]
    685          
    686              return HAL_OK;
   \   00000132   0x2000             MOVS     R0,#+0
   \   00000134   0xE000             B.N      ??HAL_USART_TransmitReceive_3
    687            }
    688            else
    689            {
    690              return HAL_BUSY;
   \                     ??HAL_USART_TransmitReceive_0: (+1)
   \   00000136   0x2002             MOVS     R0,#+2
   \                     ??HAL_USART_TransmitReceive_3: (+1)
   \   00000138   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    691            }
    692          }
    693          
    694          /**
    695            * @brief  Simplex Send an amount of data in non-blocking mode. 
    696            * @param  husart: Pointer to a USART_HandleTypeDef structure that contains
    697            *                the configuration information for the specified USART module.
    698            * @param  pTxData: Pointer to data buffer
    699            * @param  Size: Amount of data to be sent
    700            * @retval HAL status
    701            * @note   The USART errors are not managed to avoid the overrun error.
    702            */

   \                                 In section .text, align 2, keep-with-next
    703          HAL_StatusTypeDef HAL_USART_Transmit_IT(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size)
    704          {
   \                     HAL_USART_Transmit_IT: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0003             MOVS     R3,R0
    705            if(husart->State == HAL_USART_STATE_READY)
   \   00000004   0xF893 0x003D      LDRB     R0,[R3, #+61]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD122             BNE.N    ??HAL_USART_Transmit_IT_0
    706            {
    707              if((pTxData == NULL) || (Size == 0)) 
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD002             BEQ.N    ??HAL_USART_Transmit_IT_1
   \   00000010   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xD101             BNE.N    ??HAL_USART_Transmit_IT_2
    708              {
    709                return HAL_ERROR;
   \                     ??HAL_USART_Transmit_IT_1: (+1)
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE01C             B.N      ??HAL_USART_Transmit_IT_3
    710              }
    711          
    712              /* Process Locked */
    713              __HAL_LOCK(husart);
   \                     ??HAL_USART_Transmit_IT_2: (+1)
   \   0000001A   0xF893 0x003C      LDRB     R0,[R3, #+60]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD101             BNE.N    ??HAL_USART_Transmit_IT_4
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xE016             B.N      ??HAL_USART_Transmit_IT_3
   \                     ??HAL_USART_Transmit_IT_4: (+1)
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xF883 0x003C      STRB     R0,[R3, #+60]
    714          
    715              husart->pTxBuffPtr = pTxData;
   \   0000002C   0x6259             STR      R1,[R3, #+36]
    716              husart->TxXferSize = Size;
   \   0000002E   0x851A             STRH     R2,[R3, #+40]
    717              husart->TxXferCount = Size;
   \   00000030   0x855A             STRH     R2,[R3, #+42]
    718          
    719              husart->ErrorCode = HAL_USART_ERROR_NONE;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x6418             STR      R0,[R3, #+64]
    720              husart->State = HAL_USART_STATE_BUSY_TX;
   \   00000036   0x2012             MOVS     R0,#+18
   \   00000038   0xF883 0x003D      STRB     R0,[R3, #+61]
    721          
    722              /* The USART Error Interrupts: (Frame error, Noise error, Overrun error) 
    723                 are not managed by the USART transmit process to avoid the overrun interrupt
    724                 when the USART mode is configured for transmit and receive "USART_MODE_TX_RX"
    725                 to benefit for the frame error and noise interrupts the USART mode should be
    726                 configured only for transmit "USART_MODE_TX"
    727                 The __HAL_USART_ENABLE_IT(husart, USART_IT_ERR) can be used to enable the Frame error,
    728                 Noise error interrupt */
    729          
    730              /* Process Unlocked */
    731              __HAL_UNLOCK(husart);
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xF883 0x003C      STRB     R0,[R3, #+60]
    732          
    733              /* Enable the USART Transmit Data Register Empty Interrupt */
    734              __HAL_USART_ENABLE_IT(husart, USART_IT_TXE);
   \   00000042   0x6818             LDR      R0,[R3, #+0]
   \   00000044   0x68C0             LDR      R0,[R0, #+12]
   \   00000046   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000004A   0x681C             LDR      R4,[R3, #+0]
   \   0000004C   0x60E0             STR      R0,[R4, #+12]
    735          
    736              return HAL_OK;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xE000             B.N      ??HAL_USART_Transmit_IT_3
    737            }
    738            else
    739            {
    740              return HAL_BUSY;
   \                     ??HAL_USART_Transmit_IT_0: (+1)
   \   00000052   0x2002             MOVS     R0,#+2
   \                     ??HAL_USART_Transmit_IT_3: (+1)
   \   00000054   0xBC10             POP      {R4}
   \   00000056   0x4770             BX       LR               ;; return
    741            }
    742          }
    743          
    744          /**
    745            * @brief  Simplex Receive an amount of data in non-blocking mode. 
    746            * @param  husart: Pointer to a USART_HandleTypeDef structure that contains
    747            *                 the configuration information for the specified USART module.
    748            * @param  pRxData: Pointer to data buffer
    749            * @param  Size: Amount of data to be received
    750            * @retval HAL status
    751            */

   \                                 In section .text, align 2, keep-with-next
    752          HAL_StatusTypeDef HAL_USART_Receive_IT(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size)
    753          {
   \                     HAL_USART_Receive_IT: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0003             MOVS     R3,R0
    754            if(husart->State == HAL_USART_STATE_READY)
   \   00000004   0xF893 0x003D      LDRB     R0,[R3, #+61]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD132             BNE.N    ??HAL_USART_Receive_IT_0
    755            {
    756              if((pRxData == NULL) || (Size == 0)) 
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD002             BEQ.N    ??HAL_USART_Receive_IT_1
   \   00000010   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xD101             BNE.N    ??HAL_USART_Receive_IT_2
    757              {
    758                return HAL_ERROR;
   \                     ??HAL_USART_Receive_IT_1: (+1)
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE02C             B.N      ??HAL_USART_Receive_IT_3
    759              }
    760              /* Process Locked */
    761              __HAL_LOCK(husart);
   \                     ??HAL_USART_Receive_IT_2: (+1)
   \   0000001A   0xF893 0x003C      LDRB     R0,[R3, #+60]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD101             BNE.N    ??HAL_USART_Receive_IT_4
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xE026             B.N      ??HAL_USART_Receive_IT_3
   \                     ??HAL_USART_Receive_IT_4: (+1)
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xF883 0x003C      STRB     R0,[R3, #+60]
    762          
    763              husart->pRxBuffPtr = pRxData;
   \   0000002C   0x62D9             STR      R1,[R3, #+44]
    764              husart->RxXferSize = Size;
   \   0000002E   0x861A             STRH     R2,[R3, #+48]
    765              husart->RxXferCount = Size;
   \   00000030   0x865A             STRH     R2,[R3, #+50]
    766          
    767              husart->ErrorCode = HAL_USART_ERROR_NONE;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x6418             STR      R0,[R3, #+64]
    768              husart->State = HAL_USART_STATE_BUSY_RX;
   \   00000036   0x2022             MOVS     R0,#+34
   \   00000038   0xF883 0x003D      STRB     R0,[R3, #+61]
    769          
    770              /* Process Unlocked */
    771              __HAL_UNLOCK(husart);
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xF883 0x003C      STRB     R0,[R3, #+60]
    772          
    773              /* Enable the USART Data Register not empty Interrupt */
    774              __HAL_USART_ENABLE_IT(husart, USART_IT_RXNE); 
   \   00000042   0x6818             LDR      R0,[R3, #+0]
   \   00000044   0x68C0             LDR      R0,[R0, #+12]
   \   00000046   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000004A   0x681C             LDR      R4,[R3, #+0]
   \   0000004C   0x60E0             STR      R0,[R4, #+12]
    775          
    776              /* Enable the USART Parity Error Interrupt */
    777              __HAL_USART_ENABLE_IT(husart, USART_IT_PE);
   \   0000004E   0x6818             LDR      R0,[R3, #+0]
   \   00000050   0x68C0             LDR      R0,[R0, #+12]
   \   00000052   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000056   0x681C             LDR      R4,[R3, #+0]
   \   00000058   0x60E0             STR      R0,[R4, #+12]
    778          
    779              /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
    780              __HAL_USART_ENABLE_IT(husart, USART_IT_ERR);
   \   0000005A   0x6818             LDR      R0,[R3, #+0]
   \   0000005C   0x6940             LDR      R0,[R0, #+20]
   \   0000005E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000062   0x681C             LDR      R4,[R3, #+0]
   \   00000064   0x6160             STR      R0,[R4, #+20]
    781          
    782              /* Send dummy byte in order to generate the clock for the slave to send data */
    783              WRITE_REG(husart->Instance->DR, (DUMMY_DATA & (uint16_t)0x01FF));    
   \   00000066   0xF240 0x10FF      MOVW     R0,#+511
   \   0000006A   0x681C             LDR      R4,[R3, #+0]
   \   0000006C   0x6060             STR      R0,[R4, #+4]
    784          
    785              return HAL_OK;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xE000             B.N      ??HAL_USART_Receive_IT_3
    786            }
    787            else
    788            {
    789              return HAL_BUSY;
   \                     ??HAL_USART_Receive_IT_0: (+1)
   \   00000072   0x2002             MOVS     R0,#+2
   \                     ??HAL_USART_Receive_IT_3: (+1)
   \   00000074   0xBC10             POP      {R4}
   \   00000076   0x4770             BX       LR               ;; return
    790            }
    791          }
    792          
    793          /**
    794            * @brief  Full-Duplex Send receive an amount of data in full-duplex mode (non-blocking). 
    795            * @param  husart: Pointer to a USART_HandleTypeDef structure that contains
    796            *                 the configuration information for the specified USART module.
    797            * @param  pTxData: Pointer to data transmitted buffer
    798            * @param  pRxData: Pointer to data received buffer 
    799            * @param  Size: Amount of data to be received
    800            * @retval HAL status
    801            */

   \                                 In section .text, align 2, keep-with-next
    802          HAL_StatusTypeDef HAL_USART_TransmitReceive_IT(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData,  uint16_t Size)
    803          {
   \                     HAL_USART_TransmitReceive_IT: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0004             MOVS     R4,R0
    804            if(husart->State == HAL_USART_STATE_READY)
   \   00000004   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD139             BNE.N    ??HAL_USART_TransmitReceive_IT_0
    805            {
    806              if((pTxData == NULL) || (pRxData == NULL) || (Size == 0)) 
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD004             BEQ.N    ??HAL_USART_TransmitReceive_IT_1
   \   00000010   0x2A00             CMP      R2,#+0
   \   00000012   0xD002             BEQ.N    ??HAL_USART_TransmitReceive_IT_1
   \   00000014   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000016   0x2B00             CMP      R3,#+0
   \   00000018   0xD101             BNE.N    ??HAL_USART_TransmitReceive_IT_2
    807              {
    808                return HAL_ERROR;
   \                     ??HAL_USART_TransmitReceive_IT_1: (+1)
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xE031             B.N      ??HAL_USART_TransmitReceive_IT_3
    809              }
    810              /* Process Locked */
    811              __HAL_LOCK(husart);
   \                     ??HAL_USART_TransmitReceive_IT_2: (+1)
   \   0000001E   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD101             BNE.N    ??HAL_USART_TransmitReceive_IT_4
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0xE02B             B.N      ??HAL_USART_TransmitReceive_IT_3
   \                     ??HAL_USART_TransmitReceive_IT_4: (+1)
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xF884 0x003C      STRB     R0,[R4, #+60]
    812          
    813              husart->pRxBuffPtr = pRxData;
   \   00000030   0x62E2             STR      R2,[R4, #+44]
    814              husart->RxXferSize = Size;
   \   00000032   0x8623             STRH     R3,[R4, #+48]
    815              husart->RxXferCount = Size;
   \   00000034   0x8663             STRH     R3,[R4, #+50]
    816              husart->pTxBuffPtr = pTxData;
   \   00000036   0x6261             STR      R1,[R4, #+36]
    817              husart->TxXferSize = Size;
   \   00000038   0x8523             STRH     R3,[R4, #+40]
    818              husart->TxXferCount = Size;
   \   0000003A   0x8563             STRH     R3,[R4, #+42]
    819          
    820              husart->ErrorCode = HAL_USART_ERROR_NONE;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x6420             STR      R0,[R4, #+64]
    821              husart->State = HAL_USART_STATE_BUSY_TX_RX;
   \   00000040   0x2032             MOVS     R0,#+50
   \   00000042   0xF884 0x003D      STRB     R0,[R4, #+61]
    822          
    823              /* Process Unlocked */
    824              __HAL_UNLOCK(husart);
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xF884 0x003C      STRB     R0,[R4, #+60]
    825          
    826              /* Enable the USART Data Register not empty Interrupt */
    827              __HAL_USART_ENABLE_IT(husart, USART_IT_RXNE); 
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x68C0             LDR      R0,[R0, #+12]
   \   00000050   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000054   0x6825             LDR      R5,[R4, #+0]
   \   00000056   0x60E8             STR      R0,[R5, #+12]
    828          
    829              /* Enable the USART Parity Error Interrupt */
    830              __HAL_USART_ENABLE_IT(husart, USART_IT_PE);
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x68C0             LDR      R0,[R0, #+12]
   \   0000005C   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000060   0x6825             LDR      R5,[R4, #+0]
   \   00000062   0x60E8             STR      R0,[R5, #+12]
    831          
    832              /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
    833              __HAL_USART_ENABLE_IT(husart, USART_IT_ERR);
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x6940             LDR      R0,[R0, #+20]
   \   00000068   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000006C   0x6825             LDR      R5,[R4, #+0]
   \   0000006E   0x6168             STR      R0,[R5, #+20]
    834          
    835              /* Enable the USART Transmit Data Register Empty Interrupt */
    836              __HAL_USART_ENABLE_IT(husart, USART_IT_TXE);
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x68C0             LDR      R0,[R0, #+12]
   \   00000074   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000078   0x6825             LDR      R5,[R4, #+0]
   \   0000007A   0x60E8             STR      R0,[R5, #+12]
    837          
    838              return HAL_OK;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xE000             B.N      ??HAL_USART_TransmitReceive_IT_3
    839            }
    840            else
    841            {
    842              return HAL_BUSY; 
   \                     ??HAL_USART_TransmitReceive_IT_0: (+1)
   \   00000080   0x2002             MOVS     R0,#+2
   \                     ??HAL_USART_TransmitReceive_IT_3: (+1)
   \   00000082   0xBC30             POP      {R4,R5}
   \   00000084   0x4770             BX       LR               ;; return
    843            }
    844          }
    845          
    846          /**
    847            * @brief  Simplex Send an amount of data in non-blocking mode. 
    848            * @param  husart: Pointer to a USART_HandleTypeDef structure that contains
    849            *                 the configuration information for the specified USART module.
    850            * @param  pTxData: Pointer to data buffer
    851            * @param  Size: Amount of data to be sent
    852            * @retval HAL status
    853            */

   \                                 In section .text, align 2, keep-with-next
    854          HAL_StatusTypeDef HAL_USART_Transmit_DMA(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size)
    855          {
   \                     HAL_USART_Transmit_DMA: (+1)
   \   00000000   0xB573             PUSH     {R0,R1,R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0015             MOVS     R5,R2
    856            uint32_t *tmp=0;
   \   00000006   0x2600             MOVS     R6,#+0
    857            
    858            if(husart->State == HAL_USART_STATE_READY)
   \   00000008   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD13E             BNE.N    ??HAL_USART_Transmit_DMA_0
    859            {
    860              if((pTxData == NULL) || (Size == 0)) 
   \   00000010   0x9801             LDR      R0,[SP, #+4]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD002             BEQ.N    ??HAL_USART_Transmit_DMA_1
   \   00000016   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD101             BNE.N    ??HAL_USART_Transmit_DMA_2
    861              {
    862                return HAL_ERROR;
   \                     ??HAL_USART_Transmit_DMA_1: (+1)
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xE037             B.N      ??HAL_USART_Transmit_DMA_3
    863              }
    864              /* Process Locked */
    865              __HAL_LOCK(husart);  
   \                     ??HAL_USART_Transmit_DMA_2: (+1)
   \   00000020   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD101             BNE.N    ??HAL_USART_Transmit_DMA_4
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xE031             B.N      ??HAL_USART_Transmit_DMA_3
   \                     ??HAL_USART_Transmit_DMA_4: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF884 0x003C      STRB     R0,[R4, #+60]
    866          
    867              husart->pTxBuffPtr = pTxData;
   \   00000032   0x9801             LDR      R0,[SP, #+4]
   \   00000034   0x6260             STR      R0,[R4, #+36]
    868              husart->TxXferSize = Size;
   \   00000036   0x8525             STRH     R5,[R4, #+40]
    869              husart->TxXferCount = Size;
   \   00000038   0x8565             STRH     R5,[R4, #+42]
    870          
    871              husart->ErrorCode = HAL_USART_ERROR_NONE;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x6420             STR      R0,[R4, #+64]
    872              husart->State = HAL_USART_STATE_BUSY_TX;
   \   0000003E   0x2012             MOVS     R0,#+18
   \   00000040   0xF884 0x003D      STRB     R0,[R4, #+61]
    873          
    874              /* Set the USART DMA transfer complete callback */
    875              husart->hdmatx->XferCpltCallback = USART_DMATransmitCplt;
   \   00000044   0x.... 0x....      ADR.W    R0,USART_DMATransmitCplt
   \   00000048   0x6B61             LDR      R1,[R4, #+52]
   \   0000004A   0x6288             STR      R0,[R1, #+40]
    876          
    877              /* Set the USART DMA Half transfer complete callback */
    878              husart->hdmatx->XferHalfCpltCallback = USART_DMATxHalfCplt;
   \   0000004C   0x.... 0x....      ADR.W    R0,USART_DMATxHalfCplt
   \   00000050   0x6B61             LDR      R1,[R4, #+52]
   \   00000052   0x62C8             STR      R0,[R1, #+44]
    879          
    880              /* Set the DMA error callback */
    881              husart->hdmatx->XferErrorCallback = USART_DMAError;
   \   00000054   0x.... 0x....      ADR.W    R0,USART_DMAError
   \   00000058   0x6B61             LDR      R1,[R4, #+52]
   \   0000005A   0x6308             STR      R0,[R1, #+48]
    882          
    883              /* Enable the USART transmit DMA channel */
    884              tmp = (uint32_t*)&pTxData;
   \   0000005C   0xA801             ADD      R0,SP,#+4
   \   0000005E   0x0006             MOVS     R6,R0
    885              HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t*)tmp, (uint32_t)&husart->Instance->DR, Size);
   \   00000060   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000062   0x002B             MOVS     R3,R5
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x1D02             ADDS     R2,R0,#+4
   \   00000068   0x6831             LDR      R1,[R6, #+0]
   \   0000006A   0x6B60             LDR      R0,[R4, #+52]
   \   0000006C   0x.... 0x....      BL       HAL_DMA_Start_IT
    886          
    887              /* Clear the TC flag in the SR register by writing 0 to it */
    888              __HAL_USART_CLEAR_FLAG(husart, USART_FLAG_TC);
   \   00000070   0xF07F 0x0040      MVNS     R0,#+64
   \   00000074   0x6821             LDR      R1,[R4, #+0]
   \   00000076   0x6008             STR      R0,[R1, #+0]
    889          
    890              /* Enable the DMA transfer for transmit request by setting the DMAT bit
    891                 in the USART CR3 register */
    892              SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0x6940             LDR      R0,[R0, #+20]
   \   0000007C   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000080   0x6821             LDR      R1,[R4, #+0]
   \   00000082   0x6148             STR      R0,[R1, #+20]
    893          
    894              /* Process Unlocked */
    895              __HAL_UNLOCK(husart);
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0xF884 0x003C      STRB     R0,[R4, #+60]
    896          
    897              return HAL_OK;
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0xE000             B.N      ??HAL_USART_Transmit_DMA_3
    898            }
    899            else
    900            {
    901              return HAL_BUSY;
   \                     ??HAL_USART_Transmit_DMA_0: (+1)
   \   0000008E   0x2002             MOVS     R0,#+2
   \                     ??HAL_USART_Transmit_DMA_3: (+1)
   \   00000090   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    902            }
    903          }
    904          
    905          /**
    906            * @brief  Full-Duplex Receive an amount of data in non-blocking mode. 
    907            * @param  husart: Pointer to a USART_HandleTypeDef structure that contains
    908            *                 the configuration information for the specified USART module.
    909            * @param  pRxData: Pointer to data buffer
    910            * @param  Size: Amount of data to be received
    911            * @retval HAL status
    912            * @note   The USART DMA transmit channel must be configured in order to generate the clock for the slave.
    913            * @note   When the USART parity is enabled (PCE = 1) the data received contain the parity bit.
    914            */

   \                                 In section .text, align 2, keep-with-next
    915          HAL_StatusTypeDef HAL_USART_Receive_DMA(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size)
    916          {
   \                     HAL_USART_Receive_DMA: (+1)
   \   00000000   0xB573             PUSH     {R0,R1,R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0015             MOVS     R5,R2
    917            uint32_t *tmp=0;
   \   00000006   0x2600             MOVS     R6,#+0
    918            
    919            if(husart->State == HAL_USART_STATE_READY)
   \   00000008   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD151             BNE.N    ??HAL_USART_Receive_DMA_0
    920            {
    921              if((pRxData == NULL) || (Size == 0)) 
   \   00000010   0x9801             LDR      R0,[SP, #+4]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD002             BEQ.N    ??HAL_USART_Receive_DMA_1
   \   00000016   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD101             BNE.N    ??HAL_USART_Receive_DMA_2
    922              {
    923                return HAL_ERROR;
   \                     ??HAL_USART_Receive_DMA_1: (+1)
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xE04A             B.N      ??HAL_USART_Receive_DMA_3
    924              }
    925          
    926              /* Process Locked */
    927              __HAL_LOCK(husart);
   \                     ??HAL_USART_Receive_DMA_2: (+1)
   \   00000020   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD101             BNE.N    ??HAL_USART_Receive_DMA_4
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xE044             B.N      ??HAL_USART_Receive_DMA_3
   \                     ??HAL_USART_Receive_DMA_4: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF884 0x003C      STRB     R0,[R4, #+60]
    928          
    929              husart->pRxBuffPtr = pRxData;
   \   00000032   0x9801             LDR      R0,[SP, #+4]
   \   00000034   0x62E0             STR      R0,[R4, #+44]
    930              husart->RxXferSize = Size;
   \   00000036   0x8625             STRH     R5,[R4, #+48]
    931              husart->pTxBuffPtr = pRxData;
   \   00000038   0x9801             LDR      R0,[SP, #+4]
   \   0000003A   0x6260             STR      R0,[R4, #+36]
    932              husart->TxXferSize = Size;
   \   0000003C   0x8525             STRH     R5,[R4, #+40]
    933          
    934              husart->ErrorCode = HAL_USART_ERROR_NONE;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x6420             STR      R0,[R4, #+64]
    935              husart->State = HAL_USART_STATE_BUSY_RX;
   \   00000042   0x2022             MOVS     R0,#+34
   \   00000044   0xF884 0x003D      STRB     R0,[R4, #+61]
    936          
    937              /* Set the USART DMA Rx transfer complete callback */
    938              husart->hdmarx->XferCpltCallback = USART_DMAReceiveCplt;
   \   00000048   0x.... 0x....      ADR.W    R0,USART_DMAReceiveCplt
   \   0000004C   0x6BA1             LDR      R1,[R4, #+56]
   \   0000004E   0x6288             STR      R0,[R1, #+40]
    939          
    940              /* Set the USART DMA Half transfer complete callback */
    941              husart->hdmarx->XferHalfCpltCallback = USART_DMARxHalfCplt;
   \   00000050   0x.... 0x....      ADR.W    R0,USART_DMARxHalfCplt
   \   00000054   0x6BA1             LDR      R1,[R4, #+56]
   \   00000056   0x62C8             STR      R0,[R1, #+44]
    942          
    943              /* Set the USART DMA Rx transfer error callback */
    944              husart->hdmarx->XferErrorCallback = USART_DMAError;
   \   00000058   0x.... 0x....      ADR.W    R0,USART_DMAError
   \   0000005C   0x6BA1             LDR      R1,[R4, #+56]
   \   0000005E   0x6308             STR      R0,[R1, #+48]
    945          
    946              /* Enable the USART receive DMA channel */
    947              tmp = (uint32_t*)&pRxData;
   \   00000060   0xA801             ADD      R0,SP,#+4
   \   00000062   0x0006             MOVS     R6,R0
    948              HAL_DMA_Start_IT(husart->hdmarx, (uint32_t)&husart->Instance->DR, *(uint32_t*)tmp, Size);
   \   00000064   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000066   0x002B             MOVS     R3,R5
   \   00000068   0x6832             LDR      R2,[R6, #+0]
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x1D01             ADDS     R1,R0,#+4
   \   0000006E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000070   0x.... 0x....      BL       HAL_DMA_Start_IT
    949          
    950              /* Enable the USART transmit DMA channel: the transmit channel is used in order
    951                 to generate in the non-blocking mode the clock to the slave device, 
    952                 this mode isn't a simplex receive mode but a full-duplex receive one */
    953              HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t*)tmp, (uint32_t)&husart->Instance->DR, Size);
   \   00000074   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000076   0x002B             MOVS     R3,R5
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0x1D02             ADDS     R2,R0,#+4
   \   0000007C   0x6831             LDR      R1,[R6, #+0]
   \   0000007E   0x6B60             LDR      R0,[R4, #+52]
   \   00000080   0x.... 0x....      BL       HAL_DMA_Start_IT
    954          
    955              /* Clear the Overrun flag just before enabling the DMA Rx request: mandatory for the second transfer
    956                 when using the USART in circular mode */
    957              __HAL_USART_CLEAR_OREFLAG(husart);
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0x9000             STR      R0,[SP, #+0]
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x6840             LDR      R0,[R0, #+4]
   \   0000008E   0x9000             STR      R0,[SP, #+0]
   \   00000090   0x9800             LDR      R0,[SP, #+0]
    958              
    959              /* Enable the DMA transfer for the receiver request by setting the DMAR bit 
    960                 in the USART CR3 register */
    961              SET_BIT(husart->Instance->CR3, USART_CR3_DMAR);
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x6940             LDR      R0,[R0, #+20]
   \   00000096   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000009A   0x6821             LDR      R1,[R4, #+0]
   \   0000009C   0x6148             STR      R0,[R1, #+20]
    962          
    963              /* Enable the DMA transfer for transmit request by setting the DMAT bit
    964                 in the USART CR3 register */
    965              SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x6940             LDR      R0,[R0, #+20]
   \   000000A2   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000A6   0x6821             LDR      R1,[R4, #+0]
   \   000000A8   0x6148             STR      R0,[R1, #+20]
    966          
    967              /* Process Unlocked */
    968              __HAL_UNLOCK(husart);
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0xF884 0x003C      STRB     R0,[R4, #+60]
    969          
    970              return HAL_OK;
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0xE000             B.N      ??HAL_USART_Receive_DMA_3
    971            }
    972            else
    973            {
    974              return HAL_BUSY;
   \                     ??HAL_USART_Receive_DMA_0: (+1)
   \   000000B4   0x2002             MOVS     R0,#+2
   \                     ??HAL_USART_Receive_DMA_3: (+1)
   \   000000B6   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    975            }
    976          }
    977          
    978          /**
    979            * @brief  Full-Duplex Transmit Receive an amount of data in non-blocking mode. 
    980            * @param  husart: Pointer to a USART_HandleTypeDef structure that contains
    981            *                 the configuration information for the specified USART module.
    982            * @param  pTxData: Pointer to data transmitted buffer
    983            * @param  pRxData: Pointer to data received buffer 
    984            * @param  Size: Amount of data to be received
    985            * @note   When the USART parity is enabled (PCE = 1) the data received contain the parity bit.
    986            * @retval HAL status
    987            */

   \                                 In section .text, align 2, keep-with-next
    988          HAL_StatusTypeDef HAL_USART_TransmitReceive_DMA(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
    989          {
   \                     HAL_USART_TransmitReceive_DMA: (+1)
   \   00000000   0xB576             PUSH     {R1,R2,R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x001D             MOVS     R5,R3
    990            uint32_t *tmp=0;
   \   00000008   0x2600             MOVS     R6,#+0
    991            
    992            if(husart->State == HAL_USART_STATE_READY)
   \   0000000A   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD166             BNE.N    ??HAL_USART_TransmitReceive_DMA_0
    993            {
    994              if((pTxData == NULL) || (pRxData == NULL) || (Size == 0)) 
   \   00000012   0x9802             LDR      R0,[SP, #+8]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD005             BEQ.N    ??HAL_USART_TransmitReceive_DMA_1
   \   00000018   0x9803             LDR      R0,[SP, #+12]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD002             BEQ.N    ??HAL_USART_TransmitReceive_DMA_1
   \   0000001E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD101             BNE.N    ??HAL_USART_TransmitReceive_DMA_2
    995              {
    996                return HAL_ERROR;
   \                     ??HAL_USART_TransmitReceive_DMA_1: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xE05C             B.N      ??HAL_USART_TransmitReceive_DMA_3
    997              }
    998              /* Process Locked */
    999              __HAL_LOCK(husart);
   \                     ??HAL_USART_TransmitReceive_DMA_2: (+1)
   \   00000028   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xD101             BNE.N    ??HAL_USART_TransmitReceive_DMA_4
   \   00000030   0x2002             MOVS     R0,#+2
   \   00000032   0xE056             B.N      ??HAL_USART_TransmitReceive_DMA_3
   \                     ??HAL_USART_TransmitReceive_DMA_4: (+1)
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xF884 0x003C      STRB     R0,[R4, #+60]
   1000          
   1001              husart->pRxBuffPtr = pRxData;
   \   0000003A   0x9803             LDR      R0,[SP, #+12]
   \   0000003C   0x62E0             STR      R0,[R4, #+44]
   1002              husart->RxXferSize = Size;
   \   0000003E   0x8625             STRH     R5,[R4, #+48]
   1003              husart->pTxBuffPtr = pTxData;
   \   00000040   0x9802             LDR      R0,[SP, #+8]
   \   00000042   0x6260             STR      R0,[R4, #+36]
   1004              husart->TxXferSize = Size;
   \   00000044   0x8525             STRH     R5,[R4, #+40]
   1005          
   1006              husart->ErrorCode = HAL_USART_ERROR_NONE;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x6420             STR      R0,[R4, #+64]
   1007              husart->State = HAL_USART_STATE_BUSY_TX_RX;
   \   0000004A   0x2032             MOVS     R0,#+50
   \   0000004C   0xF884 0x003D      STRB     R0,[R4, #+61]
   1008          
   1009              /* Set the USART DMA Rx transfer complete callback */
   1010              husart->hdmarx->XferCpltCallback = USART_DMAReceiveCplt;
   \   00000050   0x.... 0x....      ADR.W    R0,USART_DMAReceiveCplt
   \   00000054   0x6BA1             LDR      R1,[R4, #+56]
   \   00000056   0x6288             STR      R0,[R1, #+40]
   1011          
   1012              /* Set the USART DMA Half transfer complete callback */
   1013              husart->hdmarx->XferHalfCpltCallback = USART_DMARxHalfCplt;
   \   00000058   0x.... 0x....      ADR.W    R0,USART_DMARxHalfCplt
   \   0000005C   0x6BA1             LDR      R1,[R4, #+56]
   \   0000005E   0x62C8             STR      R0,[R1, #+44]
   1014          
   1015              /* Set the USART DMA Tx transfer complete callback */
   1016              husart->hdmatx->XferCpltCallback = USART_DMATransmitCplt;
   \   00000060   0x.... 0x....      ADR.W    R0,USART_DMATransmitCplt
   \   00000064   0x6B61             LDR      R1,[R4, #+52]
   \   00000066   0x6288             STR      R0,[R1, #+40]
   1017          
   1018              /* Set the USART DMA Half transfer complete callback */
   1019              husart->hdmatx->XferHalfCpltCallback = USART_DMATxHalfCplt;
   \   00000068   0x.... 0x....      ADR.W    R0,USART_DMATxHalfCplt
   \   0000006C   0x6B61             LDR      R1,[R4, #+52]
   \   0000006E   0x62C8             STR      R0,[R1, #+44]
   1020          
   1021              /* Set the USART DMA Tx transfer error callback */
   1022              husart->hdmatx->XferErrorCallback = USART_DMAError;
   \   00000070   0x.... 0x....      ADR.W    R0,USART_DMAError
   \   00000074   0x6B61             LDR      R1,[R4, #+52]
   \   00000076   0x6308             STR      R0,[R1, #+48]
   1023          
   1024              /* Set the USART DMA Rx transfer error callback */
   1025              husart->hdmarx->XferErrorCallback = USART_DMAError;
   \   00000078   0x.... 0x....      ADR.W    R0,USART_DMAError
   \   0000007C   0x6BA1             LDR      R1,[R4, #+56]
   \   0000007E   0x6308             STR      R0,[R1, #+48]
   1026          
   1027              /* Enable the USART receive DMA channel */
   1028              tmp = (uint32_t*)&pRxData;
   \   00000080   0xA803             ADD      R0,SP,#+12
   \   00000082   0x0006             MOVS     R6,R0
   1029              HAL_DMA_Start_IT(husart->hdmarx, (uint32_t)&husart->Instance->DR, *(uint32_t*)tmp, Size);
   \   00000084   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000086   0x002B             MOVS     R3,R5
   \   00000088   0x6832             LDR      R2,[R6, #+0]
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x1D01             ADDS     R1,R0,#+4
   \   0000008E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000090   0x.... 0x....      BL       HAL_DMA_Start_IT
   1030          
   1031              /* Enable the USART transmit DMA channel */
   1032              tmp = (uint32_t*)&pTxData;
   \   00000094   0xA802             ADD      R0,SP,#+8
   \   00000096   0x0006             MOVS     R6,R0
   1033              HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t*)tmp, (uint32_t)&husart->Instance->DR, Size);
   \   00000098   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000009A   0x002B             MOVS     R3,R5
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0x1D02             ADDS     R2,R0,#+4
   \   000000A0   0x6831             LDR      R1,[R6, #+0]
   \   000000A2   0x6B60             LDR      R0,[R4, #+52]
   \   000000A4   0x.... 0x....      BL       HAL_DMA_Start_IT
   1034              
   1035              /* Clear the TC flag in the SR register by writing 0 to it */
   1036              __HAL_USART_CLEAR_FLAG(husart, USART_FLAG_TC);
   \   000000A8   0xF07F 0x0040      MVNS     R0,#+64
   \   000000AC   0x6821             LDR      R1,[R4, #+0]
   \   000000AE   0x6008             STR      R0,[R1, #+0]
   1037          
   1038              /* Clear the Overrun flag: mandatory for the second transfer in circular mode */
   1039              __HAL_USART_CLEAR_OREFLAG(husart);
   \   000000B0   0x6820             LDR      R0,[R4, #+0]
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0x9000             STR      R0,[SP, #+0]
   \   000000B6   0x6820             LDR      R0,[R4, #+0]
   \   000000B8   0x6840             LDR      R0,[R0, #+4]
   \   000000BA   0x9000             STR      R0,[SP, #+0]
   \   000000BC   0x9800             LDR      R0,[SP, #+0]
   1040              
   1041              /* Enable the DMA transfer for the receiver request by setting the DMAR bit 
   1042                 in the USART CR3 register */
   1043              SET_BIT(husart->Instance->CR3, USART_CR3_DMAR);
   \   000000BE   0x6820             LDR      R0,[R4, #+0]
   \   000000C0   0x6940             LDR      R0,[R0, #+20]
   \   000000C2   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   000000C6   0x6821             LDR      R1,[R4, #+0]
   \   000000C8   0x6148             STR      R0,[R1, #+20]
   1044          
   1045              /* Enable the DMA transfer for transmit request by setting the DMAT bit
   1046                 in the USART CR3 register */
   1047              SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
   \   000000CA   0x6820             LDR      R0,[R4, #+0]
   \   000000CC   0x6940             LDR      R0,[R0, #+20]
   \   000000CE   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000D2   0x6821             LDR      R1,[R4, #+0]
   \   000000D4   0x6148             STR      R0,[R1, #+20]
   1048          
   1049              /* Process Unlocked */
   1050              __HAL_UNLOCK(husart);
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0xF884 0x003C      STRB     R0,[R4, #+60]
   1051          
   1052              return HAL_OK;
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0xE000             B.N      ??HAL_USART_TransmitReceive_DMA_3
   1053            }
   1054            else
   1055            {
   1056              return HAL_BUSY;
   \                     ??HAL_USART_TransmitReceive_DMA_0: (+1)
   \   000000E0   0x2002             MOVS     R0,#+2
   \                     ??HAL_USART_TransmitReceive_DMA_3: (+1)
   \   000000E2   0xB004             ADD      SP,SP,#+16
   \   000000E4   0xBD70             POP      {R4-R6,PC}       ;; return
   1057            }
   1058          }
   1059          
   1060          /**
   1061            * @brief Pauses the DMA Transfer.
   1062            * @param  husart: Pointer to a USART_HandleTypeDef structure that contains
   1063            *                 the configuration information for the specified USART module.
   1064            * @retval HAL status
   1065            */

   \                                 In section .text, align 2, keep-with-next
   1066          HAL_StatusTypeDef HAL_USART_DMAPause(USART_HandleTypeDef *husart)
   1067          {
   \                     HAL_USART_DMAPause: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1068            /* Process Locked */
   1069            __HAL_LOCK(husart);
   \   00000002   0xF891 0x003C      LDRB     R0,[R1, #+60]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_USART_DMAPause_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE00C             B.N      ??HAL_USART_DMAPause_1
   \                     ??HAL_USART_DMAPause_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x003C      STRB     R0,[R1, #+60]
   1070            
   1071            /* Disable the USART DMA Tx request */
   1072            CLEAR_BIT(husart->Instance->CR3, (uint32_t)(USART_CR3_DMAT));
   \   00000014   0x6808             LDR      R0,[R1, #+0]
   \   00000016   0x6940             LDR      R0,[R0, #+20]
   \   00000018   0xF030 0x0080      BICS     R0,R0,#0x80
   \   0000001C   0x680A             LDR      R2,[R1, #+0]
   \   0000001E   0x6150             STR      R0,[R2, #+20]
   1073            
   1074            /* Process Unlocked */
   1075            __HAL_UNLOCK(husart);
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xF881 0x003C      STRB     R0,[R1, #+60]
   1076          
   1077            return HAL_OK; 
   \   00000026   0x2000             MOVS     R0,#+0
   \                     ??HAL_USART_DMAPause_1: (+1)
   \   00000028   0x4770             BX       LR               ;; return
   1078          }
   1079          
   1080          /**
   1081            * @brief Resumes the DMA Transfer.
   1082            * @param  husart: Pointer to a USART_HandleTypeDef structure that contains
   1083            *                 the configuration information for the specified USART module.
   1084            * @retval HAL status
   1085            */

   \                                 In section .text, align 2, keep-with-next
   1086          HAL_StatusTypeDef HAL_USART_DMAResume(USART_HandleTypeDef *husart)
   1087          {
   \                     HAL_USART_DMAResume: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1088            /* Process Locked */
   1089            __HAL_LOCK(husart);
   \   00000002   0xF891 0x003C      LDRB     R0,[R1, #+60]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_USART_DMAResume_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE00C             B.N      ??HAL_USART_DMAResume_1
   \                     ??HAL_USART_DMAResume_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x003C      STRB     R0,[R1, #+60]
   1090            
   1091            /* Enable the USART DMA Tx request */
   1092            SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
   \   00000014   0x6808             LDR      R0,[R1, #+0]
   \   00000016   0x6940             LDR      R0,[R0, #+20]
   \   00000018   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000001C   0x680A             LDR      R2,[R1, #+0]
   \   0000001E   0x6150             STR      R0,[R2, #+20]
   1093            
   1094            /* Process Unlocked */
   1095            __HAL_UNLOCK(husart);
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xF881 0x003C      STRB     R0,[R1, #+60]
   1096          
   1097            return HAL_OK;
   \   00000026   0x2000             MOVS     R0,#+0
   \                     ??HAL_USART_DMAResume_1: (+1)
   \   00000028   0x4770             BX       LR               ;; return
   1098          }
   1099          
   1100          /**
   1101            * @brief Stops the DMA Transfer.
   1102            * @param  husart: Pointer to a USART_HandleTypeDef structure that contains
   1103            *                 the configuration information for the specified USART module.
   1104            * @retval HAL status
   1105            */

   \                                 In section .text, align 2, keep-with-next
   1106          HAL_StatusTypeDef HAL_USART_DMAStop(USART_HandleTypeDef *husart)
   1107          {
   \                     HAL_USART_DMAStop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1108            /* The Lock is not implemented on this API to allow the user application
   1109               to call the HAL USART API under callbacks HAL_USART_TxCpltCallback() / HAL_USART_RxCpltCallback():
   1110               when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
   1111               and the correspond call back is executed HAL_USART_TxCpltCallback() / HAL_USART_RxCpltCallback()
   1112               */
   1113          
   1114            /* Abort the USART DMA Tx channel */
   1115            if(husart->hdmatx != NULL)
   \   00000004   0x6B60             LDR      R0,[R4, #+52]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD002             BEQ.N    ??HAL_USART_DMAStop_0
   1116            {
   1117              HAL_DMA_Abort(husart->hdmatx);
   \   0000000A   0x6B60             LDR      R0,[R4, #+52]
   \   0000000C   0x.... 0x....      BL       HAL_DMA_Abort
   1118            }
   1119            /* Abort the USART DMA Rx channel */
   1120            if(husart->hdmarx != NULL)
   \                     ??HAL_USART_DMAStop_0: (+1)
   \   00000010   0x6BA0             LDR      R0,[R4, #+56]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD002             BEQ.N    ??HAL_USART_DMAStop_1
   1121            {  
   1122              HAL_DMA_Abort(husart->hdmarx);
   \   00000016   0x6BA0             LDR      R0,[R4, #+56]
   \   00000018   0x.... 0x....      BL       HAL_DMA_Abort
   1123            }
   1124            
   1125            /* Disable the USART Tx/Rx DMA requests */
   1126            CLEAR_BIT(husart->Instance->CR3, (USART_CR3_DMAT | USART_CR3_DMAR));
   \                     ??HAL_USART_DMAStop_1: (+1)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6940             LDR      R0,[R0, #+20]
   \   00000020   0xF030 0x00C0      BICS     R0,R0,#0xC0
   \   00000024   0x6821             LDR      R1,[R4, #+0]
   \   00000026   0x6148             STR      R0,[R1, #+20]
   1127          
   1128            husart->State = HAL_USART_STATE_READY;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xF884 0x003D      STRB     R0,[R4, #+61]
   1129          
   1130            return HAL_OK;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
   1131          }
   1132          
   1133          /**
   1134            * @brief  This function handles USART interrupt request.
   1135            * @param  husart: Pointer to a USART_HandleTypeDef structure that contains
   1136            *                 the configuration information for the specified USART module.
   1137            * @retval None
   1138            */

   \                                 In section .text, align 2, keep-with-next
   1139          void HAL_USART_IRQHandler(USART_HandleTypeDef *husart)
   1140          {
   \                     HAL_USART_IRQHandler: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   1141            uint32_t tmp_flag = 0, tmp_it_source = 0;
   \   00000006   0x2500             MOVS     R5,#+0
   \   00000008   0x2600             MOVS     R6,#+0
   1142            
   1143            tmp_flag = __HAL_USART_GET_FLAG(husart, USART_FLAG_PE);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000012   0x0005             MOVS     R5,R0
   1144            tmp_it_source = __HAL_USART_GET_IT_SOURCE(husart, USART_IT_PE);
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x68C0             LDR      R0,[R0, #+12]
   \   00000018   0xF410 0x7080      ANDS     R0,R0,#0x100
   \   0000001C   0x0006             MOVS     R6,R0
   1145            /* USART parity error interrupt occurred -----------------------------------*/
   1146            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD00C             BEQ.N    ??HAL_USART_IRQHandler_0
   \   00000022   0x2E00             CMP      R6,#+0
   \   00000024   0xD00A             BEQ.N    ??HAL_USART_IRQHandler_0
   1147            {
   1148              __HAL_USART_CLEAR_PEFLAG(husart);
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x9000             STR      R0,[SP, #+0]
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x6840             LDR      R0,[R0, #+4]
   \   00000030   0x9000             STR      R0,[SP, #+0]
   \   00000032   0x9800             LDR      R0,[SP, #+0]
   1149              husart->ErrorCode |= HAL_USART_ERROR_PE;
   \   00000034   0x6C20             LDR      R0,[R4, #+64]
   \   00000036   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000003A   0x6420             STR      R0,[R4, #+64]
   1150            }
   1151          
   1152            tmp_flag = __HAL_USART_GET_FLAG(husart, USART_FLAG_FE);
   \                     ??HAL_USART_IRQHandler_0: (+1)
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x0840             LSRS     R0,R0,#+1
   \   00000042   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000046   0x0005             MOVS     R5,R0
   1153            tmp_it_source = __HAL_USART_GET_IT_SOURCE(husart, USART_IT_ERR);
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x6940             LDR      R0,[R0, #+20]
   \   0000004C   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000050   0x0006             MOVS     R6,R0
   1154            /* USART frame error interrupt occurred ------------------------------------*/
   1155            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   00000052   0x2D00             CMP      R5,#+0
   \   00000054   0xD00C             BEQ.N    ??HAL_USART_IRQHandler_1
   \   00000056   0x2E00             CMP      R6,#+0
   \   00000058   0xD00A             BEQ.N    ??HAL_USART_IRQHandler_1
   1156            {
   1157              __HAL_USART_CLEAR_FEFLAG(husart);
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x9000             STR      R0,[SP, #+0]
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x6840             LDR      R0,[R0, #+4]
   \   00000064   0x9000             STR      R0,[SP, #+0]
   \   00000066   0x9800             LDR      R0,[SP, #+0]
   1158              husart->ErrorCode |= HAL_USART_ERROR_FE;
   \   00000068   0x6C20             LDR      R0,[R4, #+64]
   \   0000006A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000006E   0x6420             STR      R0,[R4, #+64]
   1159            }
   1160          
   1161            tmp_flag = __HAL_USART_GET_FLAG(husart, USART_FLAG_NE);
   \                     ??HAL_USART_IRQHandler_1: (+1)
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x0880             LSRS     R0,R0,#+2
   \   00000076   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000007A   0x0005             MOVS     R5,R0
   1162            /* USART noise error interrupt occurred ------------------------------------*/
   1163            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   0000007C   0x2D00             CMP      R5,#+0
   \   0000007E   0xD00C             BEQ.N    ??HAL_USART_IRQHandler_2
   \   00000080   0x2E00             CMP      R6,#+0
   \   00000082   0xD00A             BEQ.N    ??HAL_USART_IRQHandler_2
   1164            {
   1165              __HAL_USART_CLEAR_NEFLAG(husart);
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0x9000             STR      R0,[SP, #+0]
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x6840             LDR      R0,[R0, #+4]
   \   0000008E   0x9000             STR      R0,[SP, #+0]
   \   00000090   0x9800             LDR      R0,[SP, #+0]
   1166              husart->ErrorCode |= HAL_USART_ERROR_NE;
   \   00000092   0x6C20             LDR      R0,[R4, #+64]
   \   00000094   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000098   0x6420             STR      R0,[R4, #+64]
   1167            }
   1168          
   1169            tmp_flag = __HAL_USART_GET_FLAG(husart, USART_FLAG_ORE);
   \                     ??HAL_USART_IRQHandler_2: (+1)
   \   0000009A   0x6820             LDR      R0,[R4, #+0]
   \   0000009C   0x6800             LDR      R0,[R0, #+0]
   \   0000009E   0x08C0             LSRS     R0,R0,#+3
   \   000000A0   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   000000A4   0x0005             MOVS     R5,R0
   1170            /* USART Over-Run interrupt occurred ---------------------------------------*/
   1171            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   000000A6   0x2D00             CMP      R5,#+0
   \   000000A8   0xD00C             BEQ.N    ??HAL_USART_IRQHandler_3
   \   000000AA   0x2E00             CMP      R6,#+0
   \   000000AC   0xD00A             BEQ.N    ??HAL_USART_IRQHandler_3
   1172            {
   1173              __HAL_USART_CLEAR_OREFLAG(husart);
   \   000000AE   0x6820             LDR      R0,[R4, #+0]
   \   000000B0   0x6800             LDR      R0,[R0, #+0]
   \   000000B2   0x9000             STR      R0,[SP, #+0]
   \   000000B4   0x6820             LDR      R0,[R4, #+0]
   \   000000B6   0x6840             LDR      R0,[R0, #+4]
   \   000000B8   0x9000             STR      R0,[SP, #+0]
   \   000000BA   0x9800             LDR      R0,[SP, #+0]
   1174              husart->ErrorCode |= HAL_USART_ERROR_ORE;
   \   000000BC   0x6C20             LDR      R0,[R4, #+64]
   \   000000BE   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   000000C2   0x6420             STR      R0,[R4, #+64]
   1175            }
   1176          
   1177            if(husart->ErrorCode != HAL_USART_ERROR_NONE)
   \                     ??HAL_USART_IRQHandler_3: (+1)
   \   000000C4   0x6C20             LDR      R0,[R4, #+64]
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD005             BEQ.N    ??HAL_USART_IRQHandler_4
   1178            {
   1179              /* Set the USART state ready to be able to start again the process */
   1180              husart->State = HAL_USART_STATE_READY;
   \   000000CA   0x2001             MOVS     R0,#+1
   \   000000CC   0xF884 0x003D      STRB     R0,[R4, #+61]
   1181              
   1182              HAL_USART_ErrorCallback(husart);
   \   000000D0   0x0020             MOVS     R0,R4
   \   000000D2   0x.... 0x....      BL       HAL_USART_ErrorCallback
   1183            }
   1184          
   1185            tmp_flag = __HAL_USART_GET_FLAG(husart, USART_FLAG_RXNE);
   \                     ??HAL_USART_IRQHandler_4: (+1)
   \   000000D6   0x6820             LDR      R0,[R4, #+0]
   \   000000D8   0x6800             LDR      R0,[R0, #+0]
   \   000000DA   0x0940             LSRS     R0,R0,#+5
   \   000000DC   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   000000E0   0x0005             MOVS     R5,R0
   1186            tmp_it_source = __HAL_USART_GET_IT_SOURCE(husart, USART_IT_RXNE);
   \   000000E2   0x6820             LDR      R0,[R4, #+0]
   \   000000E4   0x68C0             LDR      R0,[R0, #+12]
   \   000000E6   0xF010 0x0020      ANDS     R0,R0,#0x20
   \   000000EA   0x0006             MOVS     R6,R0
   1187            /* USART in mode Receiver --------------------------------------------------*/
   1188            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   000000EC   0x2D00             CMP      R5,#+0
   \   000000EE   0xD00C             BEQ.N    ??HAL_USART_IRQHandler_5
   \   000000F0   0x2E00             CMP      R6,#+0
   \   000000F2   0xD00A             BEQ.N    ??HAL_USART_IRQHandler_5
   1189            {
   1190              if(husart->State == HAL_USART_STATE_BUSY_RX)
   \   000000F4   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   000000F8   0x2822             CMP      R0,#+34
   \   000000FA   0xD103             BNE.N    ??HAL_USART_IRQHandler_6
   1191              {
   1192                USART_Receive_IT(husart);
   \   000000FC   0x0020             MOVS     R0,R4
   \   000000FE   0x.... 0x....      BL       USART_Receive_IT
   \   00000102   0xE002             B.N      ??HAL_USART_IRQHandler_5
   1193              }
   1194              else
   1195              {
   1196                USART_TransmitReceive_IT(husart);
   \                     ??HAL_USART_IRQHandler_6: (+1)
   \   00000104   0x0020             MOVS     R0,R4
   \   00000106   0x.... 0x....      BL       USART_TransmitReceive_IT
   1197              }
   1198            }
   1199          
   1200            tmp_flag = __HAL_USART_GET_FLAG(husart, USART_FLAG_TXE);
   \                     ??HAL_USART_IRQHandler_5: (+1)
   \   0000010A   0x6820             LDR      R0,[R4, #+0]
   \   0000010C   0x6800             LDR      R0,[R0, #+0]
   \   0000010E   0x09C0             LSRS     R0,R0,#+7
   \   00000110   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000114   0x0005             MOVS     R5,R0
   1201            tmp_it_source = __HAL_USART_GET_IT_SOURCE(husart, USART_IT_TXE);
   \   00000116   0x6820             LDR      R0,[R4, #+0]
   \   00000118   0x68C0             LDR      R0,[R0, #+12]
   \   0000011A   0xF010 0x0080      ANDS     R0,R0,#0x80
   \   0000011E   0x0006             MOVS     R6,R0
   1202            /* USART in mode Transmitter -----------------------------------------------*/
   1203            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   00000120   0x2D00             CMP      R5,#+0
   \   00000122   0xD00C             BEQ.N    ??HAL_USART_IRQHandler_7
   \   00000124   0x2E00             CMP      R6,#+0
   \   00000126   0xD00A             BEQ.N    ??HAL_USART_IRQHandler_7
   1204            {
   1205              if(husart->State == HAL_USART_STATE_BUSY_TX)
   \   00000128   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   0000012C   0x2812             CMP      R0,#+18
   \   0000012E   0xD103             BNE.N    ??HAL_USART_IRQHandler_8
   1206              {
   1207                USART_Transmit_IT(husart);
   \   00000130   0x0020             MOVS     R0,R4
   \   00000132   0x.... 0x....      BL       USART_Transmit_IT
   \   00000136   0xE002             B.N      ??HAL_USART_IRQHandler_7
   1208              }
   1209              else
   1210              {
   1211                USART_TransmitReceive_IT(husart);
   \                     ??HAL_USART_IRQHandler_8: (+1)
   \   00000138   0x0020             MOVS     R0,R4
   \   0000013A   0x.... 0x....      BL       USART_TransmitReceive_IT
   1212              }
   1213            }
   1214            
   1215            tmp_flag = __HAL_USART_GET_FLAG(husart, USART_FLAG_TC);
   \                     ??HAL_USART_IRQHandler_7: (+1)
   \   0000013E   0x6820             LDR      R0,[R4, #+0]
   \   00000140   0x6800             LDR      R0,[R0, #+0]
   \   00000142   0x0980             LSRS     R0,R0,#+6
   \   00000144   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000148   0x0005             MOVS     R5,R0
   1216            tmp_it_source = __HAL_USART_GET_IT_SOURCE(husart, USART_IT_TC);
   \   0000014A   0x6820             LDR      R0,[R4, #+0]
   \   0000014C   0x68C0             LDR      R0,[R0, #+12]
   \   0000014E   0xF010 0x0040      ANDS     R0,R0,#0x40
   \   00000152   0x0006             MOVS     R6,R0
   1217            /* USART in mode Transmitter (transmission end) -----------------------------*/
   1218            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   00000154   0x2D00             CMP      R5,#+0
   \   00000156   0xD004             BEQ.N    ??HAL_USART_IRQHandler_9
   \   00000158   0x2E00             CMP      R6,#+0
   \   0000015A   0xD002             BEQ.N    ??HAL_USART_IRQHandler_9
   1219            {
   1220              USART_EndTransmit_IT(husart);
   \   0000015C   0x0020             MOVS     R0,R4
   \   0000015E   0x.... 0x....      BL       USART_EndTransmit_IT
   1221            } 
   1222          
   1223          }
   \                     ??HAL_USART_IRQHandler_9: (+1)
   \   00000162   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
   1224          
   1225          
   1226          /**
   1227            * @brief  Tx Transfer completed callbacks.
   1228            * @param  husart: Pointer to a USART_HandleTypeDef structure that contains
   1229            *                 the configuration information for the specified USART module.
   1230            * @retval None
   1231            */

   \                                 In section .text, align 2
   1232           __weak void HAL_USART_TxCpltCallback(USART_HandleTypeDef *husart)
   1233          {
   1234            /* NOTE: This function should not be modified, when the callback is needed,
   1235                     the HAL_USART_TxCpltCallback can be implemented in the user file
   1236             */
   1237          }
   \                     HAL_USART_TxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1238          
   1239          /**
   1240            * @brief  Tx Half Transfer completed callbacks.
   1241            * @param  husart: Pointer to a USART_HandleTypeDef structure that contains
   1242            *                 the configuration information for the specified USART module.
   1243            * @retval None
   1244            */

   \                                 In section .text, align 2
   1245           __weak void HAL_USART_TxHalfCpltCallback(USART_HandleTypeDef *husart)
   1246          {
   1247            /* NOTE: This function should not be modified, when the callback is needed,
   1248                     the HAL_USART_TxHalfCpltCallback can be implemented in the user file
   1249             */
   1250          }
   \                     HAL_USART_TxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1251          
   1252          /**
   1253            * @brief  Rx Transfer completed callbacks.
   1254            * @param  husart: Pointer to a USART_HandleTypeDef structure that contains
   1255            *                 the configuration information for the specified USART module.
   1256            * @retval None
   1257            */

   \                                 In section .text, align 2
   1258          __weak void HAL_USART_RxCpltCallback(USART_HandleTypeDef *husart)
   1259          {
   1260            /* NOTE: This function should not be modified, when the callback is needed,
   1261                     the HAL_USART_RxCpltCallback can be implemented in the user file
   1262             */
   1263          }
   \                     HAL_USART_RxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1264          
   1265          /**
   1266            * @brief  Rx Half Transfer completed callbacks.
   1267            * @param  husart: Pointer to a USART_HandleTypeDef structure that contains
   1268            *                 the configuration information for the specified USART module.
   1269            * @retval None
   1270            */

   \                                 In section .text, align 2
   1271          __weak void HAL_USART_RxHalfCpltCallback(USART_HandleTypeDef *husart)
   1272          {
   1273            /* NOTE: This function should not be modified, when the callback is needed,
   1274                     the HAL_USART_RxHalfCpltCallback can be implemented in the user file
   1275             */
   1276          }
   \                     HAL_USART_RxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1277          
   1278          /**
   1279            * @brief  Tx/Rx Transfers completed callback for the non-blocking process.
   1280            * @param  husart: Pointer to a USART_HandleTypeDef structure that contains
   1281            *                 the configuration information for the specified USART module.
   1282            * @retval None
   1283            */

   \                                 In section .text, align 2
   1284          __weak void HAL_USART_TxRxCpltCallback(USART_HandleTypeDef *husart)
   1285          {
   1286            /* NOTE: This function should not be modified, when the callback is needed,
   1287                     the HAL_USART_TxRxCpltCallback can be implemented in the user file
   1288             */
   1289          }
   \                     HAL_USART_TxRxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1290          
   1291          /**
   1292            * @brief  USART error callbacks.
   1293            * @param  husart: Pointer to a USART_HandleTypeDef structure that contains
   1294            *                 the configuration information for the specified USART module.
   1295            * @retval None
   1296            */

   \                                 In section .text, align 2
   1297           __weak void HAL_USART_ErrorCallback(USART_HandleTypeDef *husart)
   1298          {
   1299            /* NOTE: This function should not be modified, when the callback is needed,
   1300                     the HAL_USART_ErrorCallback can be implemented in the user file
   1301             */ 
   1302          }
   \                     HAL_USART_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1303          
   1304          /**
   1305            * @}
   1306            */
   1307          
   1308          /** @defgroup USART_Exported_Functions_Group3 Peripheral State and Errors functions 
   1309            *  @brief   USART State and Errors functions 
   1310            *
   1311          @verbatim   
   1312            ==============================================================================
   1313                            ##### Peripheral State and Errors functions #####
   1314            ==============================================================================  
   1315            [..]
   1316              This subsection provides a set of functions allowing to return the State of 
   1317              USART communication
   1318              process, return Peripheral Errors occurred during communication process
   1319               (+) HAL_USART_GetState() API can be helpful to check in run-time the state 
   1320                   of the USART peripheral.
   1321               (+) HAL_USART_GetError() check in run-time errors that could be occurred during 
   1322                   communication. 
   1323          @endverbatim
   1324            * @{
   1325            */
   1326          
   1327          /**
   1328            * @brief  Returns the USART state.
   1329            * @param  husart: Pointer to a USART_HandleTypeDef structure that contains
   1330            *                 the configuration information for the specified USART module.
   1331            * @retval HAL state
   1332            */

   \                                 In section .text, align 2, keep-with-next
   1333          HAL_USART_StateTypeDef HAL_USART_GetState(USART_HandleTypeDef *husart)
   1334          {
   1335            return husart->State;
   \                     HAL_USART_GetState: (+1)
   \   00000000   0xF890 0x003D      LDRB     R0,[R0, #+61]
   \   00000004   0x4770             BX       LR               ;; return
   1336          }
   1337          
   1338          /**
   1339            * @brief  Return the USART error code
   1340            * @param  husart : pointer to a USART_HandleTypeDef structure that contains
   1341            *              the configuration information for the specified USART.
   1342            * @retval USART Error Code
   1343            */

   \                                 In section .text, align 2, keep-with-next
   1344          uint32_t HAL_USART_GetError(USART_HandleTypeDef *husart)
   1345          {
   1346            return husart->ErrorCode;
   \                     HAL_USART_GetError: (+1)
   \   00000000   0x6C00             LDR      R0,[R0, #+64]
   \   00000002   0x4770             BX       LR               ;; return
   1347          }
   1348          
   1349          /**
   1350            * @}
   1351            */
   1352          
   1353          /**
   1354            * @}
   1355            */
   1356          
   1357          /** @defgroup USART_Private_Functions   USART Private Functions
   1358            *  @brief   USART Private functions 
   1359            * @{
   1360            */
   1361          /**
   1362            * @brief  DMA USART transmit process complete callback. 
   1363            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
   1364            *               the configuration information for the specified DMA module.
   1365            * @retval None
   1366            */

   \                                 In section .text, align 4, keep-with-next
   1367          static void USART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
   1368          {
   \                     USART_DMATransmitCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1369            USART_HandleTypeDef* husart = ( USART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   1370          
   1371            /* DMA Normal mode */
   1372            if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0680             LSLS     R0,R0,#+26
   \   0000000C   0xD412             BMI.N    ??USART_DMATransmitCplt_0
   1373            {
   1374              husart->TxXferCount = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x8568             STRH     R0,[R5, #+42]
   1375          
   1376              if(husart->State == HAL_USART_STATE_BUSY_TX)
   \   00000012   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \   00000016   0x2812             CMP      R0,#+18
   \   00000018   0xD113             BNE.N    ??USART_DMATransmitCplt_1
   1377              {
   1378                /* Disable the DMA transfer for transmit request by resetting the DMAT bit
   1379                   in the USART CR3 register */
   1380                CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
   \   0000001A   0x6828             LDR      R0,[R5, #+0]
   \   0000001C   0x6940             LDR      R0,[R0, #+20]
   \   0000001E   0xF030 0x0080      BICS     R0,R0,#0x80
   \   00000022   0x6829             LDR      R1,[R5, #+0]
   \   00000024   0x6148             STR      R0,[R1, #+20]
   1381                
   1382                /* Enable the USART Transmit Complete Interrupt */    
   1383                __HAL_USART_ENABLE_IT(husart, USART_IT_TC);
   \   00000026   0x6828             LDR      R0,[R5, #+0]
   \   00000028   0x68C0             LDR      R0,[R0, #+12]
   \   0000002A   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000002E   0x6829             LDR      R1,[R5, #+0]
   \   00000030   0x60C8             STR      R0,[R1, #+12]
   \   00000032   0xE006             B.N      ??USART_DMATransmitCplt_1
   1384              }
   1385            }
   1386            /* DMA Circular mode */
   1387            else
   1388            {
   1389              if(husart->State == HAL_USART_STATE_BUSY_TX)
   \                     ??USART_DMATransmitCplt_0: (+1)
   \   00000034   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \   00000038   0x2812             CMP      R0,#+18
   \   0000003A   0xD102             BNE.N    ??USART_DMATransmitCplt_1
   1390              {
   1391                HAL_USART_TxCpltCallback(husart);
   \   0000003C   0x0028             MOVS     R0,R5
   \   0000003E   0x.... 0x....      BL       HAL_USART_TxCpltCallback
   1392              }
   1393            }
   1394          }
   \                     ??USART_DMATransmitCplt_1: (+1)
   \   00000042   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1395          
   1396          /**
   1397            * @brief DMA USART transmit process half complete callback 
   1398            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
   1399            *               the configuration information for the specified DMA module.
   1400            * @retval None
   1401            */

   \                                 In section .text, align 4, keep-with-next
   1402          static void USART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
   1403          {
   \                     USART_DMATxHalfCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1404            USART_HandleTypeDef* husart = (USART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   1405          
   1406            HAL_USART_TxHalfCpltCallback(husart);
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x.... 0x....      BL       HAL_USART_TxHalfCpltCallback
   1407          }
   \   0000000C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1408          
   1409          /**
   1410            * @brief  DMA USART receive process complete callback. 
   1411            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
   1412            *               the configuration information for the specified DMA module.
   1413            * @retval None
   1414            */

   \                                 In section .text, align 4, keep-with-next
   1415          static void USART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
   1416          {
   \                     USART_DMAReceiveCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1417            USART_HandleTypeDef* husart = ( USART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   1418          
   1419            /* DMA Normal mode */
   1420            if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0680             LSLS     R0,R0,#+26
   \   0000000C   0xD41F             BMI.N    ??USART_DMAReceiveCplt_0
   1421            {
   1422              husart->RxXferCount = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x8668             STRH     R0,[R5, #+50]
   1423              if(husart->State == HAL_USART_STATE_BUSY_RX)
   \   00000012   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \   00000016   0x2822             CMP      R0,#+34
   \   00000018   0xD10C             BNE.N    ??USART_DMAReceiveCplt_1
   1424              {
   1425                /* Disable the DMA transfer for the receiver requests by setting the DMAR bit 
   1426                   in the USART CR3 register */
   1427                CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
   \   0000001A   0x6828             LDR      R0,[R5, #+0]
   \   0000001C   0x6940             LDR      R0,[R0, #+20]
   \   0000001E   0xF030 0x0040      BICS     R0,R0,#0x40
   \   00000022   0x6829             LDR      R1,[R5, #+0]
   \   00000024   0x6148             STR      R0,[R1, #+20]
   1428          
   1429                husart->State= HAL_USART_STATE_READY;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xF885 0x003D      STRB     R0,[R5, #+61]
   1430                HAL_USART_RxCpltCallback(husart);
   \   0000002C   0x0028             MOVS     R0,R5
   \   0000002E   0x.... 0x....      BL       HAL_USART_RxCpltCallback
   \   00000032   0xE017             B.N      ??USART_DMAReceiveCplt_2
   1431              }
   1432              /* the usart state is HAL_USART_STATE_BUSY_TX_RX*/
   1433              else
   1434              {
   1435                /* Disable the DMA transfer for the Transmit/receiver requests by setting the DMAT/DMAR bit 
   1436                   in the USART CR3 register */
   1437                CLEAR_BIT(husart->Instance->CR3, (USART_CR3_DMAT | USART_CR3_DMAR));
   \                     ??USART_DMAReceiveCplt_1: (+1)
   \   00000034   0x6828             LDR      R0,[R5, #+0]
   \   00000036   0x6940             LDR      R0,[R0, #+20]
   \   00000038   0xF030 0x00C0      BICS     R0,R0,#0xC0
   \   0000003C   0x6829             LDR      R1,[R5, #+0]
   \   0000003E   0x6148             STR      R0,[R1, #+20]
   1438          
   1439                husart->State= HAL_USART_STATE_READY;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xF885 0x003D      STRB     R0,[R5, #+61]
   1440                HAL_USART_TxRxCpltCallback(husart);
   \   00000046   0x0028             MOVS     R0,R5
   \   00000048   0x.... 0x....      BL       HAL_USART_TxRxCpltCallback
   \   0000004C   0xE00A             B.N      ??USART_DMAReceiveCplt_2
   1441              }
   1442            }
   1443            /* DMA circular mode */
   1444            else
   1445            {
   1446              if(husart->State == HAL_USART_STATE_BUSY_RX)
   \                     ??USART_DMAReceiveCplt_0: (+1)
   \   0000004E   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \   00000052   0x2822             CMP      R0,#+34
   \   00000054   0xD103             BNE.N    ??USART_DMAReceiveCplt_3
   1447              {
   1448                HAL_USART_RxCpltCallback(husart);
   \   00000056   0x0028             MOVS     R0,R5
   \   00000058   0x.... 0x....      BL       HAL_USART_RxCpltCallback
   \   0000005C   0xE002             B.N      ??USART_DMAReceiveCplt_2
   1449              }
   1450              /* the usart state is HAL_USART_STATE_BUSY_TX_RX*/
   1451              else
   1452              {
   1453                HAL_USART_TxRxCpltCallback(husart);
   \                     ??USART_DMAReceiveCplt_3: (+1)
   \   0000005E   0x0028             MOVS     R0,R5
   \   00000060   0x.... 0x....      BL       HAL_USART_TxRxCpltCallback
   1454              }
   1455            }
   1456          }
   \                     ??USART_DMAReceiveCplt_2: (+1)
   \   00000064   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1457          
   1458          /**
   1459            * @brief DMA USART receive process half complete callback 
   1460            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
   1461            *               the configuration information for the specified DMA module.
   1462            * @retval None
   1463            */

   \                                 In section .text, align 4, keep-with-next
   1464          static void USART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
   1465          {
   \                     USART_DMARxHalfCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1466            USART_HandleTypeDef* husart = (USART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   1467          
   1468            HAL_USART_RxHalfCpltCallback(husart); 
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x.... 0x....      BL       HAL_USART_RxHalfCpltCallback
   1469          }
   \   0000000C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1470          
   1471          /**
   1472            * @brief  DMA USART communication error callback. 
   1473            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
   1474            *               the configuration information for the specified DMA module.
   1475            * @retval None
   1476            */

   \                                 In section .text, align 4, keep-with-next
   1477          static void USART_DMAError(DMA_HandleTypeDef *hdma)   
   1478          {
   \                     USART_DMAError: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1479            USART_HandleTypeDef* husart = ( USART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   1480          
   1481            husart->RxXferCount = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x8668             STRH     R0,[R5, #+50]
   1482            husart->TxXferCount = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x8568             STRH     R0,[R5, #+42]
   1483            husart->ErrorCode |= HAL_USART_ERROR_DMA;
   \   0000000E   0x6C28             LDR      R0,[R5, #+64]
   \   00000010   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000014   0x6428             STR      R0,[R5, #+64]
   1484            husart->State= HAL_USART_STATE_READY;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xF885 0x003D      STRB     R0,[R5, #+61]
   1485            
   1486            HAL_USART_ErrorCallback(husart);
   \   0000001C   0x0028             MOVS     R0,R5
   \   0000001E   0x.... 0x....      BL       HAL_USART_ErrorCallback
   1487          }
   \   00000022   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1488          
   1489          /**
   1490            * @brief  This function handles USART Communication Timeout.
   1491            * @param  husart: Pointer to a USART_HandleTypeDef structure that contains
   1492            *                 the configuration information for the specified USART module.
   1493            * @param  Flag: specifies the USART flag to check.
   1494            * @param  Status: The new Flag status (SET or RESET).
   1495            * @param  Timeout: Timeout duration
   1496            * @retval HAL status
   1497            */

   \                                 In section .text, align 2, keep-with-next
   1498          static HAL_StatusTypeDef USART_WaitOnFlagUntilTimeout(USART_HandleTypeDef *husart, uint32_t Flag, FlagStatus Status, uint32_t Timeout)
   1499          {
   \                     USART_WaitOnFlagUntilTimeout: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   1500            uint32_t tickstart = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   1501          
   1502            /* Get tick */ 
   1503            tickstart = HAL_GetTick();
   \   00000010   0x.... 0x....      BL       HAL_GetTick
   \   00000014   0x4680             MOV      R8,R0
   1504          
   1505            /* Wait until flag is set */
   1506            if(Status == RESET)
   \   00000016   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000018   0x2E00             CMP      R6,#+0
   \   0000001A   0xD12F             BNE.N    ??USART_WaitOnFlagUntilTimeout_0
   1507            {
   1508              while(__HAL_USART_GET_FLAG(husart, Flag) == RESET)
   \                     ??USART_WaitOnFlagUntilTimeout_1: (+1)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x4028             ANDS     R0,R5,R0
   \   00000022   0x42A8             CMP      R0,R5
   \   00000024   0xD05A             BEQ.N    ??USART_WaitOnFlagUntilTimeout_2
   1509              {
   1510                /* Check for the Timeout */
   1511                if(Timeout != HAL_MAX_DELAY)
   \   00000026   0xF117 0x0F01      CMN      R7,#+1
   \   0000002A   0xD0F7             BEQ.N    ??USART_WaitOnFlagUntilTimeout_1
   1512                {
   1513                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   0000002C   0x2F00             CMP      R7,#+0
   \   0000002E   0xD005             BEQ.N    ??USART_WaitOnFlagUntilTimeout_3
   \   00000030   0x.... 0x....      BL       HAL_GetTick
   \   00000034   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   00000038   0x4287             CMP      R7,R0
   \   0000003A   0xD2EF             BCS.N    ??USART_WaitOnFlagUntilTimeout_1
   1514                  {
   1515                    /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
   1516                    __HAL_USART_DISABLE_IT(husart, USART_IT_TXE);
   \                     ??USART_WaitOnFlagUntilTimeout_3: (+1)
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x68C0             LDR      R0,[R0, #+12]
   \   00000040   0xF030 0x0080      BICS     R0,R0,#0x80
   \   00000044   0x6821             LDR      R1,[R4, #+0]
   \   00000046   0x60C8             STR      R0,[R1, #+12]
   1517                    __HAL_USART_DISABLE_IT(husart, USART_IT_RXNE);
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x68C0             LDR      R0,[R0, #+12]
   \   0000004C   0xF030 0x0020      BICS     R0,R0,#0x20
   \   00000050   0x6821             LDR      R1,[R4, #+0]
   \   00000052   0x60C8             STR      R0,[R1, #+12]
   1518                    __HAL_USART_DISABLE_IT(husart, USART_IT_PE);
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x68C0             LDR      R0,[R0, #+12]
   \   00000058   0xF430 0x7080      BICS     R0,R0,#0x100
   \   0000005C   0x6821             LDR      R1,[R4, #+0]
   \   0000005E   0x60C8             STR      R0,[R1, #+12]
   1519                    __HAL_USART_DISABLE_IT(husart, USART_IT_ERR);
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x6940             LDR      R0,[R0, #+20]
   \   00000064   0x0840             LSRS     R0,R0,#+1
   \   00000066   0x0040             LSLS     R0,R0,#+1
   \   00000068   0x6821             LDR      R1,[R4, #+0]
   \   0000006A   0x6148             STR      R0,[R1, #+20]
   1520          
   1521                    husart->State= HAL_USART_STATE_READY;
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0xF884 0x003D      STRB     R0,[R4, #+61]
   1522          
   1523                    /* Process Unlocked */
   1524                    __HAL_UNLOCK(husart);
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xF884 0x003C      STRB     R0,[R4, #+60]
   1525          
   1526                    return HAL_TIMEOUT;
   \   00000078   0x2003             MOVS     R0,#+3
   \   0000007A   0xE030             B.N      ??USART_WaitOnFlagUntilTimeout_4
   1527                  }
   1528                }
   1529              }
   1530            }
   1531            else
   1532            {
   1533              while(__HAL_USART_GET_FLAG(husart, Flag) != RESET)
   \                     ??USART_WaitOnFlagUntilTimeout_0: (+1)
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x4028             ANDS     R0,R5,R0
   \   00000082   0x42A8             CMP      R0,R5
   \   00000084   0xD12A             BNE.N    ??USART_WaitOnFlagUntilTimeout_2
   1534              {
   1535                /* Check for the Timeout */
   1536                if(Timeout != HAL_MAX_DELAY)
   \   00000086   0xF117 0x0F01      CMN      R7,#+1
   \   0000008A   0xD0F7             BEQ.N    ??USART_WaitOnFlagUntilTimeout_0
   1537                {
   1538                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   0000008C   0x2F00             CMP      R7,#+0
   \   0000008E   0xD005             BEQ.N    ??USART_WaitOnFlagUntilTimeout_5
   \   00000090   0x.... 0x....      BL       HAL_GetTick
   \   00000094   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   00000098   0x4287             CMP      R7,R0
   \   0000009A   0xD2EF             BCS.N    ??USART_WaitOnFlagUntilTimeout_0
   1539                  {
   1540                    /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
   1541                    __HAL_USART_DISABLE_IT(husart, USART_IT_TXE);
   \                     ??USART_WaitOnFlagUntilTimeout_5: (+1)
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0x68C0             LDR      R0,[R0, #+12]
   \   000000A0   0xF030 0x0080      BICS     R0,R0,#0x80
   \   000000A4   0x6821             LDR      R1,[R4, #+0]
   \   000000A6   0x60C8             STR      R0,[R1, #+12]
   1542                    __HAL_USART_DISABLE_IT(husart, USART_IT_RXNE);
   \   000000A8   0x6820             LDR      R0,[R4, #+0]
   \   000000AA   0x68C0             LDR      R0,[R0, #+12]
   \   000000AC   0xF030 0x0020      BICS     R0,R0,#0x20
   \   000000B0   0x6821             LDR      R1,[R4, #+0]
   \   000000B2   0x60C8             STR      R0,[R1, #+12]
   1543                    __HAL_USART_DISABLE_IT(husart, USART_IT_PE);
   \   000000B4   0x6820             LDR      R0,[R4, #+0]
   \   000000B6   0x68C0             LDR      R0,[R0, #+12]
   \   000000B8   0xF430 0x7080      BICS     R0,R0,#0x100
   \   000000BC   0x6821             LDR      R1,[R4, #+0]
   \   000000BE   0x60C8             STR      R0,[R1, #+12]
   1544                    __HAL_USART_DISABLE_IT(husart, USART_IT_ERR);
   \   000000C0   0x6820             LDR      R0,[R4, #+0]
   \   000000C2   0x6940             LDR      R0,[R0, #+20]
   \   000000C4   0x0840             LSRS     R0,R0,#+1
   \   000000C6   0x0040             LSLS     R0,R0,#+1
   \   000000C8   0x6821             LDR      R1,[R4, #+0]
   \   000000CA   0x6148             STR      R0,[R1, #+20]
   1545          
   1546                    husart->State= HAL_USART_STATE_READY;
   \   000000CC   0x2001             MOVS     R0,#+1
   \   000000CE   0xF884 0x003D      STRB     R0,[R4, #+61]
   1547          
   1548                    /* Process Unlocked */
   1549                    __HAL_UNLOCK(husart);
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0xF884 0x003C      STRB     R0,[R4, #+60]
   1550          
   1551                    return HAL_TIMEOUT;
   \   000000D8   0x2003             MOVS     R0,#+3
   \   000000DA   0xE000             B.N      ??USART_WaitOnFlagUntilTimeout_4
   1552                  }
   1553                }
   1554              }
   1555            }
   1556            return HAL_OK;
   \                     ??USART_WaitOnFlagUntilTimeout_2: (+1)
   \   000000DC   0x2000             MOVS     R0,#+0
   \                     ??USART_WaitOnFlagUntilTimeout_4: (+1)
   \   000000DE   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1557          }
   1558          
   1559          /**
   1560            * @brief  Simplex Send an amount of data in non-blocking mode. 
   1561            * @param  husart: Pointer to a USART_HandleTypeDef structure that contains
   1562            *                 the configuration information for the specified USART module.
   1563            * @retval HAL status
   1564            * @note   The USART errors are not managed to avoid the overrun error.
   1565            */

   \                                 In section .text, align 2, keep-with-next
   1566          static HAL_StatusTypeDef USART_Transmit_IT(USART_HandleTypeDef *husart)
   1567          {
   \                     USART_Transmit_IT: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1568            uint16_t* tmp=0;
   \   00000002   0x2200             MOVS     R2,#+0
   1569           
   1570            if(husart->State == HAL_USART_STATE_BUSY_TX)
   \   00000004   0xF891 0x003D      LDRB     R0,[R1, #+61]
   \   00000008   0x2812             CMP      R0,#+18
   \   0000000A   0xD12F             BNE.N    ??USART_Transmit_IT_0
   1571            {
   1572              if(husart->Init.WordLength == USART_WORDLENGTH_9B)
   \   0000000C   0x6888             LDR      R0,[R1, #+8]
   \   0000000E   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000012   0xD111             BNE.N    ??USART_Transmit_IT_1
   1573              {
   1574                tmp = (uint16_t*) husart->pTxBuffPtr;
   \   00000014   0x6A48             LDR      R0,[R1, #+36]
   \   00000016   0x0002             MOVS     R2,R0
   1575                WRITE_REG(husart->Instance->DR, (uint16_t)(*tmp & (uint16_t)0x01FF));
   \   00000018   0x8810             LDRH     R0,[R2, #+0]
   \   0000001A   0x05C0             LSLS     R0,R0,#+23       ;; ZeroExtS R0,R0,#+23,#+23
   \   0000001C   0x0DC0             LSRS     R0,R0,#+23
   \   0000001E   0x680B             LDR      R3,[R1, #+0]
   \   00000020   0x6058             STR      R0,[R3, #+4]
   1576                if(husart->Init.Parity == USART_PARITY_NONE)
   \   00000022   0x6908             LDR      R0,[R1, #+16]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD103             BNE.N    ??USART_Transmit_IT_2
   1577                {
   1578                  husart->pTxBuffPtr += 2;
   \   00000028   0x6A48             LDR      R0,[R1, #+36]
   \   0000002A   0x1C80             ADDS     R0,R0,#+2
   \   0000002C   0x6248             STR      R0,[R1, #+36]
   \   0000002E   0xE009             B.N      ??USART_Transmit_IT_3
   1579                }
   1580                else
   1581                {
   1582                  husart->pTxBuffPtr += 1;
   \                     ??USART_Transmit_IT_2: (+1)
   \   00000030   0x6A48             LDR      R0,[R1, #+36]
   \   00000032   0x1C40             ADDS     R0,R0,#+1
   \   00000034   0x6248             STR      R0,[R1, #+36]
   \   00000036   0xE005             B.N      ??USART_Transmit_IT_3
   1583                }
   1584              } 
   1585              else
   1586              { 
   1587                WRITE_REG(husart->Instance->DR, (uint8_t)(*husart->pTxBuffPtr++ & (uint8_t)0x00FF));
   \                     ??USART_Transmit_IT_1: (+1)
   \   00000038   0x6A48             LDR      R0,[R1, #+36]
   \   0000003A   0x1C43             ADDS     R3,R0,#+1
   \   0000003C   0x624B             STR      R3,[R1, #+36]
   \   0000003E   0x7800             LDRB     R0,[R0, #+0]
   \   00000040   0x680B             LDR      R3,[R1, #+0]
   \   00000042   0x6058             STR      R0,[R3, #+4]
   1588              }
   1589              
   1590              if(--husart->TxXferCount == 0)
   \                     ??USART_Transmit_IT_3: (+1)
   \   00000044   0x8D48             LDRH     R0,[R1, #+42]
   \   00000046   0x1E40             SUBS     R0,R0,#+1
   \   00000048   0x8548             STRH     R0,[R1, #+42]
   \   0000004A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD10B             BNE.N    ??USART_Transmit_IT_4
   1591              {
   1592                /* Disable the USART Transmit data register empty Interrupt */
   1593                __HAL_USART_DISABLE_IT(husart, USART_IT_TXE);
   \   00000050   0x6808             LDR      R0,[R1, #+0]
   \   00000052   0x68C0             LDR      R0,[R0, #+12]
   \   00000054   0xF030 0x0080      BICS     R0,R0,#0x80
   \   00000058   0x680B             LDR      R3,[R1, #+0]
   \   0000005A   0x60D8             STR      R0,[R3, #+12]
   1594          
   1595                /* Enable the USART Transmit Complete Interrupt */    
   1596                __HAL_USART_ENABLE_IT(husart, USART_IT_TC);
   \   0000005C   0x6808             LDR      R0,[R1, #+0]
   \   0000005E   0x68C0             LDR      R0,[R0, #+12]
   \   00000060   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000064   0x680B             LDR      R3,[R1, #+0]
   \   00000066   0x60D8             STR      R0,[R3, #+12]
   1597              }
   1598              return HAL_OK;
   \                     ??USART_Transmit_IT_4: (+1)
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xE000             B.N      ??USART_Transmit_IT_5
   1599            }
   1600            else
   1601            {
   1602              return HAL_BUSY;
   \                     ??USART_Transmit_IT_0: (+1)
   \   0000006C   0x2002             MOVS     R0,#+2
   \                     ??USART_Transmit_IT_5: (+1)
   \   0000006E   0x4770             BX       LR               ;; return
   1603            }
   1604          }
   1605          
   1606          
   1607          /**
   1608            * @brief  Wraps up transmission in non blocking mode.
   1609            * @param  husart: pointer to a USART_HandleTypeDef structure that contains
   1610            *                the configuration information for the specified USART module.
   1611            * @retval HAL status
   1612            */

   \                                 In section .text, align 2, keep-with-next
   1613          static HAL_StatusTypeDef USART_EndTransmit_IT(USART_HandleTypeDef *husart)
   1614          {
   \                     USART_EndTransmit_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1615            /* Disable the USART Transmit Complete Interrupt */    
   1616            __HAL_USART_DISABLE_IT(husart, USART_IT_TC);
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x68C0             LDR      R0,[R0, #+12]
   \   00000008   0xF030 0x0040      BICS     R0,R0,#0x40
   \   0000000C   0x6821             LDR      R1,[R4, #+0]
   \   0000000E   0x60C8             STR      R0,[R1, #+12]
   1617            
   1618            /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error) */
   1619            __HAL_USART_DISABLE_IT(husart, USART_IT_ERR);
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x6940             LDR      R0,[R0, #+20]
   \   00000014   0x0840             LSRS     R0,R0,#+1
   \   00000016   0x0040             LSLS     R0,R0,#+1
   \   00000018   0x6821             LDR      R1,[R4, #+0]
   \   0000001A   0x6148             STR      R0,[R1, #+20]
   1620              
   1621            husart->State = HAL_USART_STATE_READY;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xF884 0x003D      STRB     R0,[R4, #+61]
   1622             
   1623            HAL_USART_TxCpltCallback(husart);
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       HAL_USART_TxCpltCallback
   1624            
   1625            return HAL_OK;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
   1626          }
   1627          
   1628          
   1629          /**
   1630            * @brief  Simplex Receive an amount of data in non-blocking mode. 
   1631            * @param  husart: Pointer to a USART_HandleTypeDef structure that contains
   1632            *                 the configuration information for the specified USART module.
   1633            * @retval HAL status
   1634            */

   \                                 In section .text, align 2, keep-with-next
   1635          static HAL_StatusTypeDef USART_Receive_IT(USART_HandleTypeDef *husart)
   1636          {
   \                     USART_Receive_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1637            uint16_t* tmp=0;
   \   00000004   0x2500             MOVS     R5,#+0
   1638            if(husart->State == HAL_USART_STATE_BUSY_RX)
   \   00000006   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   0000000A   0x2822             CMP      R0,#+34
   \   0000000C   0xD15E             BNE.N    ??USART_Receive_IT_0
   1639            {
   1640              if(husart->Init.WordLength == USART_WORDLENGTH_9B)
   \   0000000E   0x68A0             LDR      R0,[R4, #+8]
   \   00000010   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000014   0xD120             BNE.N    ??USART_Receive_IT_1
   1641              {
   1642                tmp = (uint16_t*) husart->pRxBuffPtr;
   \   00000016   0x6AE0             LDR      R0,[R4, #+44]
   \   00000018   0x0005             MOVS     R5,R0
   1643                if(husart->Init.Parity == USART_PARITY_NONE)
   \   0000001A   0x6920             LDR      R0,[R4, #+16]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD108             BNE.N    ??USART_Receive_IT_2
   1644                {
   1645                  *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x01FF);
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x6840             LDR      R0,[R0, #+4]
   \   00000024   0x05C0             LSLS     R0,R0,#+23       ;; ZeroExtS R0,R0,#+23,#+23
   \   00000026   0x0DC0             LSRS     R0,R0,#+23
   \   00000028   0x8028             STRH     R0,[R5, #+0]
   1646                  husart->pRxBuffPtr += 2;
   \   0000002A   0x6AE0             LDR      R0,[R4, #+44]
   \   0000002C   0x1C80             ADDS     R0,R0,#+2
   \   0000002E   0x62E0             STR      R0,[R4, #+44]
   \   00000030   0xE007             B.N      ??USART_Receive_IT_3
   1647                }
   1648                else
   1649                {
   1650                  *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x00FF);
   \                     ??USART_Receive_IT_2: (+1)
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x6840             LDR      R0,[R0, #+4]
   \   00000036   0xF000 0x00FF      AND      R0,R0,#0xFF
   \   0000003A   0x8028             STRH     R0,[R5, #+0]
   1651                  husart->pRxBuffPtr += 1;
   \   0000003C   0x6AE0             LDR      R0,[R4, #+44]
   \   0000003E   0x1C40             ADDS     R0,R0,#+1
   \   00000040   0x62E0             STR      R0,[R4, #+44]
   1652                }
   1653                if(--husart->RxXferCount != 0x00) 
   \                     ??USART_Receive_IT_3: (+1)
   \   00000042   0x8E60             LDRH     R0,[R4, #+50]
   \   00000044   0x1E40             SUBS     R0,R0,#+1
   \   00000046   0x8660             STRH     R0,[R4, #+50]
   \   00000048   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD01F             BEQ.N    ??USART_Receive_IT_4
   1654                {
   1655                  /* Send dummy byte in order to generate the clock for the slave to send the next data */
   1656                  WRITE_REG(husart->Instance->DR, (DUMMY_DATA & (uint16_t)0x01FF)); 
   \   0000004E   0xF240 0x10FF      MOVW     R0,#+511
   \   00000052   0x6821             LDR      R1,[R4, #+0]
   \   00000054   0x6048             STR      R0,[R1, #+4]
   \   00000056   0xE01A             B.N      ??USART_Receive_IT_4
   1657                }
   1658              } 
   1659              else
   1660              {
   1661                if(husart->Init.Parity == USART_PARITY_NONE)
   \                     ??USART_Receive_IT_1: (+1)
   \   00000058   0x6920             LDR      R0,[R4, #+16]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD106             BNE.N    ??USART_Receive_IT_5
   1662                {
   1663                  *husart->pRxBuffPtr++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x00FF);
   \   0000005E   0x6AE0             LDR      R0,[R4, #+44]
   \   00000060   0x1C41             ADDS     R1,R0,#+1
   \   00000062   0x62E1             STR      R1,[R4, #+44]
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x6849             LDR      R1,[R1, #+4]
   \   00000068   0x7001             STRB     R1,[R0, #+0]
   \   0000006A   0xE007             B.N      ??USART_Receive_IT_6
   1664                }
   1665                else
   1666                {
   1667                  *husart->pRxBuffPtr++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x007F);
   \                     ??USART_Receive_IT_5: (+1)
   \   0000006C   0x6AE0             LDR      R0,[R4, #+44]
   \   0000006E   0x1C41             ADDS     R1,R0,#+1
   \   00000070   0x62E1             STR      R1,[R4, #+44]
   \   00000072   0x6821             LDR      R1,[R4, #+0]
   \   00000074   0x6849             LDR      R1,[R1, #+4]
   \   00000076   0xF011 0x017F      ANDS     R1,R1,#0x7F
   \   0000007A   0x7001             STRB     R1,[R0, #+0]
   1668                }
   1669          
   1670                if(--husart->RxXferCount != 0x00) 
   \                     ??USART_Receive_IT_6: (+1)
   \   0000007C   0x8E60             LDRH     R0,[R4, #+50]
   \   0000007E   0x1E40             SUBS     R0,R0,#+1
   \   00000080   0x8660             STRH     R0,[R4, #+50]
   \   00000082   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD002             BEQ.N    ??USART_Receive_IT_4
   1671                {
   1672                  /* Send dummy byte in order to generate the clock for the slave to send the next data */
   1673                  WRITE_REG(husart->Instance->DR, (DUMMY_DATA & (uint16_t)0x00FF));  
   \   00000088   0x20FF             MOVS     R0,#+255
   \   0000008A   0x6821             LDR      R1,[R4, #+0]
   \   0000008C   0x6048             STR      R0,[R1, #+4]
   1674                }
   1675              }
   1676          
   1677              if(husart->RxXferCount == 0)
   \                     ??USART_Receive_IT_4: (+1)
   \   0000008E   0x8E60             LDRH     R0,[R4, #+50]
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD119             BNE.N    ??USART_Receive_IT_7
   1678              {
   1679                /* Disable the USART RXNE Interrupt */
   1680                __HAL_USART_DISABLE_IT(husart, USART_IT_RXNE);
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x68C0             LDR      R0,[R0, #+12]
   \   00000098   0xF030 0x0020      BICS     R0,R0,#0x20
   \   0000009C   0x6821             LDR      R1,[R4, #+0]
   \   0000009E   0x60C8             STR      R0,[R1, #+12]
   1681          
   1682                /* Disable the USART Parity Error Interrupt */
   1683                __HAL_USART_DISABLE_IT(husart, USART_IT_PE);
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x68C0             LDR      R0,[R0, #+12]
   \   000000A4   0xF430 0x7080      BICS     R0,R0,#0x100
   \   000000A8   0x6821             LDR      R1,[R4, #+0]
   \   000000AA   0x60C8             STR      R0,[R1, #+12]
   1684          
   1685                /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error) */
   1686                __HAL_USART_DISABLE_IT(husart, USART_IT_ERR);
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0x6940             LDR      R0,[R0, #+20]
   \   000000B0   0x0840             LSRS     R0,R0,#+1
   \   000000B2   0x0040             LSLS     R0,R0,#+1
   \   000000B4   0x6821             LDR      R1,[R4, #+0]
   \   000000B6   0x6148             STR      R0,[R1, #+20]
   1687          
   1688                husart->State = HAL_USART_STATE_READY;
   \   000000B8   0x2001             MOVS     R0,#+1
   \   000000BA   0xF884 0x003D      STRB     R0,[R4, #+61]
   1689                HAL_USART_RxCpltCallback(husart);
   \   000000BE   0x0020             MOVS     R0,R4
   \   000000C0   0x.... 0x....      BL       HAL_USART_RxCpltCallback
   1690                
   1691                return HAL_OK;
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0xE002             B.N      ??USART_Receive_IT_8
   1692              }
   1693              return HAL_OK;
   \                     ??USART_Receive_IT_7: (+1)
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0xE000             B.N      ??USART_Receive_IT_8
   1694            }
   1695            else
   1696            {
   1697              return HAL_BUSY; 
   \                     ??USART_Receive_IT_0: (+1)
   \   000000CC   0x2002             MOVS     R0,#+2
   \                     ??USART_Receive_IT_8: (+1)
   \   000000CE   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1698            }
   1699          }
   1700          
   1701          /**
   1702            * @brief  Full-Duplex Send receive an amount of data in full-duplex mode (non-blocking). 
   1703            * @param  husart: Pointer to a USART_HandleTypeDef structure that contains
   1704            *                 the configuration information for the specified USART module.
   1705            * @retval HAL status
   1706            */

   \                                 In section .text, align 2, keep-with-next
   1707          static HAL_StatusTypeDef USART_TransmitReceive_IT(USART_HandleTypeDef *husart)
   1708          {
   \                     USART_TransmitReceive_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1709            uint16_t* tmp=0;
   \   00000004   0x2500             MOVS     R5,#+0
   1710          
   1711            if(husart->State == HAL_USART_STATE_BUSY_TX_RX)
   \   00000006   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   0000000A   0x2832             CMP      R0,#+50
   \   0000000C   0xF040 0x8085      BNE.W    ??USART_TransmitReceive_IT_0
   1712            {
   1713              if(husart->TxXferCount != 0x00)
   \   00000010   0x8D60             LDRH     R0,[R4, #+42]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD02B             BEQ.N    ??USART_TransmitReceive_IT_1
   1714              {
   1715                if(__HAL_USART_GET_FLAG(husart, USART_FLAG_TXE) != RESET)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x0600             LSLS     R0,R0,#+24
   \   0000001C   0xD527             BPL.N    ??USART_TransmitReceive_IT_1
   1716                {
   1717                  if(husart->Init.WordLength == USART_WORDLENGTH_9B)
   \   0000001E   0x68A0             LDR      R0,[R4, #+8]
   \   00000020   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000024   0xD111             BNE.N    ??USART_TransmitReceive_IT_2
   1718                  {
   1719                    tmp = (uint16_t*) husart->pTxBuffPtr;
   \   00000026   0x6A60             LDR      R0,[R4, #+36]
   \   00000028   0x0005             MOVS     R5,R0
   1720                    WRITE_REG(husart->Instance->DR, (uint16_t)(*tmp & (uint16_t)0x01FF));
   \   0000002A   0x8828             LDRH     R0,[R5, #+0]
   \   0000002C   0x05C0             LSLS     R0,R0,#+23       ;; ZeroExtS R0,R0,#+23,#+23
   \   0000002E   0x0DC0             LSRS     R0,R0,#+23
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x6048             STR      R0,[R1, #+4]
   1721                    if(husart->Init.Parity == USART_PARITY_NONE)
   \   00000034   0x6920             LDR      R0,[R4, #+16]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD103             BNE.N    ??USART_TransmitReceive_IT_3
   1722                    {
   1723                      husart->pTxBuffPtr += 2;
   \   0000003A   0x6A60             LDR      R0,[R4, #+36]
   \   0000003C   0x1C80             ADDS     R0,R0,#+2
   \   0000003E   0x6260             STR      R0,[R4, #+36]
   \   00000040   0xE009             B.N      ??USART_TransmitReceive_IT_4
   1724                    }
   1725                    else
   1726                    {
   1727                      husart->pTxBuffPtr += 1;
   \                     ??USART_TransmitReceive_IT_3: (+1)
   \   00000042   0x6A60             LDR      R0,[R4, #+36]
   \   00000044   0x1C40             ADDS     R0,R0,#+1
   \   00000046   0x6260             STR      R0,[R4, #+36]
   \   00000048   0xE005             B.N      ??USART_TransmitReceive_IT_4
   1728                    }
   1729                  } 
   1730                  else
   1731                  {
   1732                    WRITE_REG(husart->Instance->DR, (uint8_t)(*husart->pTxBuffPtr++ & (uint8_t)0x00FF));
   \                     ??USART_TransmitReceive_IT_2: (+1)
   \   0000004A   0x6A60             LDR      R0,[R4, #+36]
   \   0000004C   0x1C41             ADDS     R1,R0,#+1
   \   0000004E   0x6261             STR      R1,[R4, #+36]
   \   00000050   0x7800             LDRB     R0,[R0, #+0]
   \   00000052   0x6821             LDR      R1,[R4, #+0]
   \   00000054   0x6048             STR      R0,[R1, #+4]
   1733                  }
   1734                  husart->TxXferCount--;
   \                     ??USART_TransmitReceive_IT_4: (+1)
   \   00000056   0x8D60             LDRH     R0,[R4, #+42]
   \   00000058   0x1E40             SUBS     R0,R0,#+1
   \   0000005A   0x8560             STRH     R0,[R4, #+42]
   1735          
   1736                  /* Check the latest data transmitted */
   1737                  if(husart->TxXferCount == 0)
   \   0000005C   0x8D60             LDRH     R0,[R4, #+42]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD105             BNE.N    ??USART_TransmitReceive_IT_1
   1738                  {
   1739                     __HAL_USART_DISABLE_IT(husart, USART_IT_TXE);
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x68C0             LDR      R0,[R0, #+12]
   \   00000066   0xF030 0x0080      BICS     R0,R0,#0x80
   \   0000006A   0x6821             LDR      R1,[R4, #+0]
   \   0000006C   0x60C8             STR      R0,[R1, #+12]
   1740                  }
   1741                }
   1742              }
   1743          
   1744              if(husart->RxXferCount != 0x00)
   \                     ??USART_TransmitReceive_IT_1: (+1)
   \   0000006E   0x8E60             LDRH     R0,[R4, #+50]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD033             BEQ.N    ??USART_TransmitReceive_IT_5
   1745              {
   1746                if(__HAL_USART_GET_FLAG(husart, USART_FLAG_RXNE) != RESET)
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0x0680             LSLS     R0,R0,#+26
   \   0000007A   0xD52F             BPL.N    ??USART_TransmitReceive_IT_5
   1747                {
   1748                  if(husart->Init.WordLength == USART_WORDLENGTH_9B)
   \   0000007C   0x68A0             LDR      R0,[R4, #+8]
   \   0000007E   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000082   0xD116             BNE.N    ??USART_TransmitReceive_IT_6
   1749                  {
   1750                    tmp = (uint16_t*) husart->pRxBuffPtr;
   \   00000084   0x6AE0             LDR      R0,[R4, #+44]
   \   00000086   0x0005             MOVS     R5,R0
   1751                    if(husart->Init.Parity == USART_PARITY_NONE)
   \   00000088   0x6920             LDR      R0,[R4, #+16]
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD108             BNE.N    ??USART_TransmitReceive_IT_7
   1752                    {
   1753                      *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x01FF);
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0x6840             LDR      R0,[R0, #+4]
   \   00000092   0x05C0             LSLS     R0,R0,#+23       ;; ZeroExtS R0,R0,#+23,#+23
   \   00000094   0x0DC0             LSRS     R0,R0,#+23
   \   00000096   0x8028             STRH     R0,[R5, #+0]
   1754                      husart->pRxBuffPtr += 2;
   \   00000098   0x6AE0             LDR      R0,[R4, #+44]
   \   0000009A   0x1C80             ADDS     R0,R0,#+2
   \   0000009C   0x62E0             STR      R0,[R4, #+44]
   \   0000009E   0xE01A             B.N      ??USART_TransmitReceive_IT_8
   1755                    }
   1756                    else
   1757                    {
   1758                      *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x00FF);
   \                     ??USART_TransmitReceive_IT_7: (+1)
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x6840             LDR      R0,[R0, #+4]
   \   000000A4   0xF000 0x00FF      AND      R0,R0,#0xFF
   \   000000A8   0x8028             STRH     R0,[R5, #+0]
   1759                      husart->pRxBuffPtr += 1;
   \   000000AA   0x6AE0             LDR      R0,[R4, #+44]
   \   000000AC   0x1C40             ADDS     R0,R0,#+1
   \   000000AE   0x62E0             STR      R0,[R4, #+44]
   \   000000B0   0xE011             B.N      ??USART_TransmitReceive_IT_8
   1760                    }
   1761                  } 
   1762                  else
   1763                  {
   1764                    if(husart->Init.Parity == USART_PARITY_NONE)
   \                     ??USART_TransmitReceive_IT_6: (+1)
   \   000000B2   0x6920             LDR      R0,[R4, #+16]
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD106             BNE.N    ??USART_TransmitReceive_IT_9
   1765                    {
   1766                      *husart->pRxBuffPtr++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x00FF);
   \   000000B8   0x6AE0             LDR      R0,[R4, #+44]
   \   000000BA   0x1C41             ADDS     R1,R0,#+1
   \   000000BC   0x62E1             STR      R1,[R4, #+44]
   \   000000BE   0x6821             LDR      R1,[R4, #+0]
   \   000000C0   0x6849             LDR      R1,[R1, #+4]
   \   000000C2   0x7001             STRB     R1,[R0, #+0]
   \   000000C4   0xE007             B.N      ??USART_TransmitReceive_IT_8
   1767                    }
   1768                    else
   1769                    {
   1770                      *husart->pRxBuffPtr++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x007F);
   \                     ??USART_TransmitReceive_IT_9: (+1)
   \   000000C6   0x6AE0             LDR      R0,[R4, #+44]
   \   000000C8   0x1C41             ADDS     R1,R0,#+1
   \   000000CA   0x62E1             STR      R1,[R4, #+44]
   \   000000CC   0x6821             LDR      R1,[R4, #+0]
   \   000000CE   0x6849             LDR      R1,[R1, #+4]
   \   000000D0   0xF011 0x017F      ANDS     R1,R1,#0x7F
   \   000000D4   0x7001             STRB     R1,[R0, #+0]
   1771                    }
   1772                  }
   1773                  husart->RxXferCount--;
   \                     ??USART_TransmitReceive_IT_8: (+1)
   \   000000D6   0x8E60             LDRH     R0,[R4, #+50]
   \   000000D8   0x1E40             SUBS     R0,R0,#+1
   \   000000DA   0x8660             STRH     R0,[R4, #+50]
   1774                }
   1775              }
   1776          
   1777              /* Check the latest data received */
   1778              if(husart->RxXferCount == 0)
   \                     ??USART_TransmitReceive_IT_5: (+1)
   \   000000DC   0x8E60             LDRH     R0,[R4, #+50]
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xD119             BNE.N    ??USART_TransmitReceive_IT_10
   1779              {
   1780                __HAL_USART_DISABLE_IT(husart, USART_IT_RXNE);
   \   000000E2   0x6820             LDR      R0,[R4, #+0]
   \   000000E4   0x68C0             LDR      R0,[R0, #+12]
   \   000000E6   0xF030 0x0020      BICS     R0,R0,#0x20
   \   000000EA   0x6821             LDR      R1,[R4, #+0]
   \   000000EC   0x60C8             STR      R0,[R1, #+12]
   1781          
   1782                /* Disable the USART Parity Error Interrupt */
   1783                __HAL_USART_DISABLE_IT(husart, USART_IT_PE);
   \   000000EE   0x6820             LDR      R0,[R4, #+0]
   \   000000F0   0x68C0             LDR      R0,[R0, #+12]
   \   000000F2   0xF430 0x7080      BICS     R0,R0,#0x100
   \   000000F6   0x6821             LDR      R1,[R4, #+0]
   \   000000F8   0x60C8             STR      R0,[R1, #+12]
   1784          
   1785                /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error) */
   1786                __HAL_USART_DISABLE_IT(husart, USART_IT_ERR);
   \   000000FA   0x6820             LDR      R0,[R4, #+0]
   \   000000FC   0x6940             LDR      R0,[R0, #+20]
   \   000000FE   0x0840             LSRS     R0,R0,#+1
   \   00000100   0x0040             LSLS     R0,R0,#+1
   \   00000102   0x6821             LDR      R1,[R4, #+0]
   \   00000104   0x6148             STR      R0,[R1, #+20]
   1787          
   1788                husart->State = HAL_USART_STATE_READY;
   \   00000106   0x2001             MOVS     R0,#+1
   \   00000108   0xF884 0x003D      STRB     R0,[R4, #+61]
   1789          
   1790                HAL_USART_TxRxCpltCallback(husart);
   \   0000010C   0x0020             MOVS     R0,R4
   \   0000010E   0x.... 0x....      BL       HAL_USART_TxRxCpltCallback
   1791          
   1792                return HAL_OK;
   \   00000112   0x2000             MOVS     R0,#+0
   \   00000114   0xE002             B.N      ??USART_TransmitReceive_IT_11
   1793              }
   1794          
   1795              return HAL_OK;
   \                     ??USART_TransmitReceive_IT_10: (+1)
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0xE000             B.N      ??USART_TransmitReceive_IT_11
   1796            }
   1797            else
   1798            {
   1799              return HAL_BUSY; 
   \                     ??USART_TransmitReceive_IT_0: (+1)
   \   0000011A   0x2002             MOVS     R0,#+2
   \                     ??USART_TransmitReceive_IT_11: (+1)
   \   0000011C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1800            }
   1801          }
   1802          
   1803          /**
   1804            * @brief  Configures the USART peripheral. 
   1805            * @param  husart: Pointer to a USART_HandleTypeDef structure that contains
   1806            *                 the configuration information for the specified USART module.
   1807            * @retval None
   1808            */

   \                                 In section .text, align 2, keep-with-next
   1809          static void USART_SetConfig(USART_HandleTypeDef *husart)
   1810          {
   \                     USART_SetConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1811            /* Check the parameters */
   1812            assert_param(IS_USART_POLARITY(husart->Init.CLKPolarity));
   1813            assert_param(IS_USART_PHASE(husart->Init.CLKPhase));
   1814            assert_param(IS_USART_LASTBIT(husart->Init.CLKLastBit));
   1815            assert_param(IS_USART_BAUDRATE(husart->Init.BaudRate));  
   1816            assert_param(IS_USART_WORD_LENGTH(husart->Init.WordLength));
   1817            assert_param(IS_USART_STOPBITS(husart->Init.StopBits));
   1818            assert_param(IS_USART_PARITY(husart->Init.Parity));
   1819            assert_param(IS_USART_MODE(husart->Init.Mode));
   1820          
   1821            /* The LBCL, CPOL and CPHA bits have to be selected when both the transmitter and the
   1822               receiver are disabled (TE=RE=0) to ensure that the clock pulses function correctly. */
   1823            CLEAR_BIT(husart->Instance->CR1, ((uint32_t)(USART_CR1_TE | USART_CR1_RE)));
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x68C0             LDR      R0,[R0, #+12]
   \   00000008   0xF030 0x000C      BICS     R0,R0,#0xC
   \   0000000C   0x6821             LDR      R1,[R4, #+0]
   \   0000000E   0x60C8             STR      R0,[R1, #+12]
   1824          
   1825            /*---------------------------- USART CR2 Configuration ---------------------*/
   1826            /* Configure the USART Clock, CPOL, CPHA and LastBit -----------------------*/
   1827            /* Set CPOL bit according to husart->Init.CLKPolarity value */
   1828            /* Set CPHA bit according to husart->Init.CLKPhase value */
   1829            /* Set LBCL bit according to husart->Init.CLKLastBit value */
   1830            /* Set Stop Bits: Set STOP[13:12] bits according to husart->Init.StopBits value */
   1831            /* Write to USART CR2 */
   1832            MODIFY_REG(husart->Instance->CR2, 
   1833                       (uint32_t)(USART_CR2_CPHA | USART_CR2_CPOL | USART_CR2_CLKEN | USART_CR2_LBCL | USART_CR2_STOP),
   1834                       ((uint32_t)(USART_CLOCK_ENABLE| husart->Init.CLKPolarity | husart->Init.CLKPhase| husart->Init.CLKLastBit | husart->Init.StopBits)));
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x6900             LDR      R0,[R0, #+16]
   \   00000014   0xF430 0x507C      BICS     R0,R0,#0x3F00
   \   00000018   0x69A1             LDR      R1,[R4, #+24]
   \   0000001A   0x4308             ORRS     R0,R1,R0
   \   0000001C   0x69E1             LDR      R1,[R4, #+28]
   \   0000001E   0x4308             ORRS     R0,R1,R0
   \   00000020   0x6A21             LDR      R1,[R4, #+32]
   \   00000022   0x4308             ORRS     R0,R1,R0
   \   00000024   0x68E1             LDR      R1,[R4, #+12]
   \   00000026   0x4308             ORRS     R0,R1,R0
   \   00000028   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   0000002C   0x6821             LDR      R1,[R4, #+0]
   \   0000002E   0x6108             STR      R0,[R1, #+16]
   1835          
   1836            /*-------------------------- USART CR1 Configuration -----------------------*/
   1837            /* Configure the USART Word Length, Parity and mode: 
   1838               Set the M bits according to husart->Init.WordLength value 
   1839               Set PCE and PS bits according to husart->Init.Parity value
   1840               Set TE and RE bits according to husart->Init.Mode value
   1841               Force OVER8 bit to 1 in order to reach the max USART frequencies */
   1842            MODIFY_REG(husart->Instance->CR1, 
   1843                       (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
   1844                       (uint32_t)husart->Init.WordLength | husart->Init.Parity | husart->Init.Mode | USART_CR1_OVER8);
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x68C0             LDR      R0,[R0, #+12]
   \   00000034   0x....             LDR.N    R1,??DataTable0  ;; 0xffff69f3
   \   00000036   0x4008             ANDS     R0,R1,R0
   \   00000038   0x68A1             LDR      R1,[R4, #+8]
   \   0000003A   0x4308             ORRS     R0,R1,R0
   \   0000003C   0x6921             LDR      R1,[R4, #+16]
   \   0000003E   0x4308             ORRS     R0,R1,R0
   \   00000040   0x6961             LDR      R1,[R4, #+20]
   \   00000042   0x4308             ORRS     R0,R1,R0
   \   00000044   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   00000048   0x6821             LDR      R1,[R4, #+0]
   \   0000004A   0x60C8             STR      R0,[R1, #+12]
   1845          
   1846            /*-------------------------- USART CR3 Configuration -----------------------*/  
   1847            /* Clear CTSE and RTSE bits */
   1848            CLEAR_BIT(husart->Instance->CR3, (uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE));
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6940             LDR      R0,[R0, #+20]
   \   00000050   0xF430 0x7040      BICS     R0,R0,#0x300
   \   00000054   0x6821             LDR      R1,[R4, #+0]
   \   00000056   0x6148             STR      R0,[R1, #+20]
   1849          
   1850            /*-------------------------- USART BRR Configuration -----------------------*/
   1851            if((husart->Instance == USART1))
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x....             LDR.N    R1,??DataTable0_1  ;; 0x40013800
   \   0000005C   0x4288             CMP      R0,R1
   \   0000005E   0xD130             BNE.N    ??USART_SetConfig_0
   1852            {
   1853              husart->Instance->BRR = USART_BRR(HAL_RCC_GetPCLK2Freq(), husart->Init.BaudRate);
   \   00000060   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   00000064   0x0006             MOVS     R6,R0
   \   00000066   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   0000006A   0x0005             MOVS     R5,R0
   \   0000006C   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   00000070   0x2119             MOVS     R1,#+25
   \   00000072   0xFB01 0xF106      MUL      R1,R1,R6
   \   00000076   0x6862             LDR      R2,[R4, #+4]
   \   00000078   0x0052             LSLS     R2,R2,#+1
   \   0000007A   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   0000007E   0x2264             MOVS     R2,#+100
   \   00000080   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000084   0x2219             MOVS     R2,#+25
   \   00000086   0xFB02 0xF205      MUL      R2,R2,R5
   \   0000008A   0x6863             LDR      R3,[R4, #+4]
   \   0000008C   0x005B             LSLS     R3,R3,#+1
   \   0000008E   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   00000092   0x2319             MOVS     R3,#+25
   \   00000094   0x4358             MULS     R0,R3,R0
   \   00000096   0x6863             LDR      R3,[R4, #+4]
   \   00000098   0x005B             LSLS     R3,R3,#+1
   \   0000009A   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   0000009E   0x2364             MOVS     R3,#+100
   \   000000A0   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   000000A4   0x2364             MOVS     R3,#+100
   \   000000A6   0xFB03 0x2010      MLS      R0,R3,R0,R2
   \   000000AA   0x0100             LSLS     R0,R0,#+4
   \   000000AC   0x3032             ADDS     R0,R0,#+50
   \   000000AE   0x2264             MOVS     R2,#+100
   \   000000B0   0xFBB0 0xF0F2      UDIV     R0,R0,R2
   \   000000B4   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   000000B8   0xEA50 0x1001      ORRS     R0,R0,R1, LSL #+4
   \   000000BC   0x6821             LDR      R1,[R4, #+0]
   \   000000BE   0x6088             STR      R0,[R1, #+8]
   \   000000C0   0xE02F             B.N      ??USART_SetConfig_1
   1854            }
   1855            else
   1856            {
   1857              husart->Instance->BRR = USART_BRR(HAL_RCC_GetPCLK1Freq(), husart->Init.BaudRate);
   \                     ??USART_SetConfig_0: (+1)
   \   000000C2   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   000000C6   0x0006             MOVS     R6,R0
   \   000000C8   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   000000CC   0x0005             MOVS     R5,R0
   \   000000CE   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   000000D2   0x2119             MOVS     R1,#+25
   \   000000D4   0xFB01 0xF106      MUL      R1,R1,R6
   \   000000D8   0x6862             LDR      R2,[R4, #+4]
   \   000000DA   0x0052             LSLS     R2,R2,#+1
   \   000000DC   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   000000E0   0x2264             MOVS     R2,#+100
   \   000000E2   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   000000E6   0x2219             MOVS     R2,#+25
   \   000000E8   0xFB02 0xF205      MUL      R2,R2,R5
   \   000000EC   0x6863             LDR      R3,[R4, #+4]
   \   000000EE   0x005B             LSLS     R3,R3,#+1
   \   000000F0   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   000000F4   0x2319             MOVS     R3,#+25
   \   000000F6   0x4358             MULS     R0,R3,R0
   \   000000F8   0x6863             LDR      R3,[R4, #+4]
   \   000000FA   0x005B             LSLS     R3,R3,#+1
   \   000000FC   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   00000100   0x2364             MOVS     R3,#+100
   \   00000102   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   00000106   0x2364             MOVS     R3,#+100
   \   00000108   0xFB03 0x2010      MLS      R0,R3,R0,R2
   \   0000010C   0x0100             LSLS     R0,R0,#+4
   \   0000010E   0x3032             ADDS     R0,R0,#+50
   \   00000110   0x2264             MOVS     R2,#+100
   \   00000112   0xFBB0 0xF0F2      UDIV     R0,R0,R2
   \   00000116   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   0000011A   0xEA50 0x1001      ORRS     R0,R0,R1, LSL #+4
   \   0000011E   0x6821             LDR      R1,[R4, #+0]
   \   00000120   0x6088             STR      R0,[R1, #+8]
   1858            }
   1859          }
   \                     ??USART_SetConfig_1: (+1)
   \   00000122   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0xFFFF69F3         DC32     0xffff69f3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0x40013800         DC32     0x40013800
   1860          
   1861          /**
   1862            * @}
   1863            */
   1864          
   1865          #endif /* HAL_USART_MODULE_ENABLED */
   1866          /**
   1867            * @}
   1868            */
   1869          
   1870          /**
   1871            * @}
   1872            */
   1873          
   1874          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_USART_DMAPause
       0   HAL_USART_DMAResume
       8   HAL_USART_DMAStop
         8   -> HAL_DMA_Abort
       8   HAL_USART_DeInit
         8   -> HAL_USART_MspDeInit
       0   HAL_USART_ErrorCallback
       0   HAL_USART_GetError
       0   HAL_USART_GetState
      24   HAL_USART_IRQHandler
        24   -> HAL_USART_ErrorCallback
        24   -> USART_EndTransmit_IT
        24   -> USART_Receive_IT
        24   -> USART_TransmitReceive_IT
        24   -> USART_Transmit_IT
       8   HAL_USART_Init
         8   -> HAL_USART_MspInit
         8   -> USART_SetConfig
       0   HAL_USART_MspDeInit
       0   HAL_USART_MspInit
      24   HAL_USART_Receive
        24   -> USART_WaitOnFlagUntilTimeout
      24   HAL_USART_Receive_DMA
        24   -> HAL_DMA_Start_IT
       4   HAL_USART_Receive_IT
       0   HAL_USART_RxCpltCallback
       0   HAL_USART_RxHalfCpltCallback
      24   HAL_USART_Transmit
        24   -> USART_WaitOnFlagUntilTimeout
      32   HAL_USART_TransmitReceive
        32   -> USART_WaitOnFlagUntilTimeout
      32   HAL_USART_TransmitReceive_DMA
        32   -> HAL_DMA_Start_IT
       8   HAL_USART_TransmitReceive_IT
      24   HAL_USART_Transmit_DMA
        24   -> HAL_DMA_Start_IT
       4   HAL_USART_Transmit_IT
       0   HAL_USART_TxCpltCallback
       0   HAL_USART_TxHalfCpltCallback
       0   HAL_USART_TxRxCpltCallback
      16   USART_DMAError
        16   -> HAL_USART_ErrorCallback
      16   USART_DMAReceiveCplt
        16   -> HAL_USART_RxCpltCallback
        16   -> HAL_USART_TxRxCpltCallback
      16   USART_DMARxHalfCplt
        16   -> HAL_USART_RxHalfCpltCallback
      16   USART_DMATransmitCplt
        16   -> HAL_USART_TxCpltCallback
      16   USART_DMATxHalfCplt
        16   -> HAL_USART_TxHalfCpltCallback
       8   USART_EndTransmit_IT
         8   -> HAL_USART_TxCpltCallback
      16   USART_Receive_IT
        16   -> HAL_USART_RxCpltCallback
      16   USART_SetConfig
        16   -> HAL_RCC_GetPCLK1Freq
        16   -> HAL_RCC_GetPCLK2Freq
      16   USART_TransmitReceive_IT
        16   -> HAL_USART_TxRxCpltCallback
       0   USART_Transmit_IT
      24   USART_WaitOnFlagUntilTimeout
        24   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
      42  HAL_USART_DMAPause
      42  HAL_USART_DMAResume
      50  HAL_USART_DMAStop
      56  HAL_USART_DeInit
       2  HAL_USART_ErrorCallback
       4  HAL_USART_GetError
       6  HAL_USART_GetState
     356  HAL_USART_IRQHandler
      94  HAL_USART_Init
       2  HAL_USART_MspDeInit
       2  HAL_USART_MspInit
     276  HAL_USART_Receive
     184  HAL_USART_Receive_DMA
     120  HAL_USART_Receive_IT
       2  HAL_USART_RxCpltCallback
       2  HAL_USART_RxHalfCpltCallback
     210  HAL_USART_Transmit
     316  HAL_USART_TransmitReceive
     230  HAL_USART_TransmitReceive_DMA
     134  HAL_USART_TransmitReceive_IT
     146  HAL_USART_Transmit_DMA
      88  HAL_USART_Transmit_IT
       2  HAL_USART_TxCpltCallback
       2  HAL_USART_TxHalfCpltCallback
       2  HAL_USART_TxRxCpltCallback
      36  USART_DMAError
     102  USART_DMAReceiveCplt
      14  USART_DMARxHalfCplt
      68  USART_DMATransmitCplt
      14  USART_DMATxHalfCplt
      44  USART_EndTransmit_IT
     208  USART_Receive_IT
     292  USART_SetConfig
     286  USART_TransmitReceive_IT
     112  USART_Transmit_IT
     226  USART_WaitOnFlagUntilTimeout

 
 3 780 bytes in section .text
 
 3 764 bytes of CODE memory (+ 16 bytes shared)

Errors: none
Warnings: none
