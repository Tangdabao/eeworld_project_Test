###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       29/Jan/2018  14:45:25
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_flash_ex.c
#    Command line =  
#        "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_flash_ex.c"
#        -D STM32L151xB -D STM32L1XX_XL -D USE_STM32L1XX_STEVAL_IDB00xV1 -D
#        USE_HAL_DRIVER -D HCLK_32MHZ=1 -D SYSCLK_MSI=1 -D ENABLE_USART -D
#        USER_DEFINED_PLATFORM=USER_EVAL_PLATFORM -D IRQ_RESET_PIN -D DTM_UART
#        -lC "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\List"
#        -o "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        D:\Software\IAR_BlueNRG\arm\INC\c\DLib_Config_Normal.h -I
#        "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\HAL\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\BSP\STM32L1xx_BlueNRG1\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\BSP\STM32L1xx_Nucleo\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\CMSIS\Device\ST\STM32L1xx\Include\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\STM32L1xx_HAL_BlueNRG1_Drivers\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\SimpleBlueNRG1_HCI\includes\"
#        -On --use_c++_inline -I D:\Software\IAR_BlueNRG\arm\CMSIS\Include\
#    Locale       =  Chinese (Simplified)_China.936
#    List file    =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\List\stm32l1xx_hal_flash_ex.lst
#    Object file  =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\Obj\stm32l1xx_hal_flash_ex.o
#
###############################################################################

C:\Users\Administrator\Desktop\Temporary Files\eeworld_project\Project_Test\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_flash_ex.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_hal_flash_ex.c
      4            * @author  MCD Application Team
      5            * @version V1.1.1
      6            * @date    31-March-2015
      7            * @brief   Extended FLASH HAL module driver.
      8            *    
      9            *          This file provides firmware functions to manage the following 
     10            *          functionalities of the internal FLASH memory:
     11            *            + FLASH Interface configuration
     12            *            + FLASH Memory Erasing
     13            *            + DATA EEPROM Programming/Erasing
     14            *            + Option Bytes Programming
     15            *            + Interrupts management
     16            *    
     17            @verbatim
     18            ==============================================================================
     19                         ##### Flash peripheral Extended features  #####
     20            ==============================================================================
     21                     
     22            [..] Comparing to other products, the FLASH interface for STM32L1xx
     23                 devices contains the following additional features        
     24                 (+) Erase functions
     25                 (+) DATA_EEPROM memory management
     26                 (+) BOOT option bit configuration       
     27                 (+) PCROP protection for all sectors
     28             
     29                                ##### How to use this driver #####
     30            ==============================================================================
     31            [..] This driver provides functions to configure and program the FLASH memory 
     32                 of all STM32L1xx. It includes:       
     33                 (+) Full DATA_EEPROM erase and program management
     34                 (+) Boot activation
     35                 (+) PCROP protection configuration and control for all pages
     36            
     37            @endverbatim
     38            ******************************************************************************
     39            * @attention
     40            *
     41            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     42            *
     43            * Redistribution and use in source and binary forms, with or without modification,
     44            * are permitted provided that the following conditions are met:
     45            *   1. Redistributions of source code must retain the above copyright notice,
     46            *      this list of conditions and the following disclaimer.
     47            *   2. Redistributions in binary form must reproduce the above copyright notice,
     48            *      this list of conditions and the following disclaimer in the documentation
     49            *      and/or other materials provided with the distribution.
     50            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     51            *      may be used to endorse or promote products derived from this software
     52            *      without specific prior written permission.
     53            *
     54            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     55            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     56            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     57            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     58            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     59            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     60            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     61            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     62            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     63            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     64            *
     65            ******************************************************************************  
     66            */ 
     67          
     68          /* Includes ------------------------------------------------------------------*/
     69          #include "stm32l1xx_hal.h"
     70          
     71          /** @addtogroup STM32L1xx_HAL_Driver
     72            * @{
     73            */
     74          #ifdef HAL_FLASH_MODULE_ENABLED
     75          
     76          /** @addtogroup FLASH
     77            * @{
     78            */
     79          /** @addtogroup FLASH_Private_Variables
     80           * @{
     81           */
     82          /* Variables used for Erase pages under interruption*/
     83          extern FLASH_ProcessTypeDef pFlash;
     84          /**
     85            * @}
     86            */
     87          
     88          /**
     89            * @}
     90            */
     91            
     92          /** @defgroup FLASHEx FLASHEx
     93            * @brief FLASH HAL Extension module driver
     94            * @{
     95            */
     96          
     97          /* Private typedef -----------------------------------------------------------*/
     98          /* Private define ------------------------------------------------------------*/
     99          /** @defgroup FLASHEx_Private_Defines Private Defines
    100           * @{
    101           */
    102          /**
    103            * @}
    104            */
    105          
    106          /* Private macro -------------------------------------------------------------*/
    107          /** @defgroup FLASHEx_Private_Macros Private Macros
    108            * @{
    109            */
    110          /**
    111            * @}
    112            */ 
    113          
    114          /* Private variables ---------------------------------------------------------*/
    115          /* Private function prototypes -----------------------------------------------*/
    116          /** @defgroup FLASHEx_Private_Functions Private Functions
    117           * @{
    118           */
    119          static void               FLASH_SetErrorCode(void);
    120          static void               FLASH_ErasePage(uint32_t PageAddress);
    121          
    122          static HAL_StatusTypeDef  FLASH_OB_WRPConfig(FLASH_OBProgramInitTypeDef *pOBInit, FunctionalState NewState);
    123          static void               FLASH_OB_WRPConfigWRP1OrPCROP1(uint32_t WRP1OrPCROP1, FunctionalState NewState);
    124          #if defined(STM32L100xC) || defined (STM32L151xC) || defined (STM32L152xC) || defined (STM32L162xC) || \
    125              defined(STM32L151xCA) || defined(STM32L151xD) || defined(STM32L151xDX) || defined (STM32L152xCA) || \
    126              defined(STM32L152xD) || defined(STM32L152xDX) || defined (STM32L162xCA) || defined(STM32L162xD)  || \
    127              defined(STM32L162xDX) || defined(STM32L151xE) || defined (STM32L152xE) || defined (STM32L162xE)
    128          static void               FLASH_OB_WRPConfigWRP2OrPCROP2(uint32_t WRP2OrPCROP2, FunctionalState NewState);
    129          #endif /* STM32L100xC || STM32L151xC || STM32L152xC || (...) || STM32L151xE || STM32L152xE || STM32L162xE */
    130          #if defined(STM32L151xD) || defined(STM32L151xDX) || defined(STM32L152xD) || defined(STM32L152xDX) || \
    131              defined(STM32L162xD) || defined(STM32L162xDX) || defined(STM32L151xE) || defined (STM32L152xE) || \
    132              defined (STM32L162xE)
    133          static void               FLASH_OB_WRPConfigWRP3(uint32_t WRP3, FunctionalState NewState);
    134          #endif /* STM32L151xD || STM32L152xD || STM32L162xD || STM32L151xE || STM32L152xE || STM32L162xE */
    135          #if defined(STM32L151xE) || defined (STM32L152xE) || defined (STM32L162xE) || \
    136              defined(STM32L151xDX) || defined(STM32L152xDX) || defined(STM32L162xDX)
    137          static void               FLASH_OB_WRPConfigWRP4(uint32_t WRP4, FunctionalState NewState);
    138          #endif /* STM32L151xE || STM32L152xE || STM32L162xE || STM32L151xDX || ... */
    139          static HAL_StatusTypeDef  FLASH_OB_RDPConfig(uint8_t OB_RDP);
    140          static HAL_StatusTypeDef  FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY);
    141          static HAL_StatusTypeDef  FLASH_OB_BORConfig(uint8_t OB_BOR);
    142          static uint8_t            FLASH_OB_GetRDP(void);
    143          static uint8_t            FLASH_OB_GetUser(void);
    144          static uint8_t            FLASH_OB_GetBOR(void);
    145          #if defined (STM32L151xBA) || defined (STM32L152xBA) || \
    146              defined (STM32L151xC) || defined (STM32L152xC) || defined (STM32L162xC)
    147          static HAL_StatusTypeDef  FLASH_OB_PCROPConfig(FLASH_AdvOBProgramInitTypeDef *pAdvOBInit, FunctionalState NewState);
    148          #endif /* STM32L151xBA || STM32L152xBA || STM32L151xC || STM32L152xC || STM32L162xC */
    149          #if defined(STM32L151xD) || defined(STM32L151xDX) || defined(STM32L152xD) || defined(STM32L152xDX) || \
    150              defined(STM32L162xD) || defined(STM32L162xDX) || defined(STM32L151xE) || defined (STM32L152xE) || \
    151              defined (STM32L162xE)
    152          static HAL_StatusTypeDef  FLASH_OB_BootConfig(uint8_t OB_BOOT);
    153          #endif /* STM32L151xD || STM32L152xD || STM32L162xD || STM32L151xE || STM32L152xE || STM32L162xE */
    154          
    155          static HAL_StatusTypeDef  FLASH_DATAEEPROM_FastProgramByte(uint32_t Address, uint8_t Data);
    156          static HAL_StatusTypeDef  FLASH_DATAEEPROM_FastProgramHalfWord(uint32_t Address, uint16_t Data);
    157          static HAL_StatusTypeDef  FLASH_DATAEEPROM_FastProgramWord(uint32_t Address, uint32_t Data);
    158          static HAL_StatusTypeDef  FLASH_DATAEEPROM_ProgramWord(uint32_t Address, uint32_t Data);
    159          static HAL_StatusTypeDef  FLASH_DATAEEPROM_ProgramHalfWord(uint32_t Address, uint16_t Data);
    160          static HAL_StatusTypeDef  FLASH_DATAEEPROM_ProgramByte(uint32_t Address, uint8_t Data);
    161          /**
    162            * @}
    163            */
    164          
    165          /* Exported functions ---------------------------------------------------------*/
    166          /** @defgroup FLASHEx_Exported_Functions Exported Functions
    167            * @{
    168            */
    169          
    170          /** @defgroup FLASHEx_Exported_Functions_Group1 FLASH Memory Erasing functions
    171           *  @brief   FLASH Memory Erasing functions
    172           *
    173          @verbatim   
    174            ==============================================================================
    175                          ##### FLASH Erasing Programming functions ##### 
    176            ==============================================================================
    177          
    178              [..] The FLASH Memory Erasing functions, includes the following functions:
    179              (+) HAL_FLASHEx_Erase: return only when erase has been done
    180              (+) HAL_FLASHEx_Erase_IT: end of erase is done when HAL_FLASH_EndOfOperationCallback is called with parameter
    181                  0xFFFFFFFF
    182          
    183              [..] Any operation of erase should follow these steps:
    184              (#) Call the HAL_FLASH_Unlock() function to enable the flash control register and 
    185                  program memory access.
    186              (#) Call the desired function to erase page.
    187              (#) Call the HAL_FLASH_Lock() to disable the flash program memory access 
    188                 (recommended to protect the FLASH memory against possible unwanted operation).
    189          
    190          @endverbatim
    191            * @{
    192            */
    193            
    194          /**
    195            * @brief  Erase the specified FLASH memory Pages 
    196            * @note   To correctly run this function, the HAL_FLASH_Unlock() function
    197            *         must be called before.
    198            *         Call the HAL_FLASH_Lock() to disable the flash memory access 
    199            *         (recommended to protect the FLASH memory against possible unwanted operation)
    200            * @note   For STM32L151xDX/STM32L152xDX/STM32L162xDX, as memory is not continuous between
    201            *         2 banks, user should perform pages erase by bank only.
    202            * @param[in]  pEraseInit: pointer to an FLASH_EraseInitTypeDef structure that
    203            *         contains the configuration information for the erasing.
    204            * 
    205            * @param[out]  PageError: pointer to variable  that
    206            *         contains the configuration information on faulty sector in case of error 
    207            *         (0xFFFFFFFF means that all the sectors have been correctly erased)
    208            * 
    209            * @retval HAL_StatusTypeDef HAL Status
    210            */

   \                                 In section .text, align 2, keep-with-next
    211          HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *PageError)
    212          {
   \                     HAL_FLASHEx_Erase: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    213            HAL_StatusTypeDef status = HAL_ERROR;
   \   00000006   0x2601             MOVS     R6,#+1
    214            uint32_t index = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    215            
    216            /* Process Locked */
    217            __HAL_LOCK(&pFlash);
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable24
   \   0000000E   0x7C00             LDRB     R0,[R0, #+16]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD101             BNE.N    ??HAL_FLASHEx_Erase_0
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xE03E             B.N      ??HAL_FLASHEx_Erase_1
   \                     ??HAL_FLASHEx_Erase_0: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable24
   \   0000001E   0x7408             STRB     R0,[R1, #+16]
    218          
    219            /* Wait for last operation to be completed */
    220            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   00000020   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000024   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000028   0x0006             MOVS     R6,R0
    221          
    222            if (status == HAL_OK)
   \   0000002A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002C   0x2E00             CMP      R6,#+0
   \   0000002E   0xD12C             BNE.N    ??HAL_FLASHEx_Erase_2
    223            {
    224              /*Initialization of PageError variable*/
    225              *PageError = 0xFFFFFFFF;
   \   00000030   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000034   0x6028             STR      R0,[R5, #+0]
    226          
    227              /* Check the parameters */
    228              assert_param(IS_NBPAGES(pEraseInit->NbPages));
    229              assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
    230              assert_param(IS_FLASH_PROGRAM_ADDRESS(pEraseInit->PageAddress));
    231              assert_param(IS_FLASH_PROGRAM_ADDRESS((pEraseInit->PageAddress & ~(FLASH_PAGE_SIZE - 1)) + pEraseInit->NbPages * FLASH_PAGE_SIZE - 1));
    232          
    233          #if defined(STM32L151xDX) || defined(STM32L152xDX) || defined(STM32L162xDX)
    234              /* Check on which bank belongs the 1st address to erase */
    235              if (pEraseInit->PageAddress < FLASH_BANK2_BASE)
    236              {
    237                /* BANK1 */
    238                /* Check that last page to erase still belongs to BANK1 */
    239                if (((pEraseInit->PageAddress & ~(FLASH_PAGE_SIZE - 1)) + pEraseInit->NbPages * FLASH_PAGE_SIZE - 1) > FLASH_BANK1_END)
    240                {
    241                  /*  Last page does not belong to BANK1, erase procedure cannot be performed because memory is not
    242                      continuous */
    243                  /* Process Unlocked */
    244                  __HAL_UNLOCK(&pFlash);
    245                  return HAL_ERROR;
    246                }
    247              }
    248              else
    249              {
    250                /* BANK2 */
    251                /* Check that last page to erase still belongs to BANK2 */
    252                if (((pEraseInit->PageAddress & ~(FLASH_PAGE_SIZE - 1)) + pEraseInit->NbPages * FLASH_PAGE_SIZE - 1) > FLASH_BANK2_END)
    253                {
    254                  /*  Last page does not belong to BANK2, erase procedure cannot be performed because memory is not
    255                      continuous */
    256                  /* Process Unlocked */
    257                  __HAL_UNLOCK(&pFlash);
    258                  return HAL_ERROR;
    259                }
    260              }
    261          #endif /* STM32L151xDX || STM32L152xDX || STM32L162xDX */
    262          
    263              /* Erase page by page to be done*/
    264              for(index = pEraseInit->PageAddress; index < ((pEraseInit->NbPages * FLASH_PAGE_SIZE)+ pEraseInit->PageAddress); index += FLASH_PAGE_SIZE)
   \   00000036   0x6860             LDR      R0,[R4, #+4]
   \   00000038   0x0007             MOVS     R7,R0
   \                     ??HAL_FLASHEx_Erase_3: (+1)
   \   0000003A   0x68A0             LDR      R0,[R4, #+8]
   \   0000003C   0xF44F 0x7180      MOV      R1,#+256
   \   00000040   0x6862             LDR      R2,[R4, #+4]
   \   00000042   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   00000046   0x4287             CMP      R7,R0
   \   00000048   0xD21F             BCS.N    ??HAL_FLASHEx_Erase_2
    265              {
    266                FLASH_ErasePage(index);
   \   0000004A   0x0038             MOVS     R0,R7
   \   0000004C   0x.... 0x....      BL       FLASH_ErasePage
    267          
    268                /* Wait for last operation to be completed */
    269                status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   00000050   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000054   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000058   0x0006             MOVS     R6,R0
    270          
    271                /* If the erase operation is completed, disable the ERASE Bit */
    272                CLEAR_BIT(FLASH->PECR, FLASH_PECR_PROG);
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x40023c04
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xF030 0x0008      BICS     R0,R0,#0x8
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable24_1  ;; 0x40023c04
   \   00000068   0x6008             STR      R0,[R1, #+0]
    273                CLEAR_BIT(FLASH->PECR, FLASH_PECR_ERASE);
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x40023c04
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0xF430 0x7000      BICS     R0,R0,#0x200
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable24_1  ;; 0x40023c04
   \   00000078   0x6008             STR      R0,[R1, #+0]
    274          
    275                if (status != HAL_OK) 
   \   0000007A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000007C   0x2E00             CMP      R6,#+0
   \   0000007E   0xD001             BEQ.N    ??HAL_FLASHEx_Erase_4
    276                {
    277                  /* In case of error, stop erase procedure and return the faulty sector*/
    278                  *PageError = index;
   \   00000080   0x602F             STR      R7,[R5, #+0]
    279                  break;
   \   00000082   0xE002             B.N      ??HAL_FLASHEx_Erase_2
    280                }
    281              }
   \                     ??HAL_FLASHEx_Erase_4: (+1)
   \   00000084   0xF517 0x7780      ADDS     R7,R7,#+256
   \   00000088   0xE7D7             B.N      ??HAL_FLASHEx_Erase_3
    282            }
    283          
    284            /* Process Unlocked */
    285            __HAL_UNLOCK(&pFlash);
   \                     ??HAL_FLASHEx_Erase_2: (+1)
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable24
   \   00000090   0x7408             STRB     R0,[R1, #+16]
    286          
    287            return status;
   \   00000092   0x0030             MOVS     R0,R6
   \   00000094   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_FLASHEx_Erase_1: (+1)
   \   00000096   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    288          }
    289          
    290          /**
    291            * @brief  Perform a page erase of the specified FLASH memory pages  with interrupt enabled
    292            * @note   To correctly run this function, the HAL_FLASH_Unlock() function
    293            *         must be called before.
    294            *         Call the HAL_FLASH_Lock() to disable the flash memory access 
    295            *         (recommended to protect the FLASH memory against possible unwanted operation)
    296            * @note   For STM32L151xDX/STM32L152xDX/STM32L162xDX, as memory is not continuous between
    297            *         2 banks, user should perform pages erase by bank only.
    298            * @param  pEraseInit: pointer to an FLASH_EraseInitTypeDef structure that
    299            *         contains the configuration information for the erasing.
    300            * 
    301            * @retval HAL_StatusTypeDef HAL Status
    302            */

   \                                 In section .text, align 2, keep-with-next
    303          HAL_StatusTypeDef HAL_FLASHEx_Erase_IT(FLASH_EraseInitTypeDef *pEraseInit)
    304          {
   \                     HAL_FLASHEx_Erase_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    305            HAL_StatusTypeDef status = HAL_OK;
   \   00000004   0x2500             MOVS     R5,#+0
    306          
    307            /* Check the parameters */
    308            assert_param(IS_NBPAGES(pEraseInit->NbPages));
    309            assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
    310            assert_param(IS_FLASH_PROGRAM_ADDRESS(pEraseInit->PageAddress));
    311            assert_param(IS_FLASH_PROGRAM_ADDRESS((pEraseInit->PageAddress & ~(FLASH_PAGE_SIZE - 1)) + pEraseInit->NbPages * FLASH_PAGE_SIZE - 1));
    312          
    313            /* Process Locked */
    314            __HAL_LOCK(&pFlash);
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable24
   \   0000000A   0x7C00             LDRB     R0,[R0, #+16]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_FLASHEx_Erase_IT_0
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE029             B.N      ??HAL_FLASHEx_Erase_IT_1
   \                     ??HAL_FLASHEx_Erase_IT_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable24
   \   0000001A   0x7408             STRB     R0,[R1, #+16]
    315          
    316          #if defined(STM32L151xDX) || defined(STM32L152xDX) || defined(STM32L162xDX)
    317              /* Check on which bank belongs the 1st address to erase */
    318              if (pEraseInit->PageAddress < FLASH_BANK2_BASE)
    319              {
    320                /* BANK1 */
    321                /* Check that last page to erase still belongs to BANK1 */
    322                if (((pEraseInit->PageAddress & ~(FLASH_PAGE_SIZE - 1)) + pEraseInit->NbPages * FLASH_PAGE_SIZE - 1) > FLASH_BANK1_END)
    323                {
    324                  /*  Last page does not belong to BANK1, erase procedure cannot be performed because memory is not
    325                      continuous */
    326                  /* Process Unlocked */
    327                  __HAL_UNLOCK(&pFlash);
    328                  return HAL_ERROR;
    329                }
    330              }
    331              else
    332              {
    333                /* BANK2 */
    334                /* Check that last page to erase still belongs to BANK2 */
    335                if (((pEraseInit->PageAddress & ~(FLASH_PAGE_SIZE - 1)) + pEraseInit->NbPages * FLASH_PAGE_SIZE - 1) > FLASH_BANK2_END)
    336                {
    337                  /*  Last page does not belong to BANK2, erase procedure cannot be performed because memory is not
    338                      continuous */
    339                  /* Process Unlocked */
    340                  __HAL_UNLOCK(&pFlash);
    341                  return HAL_ERROR;
    342                }
    343              }
    344          #endif /* STM32L151xDX || STM32L152xDX || STM32L162xDX */
    345          
    346            /* Enable End of FLASH Operation interrupt */
    347            __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP);
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x40023c04
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable24_1  ;; 0x40023c04
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    348            
    349            /* Enable Error source interrupt */
    350            __HAL_FLASH_ENABLE_IT(FLASH_IT_ERR);
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x40023c04
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0xF450 0x3000      ORRS     R0,R0,#0x20000
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable24_1  ;; 0x40023c04
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    351            
    352            /* Clear pending flags (if any) */  
    353            __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_MASK);
   \   0000003C   0xF640 0x7006      MOVW     R0,#+3846
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable24_2  ;; 0x40023c18
   \   00000044   0x6008             STR      R0,[R1, #+0]
    354          
    355            pFlash.ProcedureOnGoing = FLASH_PROC_PAGEERASE;
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable24
   \   0000004C   0x7008             STRB     R0,[R1, #+0]
    356            pFlash.NbPagesToErase = pEraseInit->NbPages;
   \   0000004E   0x68A0             LDR      R0,[R4, #+8]
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable24
   \   00000054   0x6048             STR      R0,[R1, #+4]
    357            pFlash.Page = pEraseInit->PageAddress;
   \   00000056   0x6860             LDR      R0,[R4, #+4]
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable24
   \   0000005C   0x6088             STR      R0,[R1, #+8]
    358          
    359            /*Erase 1st page and wait for IT*/
    360            FLASH_ErasePage(pEraseInit->PageAddress);
   \   0000005E   0x6860             LDR      R0,[R4, #+4]
   \   00000060   0x.... 0x....      BL       FLASH_ErasePage
    361          
    362            return status;
   \   00000064   0x0028             MOVS     R0,R5
   \   00000066   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_FLASHEx_Erase_IT_1: (+1)
   \   00000068   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    363          }
    364          
    365          /**
    366            * @}
    367            */
    368          
    369          
    370          /** @defgroup FLASHEx_Exported_Functions_Group2 Option Bytes Programming functions
    371           *  @brief   Option Bytes Programming functions 
    372           *
    373          @verbatim   
    374            ==============================================================================
    375                          ##### Option Bytes Programming functions ##### 
    376            ==============================================================================  
    377          
    378              [..] Any operation of erase or program should follow these steps:
    379              (#) Call the HAL_FLASH_OB_Unlock() function to enable the Flash option control 
    380                  register access.
    381              (#) Call following function to program the desired option bytes.
    382                  (++) HAL_FLASHEx_OBProgram:
    383                   - To Enable/Disable the desired sector write protection.
    384                   - To set the desired read Protection Level.
    385                   - To configure the user option Bytes: IWDG, STOP and the Standby.
    386                   - To Set the BOR level.
    387              (#) Once all needed option bytes to be programmed are correctly written, call the
    388                  HAL_FLASH_OB_Launch(void) function to launch the Option Bytes programming process.
    389              (#) Call the HAL_FLASH_OB_Lock() to disable the Flash option control register access (recommended
    390                  to protect the option Bytes against possible unwanted operations).
    391          
    392              [..] Proprietary code Read Out Protection (PcROP):    
    393              (#) The PcROP sector is selected by using the same option bytes as the Write
    394                  protection (nWRPi bits). As a result, these 2 options are exclusive each other.
    395              (#) In order to activate the PcROP (change the function of the nWRPi option bits), 
    396                  the SPRMOD option bit must be activated.
    397              (#) The active value of nWRPi bits is inverted when PCROP mode is active, this
    398                  means: if SPRMOD = 1 and nWRPi = 1 (default value), then the user sector "i"
    399                  is read/write protected.
    400              (#) To activate PCROP mode for Flash sector(s), you need to call the following function:
    401                  (++) HAL_FLASHEx_AdvOBProgram in selecting sectors to be read/write protected
    402                  (++) HAL_FLASHEx_OB_SelectPCROP to enable the read/write protection
    403              (#) PcROP is available only in STM32L151xBA, STM32L152xBA, STM32L151xC, STM32L152xC & STM32L162xC devices.
    404          
    405          @endverbatim
    406            * @{
    407            */
    408          
    409          /**
    410            * @brief  Program option bytes
    411            * @param  pOBInit: pointer to an FLASH_OBInitStruct structure that
    412            *         contains the configuration information for the programming.
    413            * 
    414            * @retval HAL_StatusTypeDef HAL Status
    415            */

   \                                 In section .text, align 2, keep-with-next
    416          HAL_StatusTypeDef HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit)
    417          {
   \                     HAL_FLASHEx_OBProgram: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    418            HAL_StatusTypeDef status = HAL_ERROR;
   \   00000004   0x2501             MOVS     R5,#+1
    419            
    420            /* Process Locked */
    421            __HAL_LOCK(&pFlash);
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable24
   \   0000000A   0x7C00             LDRB     R0,[R0, #+16]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_FLASHEx_OBProgram_0
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE055             B.N      ??HAL_FLASHEx_OBProgram_1
   \                     ??HAL_FLASHEx_OBProgram_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable24
   \   0000001A   0x7408             STRB     R0,[R1, #+16]
    422          
    423            /* Check the parameters */
    424            assert_param(IS_OPTIONBYTE(pOBInit->OptionType));
    425          
    426            /*Write protection configuration*/
    427            if((pOBInit->OptionType & OPTIONBYTE_WRP) == OPTIONBYTE_WRP)
   \   0000001C   0x7820             LDRB     R0,[R4, #+0]
   \   0000001E   0x07C0             LSLS     R0,R0,#+31
   \   00000020   0xD517             BPL.N    ??HAL_FLASHEx_OBProgram_2
    428            {
    429              assert_param(IS_WRPSTATE(pOBInit->WRPState));
    430              if (pOBInit->WRPState == OB_WRPSTATE_ENABLE)
   \   00000022   0x6860             LDR      R0,[R4, #+4]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD105             BNE.N    ??HAL_FLASHEx_OBProgram_3
    431              {
    432                /* Enable of Write protection on the selected Sector*/
    433                status = FLASH_OB_WRPConfig(pOBInit, ENABLE);
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       FLASH_OB_WRPConfig
   \   00000030   0x0005             MOVS     R5,R0
   \   00000032   0xE004             B.N      ??HAL_FLASHEx_OBProgram_4
    434              }
    435              else
    436              {
    437                /* Disable of Write protection on the selected Sector*/
    438                status = FLASH_OB_WRPConfig(pOBInit, DISABLE);
   \                     ??HAL_FLASHEx_OBProgram_3: (+1)
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       FLASH_OB_WRPConfig
   \   0000003C   0x0005             MOVS     R5,R0
    439              }
    440              if (status != HAL_OK)
   \                     ??HAL_FLASHEx_OBProgram_4: (+1)
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0x2D00             CMP      R5,#+0
   \   00000042   0xD006             BEQ.N    ??HAL_FLASHEx_OBProgram_2
    441              {
    442                /* Process Unlocked */
    443                __HAL_UNLOCK(&pFlash);
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable24
   \   0000004A   0x7408             STRB     R0,[R1, #+16]
    444                return status;
   \   0000004C   0x0028             MOVS     R0,R5
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0xE036             B.N      ??HAL_FLASHEx_OBProgram_1
    445              }
    446            }
    447            
    448            /* Read protection configuration*/
    449            if((pOBInit->OptionType & OPTIONBYTE_RDP) == OPTIONBYTE_RDP)
   \                     ??HAL_FLASHEx_OBProgram_2: (+1)
   \   00000052   0x7820             LDRB     R0,[R4, #+0]
   \   00000054   0x0780             LSLS     R0,R0,#+30
   \   00000056   0xD50D             BPL.N    ??HAL_FLASHEx_OBProgram_5
    450            {
    451              status = FLASH_OB_RDPConfig(pOBInit->RDPLevel);
   \   00000058   0x7B20             LDRB     R0,[R4, #+12]
   \   0000005A   0x.... 0x....      BL       FLASH_OB_RDPConfig
   \   0000005E   0x0005             MOVS     R5,R0
    452              if (status != HAL_OK)
   \   00000060   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000062   0x2D00             CMP      R5,#+0
   \   00000064   0xD006             BEQ.N    ??HAL_FLASHEx_OBProgram_5
    453              {
    454                /* Process Unlocked */
    455                __HAL_UNLOCK(&pFlash);
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable24
   \   0000006C   0x7408             STRB     R0,[R1, #+16]
    456                return status;
   \   0000006E   0x0028             MOVS     R0,R5
   \   00000070   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000072   0xE025             B.N      ??HAL_FLASHEx_OBProgram_1
    457              }
    458            }
    459            
    460            /* USER  configuration*/
    461            if((pOBInit->OptionType & OPTIONBYTE_USER) == OPTIONBYTE_USER)
   \                     ??HAL_FLASHEx_OBProgram_5: (+1)
   \   00000074   0x7820             LDRB     R0,[R4, #+0]
   \   00000076   0x0740             LSLS     R0,R0,#+29
   \   00000078   0xD515             BPL.N    ??HAL_FLASHEx_OBProgram_6
    462            {
    463              status = FLASH_OB_UserConfig(pOBInit->USERConfig & OB_IWDG_SW, 
    464                                           pOBInit->USERConfig & OB_STOP_NORST,
    465                                           pOBInit->USERConfig & OB_STDBY_NORST);
   \   0000007A   0x7BA0             LDRB     R0,[R4, #+14]
   \   0000007C   0xF010 0x0240      ANDS     R2,R0,#0x40
   \   00000080   0x7BA0             LDRB     R0,[R4, #+14]
   \   00000082   0xF010 0x0120      ANDS     R1,R0,#0x20
   \   00000086   0x7BA0             LDRB     R0,[R4, #+14]
   \   00000088   0xF010 0x0010      ANDS     R0,R0,#0x10
   \   0000008C   0x.... 0x....      BL       FLASH_OB_UserConfig
   \   00000090   0x0005             MOVS     R5,R0
    466              if (status != HAL_OK)
   \   00000092   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000094   0x2D00             CMP      R5,#+0
   \   00000096   0xD006             BEQ.N    ??HAL_FLASHEx_OBProgram_6
    467              {
    468                /* Process Unlocked */
    469                __HAL_UNLOCK(&pFlash);
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x.... 0x....      LDR.W    R1,??DataTable24
   \   0000009E   0x7408             STRB     R0,[R1, #+16]
    470                return status;
   \   000000A0   0x0028             MOVS     R0,R5
   \   000000A2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A4   0xE00C             B.N      ??HAL_FLASHEx_OBProgram_1
    471              }
    472            }
    473          
    474            /* BOR Level  configuration*/
    475            if((pOBInit->OptionType & OPTIONBYTE_BOR) == OPTIONBYTE_BOR)
   \                     ??HAL_FLASHEx_OBProgram_6: (+1)
   \   000000A6   0x7820             LDRB     R0,[R4, #+0]
   \   000000A8   0x0700             LSLS     R0,R0,#+28
   \   000000AA   0xD503             BPL.N    ??HAL_FLASHEx_OBProgram_7
    476            {
    477              status = FLASH_OB_BORConfig(pOBInit->BORLevel);
   \   000000AC   0x7B60             LDRB     R0,[R4, #+13]
   \   000000AE   0x.... 0x....      BL       FLASH_OB_BORConfig
   \   000000B2   0x0005             MOVS     R5,R0
    478            } 
    479            /* Process Unlocked */
    480            __HAL_UNLOCK(&pFlash);
   \                     ??HAL_FLASHEx_OBProgram_7: (+1)
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0x.... 0x....      LDR.W    R1,??DataTable24
   \   000000BA   0x7408             STRB     R0,[R1, #+16]
    481          
    482            return status;
   \   000000BC   0x0028             MOVS     R0,R5
   \   000000BE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_FLASHEx_OBProgram_1: (+1)
   \   000000C0   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    483          }
    484          
    485          /**
    486            * @brief   Get the Option byte configuration
    487            * @param  pOBInit: pointer to an FLASH_OBInitStruct structure that
    488            *         contains the configuration information for the programming.
    489            * 
    490            * @retval None
    491            */

   \                                 In section .text, align 2, keep-with-next
    492          void HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit)
    493          {
   \                     HAL_FLASHEx_OBGetConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    494            pOBInit->OptionType = OPTIONBYTE_WRP | OPTIONBYTE_RDP | OPTIONBYTE_USER | OPTIONBYTE_BOR;
   \   00000004   0x200F             MOVS     R0,#+15
   \   00000006   0x6020             STR      R0,[R4, #+0]
    495          
    496            /*Get WRP1*/
    497            pOBInit->WRPSector0To31 = (uint32_t)(FLASH->WRPR1);
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable24_3  ;; 0x40023c20
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x60A0             STR      R0,[R4, #+8]
    498          
    499          #if defined(STM32L100xC) || defined (STM32L151xC) || defined (STM32L152xC) || defined (STM32L162xC) || \
    500              defined(STM32L151xCA) || defined(STM32L151xD) || defined(STM32L151xDX) || defined (STM32L152xCA) || \
    501              defined(STM32L152xD) || defined(STM32L152xDX) || defined (STM32L162xCA) || defined(STM32L162xD)  || \
    502              defined(STM32L162xDX) || defined(STM32L151xE) || defined (STM32L152xE) || defined (STM32L162xE)
    503              
    504            /*Get WRP2*/
    505            pOBInit->WRPSector32To63 = (uint32_t)(FLASH->WRPR2);
    506          
    507          #endif /* STM32L100xC || STM32L151xC || STM32L152xC || (...) || STM32L151xE || STM32L152xE || STM32L162xE */
    508            
    509          #if defined(STM32L151xD) || defined(STM32L151xDX) || defined(STM32L152xD) || defined(STM32L152xDX) || \
    510              defined(STM32L162xD) || defined(STM32L162xDX) || defined(STM32L151xE) || defined (STM32L152xE) || \
    511              defined (STM32L162xE)
    512              
    513            /*Get WRP3*/
    514            pOBInit->WRPSector64To95 = (uint32_t)(FLASH->WRPR3);
    515          
    516          #endif /* STM32L151xD || STM32L152xD || STM32L162xD || STM32L151xE || STM32L152xE || STM32L162xE */
    517            
    518          #if defined(STM32L151xE) || defined (STM32L152xE) || defined (STM32L162xE) || \
    519              defined(STM32L151xDX) || defined(STM32L152xDX) || defined(STM32L162xDX)
    520          
    521            /*Get WRP4*/
    522            pOBInit->WRPSector96To127 = (uint32_t)(FLASH->WRPR4);
    523          
    524          #endif /* STM32L151xE || STM32L152xE || STM32L162xE || STM32L151xDX || ... */
    525          
    526            /*Get RDP Level*/
    527            pOBInit->RDPLevel   = FLASH_OB_GetRDP();
   \   00000010   0x.... 0x....      BL       FLASH_OB_GetRDP
   \   00000014   0x7320             STRB     R0,[R4, #+12]
    528          
    529            /*Get USER*/
    530            pOBInit->USERConfig = FLASH_OB_GetUser();
   \   00000016   0x.... 0x....      BL       FLASH_OB_GetUser
   \   0000001A   0x73A0             STRB     R0,[R4, #+14]
    531          
    532            /*Get BOR Level*/
    533            pOBInit->BORLevel   = FLASH_OB_GetBOR();
   \   0000001C   0x.... 0x....      BL       FLASH_OB_GetBOR
   \   00000020   0x7360             STRB     R0,[R4, #+13]
    534            
    535          }
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    536          
    537          #if defined (STM32L151xBA) || defined (STM32L152xBA) || defined (STM32L151xC) || defined (STM32L152xC) || \
    538              defined (STM32L162xC) || defined(STM32L151xD) || defined(STM32L151xDX) || defined(STM32L152xD)     || \
    539              defined(STM32L152xDX) || defined(STM32L162xD) || defined(STM32L162xDX) || defined(STM32L151xE)     || \
    540              defined (STM32L152xE) || defined (STM32L162xE)
    541              
    542          /**
    543            * @brief  Program option bytes
    544            * @note   This function can be used only for Cat2 & Cat3 devices for PCROP and Cat4 & Cat5 for BFB2.
    545            * @param  pAdvOBInit: pointer to an FLASH_AdvOBProgramInitTypeDef structure that
    546            *         contains the configuration information for the programming.
    547            * 
    548            * @retval HAL_StatusTypeDef HAL Status
    549            */
    550          HAL_StatusTypeDef HAL_FLASHEx_AdvOBProgram (FLASH_AdvOBProgramInitTypeDef *pAdvOBInit)
    551          {
    552            HAL_StatusTypeDef status = HAL_ERROR;
    553            
    554            /* Check the parameters */
    555            assert_param(IS_OBEX(pAdvOBInit->OptionType));
    556          
    557          #if defined (STM32L151xBA) || defined (STM32L152xBA) || \
    558              defined (STM32L151xC) || defined (STM32L152xC) || defined (STM32L162xC)
    559              
    560            /* Cat2 & Cat3 devices only */
    561            /*Program PCROP option byte*/
    562            if ((pAdvOBInit->OptionType & OPTIONBYTE_PCROP) == OPTIONBYTE_PCROP)
    563            {
    564              /* Check the parameters */
    565              assert_param(IS_PCROPSTATE(pAdvOBInit->PCROPState));
    566              if (pAdvOBInit->PCROPState == OB_PCROP_STATE_ENABLE)
    567              {
    568                /*Enable of Write protection on the selected Sector*/
    569                status = FLASH_OB_PCROPConfig(pAdvOBInit, ENABLE);
    570                if (status != HAL_OK)
    571                {
    572                  return status;
    573                }
    574              }
    575              else
    576              {
    577                /*Disable of Write protection on the selected Sector*/ 
    578                status = FLASH_OB_PCROPConfig(pAdvOBInit, DISABLE);
    579                if (status != HAL_OK)
    580                {
    581                  return status;
    582                }
    583              }
    584            }
    585            
    586          #endif /* STM32L151xBA || STM32L152xBA || STM32L151xC || STM32L152xC || STM32L162xC */
    587          
    588          #if defined(STM32L151xD) || defined(STM32L151xDX) || defined(STM32L152xD) || defined(STM32L152xDX) || \
    589              defined(STM32L162xD) || defined(STM32L162xDX) || defined(STM32L151xE) || defined (STM32L152xE) || \
    590              defined (STM32L162xE)
    591              
    592            /* Cat4 & Cat5 devices only */
    593            /*Program BOOT config option byte*/
    594            if ((pAdvOBInit->OptionType & OPTIONBYTE_BOOTCONFIG) == OPTIONBYTE_BOOTCONFIG)
    595            {
    596              status = FLASH_OB_BootConfig(pAdvOBInit->BootConfig);
    597            }
    598            
    599          #endif /* STM32L151xD || STM32L152xD || STM32L162xD || STM32L151xE || STM32L152xE || STM32L162xE */
    600          
    601            return status;
    602          }
    603          
    604          /**
    605            * @brief   Get the OBEX byte configuration
    606            * @note   This function can be used only for Cat2  & Cat3 devices for PCROP and Cat4 & Cat5 for BFB2.
    607            * @param  pAdvOBInit: pointer to an FLASH_AdvOBProgramInitTypeDef structure that
    608            *         contains the configuration information for the programming.
    609            * 
    610            * @retval None
    611            */
    612          void HAL_FLASHEx_AdvOBGetConfig(FLASH_AdvOBProgramInitTypeDef *pAdvOBInit)
    613          {
    614          #if defined (STM32L151xBA) || defined (STM32L152xBA) || \
    615              defined (STM32L151xC) || defined (STM32L152xC) || defined (STM32L162xC)
    616                
    617            pAdvOBInit->OptionType = OPTIONBYTE_PCROP;
    618          
    619            /*Get PCROP state */
    620            pAdvOBInit->PCROPState = (FLASH->OBR & FLASH_OBR_SPRMOD) >> POSITION_VAL(FLASH_OBR_SPRMOD);
    621            
    622            /*Get PCROP protected sector from 0 to 31 */
    623            pAdvOBInit->PCROPSector0To31 = FLASH->WRPR1;
    624            
    625            #if defined(STM32L100xC) || defined (STM32L151xC) || defined (STM32L152xC) || defined (STM32L162xC)
    626          
    627            /*Get PCROP protected sector from 32 to 63 */
    628            pAdvOBInit->PCROPSector32To63 = FLASH->WRPR2;
    629          
    630            #endif /* STM32L100xC || STM32L151xC || STM32L152xC || STM32L162xC */
    631            
    632          #endif /* STM32L151xBA || STM32L152xBA || STM32L151xC || STM32L152xC || STM32L162xC */
    633          
    634          #if defined(STM32L151xD) || defined(STM32L151xDX) || defined(STM32L152xD) || defined(STM32L152xDX) || \
    635            defined(STM32L162xD) || defined(STM32L162xDX) || defined(STM32L151xE) || defined (STM32L152xE)   || \
    636            defined (STM32L162xE)
    637                
    638            pAdvOBInit->OptionType = OPTIONBYTE_BOOTCONFIG;
    639          
    640            /*Get Boot config OB*/
    641            pAdvOBInit->BootConfig = (FLASH->OBR & 0x80000000) >> 24;
    642          
    643          #endif /* STM32L151xD || STM32L152xD || STM32L162xD || STM32L151xE || STM32L152xE || STM32L162xE */
    644          }
    645          
    646          #endif /* STM32L151xBA || STM32L152xBA || STM32L151xC || (...) || STM32L151xE || STM32L152xE || STM32L162xE */
    647          
    648          #if defined (STM32L151xBA) || defined (STM32L152xBA) || \
    649              defined (STM32L151xC) || defined (STM32L152xC) || defined (STM32L162xC)
    650          
    651          /**
    652            * @brief  Select the Protection Mode (SPRMOD).
    653            * @note   This function can be used only for STM32L151xBA, STM32L152xBA, STM32L151xC, STM32L152xC & STM32L162xC devices
    654            * @note   Once SPRMOD bit is active, unprotection of a protected sector is not possible 
    655            * @note   Read a protected sector will set RDERR Flag and write a protected sector will set WRPERR Flag
    656            * @retval HAL status
    657            */
    658          HAL_StatusTypeDef HAL_FLASHEx_OB_SelectPCROP(void)
    659          {
    660            HAL_StatusTypeDef status = HAL_OK;
    661            uint16_t tmp1 = 0;
    662            uint32_t tmp2 = 0;
    663            uint8_t optiontmp = 0;
    664            uint16_t optiontmp2 = 0;
    665            
    666            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
    667            
    668            /* Mask RDP Byte */
    669            optiontmp =  (uint8_t)(*(__IO uint8_t *)(OB_BASE)); 
    670            
    671            /* Update Option Byte */
    672            optiontmp2 = (uint16_t)(OB_PCROP_SELECTED | optiontmp); 
    673            
    674            /* calculate the option byte to write */
    675            tmp1 = (uint16_t)(~(optiontmp2 ));
    676            tmp2 = (uint32_t)(((uint32_t)((uint32_t)(tmp1) << 16)) | ((uint32_t)optiontmp2));
    677            
    678            if(status == HAL_OK)
    679            {         
    680              /* Clean the error context */
    681              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
    682          
    683              /* program PCRop */
    684              OB->RDP = tmp2;
    685            }
    686            
    687            /* Wait for last operation to be completed */
    688            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
    689            
    690            /* Return the Read protection operation Status */
    691            return status;            
    692          }
    693          
    694          /**
    695            * @brief  Deselect the Protection Mode (SPRMOD).
    696            * @note   This function can be used only for STM32L151xBA, STM32L152xBA, STM32L151xC, STM32L152xC & STM32L162xC devices
    697            * @note   Once SPRMOD bit is active, unprotection of a protected sector is not possible 
    698            * @note   Read a protected sector will set RDERR Flag and write a protected sector will set WRPERR Flag
    699            * @retval HAL status
    700            */
    701          HAL_StatusTypeDef HAL_FLASHEx_OB_DeSelectPCROP(void)
    702          {
    703            HAL_StatusTypeDef status = HAL_OK;
    704            uint16_t tmp1 = 0;
    705            uint32_t tmp2 = 0;
    706            uint8_t optiontmp = 0;
    707            uint16_t optiontmp2 = 0;
    708            
    709            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
    710            
    711            /* Mask RDP Byte */
    712            optiontmp =  (uint8_t)(*(__IO uint8_t *)(OB_BASE)); 
    713            
    714            /* Update Option Byte */
    715            optiontmp2 = (uint16_t)(OB_PCROP_DESELECTED | optiontmp); 
    716            
    717            /* calculate the option byte to write */
    718            tmp1 = (uint16_t)(~(optiontmp2 ));
    719            tmp2 = (uint32_t)(((uint32_t)((uint32_t)(tmp1) << 16)) | ((uint32_t)optiontmp2));
    720            
    721            if(status == HAL_OK)
    722            {         
    723              /* Clean the error context */
    724              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
    725          
    726              /* program PCRop */
    727              OB->RDP = tmp2;
    728            }
    729            
    730            /* Wait for last operation to be completed */
    731            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
    732            
    733            /* Return the Read protection operation Status */
    734            return status;            
    735          }
    736          
    737          #endif /* STM32L151xBA || STM32L152xBA || STM32L151xC || STM32L152xC || STM32L162xC */
    738          
    739          /**
    740            * @}
    741            */
    742          
    743          /** @defgroup FLASHEx_Exported_Functions_Group3 DATA EEPROM Programming functions
    744           *  @brief   DATA EEPROM Programming functions
    745           *
    746          @verbatim   
    747           ===============================================================================
    748                               ##### DATA EEPROM Programming functions ##### 
    749           ===============================================================================  
    750           
    751              [..] Any operation of erase or program should follow these steps:
    752              (#) Call the HAL_FLASHEx_DATAEEPROM_Unlock() function to enable the data EEPROM access
    753                  and Flash program erase control register access.
    754              (#) Call the desired function to erase or program data.
    755              (#) Call the HAL_FLASHEx_DATAEEPROM_Lock() to disable the data EEPROM access
    756                  and Flash program erase control register access(recommended
    757                  to protect the DATA_EEPROM against possible unwanted operation).
    758          
    759          @endverbatim
    760            * @{
    761            */
    762          
    763          /**
    764            * @brief  Unlocks the data memory and FLASH_PECR register access.
    765            * @retval HAL_StatusTypeDef HAL Status
    766            */

   \                                 In section .text, align 2, keep-with-next
    767          HAL_StatusTypeDef HAL_FLASHEx_DATAEEPROM_Unlock(void)
    768          {
    769            if((FLASH->PECR & FLASH_PECR_PELOCK) != RESET)
   \                     HAL_FLASHEx_DATAEEPROM_Unlock: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x40023c04
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x07C0             LSLS     R0,R0,#+31
   \   00000008   0xD50B             BPL.N    ??HAL_FLASHEx_DATAEEPROM_Unlock_0
    770            {  
    771              /* Unlocking the Data memory and FLASH_PECR register access*/
    772              FLASH->PEKEYR = FLASH_PEKEY1;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable24_4  ;; 0x89abcdef
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable24_5  ;; 0x40023c0c
   \   00000012   0x6008             STR      R0,[R1, #+0]
    773              FLASH->PEKEYR = FLASH_PEKEY2;
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable24_6  ;; 0x2030405
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable24_5  ;; 0x40023c0c
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    774            }
    775            else
    776            {
    777              return HAL_ERROR;
    778            }
    779            return HAL_OK;  
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE000             B.N      ??HAL_FLASHEx_DATAEEPROM_Unlock_1
   \                     ??HAL_FLASHEx_DATAEEPROM_Unlock_0: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \                     ??HAL_FLASHEx_DATAEEPROM_Unlock_1: (+1)
   \   00000024   0x4770             BX       LR               ;; return
    780          }
    781          
    782          /**
    783            * @brief  Locks the Data memory and FLASH_PECR register access.
    784            * @retval HAL_StatusTypeDef HAL Status
    785            */

   \                                 In section .text, align 2, keep-with-next
    786          HAL_StatusTypeDef HAL_FLASHEx_DATAEEPROM_Lock(void)
    787          {
    788            /* Set the PELOCK Bit to lock the data memory and FLASH_PECR register access */
    789            SET_BIT(FLASH->PECR, FLASH_PECR_PELOCK);
   \                     HAL_FLASHEx_DATAEEPROM_Lock: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x40023c04
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable24_1  ;; 0x40023c04
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    790            
    791            return HAL_OK;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR               ;; return
    792          }
    793          
    794          /**
    795            * @brief  Erase a word in data memory.
    796            * @param  Address: specifies the address to be erased.
    797            * @param  TypeErase:  Indicate the way to erase at a specified address.
    798            *         This parameter can be a value of @ref FLASH_Type_Program
    799            * @note   To correctly run this function, the DATA_EEPROM_Unlock() function
    800            *         must be called before.
    801            *         Call the DATA_EEPROM_Lock() to the data EEPROM access
    802            *         and Flash program erase control register access(recommended to protect 
    803            *         the DATA_EEPROM against possible unwanted operation).
    804            * @retval FLASH Status: The returned value can be: 
    805            *   FLASH_ERROR_PROGRAM, HAL_FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
    806            */

   \                                 In section .text, align 2, keep-with-next
    807          HAL_StatusTypeDef HAL_FLASHEx_DATAEEPROM_Erase(uint32_t TypeErase, uint32_t Address)
    808          {
   \                     HAL_FLASHEx_DATAEEPROM_Erase: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    809            HAL_StatusTypeDef status = HAL_OK;
   \   00000006   0x2600             MOVS     R6,#+0
    810            
    811            /* Check the parameters */
    812            assert_param(IS_TYPEPROGRAMDATA(TypeErase));
    813            assert_param(IS_FLASH_DATA_ADDRESS(Address));
    814            
    815            /* Wait for last operation to be completed */
    816            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   00000008   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000000C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000010   0x0006             MOVS     R6,R0
    817            
    818            if(status == HAL_OK)
   \   00000012   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD10F             BNE.N    ??HAL_FLASHEx_DATAEEPROM_Erase_0
    819            {
    820              /* Clean the error context */
    821              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable24
   \   0000001E   0x6148             STR      R0,[R1, #+20]
    822          
    823              if(TypeErase == FLASH_TYPEERASEDATA_WORD)
   \   00000020   0x2C02             CMP      R4,#+2
   \   00000022   0xD101             BNE.N    ??HAL_FLASHEx_DATAEEPROM_Erase_1
    824              {
    825                /* Write 00000000h to valid address in the data memory */
    826                *(__IO uint32_t *) Address = 0x00000000;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x6028             STR      R0,[R5, #+0]
    827              }
    828          
    829              if(TypeErase == FLASH_TYPEERASEDATA_HALFWORD)
   \                     ??HAL_FLASHEx_DATAEEPROM_Erase_1: (+1)
   \   00000028   0x2C01             CMP      R4,#+1
   \   0000002A   0xD101             BNE.N    ??HAL_FLASHEx_DATAEEPROM_Erase_2
    830              {
    831                /* Write 0000h to valid address in the data memory */
    832                *(__IO uint16_t *) Address = (uint16_t)0x0000;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x8028             STRH     R0,[R5, #+0]
    833              }
    834          
    835              if(TypeErase == FLASH_TYPEERASEDATA_BYTE)
   \                     ??HAL_FLASHEx_DATAEEPROM_Erase_2: (+1)
   \   00000030   0x2C00             CMP      R4,#+0
   \   00000032   0xD101             BNE.N    ??HAL_FLASHEx_DATAEEPROM_Erase_0
    836              {
    837                /* Write 00h to valid address in the data memory */
    838                *(__IO uint8_t *) Address = (uint8_t)0x00;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x7028             STRB     R0,[R5, #+0]
    839              }
    840            }
    841             
    842            /* Return the erase status */
    843            return status;
   \                     ??HAL_FLASHEx_DATAEEPROM_Erase_0: (+1)
   \   00000038   0x0030             MOVS     R0,R6
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0xBD70             POP      {R4-R6,PC}       ;; return
    844          }  
    845          
    846          /**
    847            * @brief  Program word at a specified address
    848            * @note   To correctly run this function, the HAL_FLASH_EEPROM_Unlock() function
    849            *         must be called before.
    850            *         Call the HAL_FLASHEx_DATAEEPROM_Unlock() to he data EEPROM access
    851            *         and Flash program erase control register access(recommended to protect 
    852            *         the DATA_EEPROM against possible unwanted operation).
    853            * @note   The function  HAL_FLASHEx_DATAEEPROM_EnableFixedTimeProgram() can be called before 
    854            *         this function to configure the Fixed Time Programming.
    855            * @param  TypeProgram:  Indicate the way to program at a specified address.
    856            *         This parameter can be a value of @ref FLASHEx_Type_Program_Data
    857            * @param  Address:  specifies the address to be programmed.
    858            * @param  Data: specifies the data to be programmed
    859            * 
    860            * @retval HAL_StatusTypeDef HAL Status
    861            */
    862          

   \                                 In section .text, align 2, keep-with-next
    863          HAL_StatusTypeDef   HAL_FLASHEx_DATAEEPROM_Program(uint32_t TypeProgram, uint32_t Address, uint32_t Data)
    864          {
   \                     HAL_FLASHEx_DATAEEPROM_Program: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    865            HAL_StatusTypeDef status = HAL_ERROR;
   \   00000008   0x2701             MOVS     R7,#+1
    866            
    867            /* Process Locked */
    868            __HAL_LOCK(&pFlash);
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable24
   \   0000000E   0x7C00             LDRB     R0,[R0, #+16]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD101             BNE.N    ??HAL_FLASHEx_DATAEEPROM_Program_0
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xE042             B.N      ??HAL_FLASHEx_DATAEEPROM_Program_1
   \                     ??HAL_FLASHEx_DATAEEPROM_Program_0: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable24
   \   0000001E   0x7408             STRB     R0,[R1, #+16]
    869          
    870            /* Check the parameters */
    871            assert_param(IS_TYPEPROGRAMDATA(TypeProgram));
    872          
    873            /* Wait for last operation to be completed */
    874            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   00000020   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000024   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000028   0x0007             MOVS     R7,R0
    875            
    876            if(status == HAL_OK)
   \   0000002A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000002C   0x2F00             CMP      R7,#+0
   \   0000002E   0xD130             BNE.N    ??HAL_FLASHEx_DATAEEPROM_Program_2
    877            {
    878              /* Clean the error context */
    879              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable24
   \   00000036   0x6148             STR      R0,[R1, #+20]
    880          
    881              if(TypeProgram == FLASH_TYPEPROGRAMDATA_FASTBYTE)
   \   00000038   0x2C04             CMP      R4,#+4
   \   0000003A   0xD104             BNE.N    ??HAL_FLASHEx_DATAEEPROM_Program_3
    882              {
    883                /*Program word (8-bit) at a specified address.*/
    884                FLASH_DATAEEPROM_FastProgramByte(Address, (uint8_t) Data);
   \   0000003C   0x0031             MOVS     R1,R6
   \   0000003E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000040   0x0028             MOVS     R0,R5
   \   00000042   0x.... 0x....      BL       FLASH_DATAEEPROM_FastProgramByte
    885              }
    886              
    887              if(TypeProgram == FLASH_TYPEPROGRAMDATA_FASTHALFWORD)
   \                     ??HAL_FLASHEx_DATAEEPROM_Program_3: (+1)
   \   00000046   0x2C08             CMP      R4,#+8
   \   00000048   0xD104             BNE.N    ??HAL_FLASHEx_DATAEEPROM_Program_4
    888              {
    889                /*Program word (16-bit) at a specified address.*/
    890                FLASH_DATAEEPROM_FastProgramHalfWord(Address, (uint16_t) Data);
   \   0000004A   0x0031             MOVS     R1,R6
   \   0000004C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000004E   0x0028             MOVS     R0,R5
   \   00000050   0x.... 0x....      BL       FLASH_DATAEEPROM_FastProgramHalfWord
    891              }    
    892              
    893              if(TypeProgram == FLASH_TYPEPROGRAMDATA_FASTWORD)
   \                     ??HAL_FLASHEx_DATAEEPROM_Program_4: (+1)
   \   00000054   0x2C10             CMP      R4,#+16
   \   00000056   0xD103             BNE.N    ??HAL_FLASHEx_DATAEEPROM_Program_5
    894              {
    895                /*Program word (32-bit) at a specified address.*/
    896                FLASH_DATAEEPROM_FastProgramWord(Address, (uint32_t) Data);
   \   00000058   0x0031             MOVS     R1,R6
   \   0000005A   0x0028             MOVS     R0,R5
   \   0000005C   0x.... 0x....      BL       FLASH_DATAEEPROM_FastProgramWord
    897              }
    898              
    899              if(TypeProgram == FLASH_TYPEPROGRAMDATA_WORD)
   \                     ??HAL_FLASHEx_DATAEEPROM_Program_5: (+1)
   \   00000060   0x2C02             CMP      R4,#+2
   \   00000062   0xD103             BNE.N    ??HAL_FLASHEx_DATAEEPROM_Program_6
    900              {
    901                /*Program word (32-bit) at a specified address.*/
    902                FLASH_DATAEEPROM_ProgramWord(Address, (uint32_t) Data);
   \   00000064   0x0031             MOVS     R1,R6
   \   00000066   0x0028             MOVS     R0,R5
   \   00000068   0x.... 0x....      BL       FLASH_DATAEEPROM_ProgramWord
    903              }
    904                 
    905              if(TypeProgram == FLASH_TYPEPROGRAMDATA_HALFWORD)
   \                     ??HAL_FLASHEx_DATAEEPROM_Program_6: (+1)
   \   0000006C   0x2C01             CMP      R4,#+1
   \   0000006E   0xD104             BNE.N    ??HAL_FLASHEx_DATAEEPROM_Program_7
    906              {
    907                /*Program word (16-bit) at a specified address.*/
    908                FLASH_DATAEEPROM_ProgramHalfWord(Address, (uint16_t) Data);
   \   00000070   0x0031             MOVS     R1,R6
   \   00000072   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000074   0x0028             MOVS     R0,R5
   \   00000076   0x.... 0x....      BL       FLASH_DATAEEPROM_ProgramHalfWord
    909              }
    910                  
    911              if(TypeProgram == FLASH_TYPEPROGRAMDATA_BYTE)
   \                     ??HAL_FLASHEx_DATAEEPROM_Program_7: (+1)
   \   0000007A   0x2C00             CMP      R4,#+0
   \   0000007C   0xD104             BNE.N    ??HAL_FLASHEx_DATAEEPROM_Program_8
    912              {
    913                /*Program word (8-bit) at a specified address.*/
    914                FLASH_DATAEEPROM_ProgramByte(Address, (uint8_t) Data);
   \   0000007E   0x0031             MOVS     R1,R6
   \   00000080   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000082   0x0028             MOVS     R0,R5
   \   00000084   0x.... 0x....      BL       FLASH_DATAEEPROM_ProgramByte
    915              }
    916              
    917              /* Wait for last operation to be completed */
    918              status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \                     ??HAL_FLASHEx_DATAEEPROM_Program_8: (+1)
   \   00000088   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000008C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000090   0x0007             MOVS     R7,R0
    919            }
    920            
    921            /* Process Unlocked */
    922            __HAL_UNLOCK(&pFlash);
   \                     ??HAL_FLASHEx_DATAEEPROM_Program_2: (+1)
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable24
   \   00000098   0x7408             STRB     R0,[R1, #+16]
    923          
    924            return status;
   \   0000009A   0x0038             MOVS     R0,R7
   \   0000009C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_FLASHEx_DATAEEPROM_Program_1: (+1)
   \   0000009E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    925          }
    926          
    927          /**
    928            * @brief  Enable DATA EEPROM fixed Time programming (2*Tprog).
    929            * @retval None
    930            */

   \                                 In section .text, align 2, keep-with-next
    931          void HAL_FLASHEx_DATAEEPROM_EnableFixedTimeProgram(void)
    932          {
    933            SET_BIT(FLASH->PECR, FLASH_PECR_FTDW);
   \                     HAL_FLASHEx_DATAEEPROM_EnableFixedTimeProgram: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x40023c04
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable24_1  ;; 0x40023c04
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    934          }
   \   00000010   0x4770             BX       LR               ;; return
    935          
    936          /**
    937            * @brief  Disables DATA EEPROM fixed Time programming (2*Tprog).
    938            * @retval None
    939            */

   \                                 In section .text, align 2, keep-with-next
    940          void HAL_FLASHEx_DATAEEPROM_DisableFixedTimeProgram(void)
    941          {
    942            CLEAR_BIT(FLASH->PECR, FLASH_PECR_FTDW);
   \                     HAL_FLASHEx_DATAEEPROM_DisableFixedTimeProgram: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x40023c04
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF430 0x7080      BICS     R0,R0,#0x100
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable24_1  ;; 0x40023c04
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    943          }
   \   00000010   0x4770             BX       LR               ;; return
    944          
    945          /**
    946            * @}
    947            */
    948          
    949          /**
    950            * @}
    951            */
    952          
    953          /** @addtogroup FLASHEx_Private_Functions
    954           * @{
    955           */
    956          
    957          /*
    958          ==============================================================================
    959                        ##### FLASH STATIC functions ##### 
    960          ==============================================================================
    961          */
    962          
    963          /*
    964          ==============================================================================
    965                        FLASH
    966          ==============================================================================
    967          */
    968          
    969          /**
    970            * @brief  Set the specific FLASH error flag.
    971            * @retval None
    972            */

   \                                 In section .text, align 2, keep-with-next
    973          static void FLASH_SetErrorCode(void)
    974          { 
    975            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) != RESET)
   \                     FLASH_SetErrorCode: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable24_2  ;; 0x40023c18
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x05C0             LSLS     R0,R0,#+23
   \   00000008   0xD508             BPL.N    ??FLASH_SetErrorCode_0
    976            {
    977              pFlash.ErrorCode = HAL_FLASH_ERROR_WRP;
   \   0000000A   0x2010             MOVS     R0,#+16
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable24
   \   00000010   0x6148             STR      R0,[R1, #+20]
    978              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_WRPERR);  
   \   00000012   0xF44F 0x7080      MOV      R0,#+256
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable24_2  ;; 0x40023c18
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    979            }
    980            
    981            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR) != RESET)
   \                     ??FLASH_SetErrorCode_0: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable24_2  ;; 0x40023c18
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x0580             LSLS     R0,R0,#+22
   \   00000024   0xD50C             BPL.N    ??FLASH_SetErrorCode_1
    982            {
    983              pFlash.ErrorCode |= HAL_FLASH_ERROR_PGA;
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable24
   \   0000002A   0x6940             LDR      R0,[R0, #+20]
   \   0000002C   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable24
   \   00000034   0x6148             STR      R0,[R1, #+20]
    984              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGAERR);  
   \   00000036   0xF44F 0x7000      MOV      R0,#+512
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable24_2  ;; 0x40023c18
   \   0000003E   0x6008             STR      R0,[R1, #+0]
    985            }
    986            
    987            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_SIZERR) != RESET)
   \                     ??FLASH_SetErrorCode_1: (+1)
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable24_2  ;; 0x40023c18
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x0540             LSLS     R0,R0,#+21
   \   00000048   0xD50C             BPL.N    ??FLASH_SetErrorCode_2
    988            {
    989              pFlash.ErrorCode |= HAL_FLASH_ERROR_SIZE;
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable24
   \   0000004E   0x6940             LDR      R0,[R0, #+20]
   \   00000050   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable24
   \   00000058   0x6148             STR      R0,[R1, #+20]
    990              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_SIZERR);  
   \   0000005A   0xF44F 0x6080      MOV      R0,#+1024
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable24_2  ;; 0x40023c18
   \   00000062   0x6008             STR      R0,[R1, #+0]
    991            }
    992            
    993            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR) != RESET)
   \                     ??FLASH_SetErrorCode_2: (+1)
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable24_2  ;; 0x40023c18
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x0500             LSLS     R0,R0,#+20
   \   0000006C   0xD50C             BPL.N    ??FLASH_SetErrorCode_3
    994            {
    995              pFlash.ErrorCode |= HAL_FLASH_ERROR_OPTV;
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable24
   \   00000072   0x6940             LDR      R0,[R0, #+20]
   \   00000074   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable24
   \   0000007C   0x6148             STR      R0,[R1, #+20]
    996              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPTVERR);  
   \   0000007E   0xF44F 0x6000      MOV      R0,#+2048
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable24_2  ;; 0x40023c18
   \   00000086   0x6008             STR      R0,[R1, #+0]
    997            }
    998            
    999          #if defined (STM32L151xBA) || defined (STM32L152xBA) || \
   1000              defined (STM32L151xC) || defined (STM32L152xC) || defined (STM32L162xC)
   1001            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR) != RESET)
   1002            {
   1003              pFlash.ErrorCode |= HAL_FLASH_ERROR_RD;
   1004              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_RDERR);  
   1005            }
   1006          #endif /* STM32L151xBA || STM32L152xBA || STM32L151xC || STM32L152xC || STM32L162xC */
   1007          
   1008          #if defined(STM32L100xC) || defined (STM32L151xC) || defined (STM32L152xC) || defined (STM32L162xC) || \
   1009              defined(STM32L151xCA) || defined(STM32L151xD) || defined(STM32L151xDX) || defined (STM32L152xCA) || \
   1010              defined(STM32L152xD) || defined(STM32L152xDX) || defined (STM32L162xCA) || defined(STM32L162xD)  || \
   1011              defined(STM32L162xDX) || defined(STM32L151xE) || defined (STM32L152xE) || defined (STM32L162xE)
   1012            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERRUSR) != RESET)
   1013            {
   1014              pFlash.ErrorCode |= HAL_FLASH_ERROR_OPTVUSR;
   1015              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPTVERRUSR);  
   1016            }
   1017          #endif /* STM32L100xC || STM32L151xC || STM32L152xC || (...) || STM32L151xE || STM32L152xE || STM32L162xE */
   1018          }
   \                     ??FLASH_SetErrorCode_3: (+1)
   \   00000088   0x4770             BX       LR               ;; return
   1019          
   1020          /**
   1021            * @brief  Erases a specified page in program memory.
   1022            * @param  PageAddress: The page address in program memory to be erased.
   1023            * @note   A Page is erased in the Program memory only if the address to load 
   1024            *         is the start address of a page (multiple of 256 bytes).
   1025            * @retval None
   1026            */

   \                                 In section .text, align 2, keep-with-next
   1027          static void FLASH_ErasePage(uint32_t PageAddress)
   1028          {
   1029            /* Clean the error context */
   1030            pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \                     FLASH_ErasePage: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable24
   \   00000006   0x6151             STR      R1,[R2, #+20]
   1031          
   1032            /* Set the ERASE bit */
   1033            SET_BIT(FLASH->PECR, FLASH_PECR_ERASE);
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable24_1  ;; 0x40023c04
   \   0000000C   0x6809             LDR      R1,[R1, #+0]
   \   0000000E   0xF451 0x7100      ORRS     R1,R1,#0x200
   \   00000012   0x.... 0x....      LDR.W    R2,??DataTable24_1  ;; 0x40023c04
   \   00000016   0x6011             STR      R1,[R2, #+0]
   1034          
   1035            /* Set PROG bit */
   1036            SET_BIT(FLASH->PECR, FLASH_PECR_PROG);
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable24_1  ;; 0x40023c04
   \   0000001C   0x6809             LDR      R1,[R1, #+0]
   \   0000001E   0xF051 0x0108      ORRS     R1,R1,#0x8
   \   00000022   0x.... 0x....      LDR.W    R2,??DataTable24_1  ;; 0x40023c04
   \   00000026   0x6011             STR      R1,[R2, #+0]
   1037          
   1038            /* Write 00000000h to the first word of the program page to erase */
   1039            *(__IO uint32_t *)(uint32_t)(PageAddress & ~(FLASH_PAGE_SIZE - 1)) = 0x00000000;
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x0A02             LSRS     R2,R0,#+8
   \   0000002C   0x0212             LSLS     R2,R2,#+8
   \   0000002E   0x6011             STR      R1,[R2, #+0]
   1040          }
   \   00000030   0x4770             BX       LR               ;; return
   1041            
   1042          
   1043          /*
   1044          ==============================================================================
   1045                        OPTIONS BYTES
   1046          ==============================================================================
   1047          */
   1048          /**
   1049            * @brief  Enables or disables the read out protection.
   1050            * @note   To correctly run this function, the HAL_FLASH_OB_Unlock() function
   1051            *         must be called before.
   1052            * @param  OB_RDP: specifies the read protection level. 
   1053            *   This parameter can be:
   1054            *     @arg OB_RDP_LEVEL0: No protection
   1055            *     @arg OB_RDP_LEVEL1: Read protection of the memory
   1056            *     @arg OB_RDP_LEVEL2: Chip protection
   1057            * 
   1058            *  !!!Warning!!! When enabling OB_RDP_LEVEL2 it's no more possible to go back to level 1 or 0
   1059            *   
   1060            * @retval HAL status
   1061            */

   \                                 In section .text, align 2, keep-with-next
   1062          static HAL_StatusTypeDef FLASH_OB_RDPConfig(uint8_t OB_RDP)
   1063          {
   \                     FLASH_OB_RDPConfig: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   1064            HAL_StatusTypeDef status = HAL_OK;
   \   00000006   0x2500             MOVS     R5,#+0
   1065            uint32_t tmp1 = 0, tmp2 = 0, sprmod = 0;
   \   00000008   0x2600             MOVS     R6,#+0
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   1066            
   1067            /* Check the parameters */
   1068            assert_param(IS_OB_RDP(OB_RDP));
   1069            
   1070            /* According to errata sheet, DocID022054 Rev 5, par2.1.5
   1071            Before setting Level0 in the RDP register, check that the current level is not equal to Level0.
   1072            If the current level is not equal to Level0, Level0 can be activated.
   1073            If the current level is Level0 then the RDP register must not be written again with Level0. */
   1074            tmp1 = (uint32_t)(OB->RDP & 0x000000FF);
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable24_7  ;; 0x1ff80000
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF000 0x00FF      AND      R0,R0,#0xFF
   \   0000001A   0x0006             MOVS     R6,R0
   1075            
   1076            if ((tmp1 == OB_RDP_LEVEL0) && (OB_RDP == OB_RDP_LEVEL0))
   \   0000001C   0x2EAA             CMP      R6,#+170
   \   0000001E   0xD105             BNE.N    ??FLASH_OB_RDPConfig_0
   \   00000020   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000022   0x2CAA             CMP      R4,#+170
   \   00000024   0xD102             BNE.N    ??FLASH_OB_RDPConfig_0
   1077            {
   1078              /*current level is Level0 then the RDP register must not be written again with Level0. */
   1079              status = HAL_ERROR;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x0005             MOVS     R5,R0
   \   0000002A   0xE024             B.N      ??FLASH_OB_RDPConfig_1
   1080            }
   1081            else 
   1082            {
   1083              /* Clean the error context */
   1084              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \                     ??FLASH_OB_RDPConfig_0: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable24
   \   00000032   0x6148             STR      R0,[R1, #+20]
   1085          
   1086              /* Mask SPRMOD bit */
   1087              sprmod = (uint32_t)(OB->RDP & 0x00000100);
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable24_7  ;; 0x1ff80000
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0xF410 0x7080      ANDS     R0,R0,#0x100
   \   0000003E   0x4680             MOV      R8,R0
   1088          
   1089              status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000040   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000044   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000048   0x0005             MOVS     R5,R0
   1090              
   1091              /* calculate the option byte to write */
   1092              tmp1 = (~((uint32_t)(OB_RDP | sprmod)));
   \   0000004A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004C   0xEA58 0x0004      ORRS     R0,R8,R4
   \   00000050   0x43C0             MVNS     R0,R0
   \   00000052   0x0006             MOVS     R6,R0
   1093              tmp2 = (uint32_t)(((uint32_t)((uint32_t)(tmp1) << 16)) | ((uint32_t)(OB_RDP | sprmod)));
   \   00000054   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000056   0xEA54 0x4006      ORRS     R0,R4,R6, LSL #+16
   \   0000005A   0xEA58 0x0000      ORRS     R0,R8,R0
   \   0000005E   0x0007             MOVS     R7,R0
   1094              
   1095              if(status == HAL_OK)
   \   00000060   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000062   0x2D00             CMP      R5,#+0
   \   00000064   0xD102             BNE.N    ??FLASH_OB_RDPConfig_2
   1096              {         
   1097               /* program read protection level */
   1098                OB->RDP = tmp2;
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable24_7  ;; 0x1ff80000
   \   0000006A   0x6007             STR      R7,[R0, #+0]
   1099              }
   1100              
   1101              /* Wait for last operation to be completed */
   1102              status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \                     ??FLASH_OB_RDPConfig_2: (+1)
   \   0000006C   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000070   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000074   0x0005             MOVS     R5,R0
   1103            }
   1104               
   1105            /* Return the Read protection operation Status */
   1106            return status;            
   \                     ??FLASH_OB_RDPConfig_1: (+1)
   \   00000076   0x0028             MOVS     R0,R5
   \   00000078   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1107          }
   1108          
   1109          /**
   1110            * @brief  Programs the FLASH brownout reset threshold level Option Byte.
   1111            * @param  OB_BOR: Selects the brownout reset threshold level.
   1112            *   This parameter can be one of the following values:
   1113            *     @arg OB_BOR_OFF: BOR is disabled at power down, the reset is asserted when the VDD 
   1114            *                      power supply reaches the PDR(Power Down Reset) threshold (1.5V)
   1115            *     @arg OB_BOR_LEVEL1: BOR Reset threshold levels for 1.7V - 1.8V VDD power supply
   1116            *     @arg OB_BOR_LEVEL2: BOR Reset threshold levels for 1.9V - 2.0V VDD power supply
   1117            *     @arg OB_BOR_LEVEL3: BOR Reset threshold levels for 2.3V - 2.4V VDD power supply
   1118            *     @arg OB_BOR_LEVEL4: BOR Reset threshold levels for 2.55V - 2.65V VDD power supply
   1119            *     @arg OB_BOR_LEVEL5: BOR Reset threshold levels for 2.8V - 2.9V VDD power supply
   1120            * @retval HAL status
   1121            */

   \                                 In section .text, align 2, keep-with-next
   1122          static HAL_StatusTypeDef FLASH_OB_BORConfig(uint8_t OB_BOR)
   1123          {
   \                     FLASH_OB_BORConfig: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1124            HAL_StatusTypeDef status = HAL_OK;
   \   00000004   0x2500             MOVS     R5,#+0
   1125            uint32_t tmp = 0, tmp1 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0x2700             MOVS     R7,#+0
   1126          
   1127            /* Check the parameters */
   1128            assert_param(IS_OB_BOR_LEVEL(OB_BOR));
   1129          
   1130            /* Get the User Option byte register */
   1131            tmp1 = (FLASH->OBR & (FLASH_OBR_USER)) >> 16;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable24_8  ;; 0x40023c1c
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x0C00             LSRS     R0,R0,#+16
   \   00000012   0xF010 0x0070      ANDS     R0,R0,#0x70
   \   00000016   0x0007             MOVS     R7,R0
   1132               
   1133            /* Calculate the option byte to write - [0xFF | nUSER | 0x00 | USER]*/
   1134            tmp = (uint32_t)~((OB_BOR | tmp1)) << 16;
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0xEA57 0x0004      ORRS     R0,R7,R4
   \   0000001E   0x43C0             MVNS     R0,R0
   \   00000020   0x0400             LSLS     R0,R0,#+16
   \   00000022   0x0006             MOVS     R6,R0
   1135            tmp |= (OB_BOR | tmp1);
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0xEA57 0x0004      ORRS     R0,R7,R4
   \   0000002A   0x4306             ORRS     R6,R0,R6
   1136              
   1137            /* Wait for last operation to be completed */
   1138            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   0000002C   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000030   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000034   0x0005             MOVS     R5,R0
   1139            
   1140            if(status == HAL_OK)
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0xD106             BNE.N    ??FLASH_OB_BORConfig_0
   1141            {  
   1142              /* Clean the error context */
   1143              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable24
   \   00000042   0x6148             STR      R0,[R1, #+20]
   1144          
   1145              /* Write the BOR Option Byte */            
   1146              OB->USER = tmp; 
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable24_9  ;; 0x1ff80004
   \   00000048   0x6006             STR      R6,[R0, #+0]
   1147            }
   1148            
   1149            /* Wait for last operation to be completed */
   1150            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \                     ??FLASH_OB_BORConfig_0: (+1)
   \   0000004A   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000004E   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000052   0x0005             MOVS     R5,R0
   1151                  
   1152            /* Return the Option Byte program Status */
   1153            return status;
   \   00000054   0x0028             MOVS     R0,R5
   \   00000056   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000058   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1154          }
   1155          
   1156          /**
   1157            * @brief  Returns the FLASH User Option Bytes values.
   1158            * @retval The FLASH User Option Bytes.
   1159            */

   \                                 In section .text, align 2, keep-with-next
   1160          static uint8_t FLASH_OB_GetUser(void)
   1161          {
   1162            /* Return the User Option Byte */
   1163            return (uint8_t)((FLASH->OBR & FLASH_OBR_USER) >> POSITION_VAL(FLASH_OBR_USER));
   \                     FLASH_OB_GetUser: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable24_8  ;; 0x40023c1c
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF410 0x00E0      ANDS     R0,R0,#0x700000
   \   0000000A   0xF44F 0x6160      MOV      R1,#+3584
   \   0000000E   0xFAB1 0xF181      CLZ      R1,R1
   \   00000012   0x40C8             LSRS     R0,R0,R1
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x4770             BX       LR               ;; return
   1164          }
   1165          
   1166          /**
   1167            * @brief  Checks whether the FLASH Read out Protection Status is set or not.
   1168            * @retval FLASH ReadOut Protection
   1169            */

   \                                 In section .text, align 2, keep-with-next
   1170          static uint8_t FLASH_OB_GetRDP(void)
   1171          {
   1172            return (uint8_t)(FLASH->OBR & FLASH_OBR_RDPRT);
   \                     FLASH_OB_GetRDP: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable24_8  ;; 0x40023c1c
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x4770             BX       LR               ;; return
   1173          }
   1174          
   1175          /**
   1176            * @brief  Returns the FLASH BOR level.
   1177            * @retval The FLASH User Option Bytes.
   1178            */

   \                                 In section .text, align 2, keep-with-next
   1179          static uint8_t FLASH_OB_GetBOR(void)
   1180          {
   1181            /* Return the BOR level */
   1182            return (uint8_t)((FLASH->OBR & (uint32_t)FLASH_OBR_BOR_LEV) >> POSITION_VAL(FLASH_OBR_BOR_LEV));
   \                     FLASH_OB_GetBOR: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable24_8  ;; 0x40023c1c
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF410 0x2070      ANDS     R0,R0,#0xF0000
   \   0000000A   0xF44F 0x4170      MOV      R1,#+61440
   \   0000000E   0xFAB1 0xF181      CLZ      R1,R1
   \   00000012   0x40C8             LSRS     R0,R0,R1
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x4770             BX       LR               ;; return
   1183          }
   1184          
   1185          /**
   1186            * @brief  Write protects the desired pages of the first 64KB of the Flash.
   1187            * @param  pOBInit: pointer to an FLASH_OBInitStruct structure that
   1188            *         contains WRP parameters.
   1189            * @param  NewState: new state of the specified FLASH Pages Wtite protection.
   1190            *   This parameter can be: ENABLE or DISABLE.
   1191            * @retval HAL_StatusTypeDef
   1192            */

   \                                 In section .text, align 2, keep-with-next
   1193          static HAL_StatusTypeDef FLASH_OB_WRPConfig(FLASH_OBProgramInitTypeDef *pOBInit, FunctionalState NewState)
   1194          {
   \                     FLASH_OB_WRPConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1195            HAL_StatusTypeDef status = HAL_OK;
   \   00000006   0x2600             MOVS     R6,#+0
   1196            
   1197            /* Wait for last operation to be completed */
   1198            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000008   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000000C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000010   0x0006             MOVS     R6,R0
   1199           
   1200            if(status == HAL_OK)
   \   00000012   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD110             BNE.N    ??FLASH_OB_WRPConfig_0
   1201            {
   1202              /* Clean the error context */
   1203              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable24
   \   0000001E   0x6148             STR      R0,[R1, #+20]
   1204          
   1205              /* WRP for sector between 0 to 31 */
   1206              if (pOBInit->WRPSector0To31 != 0)
   \   00000020   0x68A0             LDR      R0,[R4, #+8]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD004             BEQ.N    ??FLASH_OB_WRPConfig_1
   1207              {
   1208                FLASH_OB_WRPConfigWRP1OrPCROP1(pOBInit->WRPSector0To31, NewState);
   \   00000026   0x0029             MOVS     R1,R5
   \   00000028   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002A   0x68A0             LDR      R0,[R4, #+8]
   \   0000002C   0x.... 0x....      BL       FLASH_OB_WRPConfigWRP1OrPCROP1
   1209              }
   1210              
   1211          #if defined(STM32L100xC) || defined (STM32L151xC) || defined (STM32L152xC) || defined (STM32L162xC) || \
   1212              defined(STM32L151xCA) || defined(STM32L151xD) || defined(STM32L151xDX) || defined (STM32L152xCA) || \
   1213              defined(STM32L152xD) || defined(STM32L152xDX) || defined (STM32L162xCA) || defined(STM32L162xD)  || \
   1214              defined(STM32L162xDX) || defined(STM32L151xE) || defined (STM32L152xE) || defined (STM32L162xE)
   1215                
   1216              /* Pages for Cat3, Cat4 & Cat5 devices*/
   1217              /* WRP for sector between 32 to 63 */
   1218              if (pOBInit->WRPSector32To63 != 0)
   1219              {
   1220                FLASH_OB_WRPConfigWRP2OrPCROP2(pOBInit->WRPSector32To63, NewState);
   1221              }
   1222              
   1223          #endif /* STM32L100xC || STM32L151xC || STM32L152xC || (...) || STM32L151xE || STM32L152xE || STM32L162xE */
   1224          
   1225          #if defined(STM32L151xD) || defined(STM32L151xDX) || defined(STM32L152xD) || defined(STM32L152xDX) || \
   1226              defined(STM32L162xD) || defined(STM32L162xDX) || defined(STM32L151xE) || defined (STM32L152xE) || \
   1227              defined (STM32L162xE)
   1228                
   1229              /* Pages for devices with FLASH >= 256KB*/
   1230              /* WRP for sector between 64 to 95 */
   1231              if (pOBInit->WRPSector64To95 != 0)
   1232              {
   1233                FLASH_OB_WRPConfigWRP3(pOBInit->WRPSector64To95, NewState);
   1234              }
   1235              
   1236          #endif /* STM32L151xD || STM32L152xD || STM32L162xD || STM32L151xE || STM32L152xE || STM32L162xE */
   1237          
   1238          #if defined(STM32L151xE) || defined (STM32L152xE) || defined (STM32L162xE) || \
   1239              defined(STM32L151xDX) || defined(STM32L152xDX) || defined(STM32L162xDX)
   1240          
   1241              /* Pages for Cat5 devices*/
   1242              /* WRP for sector between 96 to 127 */
   1243              if (pOBInit->WRPSector96To127 != 0)
   1244              {
   1245                FLASH_OB_WRPConfigWRP4(pOBInit->WRPSector96To127, NewState);
   1246              }
   1247              
   1248          #endif /* STM32L151xE || STM32L152xE || STM32L162xE || STM32L151xDX || ... */
   1249          
   1250              /* Wait for last operation to be completed */
   1251              status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \                     ??FLASH_OB_WRPConfig_1: (+1)
   \   00000030   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000034   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000038   0x0006             MOVS     R6,R0
   1252            }
   1253          
   1254            /* Return the write protection operation Status */
   1255            return status;      
   \                     ??FLASH_OB_WRPConfig_0: (+1)
   \   0000003A   0x0030             MOVS     R0,R6
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0xBD70             POP      {R4-R6,PC}       ;; return
   1256          }
   1257          
   1258          #if defined (STM32L151xBA) || defined (STM32L152xBA) || \
   1259              defined (STM32L151xC) || defined (STM32L152xC) || defined (STM32L162xC)
   1260          /**
   1261            * @brief  Enables the read/write protection (PCROP) of the desired 
   1262            *         sectors.
   1263            * @note   This function can be used only for Cat2 & Cat3 devices
   1264            * @param  pAdvOBInit: pointer to an FLASH_AdvOBProgramInitTypeDef structure that
   1265            *         contains PCROP parameters.
   1266            * @param  NewState: new state of the specified FLASH Pages read/Write protection.
   1267            *   This parameter can be: ENABLE or DISABLE.
   1268            * @retval HAL status
   1269            */
   1270          static HAL_StatusTypeDef FLASH_OB_PCROPConfig(FLASH_AdvOBProgramInitTypeDef *pAdvOBInit, FunctionalState NewState)
   1271          {
   1272            HAL_StatusTypeDef status = HAL_OK;
   1273            FunctionalState pcropstate = DISABLE;
   1274            
   1275            /* Wait for last operation to be completed */
   1276            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   1277            
   1278            /* Invert state to use same function of WRP */
   1279            if (NewState == DISABLE)
   1280            {
   1281              pcropstate = ENABLE;
   1282            }
   1283                  
   1284            if(status == HAL_OK)
   1285            {
   1286              /* Clean the error context */
   1287              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   1288          
   1289              /* Pages for Cat2 devices*/
   1290              /* PCROP for sector between 0 to 31 */
   1291              if (pAdvOBInit->PCROPSector0To31 != 0)
   1292              {
   1293                FLASH_OB_WRPConfigWRP1OrPCROP1(pAdvOBInit->PCROPSector0To31, pcropstate);
   1294              }
   1295              
   1296          #if defined(STM32L100xC) || defined (STM32L151xC) || defined (STM32L152xC) || defined (STM32L162xC)
   1297          
   1298              /* Pages for Cat3 devices*/
   1299              /* WRP for sector between 32 to 63 */
   1300              if (pAdvOBInit->PCROPSector32To63 != 0)
   1301              {
   1302                FLASH_OB_WRPConfigWRP2OrPCROP2(pAdvOBInit->PCROPSector32To63, pcropstate);
   1303              }
   1304              
   1305          #endif /* STM32L100xC || STM32L151xC || STM32L152xC || STM32L162xC  */
   1306              
   1307              /* Wait for last operation to be completed */
   1308              status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   1309            }
   1310          
   1311            /* Return the write protection operation Status */
   1312            return status;      
   1313          }
   1314          #endif /* STM32L151xBA || STM32L152xBA || STM32L151xC || STM32L152xC || STM32L162xC */
   1315          
   1316          /**
   1317            * @brief  Write protects the desired pages of the first 128KB of the Flash.
   1318            * @param  WRP1OrPCROP1: specifies the address of the pages to be write protected.
   1319            *   This parameter can be a combination of @ref FLASHEx_Option_Bytes_Write_Protection1
   1320            * @param  NewState: new state of the specified FLASH Pages Wtite protection.
   1321            *   This parameter can be: ENABLE or DISABLE.
   1322            * @retval None
   1323            */

   \                                 In section .text, align 2, keep-with-next
   1324          static void FLASH_OB_WRPConfigWRP1OrPCROP1(uint32_t WRP1OrPCROP1, FunctionalState NewState)
   1325          {
   \                     FLASH_OB_WRPConfigWRP1OrPCROP1: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   1326            uint32_t wrp01data = 0, wrp23data = 0;
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x2300             MOVS     R3,#+0
   1327            
   1328            uint32_t tmp1 = 0, tmp2 = 0;
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0x2500             MOVS     R5,#+0
   1329            
   1330            if (NewState != DISABLE)
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD01B             BEQ.N    ??FLASH_OB_WRPConfigWRP1OrPCROP1_0
   1331            {
   1332              wrp01data = (uint16_t)(((WRP1OrPCROP1 & WRP_MASK_LOW) | OB->WRP01));
   \   00000010   0x.... 0x....      LDR.W    R6,??DataTable24_10  ;; 0x1ff80008
   \   00000014   0x6836             LDR      R6,[R6, #+0]
   \   00000016   0x4306             ORRS     R6,R6,R0
   \   00000018   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000001A   0x0032             MOVS     R2,R6
   1333              wrp23data = (uint16_t)((((WRP1OrPCROP1 & WRP_MASK_HIGH)>>16 | OB->WRP23))); 
   \   0000001C   0x.... 0x....      LDR.W    R6,??DataTable24_11  ;; 0x1ff8000c
   \   00000020   0x6836             LDR      R6,[R6, #+0]
   \   00000022   0xEA56 0x4610      ORRS     R6,R6,R0, LSR #+16
   \   00000026   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000028   0x0033             MOVS     R3,R6
   1334              tmp1 = (uint32_t)(~(wrp01data) << 16)|(wrp01data);
   \   0000002A   0x43D6             MVNS     R6,R2
   \   0000002C   0xEA52 0x4606      ORRS     R6,R2,R6, LSL #+16
   \   00000030   0x0034             MOVS     R4,R6
   1335              OB->WRP01 = tmp1;
   \   00000032   0x.... 0x....      LDR.W    R6,??DataTable24_10  ;; 0x1ff80008
   \   00000036   0x6034             STR      R4,[R6, #+0]
   1336          
   1337              tmp2 = (uint32_t)(~(wrp23data) << 16)|(wrp23data);
   \   00000038   0x43DE             MVNS     R6,R3
   \   0000003A   0xEA53 0x4606      ORRS     R6,R3,R6, LSL #+16
   \   0000003E   0x0035             MOVS     R5,R6
   1338              OB->WRP23 = tmp2;      
   \   00000040   0x.... 0x....      LDR.W    R6,??DataTable24_11  ;; 0x1ff8000c
   \   00000044   0x6035             STR      R5,[R6, #+0]
   \   00000046   0xE01F             B.N      ??FLASH_OB_WRPConfigWRP1OrPCROP1_1
   1339            }
   1340            else
   1341            {
   1342              wrp01data = (uint16_t)(~WRP1OrPCROP1 & (WRP_MASK_LOW & OB->WRP01));
   \                     ??FLASH_OB_WRPConfigWRP1OrPCROP1_0: (+1)
   \   00000048   0x.... 0x....      LDR.W    R6,??DataTable24_10  ;; 0x1ff80008
   \   0000004C   0x6836             LDR      R6,[R6, #+0]
   \   0000004E   0x4386             BICS     R6,R6,R0
   \   00000050   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000052   0x0032             MOVS     R2,R6
   1343              wrp23data = (uint16_t)((((~WRP1OrPCROP1 & WRP_MASK_HIGH)>>16 & OB->WRP23))); 
   \   00000054   0xF3C0 0x460F      UBFX     R6,R0,#+16,#+16
   \   00000058   0xF486 0x467F      EOR      R6,R6,#0xFF00
   \   0000005C   0xF096 0x06FF      EORS     R6,R6,#0xFF
   \   00000060   0x.... 0x....      LDR.W    R7,??DataTable24_11  ;; 0x1ff8000c
   \   00000064   0x683F             LDR      R7,[R7, #+0]
   \   00000066   0x403E             ANDS     R6,R7,R6
   \   00000068   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000006A   0x0033             MOVS     R3,R6
   1344          
   1345              tmp1 = (uint32_t)((~wrp01data) << 16)|(wrp01data);
   \   0000006C   0x43D6             MVNS     R6,R2
   \   0000006E   0xEA52 0x4606      ORRS     R6,R2,R6, LSL #+16
   \   00000072   0x0034             MOVS     R4,R6
   1346              OB->WRP01 = tmp1;
   \   00000074   0x.... 0x....      LDR.W    R6,??DataTable24_10  ;; 0x1ff80008
   \   00000078   0x6034             STR      R4,[R6, #+0]
   1347              
   1348              tmp2 = (uint32_t)((~wrp23data) << 16)|(wrp23data);
   \   0000007A   0x43DE             MVNS     R6,R3
   \   0000007C   0xEA53 0x4606      ORRS     R6,R3,R6, LSL #+16
   \   00000080   0x0035             MOVS     R5,R6
   1349              OB->WRP23 = tmp2;
   \   00000082   0x.... 0x....      LDR.W    R6,??DataTable24_11  ;; 0x1ff8000c
   \   00000086   0x6035             STR      R5,[R6, #+0]
   1350            }
   1351          }
   \                     ??FLASH_OB_WRPConfigWRP1OrPCROP1_1: (+1)
   \   00000088   0xBCF0             POP      {R4-R7}
   \   0000008A   0x4770             BX       LR               ;; return
   1352          
   1353          #if defined(STM32L100xC) || defined (STM32L151xC) || defined (STM32L152xC) || defined (STM32L162xC) || \
   1354              defined(STM32L151xCA) || defined(STM32L151xD) || defined(STM32L151xDX) || defined (STM32L152xCA) || \
   1355              defined(STM32L152xD) || defined(STM32L152xDX) || defined (STM32L162xCA) || defined(STM32L162xD)  || \
   1356              defined(STM32L162xDX) || defined(STM32L151xE) || defined (STM32L152xE) || defined (STM32L162xE)
   1357          /**
   1358            * @brief  Enable Write protects the desired pages of the second 128KB of the Flash.
   1359            * @note   This function can be used only for Cat3, Cat4  & Cat5 devices.
   1360            * @param  WRP2OrPCROP2: specifies the address of the pages to be write protected.
   1361            *   This parameter can be a combination of @ref FLASHEx_Option_Bytes_Write_Protection2
   1362            * @param  NewState: new state of the specified FLASH Pages Wtite protection.
   1363            *   This parameter can be: ENABLE or DISABLE.
   1364            * @retval None
   1365            */
   1366          static void FLASH_OB_WRPConfigWRP2OrPCROP2(uint32_t WRP2OrPCROP2, FunctionalState NewState)
   1367          {
   1368            uint32_t wrp45data = 0, wrp67data = 0;
   1369            
   1370            uint32_t tmp1 = 0, tmp2 = 0;
   1371            
   1372            if (NewState != DISABLE)
   1373            {
   1374              wrp45data = (uint16_t)(((WRP2OrPCROP2 & WRP_MASK_LOW) | OB->WRP45));
   1375              wrp67data = (uint16_t)((((WRP2OrPCROP2 & WRP_MASK_HIGH)>>16 | OB->WRP67))); 
   1376              tmp1 = (uint32_t)(~(wrp45data) << 16)|(wrp45data);
   1377              OB->WRP45 = tmp1;
   1378              
   1379              tmp2 = (uint32_t)(~(wrp67data) << 16)|(wrp67data);
   1380              OB->WRP67 = tmp2;
   1381            }
   1382            else
   1383            {
   1384              wrp45data = (uint16_t)(~WRP2OrPCROP2 & (WRP_MASK_LOW & OB->WRP45));
   1385              wrp67data = (uint16_t)((((~WRP2OrPCROP2 & WRP_MASK_HIGH)>>16 & OB->WRP67))); 
   1386              
   1387              tmp1 = (uint32_t)((~wrp45data) << 16)|(wrp45data);
   1388              OB->WRP45 = tmp1;
   1389              
   1390              tmp2 = (uint32_t)((~wrp67data) << 16)|(wrp67data);
   1391              OB->WRP67 = tmp2;
   1392            }
   1393          }
   1394          #endif /* STM32L100xC || STM32L151xC || STM32L152xC || (...) || STM32L151xE || STM32L152xE || STM32L162xE */
   1395          
   1396          #if defined(STM32L151xD) || defined(STM32L151xDX) || defined(STM32L152xD) || defined(STM32L152xDX) || \
   1397              defined(STM32L162xD) || defined(STM32L162xDX) || defined(STM32L151xE) || defined (STM32L152xE) || \
   1398              defined (STM32L162xE)
   1399          /**
   1400            * @brief  Enable Write protects the desired pages of the third 128KB of the Flash.
   1401            * @note   This function can be used only for STM32L151xD, STM32L152xD, STM32L162xD  & Cat5 devices.
   1402            * @param  WRP3: specifies the address of the pages to be write protected.
   1403            *   This parameter can be a combination of @ref FLASHEx_Option_Bytes_Write_Protection3
   1404            * @param  NewState: new state of the specified FLASH Pages Wtite protection.
   1405            *   This parameter can be: ENABLE or DISABLE.
   1406            * @retval None
   1407            */
   1408          static void FLASH_OB_WRPConfigWRP3(uint32_t WRP3, FunctionalState NewState)
   1409          {
   1410            uint32_t wrp89data = 0, wrp1011data = 0;
   1411            
   1412            uint32_t tmp1 = 0, tmp2 = 0;
   1413            
   1414            if (NewState != DISABLE)
   1415            {
   1416              wrp89data = (uint16_t)(((WRP3 & WRP_MASK_LOW) | OB->WRP89));
   1417              wrp1011data = (uint16_t)((((WRP3 & WRP_MASK_HIGH)>>16 | OB->WRP1011))); 
   1418              tmp1 = (uint32_t)(~(wrp89data) << 16)|(wrp89data);
   1419              OB->WRP89 = tmp1;
   1420          
   1421              tmp2 = (uint32_t)(~(wrp1011data) << 16)|(wrp1011data);
   1422              OB->WRP1011 = tmp2;      
   1423            }
   1424            else
   1425            {
   1426              wrp89data = (uint16_t)(~WRP3 & (WRP_MASK_LOW & OB->WRP89));
   1427              wrp1011data = (uint16_t)((((~WRP3 & WRP_MASK_HIGH)>>16 & OB->WRP1011))); 
   1428          
   1429              tmp1 = (uint32_t)((~wrp89data) << 16)|(wrp89data);
   1430              OB->WRP89 = tmp1;
   1431          
   1432              tmp2 = (uint32_t)((~wrp1011data) << 16)|(wrp1011data);
   1433              OB->WRP1011 = tmp2;
   1434            }
   1435          }
   1436          #endif /* STM32L151xD || STM32L152xD || STM32L162xD || STM32L151xE || STM32L152xE || STM32L162xE */
   1437          
   1438          #if defined(STM32L151xE) || defined (STM32L152xE) || defined (STM32L162xE) || \
   1439              defined(STM32L151xDX) || defined(STM32L152xDX) || defined(STM32L162xDX)
   1440          /**
   1441            * @brief  Enable Write protects the desired pages of the Fourth 128KB of the Flash.
   1442            * @note   This function can be used only for Cat5 & STM32L1xxDX devices.
   1443            * @param  WRP4: specifies the address of the pages to be write protected.
   1444            *   This parameter can be a combination of @ref FLASHEx_Option_Bytes_Write_Protection4
   1445            * @param  NewState: new state of the specified FLASH Pages Wtite protection.
   1446            *   This parameter can be: ENABLE or DISABLE.
   1447            * @retval None
   1448            */
   1449          static void FLASH_OB_WRPConfigWRP4(uint32_t WRP4, FunctionalState NewState)
   1450          {
   1451            uint32_t wrp1213data = 0, wrp1415data = 0;
   1452            
   1453            uint32_t tmp1 = 0, tmp2 = 0;
   1454            
   1455            if (NewState != DISABLE)
   1456            {
   1457              wrp1213data = (uint16_t)(((WRP4 & WRP_MASK_LOW) | OB->WRP1213));
   1458              wrp1415data = (uint16_t)((((WRP4 & WRP_MASK_HIGH)>>16 | OB->WRP1415))); 
   1459              tmp1 = (uint32_t)(~(wrp1213data) << 16)|(wrp1213data);
   1460              OB->WRP1213 = tmp1;
   1461          
   1462              tmp2 = (uint32_t)(~(wrp1415data) << 16)|(wrp1415data);
   1463              OB->WRP1415 = tmp2;      
   1464            }
   1465            else
   1466            {
   1467              wrp1213data = (uint16_t)(~WRP4 & (WRP_MASK_LOW & OB->WRP1213));
   1468              wrp1415data = (uint16_t)((((~WRP4 & WRP_MASK_HIGH)>>16 & OB->WRP1415))); 
   1469          
   1470              tmp1 = (uint32_t)((~wrp1213data) << 16)|(wrp1213data);
   1471              OB->WRP1213 = tmp1;
   1472          
   1473              tmp2 = (uint32_t)((~wrp1415data) << 16)|(wrp1415data);
   1474              OB->WRP1415 = tmp2;
   1475            }
   1476          }
   1477          #endif /* STM32L151xE || STM32L152xE || STM32L162xE || STM32L151xDX || ... */
   1478          
   1479          /**
   1480            * @brief  Programs the FLASH User Option Byte: IWDG_SW / RST_STOP / RST_STDBY.
   1481            * @param  OB_IWDG: Selects the WDG mode.
   1482            *   This parameter can be one of the following values:
   1483            *     @arg OB_IWDG_SW: Software WDG selected
   1484            *     @arg OB_IWDG_HW: Hardware WDG selected
   1485            * @param  OB_STOP: Reset event when entering STOP mode.
   1486            *   This parameter can be one of the following values:
   1487            *     @arg OB_STOP_NORST: No reset generated when entering in STOP
   1488            *     @arg OB_STOP_RST: Reset generated when entering in STOP
   1489            * @param  OB_STDBY: Reset event when entering Standby mode.
   1490            *   This parameter can be one of the following values:
   1491            *     @arg OB_STDBY_NORST: No reset generated when entering in STANDBY
   1492            *     @arg OB_STDBY_RST: Reset generated when entering in STANDBY
   1493            * @retval HAL status
   1494            */

   \                                 In section .text, align 2, keep-with-next
   1495          static HAL_StatusTypeDef FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
   1496          {
   \                     FLASH_OB_UserConfig: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1497            HAL_StatusTypeDef status = HAL_OK; 
   \   0000000A   0x2700             MOVS     R7,#+0
   1498            uint32_t tmp = 0, tmp1 = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
   1499          
   1500            /* Check the parameters */
   1501            assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
   1502            assert_param(IS_OB_STOP_SOURCE(OB_STOP));
   1503            assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
   1504          
   1505            /* Get the User Option byte register */
   1506            tmp1 = (FLASH->OBR & FLASH_OBR_BOR_LEV) >> 16;
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable24_8  ;; 0x40023c1c
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0xF3C0 0x4003      UBFX     R0,R0,#+16,#+4
   \   0000001E   0x4681             MOV      R9,R0
   1507            
   1508            /* Calculate the user option byte to write */ 
   1509            tmp = (uint32_t)(((uint32_t)~((uint32_t)((uint32_t)(OB_IWDG) | (uint32_t)(OB_STOP) | (uint32_t)(OB_STDBY) | tmp1))) << 16);
   \   00000020   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0xEA55 0x0004      ORRS     R0,R5,R4
   \   00000028   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002A   0x4330             ORRS     R0,R6,R0
   \   0000002C   0xEA59 0x0000      ORRS     R0,R9,R0
   \   00000030   0x43C0             MVNS     R0,R0
   \   00000032   0x0400             LSLS     R0,R0,#+16
   \   00000034   0x4680             MOV      R8,R0
   1510            tmp |= ((uint32_t)(OB_IWDG) | ((uint32_t)OB_STOP) | (uint32_t)(OB_STDBY) | tmp1);
   \   00000036   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0xEA55 0x0004      ORRS     R0,R5,R4
   \   0000003E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000040   0x4330             ORRS     R0,R6,R0
   \   00000042   0xEA59 0x0000      ORRS     R0,R9,R0
   \   00000046   0xEA50 0x0808      ORRS     R8,R0,R8
   1511            
   1512            /* Wait for last operation to be completed */
   1513            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   0000004A   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000004E   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000052   0x0007             MOVS     R7,R0
   1514            
   1515            if(status == HAL_OK)
   \   00000054   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000056   0x2F00             CMP      R7,#+0
   \   00000058   0xD107             BNE.N    ??FLASH_OB_UserConfig_0
   1516            {  
   1517              /* Clean the error context */
   1518              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable24
   \   00000060   0x6148             STR      R0,[R1, #+20]
   1519          
   1520              /* Write the User Option Byte */              
   1521              OB->USER = tmp; 
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable24_9  ;; 0x1ff80004
   \   00000066   0xF8C0 0x8000      STR      R8,[R0, #+0]
   1522            }
   1523            
   1524            /* Wait for last operation to be completed */
   1525              status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \                     ??FLASH_OB_UserConfig_0: (+1)
   \   0000006A   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000006E   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000072   0x0007             MOVS     R7,R0
   1526                 
   1527            /* Return the Option Byte program Status */
   1528            return status;
   \   00000074   0x0038             MOVS     R0,R7
   \   00000076   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000078   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1529          }
   1530          
   1531          #if defined(STM32L151xD) || defined(STM32L151xDX) || defined(STM32L152xD) || defined(STM32L152xDX) || \
   1532              defined(STM32L162xD) || defined(STM32L162xDX) || defined(STM32L151xE) || defined (STM32L152xE) || \
   1533              defined (STM32L162xE)
   1534          /**
   1535            * @brief  Configures to boot from Bank1 or Bank2.
   1536            * @param  OB_BOOT: select the FLASH Bank to boot from.
   1537            *   This parameter can be one of the following values:
   1538            *     @arg OB_BOOT_BANK2: At startup, if boot pins are set in boot from user Flash
   1539            *        position and this parameter is selected the device will boot from Bank2 or Bank1,
   1540            *        depending on the activation of the bank. The active banks are checked in
   1541            *        the following order: Bank2, followed by Bank1.
   1542            *        The active bank is recognized by the value programmed at the base address
   1543            *        of the respective bank (corresponding to the initial stack pointer value
   1544            *        in the interrupt vector table).
   1545            *     @arg OB_BOOT_BANK1: At startup, if boot pins are set in boot from user Flash
   1546            *        position and this parameter is selected the device will boot from Bank1(Default).
   1547            *        For more information, please refer to AN2606 from www.st.com. 
   1548            * @retval HAL status
   1549            */
   1550          static HAL_StatusTypeDef FLASH_OB_BootConfig(uint8_t OB_BOOT)
   1551          {
   1552            HAL_StatusTypeDef status = HAL_OK; 
   1553            uint32_t tmp = 0, tmp1 = 0;
   1554          
   1555            /* Check the parameters */
   1556            assert_param(IS_OB_BOOT_BANK(OB_BOOT));
   1557          
   1558            /* Get the User Option byte register  and BOR Level*/
   1559            tmp1 = (FLASH->OBR & (FLASH_OBR_nRST_STDBY | FLASH_OBR_nRST_STOP | FLASH_OBR_IWDG_SW | FLASH_OBR_BOR_LEV)) >> 16;
   1560               
   1561            /* Calculate the option byte to write */
   1562            tmp = (uint32_t)~(OB_BOOT | tmp1) << 16;
   1563            tmp |= (OB_BOOT | tmp1);
   1564              
   1565            /* Wait for last operation to be completed */
   1566            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   1567            
   1568            if(status == HAL_OK)
   1569            {  
   1570              /* Clean the error context */
   1571              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   1572          
   1573              /* Write the BOOT Option Byte */            
   1574              OB->USER = tmp; 
   1575            }
   1576            
   1577            /* Wait for last operation to be completed */
   1578            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   1579                 
   1580            /* Return the Option Byte program Status */
   1581            return status;
   1582          }
   1583          
   1584          #endif /* STM32L151xD || STM32L152xD || STM32L162xD || STM32L151xE || STM32L152xE || STM32L162xE */
   1585          
   1586          /*
   1587          ==============================================================================
   1588                        DATA
   1589          ==============================================================================
   1590          */
   1591          
   1592          /**
   1593            * @brief  Write a Byte at a specified address in data memory.
   1594            * @param  Address: specifies the address to be written.
   1595            * @param  Data: specifies the data to be written.
   1596            * @note   This function assumes that the is data word is already erased.
   1597            * @retval HAL status
   1598            */

   \                                 In section .text, align 2, keep-with-next
   1599          static HAL_StatusTypeDef FLASH_DATAEEPROM_FastProgramByte(uint32_t Address, uint8_t Data)
   1600          {
   \                     FLASH_DATAEEPROM_FastProgramByte: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1601            HAL_StatusTypeDef status = HAL_OK;
   \   00000008   0x2600             MOVS     R6,#+0
   1602          #if defined(STM32L100xB) || defined (STM32L151xB) || defined (STM32L152xB)
   1603            uint32_t tmp = 0, tmpaddr = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   1604          #endif /* STM32L100xB || STM32L151xB || STM32L152xB  */
   1605            
   1606            /* Check the parameters */
   1607            assert_param(IS_FLASH_DATA_ADDRESS(Address)); 
   1608          
   1609            /* Wait for last operation to be completed */
   1610            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000010   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000014   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000018   0x0006             MOVS     R6,R0
   1611              
   1612            if(status == HAL_OK)
   \   0000001A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001C   0x2E00             CMP      R6,#+0
   \   0000001E   0xD12D             BNE.N    ??FLASH_DATAEEPROM_FastProgramByte_0
   1613            {
   1614              /* Clear the FTDW bit */
   1615              CLEAR_BIT(FLASH->PECR, FLASH_PECR_FTDW);
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x40023c04
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF430 0x7080      BICS     R0,R0,#0x100
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable24_1  ;; 0x40023c04
   \   0000002E   0x6008             STR      R0,[R1, #+0]
   1616          
   1617          #if defined(STM32L100xB) || defined (STM32L151xB) || defined (STM32L152xB)
   1618              /* Possible only on Cat1 devices */
   1619              if(Data != (uint8_t)0x00) 
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD006             BEQ.N    ??FLASH_DATAEEPROM_FastProgramByte_1
   1620              {
   1621                /* If the previous operation is completed, proceed to write the new Data */
   1622                *(__IO uint8_t *)Address = Data;
   \   00000036   0x7025             STRB     R5,[R4, #+0]
   1623                      
   1624                /* Wait for last operation to be completed */
   1625                status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000038   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000003C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000040   0x0006             MOVS     R6,R0
   \   00000042   0xE01B             B.N      ??FLASH_DATAEEPROM_FastProgramByte_0
   1626              }
   1627              else
   1628              {
   1629                tmpaddr = Address & 0xFFFFFFFC;
   \                     ??FLASH_DATAEEPROM_FastProgramByte_1: (+1)
   \   00000044   0x08A0             LSRS     R0,R4,#+2
   \   00000046   0x0080             LSLS     R0,R0,#+2
   \   00000048   0x4680             MOV      R8,R0
   1630                tmp = * (__IO uint32_t *) tmpaddr;
   \   0000004A   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000004E   0x0007             MOVS     R7,R0
   1631                tmpaddr = 0xFF << ((uint32_t) (0x8 * (Address & 0x3)));
   \   00000050   0x20FF             MOVS     R0,#+255
   \   00000052   0xF014 0x0103      ANDS     R1,R4,#0x3
   \   00000056   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000058   0x00C9             LSLS     R1,R1,#+3
   \   0000005A   0x4088             LSLS     R0,R0,R1
   \   0000005C   0x4680             MOV      R8,R0
   1632                tmp &= ~tmpaddr;
   \   0000005E   0xEA37 0x0708      BICS     R7,R7,R8
   1633                status = HAL_FLASHEx_DATAEEPROM_Erase(FLASH_TYPEERASEDATA_WORD, Address & 0xFFFFFFFC);
   \   00000062   0x08A1             LSRS     R1,R4,#+2
   \   00000064   0x0089             LSLS     R1,R1,#+2
   \   00000066   0x2002             MOVS     R0,#+2
   \   00000068   0x.... 0x....      BL       HAL_FLASHEx_DATAEEPROM_Erase
   \   0000006C   0x0006             MOVS     R6,R0
   1634                status = HAL_FLASHEx_DATAEEPROM_Program(FLASH_TYPEPROGRAMDATA_FASTWORD, (Address & 0xFFFFFFFC), tmp);
   \   0000006E   0x003A             MOVS     R2,R7
   \   00000070   0x08A1             LSRS     R1,R4,#+2
   \   00000072   0x0089             LSLS     R1,R1,#+2
   \   00000074   0x2010             MOVS     R0,#+16
   \   00000076   0x.... 0x....      BL       HAL_FLASHEx_DATAEEPROM_Program
   \   0000007A   0x0006             MOVS     R6,R0
   1635              }       
   1636          #else /*!Cat1*/ 
   1637              /* If the previous operation is completed, proceed to write the new Data */
   1638              *(__IO uint8_t *)Address = Data;
   1639                      
   1640              /* Wait for last operation to be completed */
   1641              status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   1642          #endif /* STM32L100xB || STM32L151xB || STM32L152xB  */
   1643            }
   1644            /* Return the Write Status */
   1645            return status;
   \                     ??FLASH_DATAEEPROM_FastProgramByte_0: (+1)
   \   0000007C   0x0030             MOVS     R0,R6
   \   0000007E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000080   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1646          }
   1647          
   1648          /**
   1649            * @brief  Writes a half word at a specified address in data memory.
   1650            * @param  Address: specifies the address to be written.
   1651            * @param  Data: specifies the data to be written.
   1652            * @note   This function assumes that the is data word is already erased.
   1653            * @retval HAL status
   1654            */

   \                                 In section .text, align 2, keep-with-next
   1655          static HAL_StatusTypeDef FLASH_DATAEEPROM_FastProgramHalfWord(uint32_t Address, uint16_t Data)
   1656          {
   \                     FLASH_DATAEEPROM_FastProgramHalfWord: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1657            HAL_StatusTypeDef status = HAL_OK;
   \   00000008   0x2600             MOVS     R6,#+0
   1658          #if defined(STM32L100xB) || defined (STM32L151xB) || defined (STM32L152xB)
   1659            uint32_t tmp = 0, tmpaddr = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   1660          #endif /* STM32L100xB || STM32L151xB || STM32L152xB  */
   1661            
   1662            /* Check the parameters */
   1663            assert_param(IS_FLASH_DATA_ADDRESS(Address));
   1664          
   1665            /* Wait for last operation to be completed */
   1666            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000010   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000014   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000018   0x0006             MOVS     R6,R0
   1667              
   1668            if(status == HAL_OK)
   \   0000001A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001C   0x2E00             CMP      R6,#+0
   \   0000001E   0xD13D             BNE.N    ??FLASH_DATAEEPROM_FastProgramHalfWord_0
   1669            {
   1670              /* Clear the FTDW bit */
   1671              CLEAR_BIT(FLASH->PECR, FLASH_PECR_FTDW);
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x40023c04
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF430 0x7080      BICS     R0,R0,#0x100
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable24_1  ;; 0x40023c04
   \   0000002E   0x6008             STR      R0,[R1, #+0]
   1672          
   1673          #if defined(STM32L100xB) || defined (STM32L151xB) || defined (STM32L152xB)
   1674              /* Possible only on Cat1 devices */
   1675              if(Data != (uint16_t)0x0000) 
   \   00000030   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD006             BEQ.N    ??FLASH_DATAEEPROM_FastProgramHalfWord_1
   1676              {
   1677                /* If the previous operation is completed, proceed to write the new data */
   1678                *(__IO uint16_t *)Address = Data;
   \   00000036   0x8025             STRH     R5,[R4, #+0]
   1679            
   1680                /* Wait for last operation to be completed */
   1681                status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000038   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000003C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000040   0x0006             MOVS     R6,R0
   \   00000042   0xE02B             B.N      ??FLASH_DATAEEPROM_FastProgramHalfWord_0
   1682              }
   1683              else
   1684              {
   1685                if((Address & 0x3) != 0x3)
   \                     ??FLASH_DATAEEPROM_FastProgramHalfWord_1: (+1)
   \   00000044   0xF014 0x0003      ANDS     R0,R4,#0x3
   \   00000048   0x2803             CMP      R0,#+3
   \   0000004A   0xD01D             BEQ.N    ??FLASH_DATAEEPROM_FastProgramHalfWord_2
   1686                {
   1687                  tmpaddr = Address & 0xFFFFFFFC;
   \   0000004C   0x08A0             LSRS     R0,R4,#+2
   \   0000004E   0x0080             LSLS     R0,R0,#+2
   \   00000050   0x4680             MOV      R8,R0
   1688                  tmp = * (__IO uint32_t *) tmpaddr;
   \   00000052   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000056   0x0007             MOVS     R7,R0
   1689                  tmpaddr = 0xFFFF << ((uint32_t) (0x8 * (Address & 0x3)));
   \   00000058   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000005C   0xF014 0x0103      ANDS     R1,R4,#0x3
   \   00000060   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000062   0x00C9             LSLS     R1,R1,#+3
   \   00000064   0x4088             LSLS     R0,R0,R1
   \   00000066   0x4680             MOV      R8,R0
   1690                  tmp &= ~tmpaddr;        
   \   00000068   0xEA37 0x0708      BICS     R7,R7,R8
   1691                  status = HAL_FLASHEx_DATAEEPROM_Erase(FLASH_TYPEERASEDATA_WORD, Address & 0xFFFFFFFC);
   \   0000006C   0x08A1             LSRS     R1,R4,#+2
   \   0000006E   0x0089             LSLS     R1,R1,#+2
   \   00000070   0x2002             MOVS     R0,#+2
   \   00000072   0x.... 0x....      BL       HAL_FLASHEx_DATAEEPROM_Erase
   \   00000076   0x0006             MOVS     R6,R0
   1692                  status = HAL_FLASHEx_DATAEEPROM_Program(FLASH_TYPEPROGRAMDATA_FASTWORD, (Address & 0xFFFFFFFC), tmp);
   \   00000078   0x003A             MOVS     R2,R7
   \   0000007A   0x08A1             LSRS     R1,R4,#+2
   \   0000007C   0x0089             LSLS     R1,R1,#+2
   \   0000007E   0x2010             MOVS     R0,#+16
   \   00000080   0x.... 0x....      BL       HAL_FLASHEx_DATAEEPROM_Program
   \   00000084   0x0006             MOVS     R6,R0
   \   00000086   0xE009             B.N      ??FLASH_DATAEEPROM_FastProgramHalfWord_0
   1693                }
   1694                else
   1695                {
   1696                  HAL_FLASHEx_DATAEEPROM_Program(FLASH_TYPEPROGRAMDATA_FASTBYTE, Address, 0x00);
   \                     ??FLASH_DATAEEPROM_FastProgramHalfWord_2: (+1)
   \   00000088   0x2200             MOVS     R2,#+0
   \   0000008A   0x0021             MOVS     R1,R4
   \   0000008C   0x2004             MOVS     R0,#+4
   \   0000008E   0x.... 0x....      BL       HAL_FLASHEx_DATAEEPROM_Program
   1697                  HAL_FLASHEx_DATAEEPROM_Program(FLASH_TYPEPROGRAMDATA_FASTBYTE, Address + 1, 0x00);
   \   00000092   0x2200             MOVS     R2,#+0
   \   00000094   0x1C61             ADDS     R1,R4,#+1
   \   00000096   0x2004             MOVS     R0,#+4
   \   00000098   0x.... 0x....      BL       HAL_FLASHEx_DATAEEPROM_Program
   1698                }
   1699              }
   1700          #else /* !Cat1 */
   1701              /* If the previous operation is completed, proceed to write the new data */
   1702              *(__IO uint16_t *)Address = Data;
   1703            
   1704              /* Wait for last operation to be completed */
   1705              status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   1706          #endif /* STM32L100xB || STM32L151xB || STM32L152xB  */
   1707            }
   1708            /* Return the Write Status */
   1709            return status;
   \                     ??FLASH_DATAEEPROM_FastProgramHalfWord_0: (+1)
   \   0000009C   0x0030             MOVS     R0,R6
   \   0000009E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1710          }
   1711          
   1712          /**
   1713            * @brief  Programs a word at a specified address in data memory.
   1714            * @param  Address: specifies the address to be written.
   1715            * @param  Data: specifies the data to be written.
   1716            * @note   This function assumes that the is data word is already erased.
   1717            * @retval HAL status
   1718            */

   \                                 In section .text, align 2, keep-with-next
   1719          static HAL_StatusTypeDef FLASH_DATAEEPROM_FastProgramWord(uint32_t Address, uint32_t Data)
   1720          {
   \                     FLASH_DATAEEPROM_FastProgramWord: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1721            HAL_StatusTypeDef status = HAL_OK;
   \   00000006   0x2600             MOVS     R6,#+0
   1722          
   1723            /* Check the parameters */
   1724            assert_param(IS_FLASH_DATA_ADDRESS(Address));
   1725            
   1726            /* Wait for last operation to be completed */
   1727            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000008   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000000C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000010   0x0006             MOVS     R6,R0
   1728            
   1729            if(status == HAL_OK)
   \   00000012   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD10B             BNE.N    ??FLASH_DATAEEPROM_FastProgramWord_0
   1730            {
   1731              /* Clear the FTDW bit */
   1732              CLEAR_BIT(FLASH->PECR, FLASH_PECR_FTDW);
   \   00000018   0x....             LDR.N    R0,??DataTable24_1  ;; 0x40023c04
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF430 0x7080      BICS     R0,R0,#0x100
   \   00000020   0x....             LDR.N    R1,??DataTable24_1  ;; 0x40023c04
   \   00000022   0x6008             STR      R0,[R1, #+0]
   1733            
   1734              /* If the previous operation is completed, proceed to program the new data */    
   1735              *(__IO uint32_t *)Address = Data;
   \   00000024   0x6025             STR      R5,[R4, #+0]
   1736              
   1737              /* Wait for last operation to be completed */
   1738              status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);       
   \   00000026   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000002A   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000002E   0x0006             MOVS     R6,R0
   1739            }
   1740            /* Return the Write Status */
   1741            return status;
   \                     ??FLASH_DATAEEPROM_FastProgramWord_0: (+1)
   \   00000030   0x0030             MOVS     R0,R6
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0xBD70             POP      {R4-R6,PC}       ;; return
   1742          }
   1743          
   1744          /**
   1745            * @brief  Write a Byte at a specified address in data memory without erase.
   1746            * @param  Address: specifies the address to be written.
   1747            * @param  Data: specifies the data to be written.
   1748            * @retval HAL status
   1749            */

   \                                 In section .text, align 2, keep-with-next
   1750          static HAL_StatusTypeDef FLASH_DATAEEPROM_ProgramByte(uint32_t Address, uint8_t Data)
   1751          {
   \                     FLASH_DATAEEPROM_ProgramByte: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1752            HAL_StatusTypeDef status = HAL_OK;
   \   00000008   0x2600             MOVS     R6,#+0
   1753          #if defined(STM32L100xB) || defined (STM32L151xB) || defined (STM32L152xB)
   1754            uint32_t tmp = 0, tmpaddr = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   1755          #endif /* STM32L100xB || STM32L151xB || STM32L152xB  */
   1756            
   1757            /* Check the parameters */
   1758            assert_param(IS_FLASH_DATA_ADDRESS(Address)); 
   1759          
   1760            /* Wait for last operation to be completed */
   1761            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000010   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000014   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000018   0x0006             MOVS     R6,R0
   1762            
   1763            if(status == HAL_OK)
   \   0000001A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001C   0x2E00             CMP      R6,#+0
   \   0000001E   0xD125             BNE.N    ??FLASH_DATAEEPROM_ProgramByte_0
   1764            {
   1765          #if defined(STM32L100xB) || defined (STM32L151xB) || defined (STM32L152xB)
   1766              if(Data != (uint8_t) 0x00)
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD006             BEQ.N    ??FLASH_DATAEEPROM_ProgramByte_1
   1767              {  
   1768                *(__IO uint8_t *)Address = Data;
   \   00000026   0x7025             STRB     R5,[R4, #+0]
   1769              
   1770                /* Wait for last operation to be completed */
   1771                status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000028   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000002C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000030   0x0006             MOVS     R6,R0
   \   00000032   0xE01B             B.N      ??FLASH_DATAEEPROM_ProgramByte_0
   1772          
   1773              }
   1774              else
   1775              {
   1776                tmpaddr = Address & 0xFFFFFFFC;
   \                     ??FLASH_DATAEEPROM_ProgramByte_1: (+1)
   \   00000034   0x08A0             LSRS     R0,R4,#+2
   \   00000036   0x0080             LSLS     R0,R0,#+2
   \   00000038   0x4680             MOV      R8,R0
   1777                tmp = * (__IO uint32_t *) tmpaddr;
   \   0000003A   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000003E   0x0007             MOVS     R7,R0
   1778                tmpaddr = 0xFF << ((uint32_t) (0x8 * (Address & 0x3)));
   \   00000040   0x20FF             MOVS     R0,#+255
   \   00000042   0xF014 0x0103      ANDS     R1,R4,#0x3
   \   00000046   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000048   0x00C9             LSLS     R1,R1,#+3
   \   0000004A   0x4088             LSLS     R0,R0,R1
   \   0000004C   0x4680             MOV      R8,R0
   1779                tmp &= ~tmpaddr;        
   \   0000004E   0xEA37 0x0708      BICS     R7,R7,R8
   1780                status = HAL_FLASHEx_DATAEEPROM_Erase(FLASH_TYPEERASEDATA_WORD, Address & 0xFFFFFFFC);
   \   00000052   0x08A1             LSRS     R1,R4,#+2
   \   00000054   0x0089             LSLS     R1,R1,#+2
   \   00000056   0x2002             MOVS     R0,#+2
   \   00000058   0x.... 0x....      BL       HAL_FLASHEx_DATAEEPROM_Erase
   \   0000005C   0x0006             MOVS     R6,R0
   1781                status = HAL_FLASHEx_DATAEEPROM_Program(FLASH_TYPEPROGRAMDATA_FASTWORD, (Address & 0xFFFFFFFC), tmp);
   \   0000005E   0x003A             MOVS     R2,R7
   \   00000060   0x08A1             LSRS     R1,R4,#+2
   \   00000062   0x0089             LSLS     R1,R1,#+2
   \   00000064   0x2010             MOVS     R0,#+16
   \   00000066   0x.... 0x....      BL       HAL_FLASHEx_DATAEEPROM_Program
   \   0000006A   0x0006             MOVS     R6,R0
   1782              }
   1783          #else /* Not Cat1*/
   1784              *(__IO uint8_t *)Address = Data;
   1785              
   1786              /* Wait for last operation to be completed */
   1787              status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   1788          #endif /* STM32L100xB || STM32L151xB || STM32L152xB  */
   1789            }
   1790            /* Return the Write Status */
   1791            return status;
   \                     ??FLASH_DATAEEPROM_ProgramByte_0: (+1)
   \   0000006C   0x0030             MOVS     R0,R6
   \   0000006E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000070   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1792          }
   1793          
   1794          /**
   1795            * @brief  Writes a half word at a specified address in data memory without erase.
   1796            * @param  Address: specifies the address to be written.
   1797            * @param  Data: specifies the data to be written.
   1798            * @retval HAL status
   1799            */

   \                                 In section .text, align 2, keep-with-next
   1800          static HAL_StatusTypeDef FLASH_DATAEEPROM_ProgramHalfWord(uint32_t Address, uint16_t Data)
   1801          {
   \                     FLASH_DATAEEPROM_ProgramHalfWord: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1802            HAL_StatusTypeDef status = HAL_OK;
   \   00000008   0x2600             MOVS     R6,#+0
   1803          #if defined(STM32L100xB) || defined (STM32L151xB) || defined (STM32L152xB)
   1804            uint32_t tmp = 0, tmpaddr = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   1805          #endif /* STM32L100xB || STM32L151xB || STM32L152xB  */
   1806            
   1807            /* Check the parameters */
   1808            assert_param(IS_FLASH_DATA_ADDRESS(Address));
   1809          
   1810            /* Wait for last operation to be completed */
   1811            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000010   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000014   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000018   0x0006             MOVS     R6,R0
   1812            
   1813            if(status == HAL_OK)
   \   0000001A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001C   0x2E00             CMP      R6,#+0
   \   0000001E   0xD135             BNE.N    ??FLASH_DATAEEPROM_ProgramHalfWord_0
   1814            {
   1815          #if defined(STM32L100xB) || defined (STM32L151xB) || defined (STM32L152xB)
   1816              if(Data != (uint16_t)0x0000)
   \   00000020   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD006             BEQ.N    ??FLASH_DATAEEPROM_ProgramHalfWord_1
   1817              {
   1818                *(__IO uint16_t *)Address = Data;
   \   00000026   0x8025             STRH     R5,[R4, #+0]
   1819             
   1820                /* Wait for last operation to be completed */
   1821                status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000028   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000002C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000030   0x0006             MOVS     R6,R0
   \   00000032   0xE02B             B.N      ??FLASH_DATAEEPROM_ProgramHalfWord_0
   1822              }
   1823              else
   1824              {
   1825                if((Address & 0x3) != 0x3)
   \                     ??FLASH_DATAEEPROM_ProgramHalfWord_1: (+1)
   \   00000034   0xF014 0x0003      ANDS     R0,R4,#0x3
   \   00000038   0x2803             CMP      R0,#+3
   \   0000003A   0xD01D             BEQ.N    ??FLASH_DATAEEPROM_ProgramHalfWord_2
   1826                {
   1827                  tmpaddr = Address & 0xFFFFFFFC;
   \   0000003C   0x08A0             LSRS     R0,R4,#+2
   \   0000003E   0x0080             LSLS     R0,R0,#+2
   \   00000040   0x4680             MOV      R8,R0
   1828                  tmp = * (__IO uint32_t *) tmpaddr;
   \   00000042   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000046   0x0007             MOVS     R7,R0
   1829                  tmpaddr = 0xFFFF << ((uint32_t) (0x8 * (Address & 0x3)));
   \   00000048   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000004C   0xF014 0x0103      ANDS     R1,R4,#0x3
   \   00000050   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000052   0x00C9             LSLS     R1,R1,#+3
   \   00000054   0x4088             LSLS     R0,R0,R1
   \   00000056   0x4680             MOV      R8,R0
   1830                  tmp &= ~tmpaddr;          
   \   00000058   0xEA37 0x0708      BICS     R7,R7,R8
   1831                  status = HAL_FLASHEx_DATAEEPROM_Erase(FLASH_TYPEERASEDATA_WORD, Address & 0xFFFFFFFC);
   \   0000005C   0x08A1             LSRS     R1,R4,#+2
   \   0000005E   0x0089             LSLS     R1,R1,#+2
   \   00000060   0x2002             MOVS     R0,#+2
   \   00000062   0x.... 0x....      BL       HAL_FLASHEx_DATAEEPROM_Erase
   \   00000066   0x0006             MOVS     R6,R0
   1832                  status = HAL_FLASHEx_DATAEEPROM_Program(FLASH_TYPEPROGRAMDATA_FASTWORD, (Address & 0xFFFFFFFC), tmp);
   \   00000068   0x003A             MOVS     R2,R7
   \   0000006A   0x08A1             LSRS     R1,R4,#+2
   \   0000006C   0x0089             LSLS     R1,R1,#+2
   \   0000006E   0x2010             MOVS     R0,#+16
   \   00000070   0x.... 0x....      BL       HAL_FLASHEx_DATAEEPROM_Program
   \   00000074   0x0006             MOVS     R6,R0
   \   00000076   0xE009             B.N      ??FLASH_DATAEEPROM_ProgramHalfWord_0
   1833                }
   1834                else
   1835                {
   1836                  HAL_FLASHEx_DATAEEPROM_Program(FLASH_TYPEPROGRAMDATA_FASTBYTE, Address, 0x00);
   \                     ??FLASH_DATAEEPROM_ProgramHalfWord_2: (+1)
   \   00000078   0x2200             MOVS     R2,#+0
   \   0000007A   0x0021             MOVS     R1,R4
   \   0000007C   0x2004             MOVS     R0,#+4
   \   0000007E   0x.... 0x....      BL       HAL_FLASHEx_DATAEEPROM_Program
   1837                  HAL_FLASHEx_DATAEEPROM_Program(FLASH_TYPEPROGRAMDATA_FASTBYTE, Address + 1, 0x00);
   \   00000082   0x2200             MOVS     R2,#+0
   \   00000084   0x1C61             ADDS     R1,R4,#+1
   \   00000086   0x2004             MOVS     R0,#+4
   \   00000088   0x.... 0x....      BL       HAL_FLASHEx_DATAEEPROM_Program
   1838                }
   1839              }
   1840          #else /* Not Cat1*/
   1841              *(__IO uint16_t *)Address = Data;
   1842             
   1843              /* Wait for last operation to be completed */
   1844              status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   1845          #endif /* STM32L100xB || STM32L151xB || STM32L152xB  */
   1846            }
   1847            /* Return the Write Status */
   1848            return status;
   \                     ??FLASH_DATAEEPROM_ProgramHalfWord_0: (+1)
   \   0000008C   0x0030             MOVS     R0,R6
   \   0000008E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000090   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1849          }
   1850          
   1851          /**
   1852            * @brief  Programs a word at a specified address in data memory without erase.
   1853            * @param  Address: specifies the address to be written.
   1854            * @param  Data: specifies the data to be written.
   1855            * @retval HAL status
   1856            */

   \                                 In section .text, align 2, keep-with-next
   1857          static HAL_StatusTypeDef FLASH_DATAEEPROM_ProgramWord(uint32_t Address, uint32_t Data)
   1858          {
   \                     FLASH_DATAEEPROM_ProgramWord: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1859            HAL_StatusTypeDef status = HAL_OK;
   \   00000006   0x2600             MOVS     R6,#+0
   1860            
   1861            /* Check the parameters */
   1862            assert_param(IS_FLASH_DATA_ADDRESS(Address));
   1863            
   1864            /* Wait for last operation to be completed */
   1865            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000008   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000000C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000010   0x0006             MOVS     R6,R0
   1866            
   1867            if(status == HAL_OK)
   \   00000012   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD105             BNE.N    ??FLASH_DATAEEPROM_ProgramWord_0
   1868            {
   1869              *(__IO uint32_t *)Address = Data;
   \   00000018   0x6025             STR      R5,[R4, #+0]
   1870          
   1871              /* Wait for last operation to be completed */
   1872              status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   0000001A   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000001E   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000022   0x0006             MOVS     R6,R0
   1873            }
   1874            /* Return the Write Status */
   1875            return status;
   \                     ??FLASH_DATAEEPROM_ProgramWord_0: (+1)
   \   00000024   0x0030             MOVS     R0,R6
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0xBD70             POP      {R4-R6,PC}       ;; return
   1876          }
   1877          
   1878          /**
   1879            * @}
   1880            */
   1881          
   1882          /**
   1883            * @}
   1884            */
   1885          
   1886          /** @addtogroup FLASH
   1887            * @{
   1888            */ 
   1889          
   1890          /** @addtogroup FLASH_Exported_Functions
   1891            * @{
   1892            */
   1893          
   1894          /** @addtogroup FLASH_Exported_Functions_Group1
   1895           *  @brief   Interrupts  functions
   1896           *
   1897          @verbatim   
   1898            ==============================================================================
   1899                        ##### Interrupts  functions #####
   1900            ==============================================================================    
   1901          
   1902          @endverbatim
   1903            * @{
   1904            */
   1905          
   1906          /**
   1907            * @brief This function handles FLASH interrupt request.
   1908            * @retval None
   1909            */

   \                                 In section .text, align 2, keep-with-next
   1910          void HAL_FLASH_IRQHandler(void)
   1911          {
   \                     HAL_FLASH_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1912            uint32_t temp = 0;
   \   00000002   0x2400             MOVS     R4,#+0
   1913            
   1914            /* Check FLASH operation error flags */
   1915            if( (__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)     != RESET) || 
   1916                (__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR)     != RESET) || 
   1917                (__HAL_FLASH_GET_FLAG(FLASH_FLAG_SIZERR)     != RESET) || 
   1918          #if defined (STM32L151xBA) || defined (STM32L152xBA) || \
   1919              defined (STM32L151xC) || defined (STM32L152xC) || defined (STM32L162xC)
   1920                (__HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR)      != RESET) || 
   1921          #endif /* STM32L151xBA || STM32L152xBA || STM32L151xC || STM32L152xC || STM32L162xC */
   1922          #if defined(STM32L100xC) || defined (STM32L151xC) || defined (STM32L152xC) || defined (STM32L162xC)  || \
   1923              defined(STM32L151xCA) || defined(STM32L151xD) || defined(STM32L151xDX) || defined (STM32L152xCA) || \
   1924              defined(STM32L152xD) || defined(STM32L152xDX) || defined (STM32L162xCA) || defined(STM32L162xD)  || \
   1925              defined(STM32L162xDX) || defined(STM32L151xE) || defined (STM32L152xE) || defined (STM32L162xE)
   1926                (__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERRUSR) != RESET) || 
   1927          #endif /* STM32L100xC || STM32L151xC || STM32L152xC || (...) || STM32L151xE || STM32L152xE || STM32L162xE */
   1928                (__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR)    != RESET) )
   \   00000004   0x....             LDR.N    R0,??DataTable24_2  ;; 0x40023c18
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x05C0             LSLS     R0,R0,#+23
   \   0000000A   0xD40B             BMI.N    ??HAL_FLASH_IRQHandler_0
   \   0000000C   0x....             LDR.N    R0,??DataTable24_2  ;; 0x40023c18
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x0580             LSLS     R0,R0,#+22
   \   00000012   0xD407             BMI.N    ??HAL_FLASH_IRQHandler_0
   \   00000014   0x....             LDR.N    R0,??DataTable24_2  ;; 0x40023c18
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x0540             LSLS     R0,R0,#+21
   \   0000001A   0xD403             BMI.N    ??HAL_FLASH_IRQHandler_0
   \   0000001C   0x....             LDR.N    R0,??DataTable24_2  ;; 0x40023c18
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x0500             LSLS     R0,R0,#+20
   \   00000022   0xD516             BPL.N    ??HAL_FLASH_IRQHandler_1
   1929            {
   1930              if(pFlash.ProcedureOnGoing == FLASH_PROC_PAGEERASE)
   \                     ??HAL_FLASH_IRQHandler_0: (+1)
   \   00000024   0x....             LDR.N    R0,??DataTable24
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD107             BNE.N    ??HAL_FLASH_IRQHandler_2
   1931              {
   1932                /*return the faulty sector*/
   1933                temp = pFlash.Page;
   \   0000002C   0x....             LDR.N    R0,??DataTable24
   \   0000002E   0x6880             LDR      R0,[R0, #+8]
   \   00000030   0x0004             MOVS     R4,R0
   1934                pFlash.Page = 0xFFFFFFFF;
   \   00000032   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000036   0x....             LDR.N    R1,??DataTable24
   \   00000038   0x6088             STR      R0,[R1, #+8]
   \   0000003A   0xE002             B.N      ??HAL_FLASH_IRQHandler_3
   1935              }
   1936              else
   1937              {
   1938                /*return the faulty address*/
   1939                temp = pFlash.Address;
   \                     ??HAL_FLASH_IRQHandler_2: (+1)
   \   0000003C   0x....             LDR.N    R0,??DataTable24
   \   0000003E   0x68C0             LDR      R0,[R0, #+12]
   \   00000040   0x0004             MOVS     R4,R0
   1940              }
   1941              
   1942              /*Save the Error code*/
   1943              FLASH_SetErrorCode();
   \                     ??HAL_FLASH_IRQHandler_3: (+1)
   \   00000042   0x.... 0x....      BL       FLASH_SetErrorCode
   1944          
   1945              /* FLASH error interrupt user callback */
   1946              HAL_FLASH_OperationErrorCallback(temp);
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x.... 0x....      BL       HAL_FLASH_OperationErrorCallback
   1947              
   1948              /*Stop the procedure ongoing*/
   1949              pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x....             LDR.N    R1,??DataTable24
   \   00000050   0x7008             STRB     R0,[R1, #+0]
   1950            }
   1951            
   1952            /* Check FLASH End of Operation flag  */
   1953            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)
   \                     ??HAL_FLASH_IRQHandler_1: (+1)
   \   00000052   0x....             LDR.N    R0,??DataTable24_2  ;; 0x40023c18
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x0780             LSLS     R0,R0,#+30
   \   00000058   0xD54B             BPL.N    ??HAL_FLASH_IRQHandler_4
   1954            {
   1955              /* Clear pending flags (if any) */  
   1956              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);  
   \   0000005A   0x2002             MOVS     R0,#+2
   \   0000005C   0x....             LDR.N    R1,??DataTable24_2  ;; 0x40023c18
   \   0000005E   0x6008             STR      R0,[R1, #+0]
   1957          
   1958              /* Process can continue only if no error detected */
   1959              if(pFlash.ProcedureOnGoing != FLASH_PROC_NONE)
   \   00000060   0x....             LDR.N    R0,??DataTable24
   \   00000062   0x7800             LDRB     R0,[R0, #+0]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD044             BEQ.N    ??HAL_FLASH_IRQHandler_4
   1960              {
   1961                if(pFlash.ProcedureOnGoing == FLASH_PROC_PAGEERASE)
   \   00000068   0x....             LDR.N    R0,??DataTable24
   \   0000006A   0x7800             LDRB     R0,[R0, #+0]
   \   0000006C   0x2801             CMP      R0,#+1
   \   0000006E   0xD12F             BNE.N    ??HAL_FLASH_IRQHandler_5
   1962                {
   1963                  /*Nb of sector to erased can be decreased*/
   1964                  pFlash.NbPagesToErase--;
   \   00000070   0x....             LDR.N    R0,??DataTable24
   \   00000072   0x6840             LDR      R0,[R0, #+4]
   \   00000074   0x1E40             SUBS     R0,R0,#+1
   \   00000076   0x....             LDR.N    R1,??DataTable24
   \   00000078   0x6048             STR      R0,[R1, #+4]
   1965          
   1966                  /* Check if there are still sectors to erase*/
   1967                  if(pFlash.NbPagesToErase != 0)
   \   0000007A   0x....             LDR.N    R0,??DataTable24
   \   0000007C   0x6840             LDR      R0,[R0, #+4]
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD01A             BEQ.N    ??HAL_FLASH_IRQHandler_6
   1968                  {
   1969                    temp = pFlash.Page;
   \   00000082   0x....             LDR.N    R0,??DataTable24
   \   00000084   0x6880             LDR      R0,[R0, #+8]
   \   00000086   0x0004             MOVS     R4,R0
   1970                    /*Indicate user which sector has been erased*/
   1971                    HAL_FLASH_EndOfOperationCallback(temp);
   \   00000088   0x0020             MOVS     R0,R4
   \   0000008A   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
   1972          
   1973                    /*Increment sector number*/
   1974                    temp = pFlash.Page + FLASH_PAGE_SIZE;
   \   0000008E   0x....             LDR.N    R0,??DataTable24
   \   00000090   0x6880             LDR      R0,[R0, #+8]
   \   00000092   0xF510 0x7080      ADDS     R0,R0,#+256
   \   00000096   0x0004             MOVS     R4,R0
   1975                    pFlash.Page = pFlash.Page + FLASH_PAGE_SIZE;
   \   00000098   0x....             LDR.N    R0,??DataTable24
   \   0000009A   0x6880             LDR      R0,[R0, #+8]
   \   0000009C   0xF510 0x7080      ADDS     R0,R0,#+256
   \   000000A0   0x....             LDR.N    R1,??DataTable24
   \   000000A2   0x6088             STR      R0,[R1, #+8]
   1976          
   1977                    /* If the erase operation is completed, disable the ERASE Bit */
   1978                    CLEAR_BIT(FLASH->PECR, FLASH_PECR_ERASE);
   \   000000A4   0x....             LDR.N    R0,??DataTable24_1  ;; 0x40023c04
   \   000000A6   0x6800             LDR      R0,[R0, #+0]
   \   000000A8   0xF430 0x7000      BICS     R0,R0,#0x200
   \   000000AC   0x....             LDR.N    R1,??DataTable24_1  ;; 0x40023c04
   \   000000AE   0x6008             STR      R0,[R1, #+0]
   1979          
   1980                    FLASH_ErasePage(temp);
   \   000000B0   0x0020             MOVS     R0,R4
   \   000000B2   0x.... 0x....      BL       FLASH_ErasePage
   \   000000B6   0xE01C             B.N      ??HAL_FLASH_IRQHandler_4
   1981                  }
   1982                  else
   1983                  {
   1984                    /*No more sectors to Erase, user callback can be called.*/
   1985                    /*Reset Sector and stop Erase sectors procedure*/
   1986                    pFlash.Page = temp = 0xFFFFFFFF;
   \                     ??HAL_FLASH_IRQHandler_6: (+1)
   \   000000B8   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000BC   0x0004             MOVS     R4,R0
   \   000000BE   0x....             LDR.N    R0,??DataTable24
   \   000000C0   0x6084             STR      R4,[R0, #+8]
   1987                    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0x....             LDR.N    R1,??DataTable24
   \   000000C6   0x7008             STRB     R0,[R1, #+0]
   1988                    /* FLASH EOP interrupt user callback */
   1989                    HAL_FLASH_EndOfOperationCallback(temp);
   \   000000C8   0x0020             MOVS     R0,R4
   \   000000CA   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
   \   000000CE   0xE010             B.N      ??HAL_FLASH_IRQHandler_4
   1990                  }
   1991                }
   1992                else 
   1993                {
   1994                  if(pFlash.ProcedureOnGoing  == FLASH_PROC_PROGRAM)
   \                     ??HAL_FLASH_IRQHandler_5: (+1)
   \   000000D0   0x....             LDR.N    R0,??DataTable24
   \   000000D2   0x7800             LDRB     R0,[R0, #+0]
   \   000000D4   0x2802             CMP      R0,#+2
   \   000000D6   0xD109             BNE.N    ??HAL_FLASH_IRQHandler_7
   1995                  {
   1996                    /* If the program operation is completed, disable the PROG Bit */
   1997                    CLEAR_BIT(FLASH->PECR, FLASH_PECR_PROG);
   \   000000D8   0x....             LDR.N    R0,??DataTable24_1  ;; 0x40023c04
   \   000000DA   0x6800             LDR      R0,[R0, #+0]
   \   000000DC   0xF030 0x0008      BICS     R0,R0,#0x8
   \   000000E0   0x....             LDR.N    R1,??DataTable24_1  ;; 0x40023c04
   \   000000E2   0x6008             STR      R0,[R1, #+0]
   1998          
   1999                    /*Program ended. Return the selected address*/
   2000                    /* FLASH EOP interrupt user callback */
   2001                    HAL_FLASH_EndOfOperationCallback(pFlash.Address);
   \   000000E4   0x....             LDR.N    R0,??DataTable24
   \   000000E6   0x68C0             LDR      R0,[R0, #+12]
   \   000000E8   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
   2002                  }
   2003                  pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \                     ??HAL_FLASH_IRQHandler_7: (+1)
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0x....             LDR.N    R1,??DataTable24
   \   000000F0   0x7008             STRB     R0,[R1, #+0]
   2004                }
   2005              }
   2006            }
   2007            
   2008            if(pFlash.ProcedureOnGoing == FLASH_PROC_NONE)
   \                     ??HAL_FLASH_IRQHandler_4: (+1)
   \   000000F2   0x....             LDR.N    R0,??DataTable24
   \   000000F4   0x7800             LDRB     R0,[R0, #+0]
   \   000000F6   0x2800             CMP      R0,#+0
   \   000000F8   0xD114             BNE.N    ??HAL_FLASH_IRQHandler_8
   2009            {
   2010              /* Operation is completed, disable the ERASE & PROG Bits */
   2011              CLEAR_BIT(FLASH->PECR, (FLASH_PECR_ERASE | FLASH_PECR_PROG));
   \   000000FA   0x....             LDR.N    R0,??DataTable24_1  ;; 0x40023c04
   \   000000FC   0x6800             LDR      R0,[R0, #+0]
   \   000000FE   0xF430 0x7002      BICS     R0,R0,#0x208
   \   00000102   0x....             LDR.N    R1,??DataTable24_1  ;; 0x40023c04
   \   00000104   0x6008             STR      R0,[R1, #+0]
   2012          
   2013              /* Disable End of FLASH Operation interrupt */
   2014              __HAL_FLASH_DISABLE_IT(FLASH_IT_EOP);
   \   00000106   0x....             LDR.N    R0,??DataTable24_1  ;; 0x40023c04
   \   00000108   0x6800             LDR      R0,[R0, #+0]
   \   0000010A   0xF430 0x3080      BICS     R0,R0,#0x10000
   \   0000010E   0x....             LDR.N    R1,??DataTable24_1  ;; 0x40023c04
   \   00000110   0x6008             STR      R0,[R1, #+0]
   2015          
   2016              /* Disable Error source interrupt */
   2017              __HAL_FLASH_DISABLE_IT(FLASH_IT_ERR);
   \   00000112   0x....             LDR.N    R0,??DataTable24_1  ;; 0x40023c04
   \   00000114   0x6800             LDR      R0,[R0, #+0]
   \   00000116   0xF430 0x3000      BICS     R0,R0,#0x20000
   \   0000011A   0x....             LDR.N    R1,??DataTable24_1  ;; 0x40023c04
   \   0000011C   0x6008             STR      R0,[R1, #+0]
   2018          
   2019              /* Process Unlocked */
   2020              __HAL_UNLOCK(&pFlash);
   \   0000011E   0x2000             MOVS     R0,#+0
   \   00000120   0x....             LDR.N    R1,??DataTable24
   \   00000122   0x7408             STRB     R0,[R1, #+16]
   2021            }
   2022              
   2023          }
   \                     ??HAL_FLASH_IRQHandler_8: (+1)
   \   00000124   0xBD10             POP      {R4,PC}          ;; return
   2024          
   2025          /**
   2026            * @}
   2027            */
   2028          
   2029          /**
   2030            * @}
   2031            */
   2032          
   2033          /** @addtogroup FLASH_Private_Functions
   2034            * @{
   2035            */
   2036          
   2037          /**
   2038            * @brief  Wait for a FLASH operation to complete.
   2039            * @param  Timeout: maximum flash operationtimeout
   2040            * @retval HAL status
   2041            */

   \                                 In section .text, align 2, keep-with-next
   2042          HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
   2043          { 
   \                     FLASH_WaitForLastOperation: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2044            /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
   2045               Even if the FLASH operation fails, the BUSY flag will be reset and an error
   2046               flag will be set */
   2047              
   2048            uint32_t tickstart = HAL_GetTick();   
   \   00000004   0x.... 0x....      BL       HAL_GetTick
   \   00000008   0x0005             MOVS     R5,R0
   2049               
   2050            while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
   \                     ??FLASH_WaitForLastOperation_0: (+1)
   \   0000000A   0x....             LDR.N    R0,??DataTable24_2  ;; 0x40023c18
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x07C0             LSLS     R0,R0,#+31
   \   00000010   0xD50B             BPL.N    ??FLASH_WaitForLastOperation_1
   2051            { 
   2052              if(Timeout != HAL_MAX_DELAY)
   \   00000012   0xF114 0x0F01      CMN      R4,#+1
   \   00000016   0xD0F8             BEQ.N    ??FLASH_WaitForLastOperation_0
   2053              {
   2054                if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD004             BEQ.N    ??FLASH_WaitForLastOperation_2
   \   0000001C   0x.... 0x....      BL       HAL_GetTick
   \   00000020   0x1B40             SUBS     R0,R0,R5
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD2F1             BCS.N    ??FLASH_WaitForLastOperation_0
   2055                {
   2056                  return HAL_TIMEOUT;
   \                     ??FLASH_WaitForLastOperation_2: (+1)
   \   00000026   0x2003             MOVS     R0,#+3
   \   00000028   0xE01B             B.N      ??FLASH_WaitForLastOperation_3
   2057                }
   2058              } 
   2059            }
   2060            
   2061            /* Check FLASH End of Operation flag  */
   2062            if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
   \                     ??FLASH_WaitForLastOperation_1: (+1)
   \   0000002A   0x....             LDR.N    R0,??DataTable24_2  ;; 0x40023c18
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x0780             LSLS     R0,R0,#+30
   \   00000030   0xD502             BPL.N    ??FLASH_WaitForLastOperation_4
   2063            {
   2064              /* Clear FLASH End of Operation pending bit */
   2065              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0x....             LDR.N    R1,??DataTable24_2  ;; 0x40023c18
   \   00000036   0x6008             STR      R0,[R1, #+0]
   2066            }
   2067            
   2068            if( (__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)     != RESET) || 
   2069                (__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR)     != RESET) || 
   2070                (__HAL_FLASH_GET_FLAG(FLASH_FLAG_SIZERR)     != RESET) || 
   2071          #if defined (STM32L151xBA) || defined (STM32L152xBA) || \
   2072              defined (STM32L151xC) || defined (STM32L152xC) || defined (STM32L162xC)
   2073                (__HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR)      != RESET) || 
   2074          #endif /* STM32L151xBA || STM32L152xBA || STM32L151xC || STM32L152xC || STM32L162xC */
   2075          #if defined(STM32L100xC) || defined (STM32L151xC) || defined (STM32L152xC) || defined (STM32L162xC) || \
   2076              defined(STM32L151xCA) || defined(STM32L151xD) || defined(STM32L151xDX) || defined (STM32L152xCA) || \
   2077              defined(STM32L152xD) || defined(STM32L152xDX) || defined (STM32L162xCA) || defined(STM32L162xD)  || \
   2078              defined(STM32L162xDX) || defined(STM32L151xE) || defined (STM32L152xE) || defined (STM32L162xE)
   2079                (__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERRUSR) != RESET) || 
   2080          #endif /* STM32L100xC || STM32L151xC || STM32L152xC || (...) || STM32L151xE || STM32L152xE || STM32L162xE */
   2081                (__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR)    != RESET) )
   \                     ??FLASH_WaitForLastOperation_4: (+1)
   \   00000038   0x....             LDR.N    R0,??DataTable24_2  ;; 0x40023c18
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x05C0             LSLS     R0,R0,#+23
   \   0000003E   0xD40B             BMI.N    ??FLASH_WaitForLastOperation_5
   \   00000040   0x....             LDR.N    R0,??DataTable24_2  ;; 0x40023c18
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x0580             LSLS     R0,R0,#+22
   \   00000046   0xD407             BMI.N    ??FLASH_WaitForLastOperation_5
   \   00000048   0x....             LDR.N    R0,??DataTable24_2  ;; 0x40023c18
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x0540             LSLS     R0,R0,#+21
   \   0000004E   0xD403             BMI.N    ??FLASH_WaitForLastOperation_5
   \   00000050   0x....             LDR.N    R0,??DataTable24_2  ;; 0x40023c18
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x0500             LSLS     R0,R0,#+20
   \   00000056   0xD503             BPL.N    ??FLASH_WaitForLastOperation_6
   2082            {
   2083              /*Save the error code*/
   2084              FLASH_SetErrorCode();
   \                     ??FLASH_WaitForLastOperation_5: (+1)
   \   00000058   0x.... 0x....      BL       FLASH_SetErrorCode
   2085              return HAL_ERROR;
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0xE000             B.N      ??FLASH_WaitForLastOperation_3
   2086            }
   2087          
   2088            /* There is no error flag set */
   2089            return HAL_OK;
   \                     ??FLASH_WaitForLastOperation_6: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \                     ??FLASH_WaitForLastOperation_3: (+1)
   \   00000062   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2090          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x........         DC32     pFlash

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \   00000000   0x40023C04         DC32     0x40023c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_2:
   \   00000000   0x40023C18         DC32     0x40023c18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_3:
   \   00000000   0x40023C20         DC32     0x40023c20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_4:
   \   00000000   0x89ABCDEF         DC32     0x89abcdef

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_5:
   \   00000000   0x40023C0C         DC32     0x40023c0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_6:
   \   00000000   0x02030405         DC32     0x2030405

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_7:
   \   00000000   0x1FF80000         DC32     0x1ff80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_8:
   \   00000000   0x40023C1C         DC32     0x40023c1c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_9:
   \   00000000   0x1FF80004         DC32     0x1ff80004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_10:
   \   00000000   0x1FF80008         DC32     0x1ff80008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_11:
   \   00000000   0x1FF8000C         DC32     0x1ff8000c
   2091          
   2092          
   2093          /**
   2094            * @}
   2095            */
   2096          
   2097          /**
   2098            * @}
   2099            */
   2100          
   2101          #endif /* HAL_FLASH_MODULE_ENABLED */
   2102          /**
   2103            * @}
   2104            */
   2105          
   2106          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   FLASH_DATAEEPROM_FastProgramByte
        24   -> FLASH_WaitForLastOperation
        24   -> HAL_FLASHEx_DATAEEPROM_Erase
        24   -> HAL_FLASHEx_DATAEEPROM_Program
      24   FLASH_DATAEEPROM_FastProgramHalfWord
        24   -> FLASH_WaitForLastOperation
        24   -> HAL_FLASHEx_DATAEEPROM_Erase
        24   -> HAL_FLASHEx_DATAEEPROM_Program
      16   FLASH_DATAEEPROM_FastProgramWord
        16   -> FLASH_WaitForLastOperation
      24   FLASH_DATAEEPROM_ProgramByte
        24   -> FLASH_WaitForLastOperation
        24   -> HAL_FLASHEx_DATAEEPROM_Erase
        24   -> HAL_FLASHEx_DATAEEPROM_Program
      24   FLASH_DATAEEPROM_ProgramHalfWord
        24   -> FLASH_WaitForLastOperation
        24   -> HAL_FLASHEx_DATAEEPROM_Erase
        24   -> HAL_FLASHEx_DATAEEPROM_Program
      16   FLASH_DATAEEPROM_ProgramWord
        16   -> FLASH_WaitForLastOperation
       0   FLASH_ErasePage
      24   FLASH_OB_BORConfig
        24   -> FLASH_WaitForLastOperation
       0   FLASH_OB_GetBOR
       0   FLASH_OB_GetRDP
       0   FLASH_OB_GetUser
      24   FLASH_OB_RDPConfig
        24   -> FLASH_WaitForLastOperation
      32   FLASH_OB_UserConfig
        32   -> FLASH_WaitForLastOperation
      16   FLASH_OB_WRPConfig
        16   -> FLASH_OB_WRPConfigWRP1OrPCROP1
        16   -> FLASH_WaitForLastOperation
      16   FLASH_OB_WRPConfigWRP1OrPCROP1
       0   FLASH_SetErrorCode
      16   FLASH_WaitForLastOperation
        16   -> FLASH_SetErrorCode
        16   -> HAL_GetTick
       0   HAL_FLASHEx_DATAEEPROM_DisableFixedTimeProgram
       0   HAL_FLASHEx_DATAEEPROM_EnableFixedTimeProgram
      16   HAL_FLASHEx_DATAEEPROM_Erase
        16   -> FLASH_WaitForLastOperation
       0   HAL_FLASHEx_DATAEEPROM_Lock
      24   HAL_FLASHEx_DATAEEPROM_Program
        24   -> FLASH_DATAEEPROM_FastProgramByte
        24   -> FLASH_DATAEEPROM_FastProgramHalfWord
        24   -> FLASH_DATAEEPROM_FastProgramWord
        24   -> FLASH_DATAEEPROM_ProgramByte
        24   -> FLASH_DATAEEPROM_ProgramHalfWord
        24   -> FLASH_DATAEEPROM_ProgramWord
        24   -> FLASH_WaitForLastOperation
       0   HAL_FLASHEx_DATAEEPROM_Unlock
      24   HAL_FLASHEx_Erase
        24   -> FLASH_ErasePage
        24   -> FLASH_WaitForLastOperation
      16   HAL_FLASHEx_Erase_IT
        16   -> FLASH_ErasePage
       8   HAL_FLASHEx_OBGetConfig
         8   -> FLASH_OB_GetBOR
         8   -> FLASH_OB_GetRDP
         8   -> FLASH_OB_GetUser
      16   HAL_FLASHEx_OBProgram
        16   -> FLASH_OB_BORConfig
        16   -> FLASH_OB_RDPConfig
        16   -> FLASH_OB_UserConfig
        16   -> FLASH_OB_WRPConfig
       8   HAL_FLASH_IRQHandler
         8   -> FLASH_ErasePage
         8   -> FLASH_SetErrorCode
         8   -> HAL_FLASH_EndOfOperationCallback
         8   -> HAL_FLASH_OperationErrorCallback


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_10
       4  ??DataTable24_11
       4  ??DataTable24_2
       4  ??DataTable24_3
       4  ??DataTable24_4
       4  ??DataTable24_5
       4  ??DataTable24_6
       4  ??DataTable24_7
       4  ??DataTable24_8
       4  ??DataTable24_9
     132  FLASH_DATAEEPROM_FastProgramByte
     164  FLASH_DATAEEPROM_FastProgramHalfWord
      54  FLASH_DATAEEPROM_FastProgramWord
     116  FLASH_DATAEEPROM_ProgramByte
     148  FLASH_DATAEEPROM_ProgramHalfWord
      42  FLASH_DATAEEPROM_ProgramWord
      50  FLASH_ErasePage
      90  FLASH_OB_BORConfig
      24  FLASH_OB_GetBOR
      10  FLASH_OB_GetRDP
      24  FLASH_OB_GetUser
     126  FLASH_OB_RDPConfig
     124  FLASH_OB_UserConfig
      64  FLASH_OB_WRPConfig
     140  FLASH_OB_WRPConfigWRP1OrPCROP1
     138  FLASH_SetErrorCode
     100  FLASH_WaitForLastOperation
      18  HAL_FLASHEx_DATAEEPROM_DisableFixedTimeProgram
      18  HAL_FLASHEx_DATAEEPROM_EnableFixedTimeProgram
      62  HAL_FLASHEx_DATAEEPROM_Erase
      20  HAL_FLASHEx_DATAEEPROM_Lock
     160  HAL_FLASHEx_DATAEEPROM_Program
      38  HAL_FLASHEx_DATAEEPROM_Unlock
     152  HAL_FLASHEx_Erase
     106  HAL_FLASHEx_Erase_IT
      36  HAL_FLASHEx_OBGetConfig
     194  HAL_FLASHEx_OBProgram
     294  HAL_FLASH_IRQHandler

 
 2 692 bytes in section .text
 
 2 692 bytes of CODE memory

Errors: none
Warnings: none
