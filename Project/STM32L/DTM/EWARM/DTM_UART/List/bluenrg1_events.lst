###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       29/Jan/2018  14:45:19
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\SimpleBlueNRG1_HCI\hci\bluenrg1_events.c
#    Command line =  
#        "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\SimpleBlueNRG1_HCI\hci\bluenrg1_events.c"
#        -D STM32L151xB -D STM32L1XX_XL -D USE_STM32L1XX_STEVAL_IDB00xV1 -D
#        USE_HAL_DRIVER -D HCLK_32MHZ=1 -D SYSCLK_MSI=1 -D ENABLE_USART -D
#        USER_DEFINED_PLATFORM=USER_EVAL_PLATFORM -D IRQ_RESET_PIN -D DTM_UART
#        -lC "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\List"
#        -o "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        D:\Software\IAR_BlueNRG\arm\INC\c\DLib_Config_Normal.h -I
#        "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\HAL\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\BSP\STM32L1xx_BlueNRG1\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\BSP\STM32L1xx_Nucleo\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\CMSIS\Device\ST\STM32L1xx\Include\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\STM32L1xx_HAL_BlueNRG1_Drivers\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\SimpleBlueNRG1_HCI\includes\"
#        -On --use_c++_inline -I D:\Software\IAR_BlueNRG\arm\CMSIS\Include\
#    Locale       =  Chinese (Simplified)_China.936
#    List file    =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\List\bluenrg1_events.lst
#    Object file  =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\Obj\bluenrg1_events.o
#
###############################################################################

C:\Users\Administrator\Desktop\Temporary Files\eeworld_project\Project_Test\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\SimpleBlueNRG1_HCI\hci\bluenrg1_events.c
      1          
      2          
      3          /**
      4            ******************************************************************************
      5            * @file    bluenrg1_events.c
      6            * @author  AMG - RF Application team
      7            * @version V1.0.0
      8            * @date    22 June 2017
      9            * @brief   Source file for external uC - BlueNRG-x in network coprocessor mode (Event callbacks)
     10            *          Autogenerated files, do not edit!!
     11            ******************************************************************************
     12            * @attention
     13            *
     14            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     15            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     16            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     17            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     18            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     19            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     20            *
     21            * <h2><center>&copy; COPYRIGHT STMicroelectronics</center></h2>
     22            ******************************************************************************
     23            */
     24          #include <stdint.h>
     25          #include "bluenrg1_events.h"
     26          #include "osal.h"
     27          tBleStatus hci_disconnection_complete_event_process(uint8_t *buffer_in);
     28          tBleStatus hci_encryption_change_event_process(uint8_t *buffer_in);
     29          tBleStatus hci_read_remote_version_information_complete_event_process(uint8_t *buffer_in);
     30          tBleStatus hci_hardware_error_event_process(uint8_t *buffer_in);
     31          tBleStatus hci_number_of_completed_packets_event_process(uint8_t *buffer_in);
     32          tBleStatus hci_data_buffer_overflow_event_process(uint8_t *buffer_in);
     33          tBleStatus hci_encryption_key_refresh_complete_event_process(uint8_t *buffer_in);
     34          tBleStatus aci_blue_initialized_event_process(uint8_t *buffer_in);
     35          tBleStatus aci_blue_events_lost_event_process(uint8_t *buffer_in);
     36          tBleStatus aci_blue_crash_info_event_process(uint8_t *buffer_in);
     37          tBleStatus aci_hal_end_of_radio_activity_event_process(uint8_t *buffer_in);
     38          tBleStatus aci_hal_scan_req_report_event_process(uint8_t *buffer_in);
     39          tBleStatus aci_gap_limited_discoverable_event_process(uint8_t *buffer_in);
     40          tBleStatus aci_gap_pairing_complete_event_process(uint8_t *buffer_in);
     41          tBleStatus aci_gap_pass_key_req_event_process(uint8_t *buffer_in);
     42          tBleStatus aci_gap_authorization_req_event_process(uint8_t *buffer_in);
     43          tBleStatus aci_gap_slave_security_initiated_event_process(uint8_t *buffer_in);
     44          tBleStatus aci_gap_bond_lost_event_process(uint8_t *buffer_in);
     45          tBleStatus aci_gap_proc_complete_event_process(uint8_t *buffer_in);
     46          tBleStatus aci_gap_addr_not_resolved_event_process(uint8_t *buffer_in);
     47          tBleStatus aci_gap_numeric_comparison_value_event_process(uint8_t *buffer_in);
     48          tBleStatus aci_gap_keypress_notification_event_process(uint8_t *buffer_in);
     49          tBleStatus aci_l2cap_connection_update_resp_event_process(uint8_t *buffer_in);
     50          tBleStatus aci_l2cap_proc_timeout_event_process(uint8_t *buffer_in);
     51          tBleStatus aci_l2cap_connection_update_req_event_process(uint8_t *buffer_in);
     52          tBleStatus aci_l2cap_command_reject_event_process(uint8_t *buffer_in);
     53          tBleStatus aci_gatt_attribute_modified_event_process(uint8_t *buffer_in);
     54          tBleStatus aci_gatt_proc_timeout_event_process(uint8_t *buffer_in);
     55          tBleStatus aci_att_exchange_mtu_resp_event_process(uint8_t *buffer_in);
     56          tBleStatus aci_att_find_info_resp_event_process(uint8_t *buffer_in);
     57          tBleStatus aci_att_find_by_type_value_resp_event_process(uint8_t *buffer_in);
     58          tBleStatus aci_att_read_by_type_resp_event_process(uint8_t *buffer_in);
     59          tBleStatus aci_att_read_resp_event_process(uint8_t *buffer_in);
     60          tBleStatus aci_att_read_blob_resp_event_process(uint8_t *buffer_in);
     61          tBleStatus aci_att_read_multiple_resp_event_process(uint8_t *buffer_in);
     62          tBleStatus aci_att_read_by_group_type_resp_event_process(uint8_t *buffer_in);
     63          tBleStatus aci_att_prepare_write_resp_event_process(uint8_t *buffer_in);
     64          tBleStatus aci_att_exec_write_resp_event_process(uint8_t *buffer_in);
     65          tBleStatus aci_gatt_indication_event_process(uint8_t *buffer_in);
     66          tBleStatus aci_gatt_notification_event_process(uint8_t *buffer_in);
     67          tBleStatus aci_gatt_proc_complete_event_process(uint8_t *buffer_in);
     68          tBleStatus aci_gatt_error_resp_event_process(uint8_t *buffer_in);
     69          tBleStatus aci_gatt_disc_read_char_by_uuid_resp_event_process(uint8_t *buffer_in);
     70          tBleStatus aci_gatt_write_permit_req_event_process(uint8_t *buffer_in);
     71          tBleStatus aci_gatt_read_permit_req_event_process(uint8_t *buffer_in);
     72          tBleStatus aci_gatt_read_multi_permit_req_event_process(uint8_t *buffer_in);
     73          tBleStatus aci_gatt_tx_pool_available_event_process(uint8_t *buffer_in);
     74          tBleStatus aci_gatt_server_confirmation_event_process(uint8_t *buffer_in);
     75          tBleStatus aci_gatt_prepare_write_permit_req_event_process(uint8_t *buffer_in);
     76          tBleStatus hci_le_connection_complete_event_process(uint8_t *buffer_in);
     77          tBleStatus hci_le_advertising_report_event_process(uint8_t *buffer_in);
     78          tBleStatus hci_le_connection_update_complete_event_process(uint8_t *buffer_in);
     79          tBleStatus hci_le_read_remote_used_features_complete_event_process(uint8_t *buffer_in);
     80          tBleStatus hci_le_long_term_key_request_event_process(uint8_t *buffer_in);
     81          tBleStatus hci_le_read_local_p256_public_key_complete_event_process(uint8_t *buffer_in);
     82          tBleStatus hci_le_generate_dhkey_complete_event_process(uint8_t *buffer_in);
     83          tBleStatus hci_le_enhanced_connection_complete_event_process(uint8_t *buffer_in);
     84          tBleStatus hci_le_direct_advertising_report_event_process(uint8_t *buffer_in);

   \                                 In section .rodata, align 4
     85          const hci_events_table_type hci_events_table[7] = {
   \                     hci_events_table:
   \   00000000   0x0005             DC16 5
   \   00000002   0x00 0x00          DC8 0, 0
   \   00000004   0x........         DC32 hci_disconnection_complete_event_process
   \   00000008   0x0008             DC16 8
   \   0000000A   0x00 0x00          DC8 0, 0
   \   0000000C   0x........         DC32 hci_encryption_change_event_process
   \   00000010   0x000C             DC16 12
   \   00000012   0x00 0x00          DC8 0, 0
   \   00000014   0x........         DC32 hci_read_remote_version_information_complete_event_process
   \   00000018   0x0010             DC16 16
   \   0000001A   0x00 0x00          DC8 0, 0
   \   0000001C   0x........         DC32 hci_hardware_error_event_process
   \   00000020   0x0013             DC16 19
   \   00000022   0x00 0x00          DC8 0, 0
   \   00000024   0x........         DC32 hci_number_of_completed_packets_event_process
   \   00000028   0x001A             DC16 26
   \   0000002A   0x00 0x00          DC8 0, 0
   \   0000002C   0x........         DC32 hci_data_buffer_overflow_event_process
   \   00000030   0x0030             DC16 48
   \   00000032   0x00 0x00          DC8 0, 0
   \   00000034   0x........         DC32 hci_encryption_key_refresh_complete_event_process
     86            /* hci_disconnection_complete_event */
     87            0x0005, hci_disconnection_complete_event_process,
     88            /* hci_encryption_change_event */
     89            0x0008, hci_encryption_change_event_process,
     90            /* hci_read_remote_version_information_complete_event */
     91            0x000c, hci_read_remote_version_information_complete_event_process,
     92            /* hci_hardware_error_event */
     93            0x0010, hci_hardware_error_event_process,
     94            /* hci_number_of_completed_packets_event */
     95            0x0013, hci_number_of_completed_packets_event_process,
     96            /* hci_data_buffer_overflow_event */
     97            0x001a, hci_data_buffer_overflow_event_process,
     98            /* hci_encryption_key_refresh_complete_event */
     99            0x0030, hci_encryption_key_refresh_complete_event_process,
    100          };

   \                                 In section .rodata, align 4
    101          const hci_le_meta_events_table_type hci_le_meta_events_table[9] = {
   \                     hci_le_meta_events_table:
   \   00000000   0x0001             DC16 1
   \   00000002   0x00 0x00          DC8 0, 0
   \   00000004   0x........         DC32 hci_le_connection_complete_event_process
   \   00000008   0x0002             DC16 2
   \   0000000A   0x00 0x00          DC8 0, 0
   \   0000000C   0x........         DC32 hci_le_advertising_report_event_process
   \   00000010   0x0003             DC16 3
   \   00000012   0x00 0x00          DC8 0, 0
   \   00000014   0x........         DC32 hci_le_connection_update_complete_event_process
   \   00000018   0x0004             DC16 4
   \   0000001A   0x00 0x00          DC8 0, 0
   \   0000001C   0x........         DC32 hci_le_read_remote_used_features_complete_event_process
   \   00000020   0x0005             DC16 5
   \   00000022   0x00 0x00          DC8 0, 0
   \   00000024   0x........         DC32 hci_le_long_term_key_request_event_process
   \   00000028   0x0008             DC16 8
   \   0000002A   0x00 0x00          DC8 0, 0
   \   0000002C   0x........         DC32 hci_le_read_local_p256_public_key_complete_event_process
   \   00000030   0x0009             DC16 9
   \   00000032   0x00 0x00          DC8 0, 0
   \   00000034   0x........         DC32 hci_le_generate_dhkey_complete_event_process
   \   00000038   0x000A             DC16 10
   \   0000003A   0x00 0x00          DC8 0, 0
   \   0000003C   0x........         DC32 hci_le_enhanced_connection_complete_event_process
   \   00000040   0x000B             DC16 11
   \   00000042   0x00 0x00          DC8 0, 0
   \   00000044   0x........         DC32 hci_le_direct_advertising_report_event_process
    102            /* hci_le_connection_complete_event */
    103            0x0001, hci_le_connection_complete_event_process,
    104            /* hci_le_advertising_report_event */
    105            0x0002, hci_le_advertising_report_event_process,
    106            /* hci_le_connection_update_complete_event */
    107            0x0003, hci_le_connection_update_complete_event_process,
    108            /* hci_le_read_remote_used_features_complete_event */
    109            0x0004, hci_le_read_remote_used_features_complete_event_process,
    110            /* hci_le_long_term_key_request_event */
    111            0x0005, hci_le_long_term_key_request_event_process,
    112            /* hci_le_read_local_p256_public_key_complete_event */
    113            0x0008, hci_le_read_local_p256_public_key_complete_event_process,
    114            /* hci_le_generate_dhkey_complete_event */
    115            0x0009, hci_le_generate_dhkey_complete_event_process,
    116            /* hci_le_enhanced_connection_complete_event */
    117            0x000a, hci_le_enhanced_connection_complete_event_process,
    118            /* hci_le_direct_advertising_report_event */
    119            0x000b, hci_le_direct_advertising_report_event_process,
    120          };

   \                                 In section .rodata, align 4
    121          const hci_vendor_specific_events_table_type hci_vendor_specific_events_table[42] = {
   \                     hci_vendor_specific_events_table:
   \   00000000   0x0001             DC16 1
   \   00000002   0x00 0x00          DC8 0, 0
   \   00000004   0x........         DC32 aci_blue_initialized_event_process
   \   00000008   0x0002             DC16 2
   \   0000000A   0x00 0x00          DC8 0, 0
   \   0000000C   0x........         DC32 aci_blue_events_lost_event_process
   \   00000010   0x0003             DC16 3
   \   00000012   0x00 0x00          DC8 0, 0
   \   00000014   0x........         DC32 aci_blue_crash_info_event_process
   \   00000018   0x0004             DC16 4
   \   0000001A   0x00 0x00          DC8 0, 0
   \   0000001C   0x........         DC32 aci_hal_end_of_radio_activity_event_process
   \   00000020   0x0005             DC16 5
   \   00000022   0x00 0x00          DC8 0, 0
   \   00000024   0x........         DC32 aci_hal_scan_req_report_event_process
   \   00000028   0x0400             DC16 1024
   \   0000002A   0x00 0x00          DC8 0, 0
   \   0000002C   0x........         DC32 aci_gap_limited_discoverable_event_process
   \   00000030   0x0401             DC16 1025
   \   00000032   0x00 0x00          DC8 0, 0
   \   00000034   0x........         DC32 aci_gap_pairing_complete_event_process
   \   00000038   0x0402             DC16 1026
   \   0000003A   0x00 0x00          DC8 0, 0
   \   0000003C   0x........         DC32 aci_gap_pass_key_req_event_process
   \   00000040   0x0403             DC16 1027
   \   00000042   0x00 0x00          DC8 0, 0
   \   00000044   0x........         DC32 aci_gap_authorization_req_event_process
   \   00000048   0x0404             DC16 1028
   \   0000004A   0x00 0x00          DC8 0, 0
   \   0000004C   0x........         DC32 aci_gap_slave_security_initiated_event_process
   \   00000050   0x0405             DC16 1029
   \   00000052   0x00 0x00          DC8 0, 0
   \   00000054   0x........         DC32 aci_gap_bond_lost_event_process
   \   00000058   0x0407             DC16 1031
   \   0000005A   0x00 0x00          DC8 0, 0
   \   0000005C   0x........         DC32 aci_gap_proc_complete_event_process
   \   00000060   0x0408             DC16 1032
   \   00000062   0x00 0x00          DC8 0, 0
   \   00000064   0x........         DC32 aci_gap_addr_not_resolved_event_process
   \   00000068   0x0409             DC16 1033
   \   0000006A   0x00 0x00          DC8 0, 0
   \   0000006C   0x........         DC32 aci_gap_numeric_comparison_value_event_process
   \   00000070   0x040A             DC16 1034
   \   00000072   0x00 0x00          DC8 0, 0
   \   00000074   0x........         DC32 aci_gap_keypress_notification_event_process
   \   00000078   0x0800             DC16 2048
   \   0000007A   0x00 0x00          DC8 0, 0
   \   0000007C   0x........         DC32 aci_l2cap_connection_update_resp_event_process
   \   00000080   0x0801             DC16 2049
   \   00000082   0x00 0x00          DC8 0, 0
   \   00000084   0x........         DC32 aci_l2cap_proc_timeout_event_process
   \   00000088   0x0802             DC16 2050
   \   0000008A   0x00 0x00          DC8 0, 0
   \   0000008C   0x........         DC32 aci_l2cap_connection_update_req_event_process
   \   00000090   0x080A             DC16 2058
   \   00000092   0x00 0x00          DC8 0, 0
   \   00000094   0x........         DC32 aci_l2cap_command_reject_event_process
   \   00000098   0x0C01             DC16 3073
   \   0000009A   0x00 0x00          DC8 0, 0
   \   0000009C   0x........         DC32 aci_gatt_attribute_modified_event_process
   \   000000A0   0x0C02             DC16 3074
   \   000000A2   0x00 0x00          DC8 0, 0
   \   000000A4   0x........         DC32 aci_gatt_proc_timeout_event_process
   \   000000A8   0x0C03             DC16 3075
   \   000000AA   0x00 0x00          DC8 0, 0
   \   000000AC   0x........         DC32 aci_att_exchange_mtu_resp_event_process
   \   000000B0   0x0C04             DC16 3076
   \   000000B2   0x00 0x00          DC8 0, 0
   \   000000B4   0x........         DC32 aci_att_find_info_resp_event_process
   \   000000B8   0x0C05             DC16 3077
   \   000000BA   0x00 0x00          DC8 0, 0
   \   000000BC   0x........         DC32 aci_att_find_by_type_value_resp_event_process
   \   000000C0   0x0C06             DC16 3078
   \   000000C2   0x00 0x00          DC8 0, 0
   \   000000C4   0x........         DC32 aci_att_read_by_type_resp_event_process
   \   000000C8   0x0C07             DC16 3079
   \   000000CA   0x00 0x00          DC8 0, 0
   \   000000CC   0x........         DC32 aci_att_read_resp_event_process
   \   000000D0   0x0C08             DC16 3080
   \   000000D2   0x00 0x00          DC8 0, 0
   \   000000D4   0x........         DC32 aci_att_read_blob_resp_event_process
   \   000000D8   0x0C09             DC16 3081
   \   000000DA   0x00 0x00          DC8 0, 0
   \   000000DC   0x........         DC32 aci_att_read_multiple_resp_event_process
   \   000000E0   0x0C0A             DC16 3082
   \   000000E2   0x00 0x00          DC8 0, 0
   \   000000E4   0x........         DC32 aci_att_read_by_group_type_resp_event_process
   \   000000E8   0x0C0C             DC16 3084
   \   000000EA   0x00 0x00          DC8 0, 0
   \   000000EC   0x........         DC32 aci_att_prepare_write_resp_event_process
   \   000000F0   0x0C0D             DC16 3085
   \   000000F2   0x00 0x00          DC8 0, 0
   \   000000F4   0x........         DC32 aci_att_exec_write_resp_event_process
   \   000000F8   0x0C0E             DC16 3086
   \   000000FA   0x00 0x00          DC8 0, 0
   \   000000FC   0x........         DC32 aci_gatt_indication_event_process
   \   00000100   0x0C0F             DC16 3087
   \   00000102   0x00 0x00          DC8 0, 0
   \   00000104   0x........         DC32 aci_gatt_notification_event_process
   \   00000108   0x0C10             DC16 3088
   \   0000010A   0x00 0x00          DC8 0, 0
   \   0000010C   0x........         DC32 aci_gatt_proc_complete_event_process
   \   00000110   0x0C11             DC16 3089
   \   00000112   0x00 0x00          DC8 0, 0
   \   00000114   0x........         DC32 aci_gatt_error_resp_event_process
   \   00000118   0x0C12             DC16 3090
   \   0000011A   0x00 0x00          DC8 0, 0
   \   0000011C   0x........         DC32 aci_gatt_disc_read_char_by_uuid_resp_event_process
   \   00000120   0x0C13             DC16 3091
   \   00000122   0x00 0x00          DC8 0, 0
   \   00000124   0x........         DC32 aci_gatt_write_permit_req_event_process
   \   00000128   0x0C14             DC16 3092
   \   0000012A   0x00 0x00          DC8 0, 0
   \   0000012C   0x........         DC32 aci_gatt_read_permit_req_event_process
   \   00000130   0x0C15             DC16 3093
   \   00000132   0x00 0x00          DC8 0, 0
   \   00000134   0x........         DC32 aci_gatt_read_multi_permit_req_event_process
   \   00000138   0x0C16             DC16 3094
   \   0000013A   0x00 0x00          DC8 0, 0
   \   0000013C   0x........         DC32 aci_gatt_tx_pool_available_event_process
   \   00000140   0x0C17             DC16 3095
   \   00000142   0x00 0x00          DC8 0, 0
   \   00000144   0x........         DC32 aci_gatt_server_confirmation_event_process
   \   00000148   0x0C18             DC16 3096
   \   0000014A   0x00 0x00          DC8 0, 0
   \   0000014C   0x........         DC32 aci_gatt_prepare_write_permit_req_event_process
    122            /* aci_blue_initialized_event */
    123            0x0001, aci_blue_initialized_event_process,
    124            /* aci_blue_events_lost_event */
    125            0x0002, aci_blue_events_lost_event_process,
    126            /* aci_blue_crash_info_event */
    127            0x0003, aci_blue_crash_info_event_process,
    128            /* aci_hal_end_of_radio_activity_event */
    129            0x0004, aci_hal_end_of_radio_activity_event_process,
    130            /* aci_hal_scan_req_report_event */
    131            0x0005, aci_hal_scan_req_report_event_process,
    132            /* aci_gap_limited_discoverable_event */
    133            0x0400, aci_gap_limited_discoverable_event_process,
    134            /* aci_gap_pairing_complete_event */
    135            0x0401, aci_gap_pairing_complete_event_process,
    136            /* aci_gap_pass_key_req_event */
    137            0x0402, aci_gap_pass_key_req_event_process,
    138            /* aci_gap_authorization_req_event */
    139            0x0403, aci_gap_authorization_req_event_process,
    140            /* aci_gap_slave_security_initiated_event */
    141            0x0404, aci_gap_slave_security_initiated_event_process,
    142            /* aci_gap_bond_lost_event */
    143            0x0405, aci_gap_bond_lost_event_process,
    144            /* aci_gap_proc_complete_event */
    145            0x0407, aci_gap_proc_complete_event_process,
    146            /* aci_gap_addr_not_resolved_event */
    147            0x0408, aci_gap_addr_not_resolved_event_process,
    148            /* aci_gap_numeric_comparison_value_event */
    149            0x0409, aci_gap_numeric_comparison_value_event_process,
    150            /* aci_gap_keypress_notification_event */
    151            0x040a, aci_gap_keypress_notification_event_process,
    152            /* aci_l2cap_connection_update_resp_event */
    153            0x0800, aci_l2cap_connection_update_resp_event_process,
    154            /* aci_l2cap_proc_timeout_event */
    155            0x0801, aci_l2cap_proc_timeout_event_process,
    156            /* aci_l2cap_connection_update_req_event */
    157            0x0802, aci_l2cap_connection_update_req_event_process,
    158            /* aci_l2cap_command_reject_event */
    159            0x080a, aci_l2cap_command_reject_event_process,
    160            /* aci_gatt_attribute_modified_event */
    161            0x0c01, aci_gatt_attribute_modified_event_process,
    162            /* aci_gatt_proc_timeout_event */
    163            0x0c02, aci_gatt_proc_timeout_event_process,
    164            /* aci_att_exchange_mtu_resp_event */
    165            0x0c03, aci_att_exchange_mtu_resp_event_process,
    166            /* aci_att_find_info_resp_event */
    167            0x0c04, aci_att_find_info_resp_event_process,
    168            /* aci_att_find_by_type_value_resp_event */
    169            0x0c05, aci_att_find_by_type_value_resp_event_process,
    170            /* aci_att_read_by_type_resp_event */
    171            0x0c06, aci_att_read_by_type_resp_event_process,
    172            /* aci_att_read_resp_event */
    173            0x0c07, aci_att_read_resp_event_process,
    174            /* aci_att_read_blob_resp_event */
    175            0x0c08, aci_att_read_blob_resp_event_process,
    176            /* aci_att_read_multiple_resp_event */
    177            0x0c09, aci_att_read_multiple_resp_event_process,
    178            /* aci_att_read_by_group_type_resp_event */
    179            0x0c0a, aci_att_read_by_group_type_resp_event_process,
    180            /* aci_att_prepare_write_resp_event */
    181            0x0c0c, aci_att_prepare_write_resp_event_process,
    182            /* aci_att_exec_write_resp_event */
    183            0x0c0d, aci_att_exec_write_resp_event_process,
    184            /* aci_gatt_indication_event */
    185            0x0c0e, aci_gatt_indication_event_process,
    186            /* aci_gatt_notification_event */
    187            0x0c0f, aci_gatt_notification_event_process,
    188            /* aci_gatt_proc_complete_event */
    189            0x0c10, aci_gatt_proc_complete_event_process,
    190            /* aci_gatt_error_resp_event */
    191            0x0c11, aci_gatt_error_resp_event_process,
    192            /* aci_gatt_disc_read_char_by_uuid_resp_event */
    193            0x0c12, aci_gatt_disc_read_char_by_uuid_resp_event_process,
    194            /* aci_gatt_write_permit_req_event */
    195            0x0c13, aci_gatt_write_permit_req_event_process,
    196            /* aci_gatt_read_permit_req_event */
    197            0x0c14, aci_gatt_read_permit_req_event_process,
    198            /* aci_gatt_read_multi_permit_req_event */
    199            0x0c15, aci_gatt_read_multi_permit_req_event_process,
    200            /* aci_gatt_tx_pool_available_event */
    201            0x0c16, aci_gatt_tx_pool_available_event_process,
    202            /* aci_gatt_server_confirmation_event */
    203            0x0c17, aci_gatt_server_confirmation_event_process,
    204            /* aci_gatt_prepare_write_permit_req_event */
    205            0x0c18, aci_gatt_prepare_write_permit_req_event_process,
    206          };
    207          /* hci_disconnection_complete_event */
    208          /* Event len: 1 + 2 + 1 */
    209          /**
    210            * @brief The Disconnection Complete event occurs when a connection is terminated.
    211          The status parameter indicates if the disconnection was successful or not. The
    212          reason parameter indicates the reason for the disconnection if the disconnection
    213          was successful. If the disconnection was not successful, the value of the
    214          reason parameter can be ignored by the Host. For example, this can be the
    215          case if the Host has issued the Disconnect command and there was a parameter
    216          error, or the command was not presently allowed, or a Connection_Handle
    217          that didn't correspond to a connection was given.
    218            * @param Status Error code. See Core v4.1, Vol. 2, part D.
    219            * @param Connection_Handle Connection_Handle which was disconnected.
    220            * Values:
    221            - 0x0000 ... 0x0EFF
    222            * @param Reason Reason for disconnection.
    223            * Values:
    224            - 0x00: Success
    225            - 0x01: Unknown HCI Command
    226            - 0x02: Unknown Connection Identifier
    227            - 0x03: Hardware Failure
    228            - 0x04: Page Timeout
    229            - 0x05: Authentication Failure
    230            - 0x06: PIN or Key Missing
    231            - 0x07: Memory Capacity Exceeded
    232            - 0x08: Connection Timeout
    233            - 0x09: Connection Limit Exceeded
    234            - 0x0A: Synchronous Connection Limit to a Device Exceeded
    235            - 0x0B: ACL Connection Already Exists
    236            - 0x0C: Command Disallowed
    237            - 0x0D: Connection Rejected Due To Limited Resources
    238            - 0x0E: Connection Rejected Due To Security Reasons
    239            - 0x0F: Connection Rejected due to Unacceptable BD_ADDR
    240            - 0x10: Connection Accept Timeout Exceeded
    241            - 0x11: Unsupported Feature Or Parameter Value
    242            - 0x12: Invalid HCI Command Parameters
    243            - 0x13: Remote User Terminated Connection
    244            - 0x14: Remote Device Terminated Connection due to Low Resources
    245            - 0x15: Remote Device Terminated Connection due to Power Off
    246            - 0x16: Connection Terminated By Local Host
    247            - 0x17: Repeated Attempts
    248            - 0x18: Pairing Not Allowed
    249            - 0x19: Unknown LMP PDU
    250            - 0x1A: Unsupported Remote Feature / Unsupported LMP Feature
    251            - 0x1B: SCO Offset Rejected
    252            - 0x1C: SCO Interval Rejected
    253            - 0x1D: SCO Air Mode Rejected
    254            - 0x1E: Invalid LMP Parameters
    255            - 0x1F: Unspecified Error
    256            - 0x20: Unsupported LMP Parameter Value
    257            - 0x21: Role Change Not Allowed
    258            - 0x22: LMP Response Timeout / LL Response Timeout
    259            - 0x23: LMP Error Transaction Collision
    260            - 0x24: LMP PDU Not Allowed
    261            - 0x25: Encryption Mode Not Acceptable
    262            - 0x26: Link Key cannot be Changed
    263            - 0x27: Requested QoS Not Supported
    264            - 0x28: Instant Passed
    265            - 0x29: Pairing With Unit Key Not Supported
    266            - 0x2A: Different Transaction Collision
    267            - 0x2C: QoS Unacceptable Parameter
    268            - 0x2D: QoS Rejected
    269            - 0x2E: Channel Assessment Not Supported
    270            - 0x2F: Insufficient Security
    271            - 0x30: Parameter Out Of Mandatory Range
    272            - 0x32: Role Switch Pending
    273            - 0x34: Reserved Slot Violation
    274            - 0x35: Role Switch Failed
    275            - 0x36: Extended Inquiry Response Too Large
    276            - 0x37: Secure Simple Pairing Not Supported by Host
    277            - 0x38: Host Busy - Pairing
    278            - 0x39: Connection Rejected due to No Suitable Channel Found
    279            - 0x3A: Controller Busy
    280            - 0x3B: Unacceptable Connection Interval
    281            - 0x3C: Directed Advertising Timeout
    282            - 0x3D: Connection Terminated Due to MIC Failure
    283            - 0x3E: Connection Failed to be Established
    284            - 0x3F: MAC of the 802.11 AMP
    285            - 0x41: Failed
    286            - 0x42: Invalid parameters
    287            - 0x43: Busy
    288            - 0x44: Invalid length
    289            - 0x45: Pending
    290            - 0x46: Not allowed
    291            - 0x47: GATT error
    292            - 0x48: Address not resolved
    293            - 0x49: Flash read failed
    294            - 0x4A: Flash write failed
    295            - 0x4B: Flash erase failed
    296            - 0x50: Invalid CID
    297            - 0x5A: CSRK not found
    298            - 0x5B: IRK not found
    299            - 0x5C: Device not found in DB
    300            - 0x5D: Security DB full
    301            - 0x5E: Device not bonded
    302            - 0x5F: Device in blacklist
    303            - 0x60: Invalid handle
    304            - 0x61: Invalid parameter
    305            - 0x62: Out of handles
    306            - 0x63: Invalid operation
    307            - 0x64: Insufficient resources
    308            - 0x65: Insufficient encryption key size
    309            - 0x66: Characteristic already exist
    310            - 0x82: No valid slot
    311            - 0x83: Short window
    312            - 0x84: New interval failed
    313            - 0x85: Too large interval
    314            - 0x86: Slot length failed
    315            * @retval None
    316          */
    317          

   \                                 In section .text, align 2, keep-with-next
    318          tBleStatus hci_disconnection_complete_event_process(uint8_t *buffer_in)
    319          {
   \                     hci_disconnection_complete_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    320            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
    321            /* Input params */
    322            hci_disconnection_complete_event_rp0 *rp0 = (hci_disconnection_complete_event_rp0 *)buffer_in;
    323            hci_disconnection_complete_event(rp0->Status,
    324                                             rp0->Connection_Handle,
    325                                             rp0->Reason);
   \   00000006   0x78E2             LDRB     R2,[R4, #+3]
   \   00000008   0xF8B4 0x1001      LDRH     R1,[R4, #+1]
   \   0000000C   0x7820             LDRB     R0,[R4, #+0]
   \   0000000E   0x.... 0x....      BL       hci_disconnection_complete_event
    326          
    327            return status;
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    328          }
    329          /* hci_encryption_change_event */
    330          /* Event len: 1 + 2 + 1 */
    331          /**
    332            * @brief The Encryption Change event is used to indicate that the change of the encryption
    333          mode has been completed. The Connection_Handle will be a Connection_Handle
    334          for an ACL connection. The Encryption_Enabled event parameter
    335          specifies the new Encryption_Enabled parameter for the Connection_Handle
    336          specified by the Connection_Handle event parameter. This event will occur on
    337          both devices to notify the Hosts when Encryption has changed for the specified
    338          Connection_Handle between two devices. Note: This event shall not be generated
    339          if encryption is paused or resumed; during a role switch, for example.
    340          The meaning of the Encryption_Enabled parameter depends on whether the
    341          Host has indicated support for Secure Connections in the Secure_Connections_Host_Support
    342          parameter. When Secure_Connections_Host_Support is
    343          'disabled' or the Connection_Handle refers to an LE link, the Controller shall
    344          only use Encryption_Enabled values 0x00 (OFF) and 0x01 (ON).
    345          (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.7.8)
    346            * @param Status Error code. See Core v4.1, Vol. 2, part D.
    347            * @param Connection_Handle Connection handle for which the command is given.
    348            * Values:
    349            - 0x0000 ... 0x0EFF
    350            * @param Encryption_Enabled Link Level Encryption.
    351            * Values:
    352            - 0x00: Link Level Encryption OFF
    353            - 0x01: Link Level Encryption is ON with AES-CCM
    354            * @retval None
    355          */
    356          

   \                                 In section .text, align 2, keep-with-next
    357          tBleStatus hci_encryption_change_event_process(uint8_t *buffer_in)
    358          {
   \                     hci_encryption_change_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    359            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
    360            /* Input params */
    361            hci_encryption_change_event_rp0 *rp0 = (hci_encryption_change_event_rp0 *)buffer_in;
    362            hci_encryption_change_event(rp0->Status,
    363                                        rp0->Connection_Handle,
    364                                        rp0->Encryption_Enabled);
   \   00000006   0x78E2             LDRB     R2,[R4, #+3]
   \   00000008   0xF8B4 0x1001      LDRH     R1,[R4, #+1]
   \   0000000C   0x7820             LDRB     R0,[R4, #+0]
   \   0000000E   0x.... 0x....      BL       hci_encryption_change_event
    365          
    366            return status;
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    367          }
    368          /* hci_read_remote_version_information_complete_event */
    369          /* Event len: 1 + 2 + 1 + 2 + 2 */
    370          /**
    371            * @brief The Read Remote Version Information Complete event is used to indicate the
    372          completion of the process obtaining the version information of the remote Controller
    373          specified by the Connection_Handle event parameter. The Connection_Handle
    374          shall be for an ACL connection.
    375          The Version event parameter defines the specification version of the LE Controller.
    376          The Manufacturer_Name event parameter indicates the manufacturer
    377          of the remote Controller. The Subversion event parameter is controlled
    378          by the manufacturer and is implementation dependent. The Subversion
    379          event parameter defines the various revisions that each version of the Bluetooth
    380          hardware will go through as design processes change and errors are
    381          fixed. This allows the software to determine what Bluetooth hardware is being
    382          used and, if necessary, to work around various bugs in the hardware.
    383          When the Connection_Handle is associated with an LE-U logical link, the Version
    384          event parameter shall be Link Layer VersNr parameter, the Manufacturer_Name
    385          event parameter shall be the CompId parameter, and the Subversion
    386          event parameter shall be the SubVersNr parameter.
    387          (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.7.12)
    388            * @param Status Error code. See Core v4.1, Vol. 2, part D.
    389            * @param Connection_Handle Connection handle for which the command is given.
    390            * Values:
    391            - 0x0000 ... 0x0EFF
    392            * @param Version Version of the Current LMP in the remote Controller
    393            * @param Manufacturer_Name Manufacturer Name of the remote Controller
    394            * @param Subversion Subversion of the LMP in the remote Controller
    395            * @retval None
    396          */
    397          

   \                                 In section .text, align 2, keep-with-next
    398          tBleStatus hci_read_remote_version_information_complete_event_process(uint8_t *buffer_in)
    399          {
   \                     hci_read_remote_version_information_complete_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    400            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
    401            /* Input params */
    402            hci_read_remote_version_information_complete_event_rp0 *rp0 = (hci_read_remote_version_information_complete_event_rp0 *)buffer_in;
    403            hci_read_remote_version_information_complete_event(rp0->Status,
    404                                                               rp0->Connection_Handle,
    405                                                               rp0->Version,
    406                                                               rp0->Manufacturer_Name,
    407                                                               rp0->Subversion);
   \   00000006   0x88E0             LDRH     R0,[R4, #+6]
   \   00000008   0x9000             STR      R0,[SP, #+0]
   \   0000000A   0x88A3             LDRH     R3,[R4, #+4]
   \   0000000C   0x78E2             LDRB     R2,[R4, #+3]
   \   0000000E   0xF8B4 0x1001      LDRH     R1,[R4, #+1]
   \   00000012   0x7820             LDRB     R0,[R4, #+0]
   \   00000014   0x.... 0x....      BL       hci_read_remote_version_information_complete_event
    408          
    409            return status;
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    410          }
    411          /* hci_hardware_error_event */
    412          /* Event len: 1 */
    413          /**
    414            * @brief The Hardware Error event is used to indicate some implementation specific type of hardware failure for the controller. This event is used to notify the Host that a hardware failure has occurred in the Controller.
    415            * @param Hardware_Code Hardware Error Event code.
    416          Error code 0 means that an error on the SPI bus has been detected,
    417          most likely caused by incorrect SPI configuration on the external micro-controller.
    418          Error code 0x01 and 0x02 are errors caused by a slow crystal startup and they are an indication that
    419          the HS_STARTUP_TIME in the device configuration needs to be tuned.
    420          After this event is recommended to hardware reset the device.
    421            * Values:
    422            - 0x00: SPI framing error
    423            - 0x01: Radio state error
    424            - 0x02: Timer overrun error
    425            * @retval None
    426          */
    427          

   \                                 In section .text, align 2, keep-with-next
    428          tBleStatus hci_hardware_error_event_process(uint8_t *buffer_in)
    429          {
   \                     hci_hardware_error_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    430            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
    431            /* Input params */
    432            hci_hardware_error_event_rp0 *rp0 = (hci_hardware_error_event_rp0 *)buffer_in;
    433            hci_hardware_error_event(rp0->Hardware_Code);
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       hci_hardware_error_event
    434          
    435            return status;
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    436          }
    437          /* hci_number_of_completed_packets_event */
    438          /* Event len: 1 + rp0->Number_of_Handles * (sizeof(Handle_Packets_Pair_Entry_t)) */
    439          /**
    440            * @brief 'The Number Of Completed Packets event is used by the Controller to indicate
    441          to the Host how many HCI Data Packets have been completed (transmitted or
    442          flushed) for each Connection_Handle since the previous Number Of Completed
    443          Packets event was sent to the Host. This means that the corresponding
    444          buffer space has been freed in the Controller. Based on this information, and
    445          the HC_Total_Num_ACL_Data_Packets and HC_Total_Num_Synchronous_-
    446          Data_Packets return parameter of the Read_Buffer_Size command, the Host
    447          can determine for which Connection_Handles the following HCI Data Packets
    448          should be sent to the Controller. The Number Of Completed Packets event
    449          must not be sent before the corresponding Connection Complete event. While
    450          the Controller has HCI data packets in its buffer, it must keep sending the Number
    451          Of Completed Packets event to the Host at least periodically, until it finally
    452          reports that all the pending ACL Data Packets have been transmitted or
    453          flushed.
    454            * @param Number_of_Handles The number of Connection_Handles and Num_HCI_Data_Packets parameters pairs contained in this event
    455            * @param Handle_Packets_Pair_Entry See @ref Handle_Packets_Pair_Entry_t
    456            * @retval None
    457          */
    458          

   \                                 In section .text, align 2, keep-with-next
    459          tBleStatus hci_number_of_completed_packets_event_process(uint8_t *buffer_in)
    460          {
   \                     hci_number_of_completed_packets_event_process: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB0A0             SUB      SP,SP,#+128
   \   00000006   0x0004             MOVS     R4,R0
    461            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000008   0x2500             MOVS     R5,#+0
    462            /* Input params */
    463            hci_number_of_completed_packets_event_rp0 *rp0 = (hci_number_of_completed_packets_event_rp0 *)buffer_in;
   \   0000000A   0x0026             MOVS     R6,R4
    464            uint8_t size = 1;
   \   0000000C   0x2701             MOVS     R7,#+1
    465            int i;
    466            Handle_Packets_Pair_Entry_t Handle_Packets_Pair_Entry[HCI_MAX_PAYLOAD_SIZE/sizeof(Handle_Packets_Pair_Entry_t)];
    467            for (i = 0; i < rp0->Number_of_Handles; i++) {
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x4680             MOV      R8,R0
   \                     ??hci_number_of_completed_packets_event_process_0: (+1)
   \   00000012   0x7830             LDRB     R0,[R6, #+0]
   \   00000014   0x4580             CMP      R8,R0
   \   00000016   0xDA13             BGE.N    ??hci_number_of_completed_packets_event_process_1
    468              Handle_Packets_Pair_Entry[i].Connection_Handle = rp0->Handle_Packets_Pair_Entry[i].Connection_Handle;
   \   00000018   0xEB06 0x0088      ADD      R0,R6,R8, LSL #+2
   \   0000001C   0xF8B0 0x0001      LDRH     R0,[R0, #+1]
   \   00000020   0x4669             MOV      R1,SP
   \   00000022   0xF821 0x0028      STRH     R0,[R1, R8, LSL #+2]
    469              size += 2;
   \   00000026   0x1CBF             ADDS     R7,R7,#+2
    470              Handle_Packets_Pair_Entry[i].HC_Num_Of_Completed_Packets = rp0->Handle_Packets_Pair_Entry[i].HC_Num_Of_Completed_Packets;
   \   00000028   0xEB06 0x0088      ADD      R0,R6,R8, LSL #+2
   \   0000002C   0xF8B0 0x0003      LDRH     R0,[R0, #+3]
   \   00000030   0x4669             MOV      R1,SP
   \   00000032   0xEB01 0x0188      ADD      R1,R1,R8, LSL #+2
   \   00000036   0x8048             STRH     R0,[R1, #+2]
    471              size += 2;
   \   00000038   0x1CBF             ADDS     R7,R7,#+2
    472            }
   \   0000003A   0xF118 0x0801      ADDS     R8,R8,#+1
   \   0000003E   0xE7E8             B.N      ??hci_number_of_completed_packets_event_process_0
    473            hci_number_of_completed_packets_event(rp0->Number_of_Handles,
    474                                                  Handle_Packets_Pair_Entry);
   \                     ??hci_number_of_completed_packets_event_process_1: (+1)
   \   00000040   0x4669             MOV      R1,SP
   \   00000042   0x7830             LDRB     R0,[R6, #+0]
   \   00000044   0x.... 0x....      BL       hci_number_of_completed_packets_event
    475          
    476            return status;
   \   00000048   0x0028             MOVS     R0,R5
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   0xB020             ADD      SP,SP,#+128
   \   0000004E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    477          }
    478          /* hci_data_buffer_overflow_event */
    479          /* Event len: 1 */
    480          /**
    481            * @brief 'This event is used to indicate that the Controller's data buffers have been overflowed.
    482          This can occur if the Host has sent more packets than allowed. The
    483          Link_Type parameter is used to indicate that the overflow was caused by ACL data.
    484            * @param Link_Type On wich type of channel overflow has occurred.
    485            * Values:
    486            - 0x01: ACL Buffer Overflow
    487            * @retval None
    488          */
    489          

   \                                 In section .text, align 2, keep-with-next
    490          tBleStatus hci_data_buffer_overflow_event_process(uint8_t *buffer_in)
    491          {
   \                     hci_data_buffer_overflow_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    492            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
    493            /* Input params */
    494            hci_data_buffer_overflow_event_rp0 *rp0 = (hci_data_buffer_overflow_event_rp0 *)buffer_in;
    495            hci_data_buffer_overflow_event(rp0->Link_Type);
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       hci_data_buffer_overflow_event
    496          
    497            return status;
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    498          }
    499          /* hci_encryption_key_refresh_complete_event */
    500          /* Event len: 1 + 2 */
    501          /**
    502            * @brief 'The Encryption Key Refresh Complete event is used to indicate to the Host
    503          that the encryption key was refreshed on the given Connection_Handle any
    504          time encryption is paused and then resumed.
    505          If the Encryption Key Refresh Complete event was generated due to an
    506          encryption pause and resume operation embedded within a change connection
    507          link key procedure, the Encryption Key Refresh Complete event shall be sent
    508          prior to the Change Connection Link Key Complete event.
    509          If the Encryption Key Refresh Complete event was generated due to an
    510          encryption pause and resume operation embedded within a role switch procedure,
    511          the Encryption Key Refresh Complete event shall be sent prior to the
    512          Role Change event.
    513            * @param Status Error code. See Core v4.1, Vol. 2, part D.
    514            * @param Connection_Handle Connection handle for which the command is given.
    515            * Values:
    516            - 0x0000 ... 0x0EFF
    517            * @retval None
    518          */
    519          

   \                                 In section .text, align 2, keep-with-next
    520          tBleStatus hci_encryption_key_refresh_complete_event_process(uint8_t *buffer_in)
    521          {
   \                     hci_encryption_key_refresh_complete_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    522            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
    523            /* Input params */
    524            hci_encryption_key_refresh_complete_event_rp0 *rp0 = (hci_encryption_key_refresh_complete_event_rp0 *)buffer_in;
    525            hci_encryption_key_refresh_complete_event(rp0->Status,
    526                                                      rp0->Connection_Handle);
   \   00000006   0xF8B4 0x1001      LDRH     R1,[R4, #+1]
   \   0000000A   0x7820             LDRB     R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       hci_encryption_key_refresh_complete_event
    527          
    528            return status;
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    529          }
    530          /* aci_blue_initialized_event */
    531          /* Event len: 1 */
    532          /**
    533            * @brief This event inform the application that the network coprocessor has been reset. If the reason code is a system crash,
    534          a following event @ref aci_blue_crash_info_event will provide more information regarding the system crash details.
    535            * @param Reason_Code Reason code describing why device was reset and in which mode is operating (Updater or Normal mode)
    536            * Values:
    537            - 0x01: Firmware started properly
    538            - 0x02: Updater mode entered with ACI command
    539            - 0x03: Updater mode entered due to bad Blue Flag
    540            - 0x04: Updater mode entered due to IRQ pin
    541            - 0x05: System reset due to watchdog
    542            - 0x06: System reset due to lockup
    543            - 0x07: System reset due to brownout reset
    544            - 0x08: System reset due to crash
    545            - 0x09: System reset due to ECC error
    546            * @retval None
    547          */
    548          

   \                                 In section .text, align 2, keep-with-next
    549          tBleStatus aci_blue_initialized_event_process(uint8_t *buffer_in)
    550          {
   \                     aci_blue_initialized_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    551            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
    552            /* Input params */
    553            aci_blue_initialized_event_rp0 *rp0 = (aci_blue_initialized_event_rp0 *)buffer_in;
    554            aci_blue_initialized_event(rp0->Reason_Code);
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       aci_blue_initialized_event
    555          
    556            return status;
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    557          }
    558          /* aci_blue_events_lost_event */
    559          /* Event len: 8 */
    560          /**
    561            * @brief 'This event is generated when an overflow occurs in the event queue read by the
    562          external microcontroller. This is normally caused when the external microcontroller does 
    563          not read pending events. The returned bitmap indicates which event has been lost. Please
    564           note that one bit set to 1 indicates one or more occurrences of the particular events.
    565          The event ACI_BLUE_EVENTS_LOST_EVENT cannot be lost and it will inserted in the
    566          event queue as soon as a position is freed in the event queue. This event should not happen under normal
    567          operating condition where external microcontroller promptly reads events signaled by IRQ pin.
    568          It is provided to detected unexpected behavior of the external microcontroller or to
    569          allow application to recover situations where critical events are lost.
    570            * @param Lost_Events Bitmap of lost events. Each bit indicates one or more occurrences of the specific event:
    571          0x0000000000000001 HCI_DISCONNECTION_COMPLETE_EVENT
    572          0x0000000000000002 HCI_ENCRYPTION_CHANGE_EVENT
    573          0x0000000000000004 HCI_READ_REMOTE_VERSION_INFORMATION_COMPLETE_EVENT
    574          0x0000000000000008 HCI_COMMAND_COMPLETE_EVENT
    575          0x0000000000000010 HCI_COMMAND_STATUS_EVENT
    576          0x0000000000000020 HCI_HARDWARE_ERROR_EVENT
    577          0x0000000000000040 HCI_NUMBER_OF_COMPLETED_PACKETS_EVENT
    578          0x0000000000000080 HCI_ENCRYPTION_KEY_REFRESH_COMPLETE_EVENT
    579          0x0000000000000100 ACI_BLUE_INITIALIZED_EVENT
    580          0x0000000000000200 ACI_GAP_LIMITED_DISCOVERABLE_EVENT
    581          0x0000000000000400 ACI_GAP_PAIRING_COMPLETE_EVENT
    582          0x0000000000000800 ACI_GAP_PASS_KEY_REQ_EVENT
    583          0x0000000000001000 ACI_GAP_AUTHORIZATION_REQ_EVENT
    584          0x0000000000002000 ACI_GAP_SLAVE_SECURITY_INITIATED_EVENT
    585          0x0000000000004000 ACI_GAP_BOND_LOST_EVENT
    586          0x0000000000008000 ACI_GAP_PROC_COMPLETE_EVENT
    587          0x0000000000010000 ACI_GAP_ADDR_NOT_RESOLVED_EVENT
    588          0x0000000000020000 ACI_GAP_NUMERIC_COMPARISON_VALUE_EVENT
    589          0x0000000000040000 ACI_GAP_KEYPRESS_NOTIFICATION_EVENT
    590          0x0000000000080000 ACI_L2CAP_CONNECTION_UPDATE_RESP_EVENT
    591          0x0000000000100000 ACI_L2CAP_PROC_TIMEOUT_EVENT
    592          0x0000000000200000 ACI_L2CAP_CONNECTION_UPDATE_REQ_EVENT
    593          0x0000000000400000 ACI_GATT_ATTRIBUTE_MODIFIED_EVENT
    594          0x0000000000800000 ACI_GATT_PROC_TIMEOUT_EVENT
    595          0x0000000001000000 ACI_ATT_EXCHANGE_MTU_RESP_EVENT
    596          0x0000000002000000 ACI_ATT_FIND_INFO_RESP_EVENT
    597          0x0000000004000000 ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT
    598          0x0000000008000000 ACI_ATT_READ_BY_TYPE_RESP_EVENT
    599          0x0000000010000000 ACI_ATT_READ_RESP_EVENT
    600          0x0000000020000000 ACI_ATT_READ_BLOB_RESP_EVENT
    601          0x0000000040000000 ACI_ATT_READ_MULTIPLE_RESP_EVENT
    602          0x0000000080000000 ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT
    603          0x0000000100000000 ACI_ATT_WRITE_RESP_EVENT
    604          0x0000000200000000 ACI_ATT_PREPARE_WRITE_RESP_EVENT
    605          0x0000000400000000 ACI_ATT_EXEC_WRITE_RESP_EVENT
    606          0x0000000800000000 ACI_GATT_INDICATION_EVENT
    607          0x0000001000000000 ACI_GATT_NOTIFICATION_EVENT
    608          0x0000002000000000 ACI_GATT_PROC_COMPLETE_EVENT
    609          0x0000004000000000 ACI_GATT_ERROR_RESP_EVENT
    610          0x0000008000000000 ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT
    611          0x0000010000000000 ACI_GATT_WRITE_PERMIT_REQ_EVENT
    612          0x0000020000000000 ACI_GATT_READ_PERMIT_REQ_EVENT
    613          0x0000040000000000 ACI_GATT_READ_MULTI_PERMIT_REQ_EVENT
    614          0x0000080000000000 ACI_GATT_TX_POOL_AVAILABLE_EVENT
    615          0x0000100000000000 ACI_GATT_SERVER_CONFIRMATION_EVENT
    616          0x0000200000000000 ACI_GATT_PREPARE_WRITE_PERMIT_REQ_EVENT
    617          0x0000400000000000 HCI_LE_CONNECTION_UPDATE_COMPLETE_EVENT
    618          0x0000800000000000 HCI_LE_READ_REMOTE_USED_FEATURES_COMPLETE_EVENT
    619          0x0001000000000000 HCI_LE_LONG_TERM_KEY_REQUEST_EVENT
    620          0x0008000000000000 HCI_LE_READ_LOCAL_P256_PUBLIC_KEY_COMPLETE_EVENT
    621          0x0010000000000000 HCI_LE_GENERATE_DHKEY_COMPLETE_EVENT
    622          0x0020000000000000 HCI_LE_ENHANCED_CONNECTION_COMPLETE_EVENT
    623          0x0040000000000000 HCI_LE_DIRECT_ADVERTISING_REPORT_EVENT
    624            * Flags:
    625            - 0x0000000000000001: HCI_DISCONNECTION_COMPLETE_EVENT
    626            - 0x0000000000000002: HCI_ENCRYPTION_CHANGE_EVENT
    627            - 0x0000000000000004: HCI_READ_REMOTE_VERSION_INFORMATION_COMPLETE_EVENT
    628            - 0x0000000000000008: HCI_COMMAND_COMPLETE_EVENT
    629            - 0x0000000000000010: HCI_COMMAND_STATUS_EVENT
    630            - 0x0000000000000020: HCI_HARDWARE_ERROR_EVENT
    631            - 0x0000000000000040: HCI_NUMBER_OF_COMPLETED_PACKETS_EVENT
    632            - 0x0000000000000080: HCI_ENCRYPTION_KEY_REFRESH_COMPLETE_EVENT
    633            - 0x0000000000000100: ACI_BLUE_INITIALIZED_EVENT
    634            - 0x0000000000000200: ACI_GAP_LIMITED_DISCOVERABLE_EVENT
    635            - 0x0000000000000400: ACI_GAP_PAIRING_COMPLETE_EVENT
    636            - 0x0000000000000800: ACI_GAP_PASS_KEY_REQ_EVENT
    637            - 0x0000000000001000: ACI_GAP_AUTHORIZATION_REQ_EVENT
    638            - 0x0000000000002000: ACI_GAP_SLAVE_SECURITY_INITIATED_EVENT
    639            - 0x0000000000004000: ACI_GAP_BOND_LOST_EVENT
    640            - 0x0000000000008000: ACI_GAP_PROC_COMPLETE_EVENT
    641            - 0x0000000000010000: ACI_GAP_ADDR_NOT_RESOLVED_EVENT
    642            - 0x0000000000020000: ACI_GAP_NUMERIC_COMPARISON_VALUE_EVENT
    643            - 0x0000000000040000: ACI_GAP_KEYPRESS_NOTIFICATION_EVENT
    644            - 0x0000000000080000: ACI_L2CAP_CONNECTION_UPDATE_RESP_EVENT
    645            - 0x0000000000100000: ACI_L2CAP_PROC_TIMEOUT_EVENT
    646            - 0x0000000000200000: ACI_L2CAP_CONNECTION_UPDATE_REQ_EVENT
    647            - 0x0000000000400000: ACI_GATT_ATTRIBUTE_MODIFIED_EVENT
    648            - 0x0000000000800000: ACI_GATT_PROC_TIMEOUT_EVENT
    649            - 0x0000000001000000: ACI_ATT_EXCHANGE_MTU_RESP_EVENT
    650            - 0x0000000002000000: ACI_ATT_FIND_INFO_RESP_EVENT
    651            - 0x0000000004000000: ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT
    652            - 0x0000000008000000: ACI_ATT_READ_BY_TYPE_RESP_EVENT
    653            - 0x0000000010000000: ACI_ATT_READ_RESP_EVENT
    654            - 0x0000000020000000: ACI_ATT_READ_BLOB_RESP_EVENT
    655            - 0x0000000040000000: ACI_ATT_READ_MULTIPLE_RESP_EVENT
    656            - 0x0000000080000000: ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT
    657            - 0x0000000100000000: ACI_ATT_WRITE_RESP_EVENT
    658            - 0x0000000200000000: ACI_ATT_PREPARE_WRITE_RESP_EVENT
    659            - 0x0000000400000000: ACI_ATT_EXEC_WRITE_RESP_EVENT
    660            - 0x0000000800000000: ACI_GATT_INDICATION_EVENT
    661            - 0x0000001000000000: ACI_GATT_NOTIFICATION_EVENT
    662            - 0x0000002000000000: ACI_GATT_PROC_COMPLETE_EVENT
    663            - 0x0000004000000000: ACI_GATT_ERROR_RESP_EVENT
    664            - 0x0000008000000000: ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT
    665            - 0x0000010000000000: ACI_GATT_WRITE_PERMIT_REQ_EVENT
    666            - 0x0000020000000000: ACI_GATT_READ_PERMIT_REQ_EVENT
    667            - 0x0000040000000000: ACI_GATT_READ_MULTI_PERMIT_REQ_EVENT
    668            - 0x0000080000000000: ACI_GATT_TX_POOL_AVAILABLE_EVENT
    669            - 0x0000100000000000: ACI_GATT_SERVER_CONFIRMATION_EVENT
    670            - 0x0000200000000000: ACI_GATT_PREPARE_WRITE_PERMIT_REQ_EVENT
    671            - 0x0000400000000000: HCI_LE_CONNECTION_UPDATE_COMPLETE_EVENT
    672            - 0x0000800000000000: HCI_LE_READ_REMOTE_USED_FEATURES_COMPLETE_EVENT
    673            - 0x0001000000000000: HCI_LE_LONG_TERM_KEY_REQUEST_EVENT
    674            - 0x0008000000000000: HCI_LE_READ_LOCAL_P256_PUBLIC_KEY_COMPLETE_EVENT
    675            - 0x0010000000000000: HCI_LE_GENERATE_DHKEY_COMPLETE_EVENT
    676            - 0x0020000000000000: HCI_LE_ENHANCED_CONNECTION_COMPLETE_EVENT
    677            - 0x0040000000000000: HCI_LE_DIRECT_ADVERTISING_REPORT_EVENT
    678            * @retval None
    679          */
    680          

   \                                 In section .text, align 2, keep-with-next
    681          tBleStatus aci_blue_events_lost_event_process(uint8_t *buffer_in)
    682          {
   \                     aci_blue_events_lost_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    683            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
    684            /* Input params */
    685            aci_blue_events_lost_event_rp0 *rp0 = (aci_blue_events_lost_event_rp0 *)buffer_in;
    686            aci_blue_events_lost_event(rp0->Lost_Events);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       aci_blue_events_lost_event
    687          
    688            return status;
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    689          }
    690          /* aci_blue_crash_info_event */
    691          /* Event len: 1 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 1 + rp0->Debug_Data_Length * (sizeof(uint8_t)) */
    692          /**
    693            * @brief 'This event is given to the application after the @ref aci_blue_initialized_event
    694          when a system crash is detected. This events returns system crash information for debugging purposes. 
    695          Information reported are useful to understand the root cause of the crash.
    696            * @param Crash_Type Crash type
    697            * Values:
    698            - 0x00: Assert failed
    699            - 0x01: NMI fault
    700            - 0x02: Hard fault
    701            * @param SP Stack pointer
    702            * @param R0 Register R0
    703            * @param R1 Register R1
    704            * @param R2 Register R2
    705            * @param R3 Register R3
    706            * @param R12 Register R12
    707            * @param LR Link register
    708            * @param PC Program counter where crash occurred
    709            * @param xPSR xPSR register
    710            * @param Debug_Data_Length Length of Debug_Data field
    711            * @param Debug_Data Debug data
    712            * @retval None
    713          */
    714          

   \                                 In section .text, align 2, keep-with-next
    715          tBleStatus aci_blue_crash_info_event_process(uint8_t *buffer_in)
    716          {
   \                     aci_blue_crash_info_event_process: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   \   00000004   0x0004             MOVS     R4,R0
    717            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000006   0x2500             MOVS     R5,#+0
    718            /* Input params */
    719            aci_blue_crash_info_event_rp0 *rp0 = (aci_blue_crash_info_event_rp0 *)buffer_in;
    720            aci_blue_crash_info_event(rp0->Crash_Type,
    721                                      rp0->SP,
    722                                      rp0->R0,
    723                                      rp0->R1,
    724                                      rp0->R2,
    725                                      rp0->R3,
    726                                      rp0->R12,
    727                                      rp0->LR,
    728                                      rp0->PC,
    729                                      rp0->xPSR,
    730                                      rp0->Debug_Data_Length,
    731                                      rp0->Debug_Data);
   \   00000008   0xF114 0x0026      ADDS     R0,R4,#+38
   \   0000000C   0x9007             STR      R0,[SP, #+28]
   \   0000000E   0xF894 0x0025      LDRB     R0,[R4, #+37]
   \   00000012   0x9006             STR      R0,[SP, #+24]
   \   00000014   0xF8D4 0x0021      LDR      R0,[R4, #+33]
   \   00000018   0x9005             STR      R0,[SP, #+20]
   \   0000001A   0xF8D4 0x001D      LDR      R0,[R4, #+29]
   \   0000001E   0x9004             STR      R0,[SP, #+16]
   \   00000020   0xF8D4 0x0019      LDR      R0,[R4, #+25]
   \   00000024   0x9003             STR      R0,[SP, #+12]
   \   00000026   0xF8D4 0x0015      LDR      R0,[R4, #+21]
   \   0000002A   0x9002             STR      R0,[SP, #+8]
   \   0000002C   0xF8D4 0x0011      LDR      R0,[R4, #+17]
   \   00000030   0x9001             STR      R0,[SP, #+4]
   \   00000032   0xF8D4 0x000D      LDR      R0,[R4, #+13]
   \   00000036   0x9000             STR      R0,[SP, #+0]
   \   00000038   0xF8D4 0x3009      LDR      R3,[R4, #+9]
   \   0000003C   0xF8D4 0x2005      LDR      R2,[R4, #+5]
   \   00000040   0xF8D4 0x1001      LDR      R1,[R4, #+1]
   \   00000044   0x7820             LDRB     R0,[R4, #+0]
   \   00000046   0x.... 0x....      BL       aci_blue_crash_info_event
    732          
    733            return status;
   \   0000004A   0x0028             MOVS     R0,R5
   \   0000004C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004E   0xB009             ADD      SP,SP,#+36
   \   00000050   0xBD30             POP      {R4,R5,PC}       ;; return
    734          }
    735          /* aci_hal_end_of_radio_activity_event */
    736          /* Event len: 1 + 1 + 4 */
    737          /**
    738            * @brief 'This event is generated when the device completes a radio activity and provide information when a new radio acitivity will be performed.
    739          Informtation provided includes type of radio activity and absolute time in system ticks when a new radio acitivity is schedule, if any. Application can use this information to schedule user activities synchronous to selected radio activitities. A command @ref aci_hal_set_radio_activity_mask is provided to enable radio activity events of user interests, by default no events are enabled.
    740          User should take into account that enablinng radio events in application with intense radio activity could lead to a fairly high rate of events generated.
    741          Application use cases includes synchronizing notification with connection interval, switiching antenna at the end of advertising or performing flash erase operation while radio is idle.
    742            * @param Last_State Completed radio events
    743            * Values:
    744            - 0x00: Idle
    745            - 0x01: Advertising
    746            - 0x02: Connection event slave
    747            - 0x03: Scanning
    748            - 0x04: Connection request
    749            - 0x05: Connection event slave
    750            - 0x06: TX test mode
    751            - 0x07: RX test mode
    752            * @param Next_State Incoming radio events
    753            * Values:
    754            - 0x00: Idle
    755            - 0x01: Advertising
    756            - 0x02: Connection event slave
    757            - 0x03: Scanning
    758            - 0x04: Connection request
    759            - 0x05: Connection event slave
    760            - 0x06: TX test mode
    761            - 0x07: RX test mode
    762            * @param Next_State_SysTime 32bit absolute current time expressed in internal time units.
    763            * @retval None
    764          */
    765          

   \                                 In section .text, align 2, keep-with-next
    766          tBleStatus aci_hal_end_of_radio_activity_event_process(uint8_t *buffer_in)
    767          {
   \                     aci_hal_end_of_radio_activity_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    768            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
    769            /* Input params */
    770            aci_hal_end_of_radio_activity_event_rp0 *rp0 = (aci_hal_end_of_radio_activity_event_rp0 *)buffer_in;
    771            aci_hal_end_of_radio_activity_event(rp0->Last_State,
    772                                                rp0->Next_State,
    773                                                rp0->Next_State_SysTime);
   \   00000006   0xF8D4 0x2002      LDR      R2,[R4, #+2]
   \   0000000A   0x7861             LDRB     R1,[R4, #+1]
   \   0000000C   0x7820             LDRB     R0,[R4, #+0]
   \   0000000E   0x.... 0x....      BL       aci_hal_end_of_radio_activity_event
    774          
    775            return status;
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    776          }
    777          /* aci_hal_scan_req_report_event */
    778          /* Event len: 1 + 1 + 6 */
    779          /**
    780            * @brief This event is reported to the application after a scan request is received and a scan reponse
    781          is scheduled to be transmitted.
    782            * @param RSSI N Size: 1 Octet (signed integer)
    783          Units: dBm
    784            * Values:
    785            - 127: RSSI not available
    786            - -127 ... 20
    787            * @param Peer_Address_Type 0x00 Public Device Address
    788          0x01 Random Device Address
    789          0x02 Public Identity Address (Corresponds to Resolved Private Address)
    790          0x03 Random (Static) Identity Address (Corresponds to Resolved Private Address)
    791            * Values:
    792            - 0x00: Public Device Address
    793            - 0x01: Random Device Address
    794            - 0x02: Public Identity Address
    795            - 0x03: Random (Static) Identity Address
    796            * @param Peer_Address Public Device Address or Random Device Address of the peer device
    797            * @retval None
    798          */
    799          

   \                                 In section .text, align 2, keep-with-next
    800          tBleStatus aci_hal_scan_req_report_event_process(uint8_t *buffer_in)
    801          {
   \                     aci_hal_scan_req_report_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    802            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
    803            /* Input params */
    804            aci_hal_scan_req_report_event_rp0 *rp0 = (aci_hal_scan_req_report_event_rp0 *)buffer_in;
    805            aci_hal_scan_req_report_event(rp0->RSSI,
    806                                          rp0->Peer_Address_Type,
    807                                          rp0->Peer_Address);
   \   00000006   0x1CA2             ADDS     R2,R4,#+2
   \   00000008   0x7861             LDRB     R1,[R4, #+1]
   \   0000000A   0x7820             LDRB     R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       aci_hal_scan_req_report_event
    808          
    809            return status;
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    810          }
    811          /* aci_gap_limited_discoverable_event */
    812          /* Event len: 0 */
    813          /**
    814            * @brief This event is generated by the controller when the limited discoverable mode ends due to
    815          timeout. The timeout is 180 seconds.
    816            * @retval None
    817          */
    818          

   \                                 In section .text, align 2, keep-with-next
    819          tBleStatus aci_gap_limited_discoverable_event_process(uint8_t *buffer_in)
    820          {
   \                     aci_gap_limited_discoverable_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    821            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
    822            aci_gap_limited_discoverable_event();
   \   00000006   0x.... 0x....      BL       aci_gap_limited_discoverable_event
    823          
    824            return status;
   \   0000000A   0x0028             MOVS     R0,R5
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    825          }
    826          /* aci_gap_pairing_complete_event */
    827          /* Event len: 2 + 1 + 1 */
    828          /**
    829            * @brief This event is generated when the pairing process has completed successfully or a pairing
    830          procedure timeout has occurred or the pairing has failed. This is to notify the application that
    831          we have paired with a remote device so that it can take further actions or to notify that a
    832          timeout has occurred so that the upper layer can decide to disconnect the link.
    833            * @param Connection_Handle Connection handle on which the pairing procedure completed
    834            * @param Status Pairing status
    835            * Values:
    836            - 0x00: Success
    837            - 0x01: Timeout
    838            - 0x02: Failed
    839            * @param Reason Pairing reason error code
    840            * Values:
    841            - 0x00
    842            - 0x01: PASSKEY_ENTRY_FAILED
    843            - 0x02: OOB_NOT_AVAILABLE
    844            - 0x03: AUTH_REQ_CANNOT_BE_MET
    845            - 0x04: CONFIRM_VALUE_FAILED
    846            - 0x05: PAIRING_NOT_SUPPORTED
    847            - 0x06: INSUFF_ENCRYPTION_KEY_SIZE
    848            - 0x07: CMD_NOT_SUPPORTED
    849            - 0x08: UNSPECIFIED_REASON
    850            - 0x09: VERY_EARLY_NEXT_ATTEMPT
    851            - 0x0A: SM_INVALID_PARAMS
    852            - 0x0B: SMP_SC_DHKEY_CHECK_FAILED
    853            - 0x0C: SMP_SC_NUMCOMPARISON_FAILED
    854            * @retval None
    855          */
    856          

   \                                 In section .text, align 2, keep-with-next
    857          tBleStatus aci_gap_pairing_complete_event_process(uint8_t *buffer_in)
    858          {
   \                     aci_gap_pairing_complete_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    859            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
    860            /* Input params */
    861            aci_gap_pairing_complete_event_rp0 *rp0 = (aci_gap_pairing_complete_event_rp0 *)buffer_in;
    862            aci_gap_pairing_complete_event(rp0->Connection_Handle,
    863                                           rp0->Status,
    864                                           rp0->Reason);
   \   00000006   0x78E2             LDRB     R2,[R4, #+3]
   \   00000008   0x78A1             LDRB     R1,[R4, #+2]
   \   0000000A   0x8820             LDRH     R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       aci_gap_pairing_complete_event
    865          
    866            return status;
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    867          }
    868          /* aci_gap_pass_key_req_event */
    869          /* Event len: 2 */
    870          /**
    871            * @brief This event is generated by the Security manager to the application when a passkey is
    872          required for pairing. When this event is received, the application has to respond with the
    873          @ref aci_gap_pass_key_resp command.
    874            * @param Connection_Handle Connection handle for which the passkey has been requested.
    875            * @retval None
    876          */
    877          

   \                                 In section .text, align 2, keep-with-next
    878          tBleStatus aci_gap_pass_key_req_event_process(uint8_t *buffer_in)
    879          {
   \                     aci_gap_pass_key_req_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    880            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
    881            /* Input params */
    882            aci_gap_pass_key_req_event_rp0 *rp0 = (aci_gap_pass_key_req_event_rp0 *)buffer_in;
    883            aci_gap_pass_key_req_event(rp0->Connection_Handle);
   \   00000006   0x8820             LDRH     R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       aci_gap_pass_key_req_event
    884          
    885            return status;
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    886          }
    887          /* aci_gap_authorization_req_event */
    888          /* Event len: 2 */
    889          /**
    890            * @brief This event is generated by the Security manager to the application when the application has
    891          set that authorization is required for reading/writing of attributes. This event will be
    892          generated as soon as the pairing is complete. When this event is received,
    893          @ref aci_gap_authorization_resp command should be used to respond by the application.
    894            * @param Connection_Handle Connection handle for which authorization has been requested.
    895            * @retval None
    896          */
    897          

   \                                 In section .text, align 2, keep-with-next
    898          tBleStatus aci_gap_authorization_req_event_process(uint8_t *buffer_in)
    899          {
   \                     aci_gap_authorization_req_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    900            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
    901            /* Input params */
    902            aci_gap_authorization_req_event_rp0 *rp0 = (aci_gap_authorization_req_event_rp0 *)buffer_in;
    903            aci_gap_authorization_req_event(rp0->Connection_Handle);
   \   00000006   0x8820             LDRH     R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       aci_gap_authorization_req_event
    904          
    905            return status;
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    906          }
    907          /* aci_gap_slave_security_initiated_event */
    908          /* Event len: 0 */
    909          /**
    910            * @brief This event is generated when the slave security request is successfully sent to the master.
    911            * @retval None
    912          */
    913          

   \                                 In section .text, align 2, keep-with-next
    914          tBleStatus aci_gap_slave_security_initiated_event_process(uint8_t *buffer_in)
    915          {
   \                     aci_gap_slave_security_initiated_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    916            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
    917            aci_gap_slave_security_initiated_event();
   \   00000006   0x.... 0x....      BL       aci_gap_slave_security_initiated_event
    918          
    919            return status;
   \   0000000A   0x0028             MOVS     R0,R5
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    920          }
    921          /* aci_gap_bond_lost_event */
    922          /* Event len: 0 */
    923          /**
    924            * @brief This event is generated when a pairing request is issued in response to a slave security
    925          request from a master which has previously bonded with the slave. When this event is
    926          received, the upper layer has to issue the command @ref aci_gap_allow_rebond in order to
    927          allow the slave to continue the pairing process with the master.
    928            * @retval None
    929          */
    930          

   \                                 In section .text, align 2, keep-with-next
    931          tBleStatus aci_gap_bond_lost_event_process(uint8_t *buffer_in)
    932          {
   \                     aci_gap_bond_lost_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    933            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
    934            aci_gap_bond_lost_event();
   \   00000006   0x.... 0x....      BL       aci_gap_bond_lost_event
    935          
    936            return status;
   \   0000000A   0x0028             MOVS     R0,R5
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    937          }
    938          /* aci_gap_proc_complete_event */
    939          /* Event len: 1 + 1 + 1 + rp0->Data_Length * (sizeof(uint8_t)) */
    940          /**
    941            * @brief This event is sent by the GAP to the upper layers when a procedure previously started has
    942          been terminated by the upper layer or has completed for any other reason
    943            * @param Procedure_Code Terminated procedure.
    944            * Values:
    945            - 0x01: LIMITED_DISCOVERY_PROC
    946            - 0x02: GENERAL_DISCOVERY_PROC
    947            - 0x04: NAME_DISCOVERY_PROC
    948            - 0x08: AUTO_CONNECTION_ESTABLISHMENT_PROC
    949            - 0x10: GENERAL_CONNECTION_ESTABLISHMENT_PROC
    950            - 0x20: SELECTIVE_CONNECTION_ESTABLISHMENT_PROC
    951            - 0x40: DIRECT_CONNECTION_ESTABLISHMENT_PROC
    952            - 0x80: OBSERVATION_PROC
    953            * @param Status Error code. See Core v4.1, Vol. 2, part D.
    954            * @param Data_Length Length of Data in octets
    955            * @param Data Procedure Specific Data:
    956          - For Name Discovery Procedure: the name of the peer device if the procedure completed successfully.
    957            * @retval None
    958          */
    959          

   \                                 In section .text, align 2, keep-with-next
    960          tBleStatus aci_gap_proc_complete_event_process(uint8_t *buffer_in)
    961          {
   \                     aci_gap_proc_complete_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    962            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
    963            /* Input params */
    964            aci_gap_proc_complete_event_rp0 *rp0 = (aci_gap_proc_complete_event_rp0 *)buffer_in;
    965            aci_gap_proc_complete_event(rp0->Procedure_Code,
    966                                        rp0->Status,
    967                                        rp0->Data_Length,
    968                                        rp0->Data);
   \   00000006   0x1CE3             ADDS     R3,R4,#+3
   \   00000008   0x78A2             LDRB     R2,[R4, #+2]
   \   0000000A   0x7861             LDRB     R1,[R4, #+1]
   \   0000000C   0x7820             LDRB     R0,[R4, #+0]
   \   0000000E   0x.... 0x....      BL       aci_gap_proc_complete_event
    969          
    970            return status;
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    971          }
    972          /* aci_gap_addr_not_resolved_event */
    973          /* Event len: 2 */
    974          /**
    975            * @brief This event is sent only by a privacy enabled Peripheral. The event is sent to the
    976          upper layers when the peripheral is unsuccessful in resolving the resolvable
    977          address of the peer device after connecting to it.
    978            * @param Connection_Handle Connection handle for which the private address could not be
    979          resolved with any of the stored IRK's.
    980            * @retval None
    981          */
    982          

   \                                 In section .text, align 2, keep-with-next
    983          tBleStatus aci_gap_addr_not_resolved_event_process(uint8_t *buffer_in)
    984          {
   \                     aci_gap_addr_not_resolved_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    985            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
    986            /* Input params */
    987            aci_gap_addr_not_resolved_event_rp0 *rp0 = (aci_gap_addr_not_resolved_event_rp0 *)buffer_in;
    988            aci_gap_addr_not_resolved_event(rp0->Connection_Handle);
   \   00000006   0x8820             LDRH     R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       aci_gap_addr_not_resolved_event
    989          
    990            return status;
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    991          }
    992          /* aci_gap_numeric_comparison_value_event */
    993          /* Event len: 2 + 4 */
    994          /**
    995            * @brief This event is sent only during SC v.4.2 Pairing, when Numeric Comparison Association model is selected, in order to show the Numeric Value generated, and to ask for Confirmation to the User. When this event is received, the application has to respond with the
    996          @ref aci_gap_numeric_comparison_resp command.
    997            * @param Connection_Handle Connection handle related to the underlying Pairing
    998            * @param Numeric_Value 
    999            * @retval None
   1000          */
   1001          

   \                                 In section .text, align 2, keep-with-next
   1002          tBleStatus aci_gap_numeric_comparison_value_event_process(uint8_t *buffer_in)
   1003          {
   \                     aci_gap_numeric_comparison_value_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1004            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
   1005            /* Input params */
   1006            aci_gap_numeric_comparison_value_event_rp0 *rp0 = (aci_gap_numeric_comparison_value_event_rp0 *)buffer_in;
   1007            aci_gap_numeric_comparison_value_event(rp0->Connection_Handle,
   1008                                                   rp0->Numeric_Value);
   \   00000006   0xF8D4 0x1002      LDR      R1,[R4, #+2]
   \   0000000A   0x8820             LDRH     R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       aci_gap_numeric_comparison_value_event
   1009          
   1010            return status;
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1011          }
   1012          /* aci_gap_keypress_notification_event */
   1013          /* Event len: 2 + 1 */
   1014          /**
   1015            * @brief This event is sent only during SC v.4.2 Pairing, when Keypress Notifications are supported, in order to show the input type signalled by the peer device, having Keyboard only I/O capabilities. When this event is received, no action is required to the User.
   1016            * @param Connection_Handle Connection handle related to the underlying Pairing
   1017            * @param Notification_Type Type of Keypress input notified/signaled by peer device (having Keyboard only I/O capabilities
   1018            * @retval None
   1019          */
   1020          

   \                                 In section .text, align 2, keep-with-next
   1021          tBleStatus aci_gap_keypress_notification_event_process(uint8_t *buffer_in)
   1022          {
   \                     aci_gap_keypress_notification_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1023            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
   1024            /* Input params */
   1025            aci_gap_keypress_notification_event_rp0 *rp0 = (aci_gap_keypress_notification_event_rp0 *)buffer_in;
   1026            aci_gap_keypress_notification_event(rp0->Connection_Handle,
   1027                                                rp0->Notification_Type);
   \   00000006   0x78A1             LDRB     R1,[R4, #+2]
   \   00000008   0x8820             LDRH     R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       aci_gap_keypress_notification_event
   1028          
   1029            return status;
   \   0000000E   0x0028             MOVS     R0,R5
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1030          }
   1031          /* aci_l2cap_connection_update_resp_event */
   1032          /* Event len: 2 + 2 */
   1033          /**
   1034            * @brief This event is generated when the master responds to the connection update request packet
   1035          with a connection update response packet.
   1036            * @param Connection_Handle Connection handle referring to the COS Channel where the Disconnection has been received.
   1037            * @param Result 
   1038            * @retval None
   1039          */
   1040          

   \                                 In section .text, align 2, keep-with-next
   1041          tBleStatus aci_l2cap_connection_update_resp_event_process(uint8_t *buffer_in)
   1042          {
   \                     aci_l2cap_connection_update_resp_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1043            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
   1044            /* Input params */
   1045            aci_l2cap_connection_update_resp_event_rp0 *rp0 = (aci_l2cap_connection_update_resp_event_rp0 *)buffer_in;
   1046            aci_l2cap_connection_update_resp_event(rp0->Connection_Handle,
   1047                                                   rp0->Result);
   \   00000006   0x8861             LDRH     R1,[R4, #+2]
   \   00000008   0x8820             LDRH     R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       aci_l2cap_connection_update_resp_event
   1048          
   1049            return status;
   \   0000000E   0x0028             MOVS     R0,R5
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1050          }
   1051          /* aci_l2cap_proc_timeout_event */
   1052          /* Event len: 2 + 1 + rp0->Data_Length * (sizeof(uint8_t)) */
   1053          /**
   1054            * @brief This event is generated when the master does not respond to the connection update
   1055          request packet with a connection update response packet or a command reject packet
   1056          within 30 seconds.
   1057            * @param Connection_Handle Handle of the connection related to this
   1058          L2CAP procedure.
   1059            * @param Data_Length Length of following data
   1060            * @param Data 
   1061            * @retval None
   1062          */
   1063          

   \                                 In section .text, align 2, keep-with-next
   1064          tBleStatus aci_l2cap_proc_timeout_event_process(uint8_t *buffer_in)
   1065          {
   \                     aci_l2cap_proc_timeout_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1066            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
   1067            /* Input params */
   1068            aci_l2cap_proc_timeout_event_rp0 *rp0 = (aci_l2cap_proc_timeout_event_rp0 *)buffer_in;
   1069            aci_l2cap_proc_timeout_event(rp0->Connection_Handle,
   1070                                         rp0->Data_Length,
   1071                                         rp0->Data);
   \   00000006   0x1CE2             ADDS     R2,R4,#+3
   \   00000008   0x78A1             LDRB     R1,[R4, #+2]
   \   0000000A   0x8820             LDRH     R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       aci_l2cap_proc_timeout_event
   1072          
   1073            return status;
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1074          }
   1075          /* aci_l2cap_connection_update_req_event */
   1076          /* Event len: 2 + 1 + 2 + 2 + 2 + 2 + 2 */
   1077          /**
   1078            * @brief The event is given by the L2CAP layer when a connection update request is received from
   1079          the slave. The upper layer which receives this event has to respond by sending a
   1080          @ref aci_l2cap_connection_parameter_update_resp command.
   1081            * @param Connection_Handle Handle of the connection related to this
   1082          L2CAP procedure.
   1083            * @param Identifier This is the identifier which associate the request to the
   1084          response.
   1085            * @param L2CAP_Length Length of the L2CAP connection update request.
   1086            * @param Interval_Min Minimum value for the connection event interval. This shall be less
   1087          than or equal to Conn_Interval_Max.
   1088          Time = N * 1.25 msec.
   1089            * Values:
   1090            - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
   1091            * @param Interval_Max Maximum value for the connection event interval. This shall be
   1092          greater than or equal to Conn_Interval_Min.
   1093          Time = N * 1.25 msec.
   1094            * Values:
   1095            - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
   1096            * @param Slave_Latency Slave latency for the connection in number of connection events.
   1097            * Values:
   1098            - 0x0000 ... 0x01F3
   1099            * @param Timeout_Multiplier Defines connection timeout parameter in the following manner: Timeout Multiplier * 10ms.
   1100            * @retval None
   1101          */
   1102          

   \                                 In section .text, align 2, keep-with-next
   1103          tBleStatus aci_l2cap_connection_update_req_event_process(uint8_t *buffer_in)
   1104          {
   \                     aci_l2cap_connection_update_req_event_process: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1105            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
   1106            /* Input params */
   1107            aci_l2cap_connection_update_req_event_rp0 *rp0 = (aci_l2cap_connection_update_req_event_rp0 *)buffer_in;
   1108            aci_l2cap_connection_update_req_event(rp0->Connection_Handle,
   1109                                                  rp0->Identifier,
   1110                                                  rp0->L2CAP_Length,
   1111                                                  rp0->Interval_Min,
   1112                                                  rp0->Interval_Max,
   1113                                                  rp0->Slave_Latency,
   1114                                                  rp0->Timeout_Multiplier);
   \   00000006   0xF8B4 0x000B      LDRH     R0,[R4, #+11]
   \   0000000A   0x9002             STR      R0,[SP, #+8]
   \   0000000C   0xF8B4 0x0009      LDRH     R0,[R4, #+9]
   \   00000010   0x9001             STR      R0,[SP, #+4]
   \   00000012   0xF8B4 0x0007      LDRH     R0,[R4, #+7]
   \   00000016   0x9000             STR      R0,[SP, #+0]
   \   00000018   0xF8B4 0x3005      LDRH     R3,[R4, #+5]
   \   0000001C   0xF8B4 0x2003      LDRH     R2,[R4, #+3]
   \   00000020   0x78A1             LDRB     R1,[R4, #+2]
   \   00000022   0x8820             LDRH     R0,[R4, #+0]
   \   00000024   0x.... 0x....      BL       aci_l2cap_connection_update_req_event
   1115          
   1116            return status;
   \   00000028   0x0028             MOVS     R0,R5
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0xBD3E             POP      {R1-R5,PC}       ;; return
   1117          }
   1118          /* aci_l2cap_command_reject_event */
   1119          /* Event len: 2 + 1 + 2 + 1 + rp0->Data_Length * (sizeof(uint8_t)) */
   1120          /**
   1121            * @brief This event is generated when the master responds to the connection update request packet
   1122          with a command reject packet.
   1123            * @param Connection_Handle Connection handle referring to the COS Channel where the Disconnection has been received.
   1124            * @param Identifier This is the identifier which associate the request to the
   1125          response.
   1126            * @param Reason Reason
   1127            * @param Data_Length Length of following data
   1128            * @param Data Data field associated with Reason
   1129            * @retval None
   1130          */
   1131          

   \                                 In section .text, align 2, keep-with-next
   1132          tBleStatus aci_l2cap_command_reject_event_process(uint8_t *buffer_in)
   1133          {
   \                     aci_l2cap_command_reject_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1134            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
   1135            /* Input params */
   1136            aci_l2cap_command_reject_event_rp0 *rp0 = (aci_l2cap_command_reject_event_rp0 *)buffer_in;
   1137            aci_l2cap_command_reject_event(rp0->Connection_Handle,
   1138                                           rp0->Identifier,
   1139                                           rp0->Reason,
   1140                                           rp0->Data_Length,
   1141                                           rp0->Data);
   \   00000006   0x1DA0             ADDS     R0,R4,#+6
   \   00000008   0x9000             STR      R0,[SP, #+0]
   \   0000000A   0x7963             LDRB     R3,[R4, #+5]
   \   0000000C   0xF8B4 0x2003      LDRH     R2,[R4, #+3]
   \   00000010   0x78A1             LDRB     R1,[R4, #+2]
   \   00000012   0x8820             LDRH     R0,[R4, #+0]
   \   00000014   0x.... 0x....      BL       aci_l2cap_command_reject_event
   1142          
   1143            return status;
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1144          }
   1145          /* aci_gatt_attribute_modified_event */
   1146          /* Event len: 2 + 2 + 2 + 2 + rp0->Attr_Data_Length * (sizeof(uint8_t)) */
   1147          /**
   1148            * @brief This event is generated to the application by the GATT server when a client modifies any
   1149          attribute on the server, as consequence of one of the following GATT procedures:
   1150          - write without response
   1151          - signed write without response
   1152          - write characteristic value
   1153          - write long characteristic value
   1154          - reliable write.
   1155            * @param Connection_Handle The connection handle which modified the attribute.
   1156            * @param Attr_Handle Handle of the attribute that was modified.
   1157            * @param Offset Offset from which the write has been performed by the peer device.
   1158            * @param Attr_Data_Length Length of Attr_Data in octets
   1159            * @param Attr_Data The modified value
   1160            * @retval None
   1161          */
   1162          

   \                                 In section .text, align 2, keep-with-next
   1163          tBleStatus aci_gatt_attribute_modified_event_process(uint8_t *buffer_in)
   1164          {
   \                     aci_gatt_attribute_modified_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1165            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
   1166            /* Input params */
   1167            aci_gatt_attribute_modified_event_rp0 *rp0 = (aci_gatt_attribute_modified_event_rp0 *)buffer_in;
   1168            aci_gatt_attribute_modified_event(rp0->Connection_Handle,
   1169                                              rp0->Attr_Handle,
   1170                                              rp0->Offset,
   1171                                              rp0->Attr_Data_Length,
   1172                                              rp0->Attr_Data);
   \   00000006   0xF114 0x0008      ADDS     R0,R4,#+8
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   \   0000000C   0x88E3             LDRH     R3,[R4, #+6]
   \   0000000E   0x88A2             LDRH     R2,[R4, #+4]
   \   00000010   0x8861             LDRH     R1,[R4, #+2]
   \   00000012   0x8820             LDRH     R0,[R4, #+0]
   \   00000014   0x.... 0x....      BL       aci_gatt_attribute_modified_event
   1173          
   1174            return status;
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1175          }
   1176          /* aci_gatt_proc_timeout_event */
   1177          /* Event len: 2 */
   1178          /**
   1179            * @brief This event is generated by the client/server to the application on a GATT timeout (30
   1180          seconds). This is a critical event that should not happen during normal operating conditions. It is an indication of either a major disruption in the communication link or a mistake in the application which does not provide a reply to GATT procedures. After this event, the GATT channel is closed and no more GATT communication can be performed. The applications is exptected to issue an @ref aci_gap_terminate to disconnect from the peer device. It is important to leave an 100 ms blank window before sending the @ref aci_gap_terminate, since immediately after this event, system could save important information in non volatile memory.
   1181            * @param Connection_Handle Connection handle on which the GATT procedure has timed out
   1182            * @retval None
   1183          */
   1184          

   \                                 In section .text, align 2, keep-with-next
   1185          tBleStatus aci_gatt_proc_timeout_event_process(uint8_t *buffer_in)
   1186          {
   \                     aci_gatt_proc_timeout_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1187            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
   1188            /* Input params */
   1189            aci_gatt_proc_timeout_event_rp0 *rp0 = (aci_gatt_proc_timeout_event_rp0 *)buffer_in;
   1190            aci_gatt_proc_timeout_event(rp0->Connection_Handle);
   \   00000006   0x8820             LDRH     R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       aci_gatt_proc_timeout_event
   1191          
   1192            return status;
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1193          }
   1194          /* aci_att_exchange_mtu_resp_event */
   1195          /* Event len: 2 + 2 */
   1196          /**
   1197            * @brief This event is generated in response to an Exchange MTU request. See
   1198          @ref aci_gatt_exchange_config.
   1199            * @param Connection_Handle Connection handle related to the response
   1200            * @param Server_RX_MTU Attribute server receive MTU size
   1201            * @retval None
   1202          */
   1203          

   \                                 In section .text, align 2, keep-with-next
   1204          tBleStatus aci_att_exchange_mtu_resp_event_process(uint8_t *buffer_in)
   1205          {
   \                     aci_att_exchange_mtu_resp_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1206            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
   1207            /* Input params */
   1208            aci_att_exchange_mtu_resp_event_rp0 *rp0 = (aci_att_exchange_mtu_resp_event_rp0 *)buffer_in;
   1209            aci_att_exchange_mtu_resp_event(rp0->Connection_Handle,
   1210                                            rp0->Server_RX_MTU);
   \   00000006   0x8861             LDRH     R1,[R4, #+2]
   \   00000008   0x8820             LDRH     R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       aci_att_exchange_mtu_resp_event
   1211          
   1212            return status;
   \   0000000E   0x0028             MOVS     R0,R5
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1213          }
   1214          /* aci_att_find_info_resp_event */
   1215          /* Event len: 2 + 1 + 1 + rp0->Event_Data_Length * (sizeof(uint8_t)) */
   1216          /**
   1217            * @brief This event is generated in response to a Find Information Request. See
   1218          @ref aci_att_find_info_req and Find Information Response in Bluetooth Core v4.1
   1219          spec.
   1220            * @param Connection_Handle Connection handle related to the response
   1221            * @param Format Format of the hanndle-uuid pairs
   1222            * @param Event_Data_Length Length of Handle_UUID_Pair in octets
   1223            * @param Handle_UUID_Pair A sequence of handle-uuid pairs. if format=1, each pair is:[2 octets for handle, 2 octets for UUIDs], if format=2, each pair is:[2 octets for handle, 16 octets for UUIDs]
   1224            * @retval None
   1225          */
   1226          

   \                                 In section .text, align 2, keep-with-next
   1227          tBleStatus aci_att_find_info_resp_event_process(uint8_t *buffer_in)
   1228          {
   \                     aci_att_find_info_resp_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1229            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
   1230            /* Input params */
   1231            aci_att_find_info_resp_event_rp0 *rp0 = (aci_att_find_info_resp_event_rp0 *)buffer_in;
   1232            aci_att_find_info_resp_event(rp0->Connection_Handle,
   1233                                         rp0->Format,
   1234                                         rp0->Event_Data_Length,
   1235                                         rp0->Handle_UUID_Pair);
   \   00000006   0x1D23             ADDS     R3,R4,#+4
   \   00000008   0x78E2             LDRB     R2,[R4, #+3]
   \   0000000A   0x78A1             LDRB     R1,[R4, #+2]
   \   0000000C   0x8820             LDRH     R0,[R4, #+0]
   \   0000000E   0x.... 0x....      BL       aci_att_find_info_resp_event
   1236          
   1237            return status;
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1238          }
   1239          /* aci_att_find_by_type_value_resp_event */
   1240          /* Event len: 2 + 1 + rp0->Num_of_Handle_Pair * (sizeof(Attribute_Group_Handle_Pair_t)) */
   1241          /**
   1242            * @brief This event is generated in response to a @ref aci_att_find_by_type_value_req
   1243            * @param Connection_Handle Connection handle related to the response
   1244            * @param Num_of_Handle_Pair Number of attribute, group handle pairs
   1245            * @param Attribute_Group_Handle_Pair See @ref Attribute_Group_Handle_Pair_t
   1246            * @retval None
   1247          */
   1248          

   \                                 In section .text, align 2, keep-with-next
   1249          tBleStatus aci_att_find_by_type_value_resp_event_process(uint8_t *buffer_in)
   1250          {
   \                     aci_att_find_by_type_value_resp_event_process: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB0A0             SUB      SP,SP,#+128
   \   00000006   0x0004             MOVS     R4,R0
   1251            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000008   0x2500             MOVS     R5,#+0
   1252            /* Input params */
   1253            aci_att_find_by_type_value_resp_event_rp0 *rp0 = (aci_att_find_by_type_value_resp_event_rp0 *)buffer_in;
   \   0000000A   0x0026             MOVS     R6,R4
   1254            uint8_t size = 3;
   \   0000000C   0x2703             MOVS     R7,#+3
   1255            int i;
   1256            Attribute_Group_Handle_Pair_t Attribute_Group_Handle_Pair[HCI_MAX_PAYLOAD_SIZE/sizeof(Attribute_Group_Handle_Pair_t)];
   1257            for (i = 0; i < rp0->Num_of_Handle_Pair; i++) {
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x4680             MOV      R8,R0
   \                     ??aci_att_find_by_type_value_resp_event_process_0: (+1)
   \   00000012   0x78B0             LDRB     R0,[R6, #+2]
   \   00000014   0x4580             CMP      R8,R0
   \   00000016   0xDA13             BGE.N    ??aci_att_find_by_type_value_resp_event_process_1
   1258              Attribute_Group_Handle_Pair[i].Found_Attribute_Handle = rp0->Attribute_Group_Handle_Pair[i].Found_Attribute_Handle;
   \   00000018   0xEB06 0x0088      ADD      R0,R6,R8, LSL #+2
   \   0000001C   0xF8B0 0x0003      LDRH     R0,[R0, #+3]
   \   00000020   0x4669             MOV      R1,SP
   \   00000022   0xF821 0x0028      STRH     R0,[R1, R8, LSL #+2]
   1259              size += 2;
   \   00000026   0x1CBF             ADDS     R7,R7,#+2
   1260              Attribute_Group_Handle_Pair[i].Group_End_Handle = rp0->Attribute_Group_Handle_Pair[i].Group_End_Handle;
   \   00000028   0xEB06 0x0088      ADD      R0,R6,R8, LSL #+2
   \   0000002C   0xF8B0 0x0005      LDRH     R0,[R0, #+5]
   \   00000030   0x4669             MOV      R1,SP
   \   00000032   0xEB01 0x0188      ADD      R1,R1,R8, LSL #+2
   \   00000036   0x8048             STRH     R0,[R1, #+2]
   1261              size += 2;
   \   00000038   0x1CBF             ADDS     R7,R7,#+2
   1262            }
   \   0000003A   0xF118 0x0801      ADDS     R8,R8,#+1
   \   0000003E   0xE7E8             B.N      ??aci_att_find_by_type_value_resp_event_process_0
   1263            aci_att_find_by_type_value_resp_event(rp0->Connection_Handle,
   1264                                                  rp0->Num_of_Handle_Pair,
   1265                                                  Attribute_Group_Handle_Pair);
   \                     ??aci_att_find_by_type_value_resp_event_process_1: (+1)
   \   00000040   0x466A             MOV      R2,SP
   \   00000042   0x78B1             LDRB     R1,[R6, #+2]
   \   00000044   0x8830             LDRH     R0,[R6, #+0]
   \   00000046   0x.... 0x....      BL       aci_att_find_by_type_value_resp_event
   1266          
   1267            return status;
   \   0000004A   0x0028             MOVS     R0,R5
   \   0000004C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004E   0xB020             ADD      SP,SP,#+128
   \   00000050   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1268          }
   1269          /* aci_att_read_by_type_resp_event */
   1270          /* Event len: 2 + 1 + 1 + rp0->Data_Length * (sizeof(uint8_t)) */
   1271          /**
   1272            * @brief This event is generated in response to a @ref aci_att_read_by_type_req. See
   1273          @ref aci_gatt_find_included_services and @ref aci_gatt_disc_all_char_desc.
   1274            * @param Connection_Handle Connection handle related to the response
   1275            * @param Handle_Value_Pair_Length The size of each attribute handle-value pair
   1276            * @param Data_Length Length of Handle_Value_Pair_Data in octets
   1277            * @param Handle_Value_Pair_Data Attribute Data List as defined in Bluetooth Core v4.1 spec. A sequence of handle-value pairs: [2 octets for Attribute Handle, (Handle_Value_Pair_Length - 2 octets) for Attribute Value]
   1278            * @retval None
   1279          */
   1280          

   \                                 In section .text, align 2, keep-with-next
   1281          tBleStatus aci_att_read_by_type_resp_event_process(uint8_t *buffer_in)
   1282          {
   \                     aci_att_read_by_type_resp_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1283            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
   1284            /* Input params */
   1285            aci_att_read_by_type_resp_event_rp0 *rp0 = (aci_att_read_by_type_resp_event_rp0 *)buffer_in;
   1286            aci_att_read_by_type_resp_event(rp0->Connection_Handle,
   1287                                            rp0->Handle_Value_Pair_Length,
   1288                                            rp0->Data_Length,
   1289                                            rp0->Handle_Value_Pair_Data);
   \   00000006   0x1D23             ADDS     R3,R4,#+4
   \   00000008   0x78E2             LDRB     R2,[R4, #+3]
   \   0000000A   0x78A1             LDRB     R1,[R4, #+2]
   \   0000000C   0x8820             LDRH     R0,[R4, #+0]
   \   0000000E   0x.... 0x....      BL       aci_att_read_by_type_resp_event
   1290          
   1291            return status;
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1292          }
   1293          /* aci_att_read_resp_event */
   1294          /* Event len: 2 + 1 + rp0->Event_Data_Length * (sizeof(uint8_t)) */
   1295          /**
   1296            * @brief This event is generated in response to a Read Request. See @ref aci_gatt_read_char_value.
   1297            * @param Connection_Handle Connection handle related to the response
   1298            * @param Event_Data_Length Length of following data
   1299            * @param Attribute_Value The value of the attribute.
   1300            * @retval None
   1301          */
   1302          

   \                                 In section .text, align 2, keep-with-next
   1303          tBleStatus aci_att_read_resp_event_process(uint8_t *buffer_in)
   1304          {
   \                     aci_att_read_resp_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1305            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
   1306            /* Input params */
   1307            aci_att_read_resp_event_rp0 *rp0 = (aci_att_read_resp_event_rp0 *)buffer_in;
   1308            aci_att_read_resp_event(rp0->Connection_Handle,
   1309                                    rp0->Event_Data_Length,
   1310                                    rp0->Attribute_Value);
   \   00000006   0x1CE2             ADDS     R2,R4,#+3
   \   00000008   0x78A1             LDRB     R1,[R4, #+2]
   \   0000000A   0x8820             LDRH     R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       aci_att_read_resp_event
   1311          
   1312            return status;
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1313          }
   1314          /* aci_att_read_blob_resp_event */
   1315          /* Event len: 2 + 1 + rp0->Event_Data_Length * (sizeof(uint8_t)) */
   1316          /**
   1317            * @brief This event can be generated during a read long characteristic value procedure. See @ref aci_gatt_read_long_char_value.
   1318            * @param Connection_Handle Connection handle related to the response
   1319            * @param Event_Data_Length Length of following data
   1320            * @param Attribute_Value Part of the attribute value.
   1321            * @retval None
   1322          */
   1323          

   \                                 In section .text, align 2, keep-with-next
   1324          tBleStatus aci_att_read_blob_resp_event_process(uint8_t *buffer_in)
   1325          {
   \                     aci_att_read_blob_resp_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1326            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
   1327            /* Input params */
   1328            aci_att_read_blob_resp_event_rp0 *rp0 = (aci_att_read_blob_resp_event_rp0 *)buffer_in;
   1329            aci_att_read_blob_resp_event(rp0->Connection_Handle,
   1330                                         rp0->Event_Data_Length,
   1331                                         rp0->Attribute_Value);
   \   00000006   0x1CE2             ADDS     R2,R4,#+3
   \   00000008   0x78A1             LDRB     R1,[R4, #+2]
   \   0000000A   0x8820             LDRH     R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       aci_att_read_blob_resp_event
   1332          
   1333            return status;
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1334          }
   1335          /* aci_att_read_multiple_resp_event */
   1336          /* Event len: 2 + 1 + rp0->Event_Data_Length * (sizeof(uint8_t)) */
   1337          /**
   1338            * @brief This event is generated in response to a Read Multiple Request.
   1339            * @param Connection_Handle Connection handle related to the response
   1340            * @param Event_Data_Length Length of following data
   1341            * @param Set_Of_Values A set of two or more values.
   1342          A concatenation of attribute values for each of the attribute handles in the request in the order that they were requested.
   1343            * @retval None
   1344          */
   1345          

   \                                 In section .text, align 2, keep-with-next
   1346          tBleStatus aci_att_read_multiple_resp_event_process(uint8_t *buffer_in)
   1347          {
   \                     aci_att_read_multiple_resp_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1348            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
   1349            /* Input params */
   1350            aci_att_read_multiple_resp_event_rp0 *rp0 = (aci_att_read_multiple_resp_event_rp0 *)buffer_in;
   1351            aci_att_read_multiple_resp_event(rp0->Connection_Handle,
   1352                                             rp0->Event_Data_Length,
   1353                                             rp0->Set_Of_Values);
   \   00000006   0x1CE2             ADDS     R2,R4,#+3
   \   00000008   0x78A1             LDRB     R1,[R4, #+2]
   \   0000000A   0x8820             LDRH     R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       aci_att_read_multiple_resp_event
   1354          
   1355            return status;
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1356          }
   1357          /* aci_att_read_by_group_type_resp_event */
   1358          /* Event len: 2 + 1 + 1 + rp0->Data_Length * (sizeof(uint8_t)) */
   1359          /**
   1360            * @brief This event is generated in response to a Read By Group Type Request. See
   1361          @ref aci_gatt_disc_all_primary_services.
   1362            * @param Connection_Handle Connection handle related to the response
   1363            * @param Attribute_Data_Length The size of each attribute data
   1364            * @param Data_Length Length of Attribute_Data_List in octets
   1365            * @param Attribute_Data_List Attribute Data List as defined in Bluetooth Core v4.1 spec. A sequence of attribute handle, end group handle, attribute value tuples: [2 octets for Attribute Handle, 2 octets End Group Handle, (Attribute_Data_Length - 4 octets) for Attribute Value]
   1366            * @retval None
   1367          */
   1368          

   \                                 In section .text, align 2, keep-with-next
   1369          tBleStatus aci_att_read_by_group_type_resp_event_process(uint8_t *buffer_in)
   1370          {
   \                     aci_att_read_by_group_type_resp_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1371            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
   1372            /* Input params */
   1373            aci_att_read_by_group_type_resp_event_rp0 *rp0 = (aci_att_read_by_group_type_resp_event_rp0 *)buffer_in;
   1374            aci_att_read_by_group_type_resp_event(rp0->Connection_Handle,
   1375                                                  rp0->Attribute_Data_Length,
   1376                                                  rp0->Data_Length,
   1377                                                  rp0->Attribute_Data_List);
   \   00000006   0x1D23             ADDS     R3,R4,#+4
   \   00000008   0x78E2             LDRB     R2,[R4, #+3]
   \   0000000A   0x78A1             LDRB     R1,[R4, #+2]
   \   0000000C   0x8820             LDRH     R0,[R4, #+0]
   \   0000000E   0x.... 0x....      BL       aci_att_read_by_group_type_resp_event
   1378          
   1379            return status;
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1380          }
   1381          /* aci_att_prepare_write_resp_event */
   1382          /* Event len: 2 + 2 + 2 + 1 + rp0->Part_Attribute_Value_Length * (sizeof(uint8_t)) */
   1383          /**
   1384            * @brief This event is generated in response to a @ref aci_att_prepare_write_req.
   1385            * @param Connection_Handle Connection handle related to the response
   1386            * @param Attribute_Handle The handle of the attribute to be written
   1387            * @param Offset The offset of the first octet to be written.
   1388            * @param Part_Attribute_Value_Length Length of Part_Attribute_Value in octets
   1389            * @param Part_Attribute_Value The value of the attribute to be written
   1390            * @retval None
   1391          */
   1392          

   \                                 In section .text, align 2, keep-with-next
   1393          tBleStatus aci_att_prepare_write_resp_event_process(uint8_t *buffer_in)
   1394          {
   \                     aci_att_prepare_write_resp_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1395            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
   1396            /* Input params */
   1397            aci_att_prepare_write_resp_event_rp0 *rp0 = (aci_att_prepare_write_resp_event_rp0 *)buffer_in;
   1398            aci_att_prepare_write_resp_event(rp0->Connection_Handle,
   1399                                             rp0->Attribute_Handle,
   1400                                             rp0->Offset,
   1401                                             rp0->Part_Attribute_Value_Length,
   1402                                             rp0->Part_Attribute_Value);
   \   00000006   0x1DE0             ADDS     R0,R4,#+7
   \   00000008   0x9000             STR      R0,[SP, #+0]
   \   0000000A   0x79A3             LDRB     R3,[R4, #+6]
   \   0000000C   0x88A2             LDRH     R2,[R4, #+4]
   \   0000000E   0x8861             LDRH     R1,[R4, #+2]
   \   00000010   0x8820             LDRH     R0,[R4, #+0]
   \   00000012   0x.... 0x....      BL       aci_att_prepare_write_resp_event
   1403          
   1404            return status;
   \   00000016   0x0028             MOVS     R0,R5
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1405          }
   1406          /* aci_att_exec_write_resp_event */
   1407          /* Event len: 2 */
   1408          /**
   1409            * @brief This event is generated in response to an Execute Write Request.
   1410            * @param Connection_Handle Connection handle related to the response
   1411            * @retval None
   1412          */
   1413          

   \                                 In section .text, align 2, keep-with-next
   1414          tBleStatus aci_att_exec_write_resp_event_process(uint8_t *buffer_in)
   1415          {
   \                     aci_att_exec_write_resp_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1416            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
   1417            /* Input params */
   1418            aci_att_exec_write_resp_event_rp0 *rp0 = (aci_att_exec_write_resp_event_rp0 *)buffer_in;
   1419            aci_att_exec_write_resp_event(rp0->Connection_Handle);
   \   00000006   0x8820             LDRH     R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       aci_att_exec_write_resp_event
   1420          
   1421            return status;
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1422          }
   1423          /* aci_gatt_indication_event */
   1424          /* Event len: 2 + 2 + 1 + rp0->Attribute_Value_Length * (sizeof(uint8_t)) */
   1425          /**
   1426            * @brief This event is generated when an indication is received from the server.
   1427            * @param Connection_Handle Connection handle related to the response
   1428            * @param Attribute_Handle The handle of the attribute
   1429            * @param Attribute_Value_Length Length of Attribute_Value in octets
   1430            * @param Attribute_Value The current value of the attribute
   1431            * @retval None
   1432          */
   1433          

   \                                 In section .text, align 2, keep-with-next
   1434          tBleStatus aci_gatt_indication_event_process(uint8_t *buffer_in)
   1435          {
   \                     aci_gatt_indication_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1436            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
   1437            /* Input params */
   1438            aci_gatt_indication_event_rp0 *rp0 = (aci_gatt_indication_event_rp0 *)buffer_in;
   1439            aci_gatt_indication_event(rp0->Connection_Handle,
   1440                                      rp0->Attribute_Handle,
   1441                                      rp0->Attribute_Value_Length,
   1442                                      rp0->Attribute_Value);
   \   00000006   0x1D63             ADDS     R3,R4,#+5
   \   00000008   0x7922             LDRB     R2,[R4, #+4]
   \   0000000A   0x8861             LDRH     R1,[R4, #+2]
   \   0000000C   0x8820             LDRH     R0,[R4, #+0]
   \   0000000E   0x.... 0x....      BL       aci_gatt_indication_event
   1443          
   1444            return status;
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1445          }
   1446          /* aci_gatt_notification_event */
   1447          /* Event len: 2 + 2 + 1 + rp0->Attribute_Value_Length * (sizeof(uint8_t)) */
   1448          /**
   1449            * @brief This event is generated when a notification is received from the server.
   1450            * @param Connection_Handle Connection handle related to the response
   1451            * @param Attribute_Handle The handle of the attribute
   1452            * @param Attribute_Value_Length Length of Attribute_Value in octets
   1453            * @param Attribute_Value The current value of the attribute
   1454            * @retval None
   1455          */
   1456          

   \                                 In section .text, align 2, keep-with-next
   1457          tBleStatus aci_gatt_notification_event_process(uint8_t *buffer_in)
   1458          {
   \                     aci_gatt_notification_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1459            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
   1460            /* Input params */
   1461            aci_gatt_notification_event_rp0 *rp0 = (aci_gatt_notification_event_rp0 *)buffer_in;
   1462            aci_gatt_notification_event(rp0->Connection_Handle,
   1463                                        rp0->Attribute_Handle,
   1464                                        rp0->Attribute_Value_Length,
   1465                                        rp0->Attribute_Value);
   \   00000006   0x1D63             ADDS     R3,R4,#+5
   \   00000008   0x7922             LDRB     R2,[R4, #+4]
   \   0000000A   0x8861             LDRH     R1,[R4, #+2]
   \   0000000C   0x8820             LDRH     R0,[R4, #+0]
   \   0000000E   0x.... 0x....      BL       aci_gatt_notification_event
   1466          
   1467            return status;
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1468          }
   1469          /* aci_gatt_proc_complete_event */
   1470          /* Event len: 2 + 1 */
   1471          /**
   1472            * @brief This event is generated when a GATT client procedure completes either with error or
   1473          successfully.
   1474            * @param Connection_Handle Connection handle related to the response
   1475            * @param Error_Code Indicates whether the procedure completed with an error or was successful
   1476            * Values:
   1477            - 0x00: Success
   1478            - 0x01: Unknown HCI Command
   1479            - 0x02: Unknown Connection Identifier
   1480            - 0x03: Hardware Failure
   1481            - 0x04: Page Timeout
   1482            - 0x05: Authentication Failure
   1483            - 0x06: PIN or Key Missing
   1484            - 0x07: Memory Capacity Exceeded
   1485            - 0x08: Connection Timeout
   1486            - 0x09: Connection Limit Exceeded
   1487            - 0x0A: Synchronous Connection Limit to a Device Exceeded
   1488            - 0x0B: ACL Connection Already Exists
   1489            - 0x0C: Command Disallowed
   1490            - 0x0D: Connection Rejected Due To Limited Resources
   1491            - 0x0E: Connection Rejected Due To Security Reasons
   1492            - 0x0F: Connection Rejected due to Unacceptable BD_ADDR
   1493            - 0x10: Connection Accept Timeout Exceeded
   1494            - 0x11: Unsupported Feature Or Parameter Value
   1495            - 0x12: Invalid HCI Command Parameters
   1496            - 0x13: Remote User Terminated Connection
   1497            - 0x14: Remote Device Terminated Connection due to Low Resources
   1498            - 0x15: Remote Device Terminated Connection due to Power Off
   1499            - 0x16: Connection Terminated By Local Host
   1500            - 0x17: Repeated Attempts
   1501            - 0x18: Pairing Not Allowed
   1502            - 0x19: Unknown LMP PDU
   1503            - 0x1A: Unsupported Remote Feature / Unsupported LMP Feature
   1504            - 0x1B: SCO Offset Rejected
   1505            - 0x1C: SCO Interval Rejected
   1506            - 0x1D: SCO Air Mode Rejected
   1507            - 0x1E: Invalid LMP Parameters
   1508            - 0x1F: Unspecified Error
   1509            - 0x20: Unsupported LMP Parameter Value
   1510            - 0x21: Role Change Not Allowed
   1511            - 0x22: LMP Response Timeout / LL Response Timeout
   1512            - 0x23: LMP Error Transaction Collision
   1513            - 0x24: LMP PDU Not Allowed
   1514            - 0x25: Encryption Mode Not Acceptable
   1515            - 0x26: Link Key cannot be Changed
   1516            - 0x27: Requested QoS Not Supported
   1517            - 0x28: Instant Passed
   1518            - 0x29: Pairing With Unit Key Not Supported
   1519            - 0x2A: Different Transaction Collision
   1520            - 0x2C: QoS Unacceptable Parameter
   1521            - 0x2D: QoS Rejected
   1522            - 0x2E: Channel Assessment Not Supported
   1523            - 0x2F: Insufficient Security
   1524            - 0x30: Parameter Out Of Mandatory Range
   1525            - 0x32: Role Switch Pending
   1526            - 0x34: Reserved Slot Violation
   1527            - 0x35: Role Switch Failed
   1528            - 0x36: Extended Inquiry Response Too Large
   1529            - 0x37: Secure Simple Pairing Not Supported by Host
   1530            - 0x38: Host Busy - Pairing
   1531            - 0x39: Connection Rejected due to No Suitable Channel Found
   1532            - 0x3A: Controller Busy
   1533            - 0x3B: Unacceptable Connection Interval
   1534            - 0x3C: Directed Advertising Timeout
   1535            - 0x3D: Connection Terminated Due to MIC Failure
   1536            - 0x3E: Connection Failed to be Established
   1537            - 0x3F: MAC of the 802.11 AMP
   1538            - 0x41: Failed
   1539            - 0x42: Invalid parameters
   1540            - 0x43: Busy
   1541            - 0x44: Invalid length
   1542            - 0x45: Pending
   1543            - 0x46: Not allowed
   1544            - 0x47: GATT error
   1545            - 0x48: Address not resolved
   1546            - 0x49: Flash read failed
   1547            - 0x4A: Flash write failed
   1548            - 0x4B: Flash erase failed
   1549            - 0x50: Invalid CID
   1550            - 0x5A: CSRK not found
   1551            - 0x5B: IRK not found
   1552            - 0x5C: Device not found in DB
   1553            - 0x5D: Security DB full
   1554            - 0x5E: Device not bonded
   1555            - 0x5F: Device in blacklist
   1556            - 0x60: Invalid handle
   1557            - 0x61: Invalid parameter
   1558            - 0x62: Out of handles
   1559            - 0x63: Invalid operation
   1560            - 0x64: Insufficient resources
   1561            - 0x65: Insufficient encryption key size
   1562            - 0x66: Characteristic already exist
   1563            - 0x82: No valid slot
   1564            - 0x83: Short window
   1565            - 0x84: New interval failed
   1566            - 0x85: Too large interval
   1567            - 0x86: Slot length failed
   1568            * @retval None
   1569          */
   1570          

   \                                 In section .text, align 2, keep-with-next
   1571          tBleStatus aci_gatt_proc_complete_event_process(uint8_t *buffer_in)
   1572          {
   \                     aci_gatt_proc_complete_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1573            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
   1574            /* Input params */
   1575            aci_gatt_proc_complete_event_rp0 *rp0 = (aci_gatt_proc_complete_event_rp0 *)buffer_in;
   1576            aci_gatt_proc_complete_event(rp0->Connection_Handle,
   1577                                         rp0->Error_Code);
   \   00000006   0x78A1             LDRB     R1,[R4, #+2]
   \   00000008   0x8820             LDRH     R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       aci_gatt_proc_complete_event
   1578          
   1579            return status;
   \   0000000E   0x0028             MOVS     R0,R5
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1580          }
   1581          /* aci_gatt_error_resp_event */
   1582          /* Event len: 2 + 1 + 2 + 1 */
   1583          /**
   1584            * @brief This event is generated when an Error Response is received from the server. The error
   1585          response can be given by the server at the end of one of the GATT discovery procedures.
   1586          This does not mean that the procedure ended with an error, but this error event is part of the
   1587          procedure itself.
   1588            * @param Connection_Handle Connection handle related to the response
   1589            * @param Req_Opcode The request that generated this error response
   1590            * @param Attribute_Handle The attribute handle that generated this error response
   1591            * @param Error_Code The reason why the request has generated an error response (ATT error codes)
   1592            * Values:
   1593            - 0x01: Invalid handle
   1594            - 0x02: Read not permitted
   1595            - 0x03: Write not permitted
   1596            - 0x04: Invalid PDU
   1597            - 0x05: Insufficient authentication
   1598            - 0x06: Request not supported
   1599            - 0x07: Invalid offset
   1600            - 0x08: Insufficient authorization
   1601            - 0x09: Prepare queue full
   1602            - 0x0A: Attribute not found
   1603            - 0x0B: Attribute not long
   1604            - 0x0C: Insufficient encryption key size
   1605            - 0x0D: Invalid attribute value length
   1606            - 0x0E: Unlikely error
   1607            - 0x0F: Insufficient encryption
   1608            - 0x10: Unsupported group type
   1609            - 0x11: Insufficient resources
   1610            * @retval None
   1611          */
   1612          

   \                                 In section .text, align 2, keep-with-next
   1613          tBleStatus aci_gatt_error_resp_event_process(uint8_t *buffer_in)
   1614          {
   \                     aci_gatt_error_resp_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1615            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
   1616            /* Input params */
   1617            aci_gatt_error_resp_event_rp0 *rp0 = (aci_gatt_error_resp_event_rp0 *)buffer_in;
   1618            aci_gatt_error_resp_event(rp0->Connection_Handle,
   1619                                      rp0->Req_Opcode,
   1620                                      rp0->Attribute_Handle,
   1621                                      rp0->Error_Code);
   \   00000006   0x7963             LDRB     R3,[R4, #+5]
   \   00000008   0xF8B4 0x2003      LDRH     R2,[R4, #+3]
   \   0000000C   0x78A1             LDRB     R1,[R4, #+2]
   \   0000000E   0x8820             LDRH     R0,[R4, #+0]
   \   00000010   0x.... 0x....      BL       aci_gatt_error_resp_event
   1622          
   1623            return status;
   \   00000014   0x0028             MOVS     R0,R5
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1624          }
   1625          /* aci_gatt_disc_read_char_by_uuid_resp_event */
   1626          /* Event len: 2 + 2 + 1 + rp0->Attribute_Value_Length * (sizeof(uint8_t)) */
   1627          /**
   1628            * @brief This event can be generated during a "Discover Characteristics By UUID" procedure or a
   1629          "Read using Characteristic UUID" procedure.
   1630          The attribute value will be a service declaration as defined in Bluetooth Core v4.1spec
   1631          (vol.3, Part G, ch. 3.3.1), when a "Discover Characteristics By UUID" has been started. It will
   1632          be the value of the Characteristic if a* "Read using Characteristic UUID" has been
   1633          performed.
   1634            * @param Connection_Handle Connection handle related to the response
   1635            * @param Attribute_Handle The handle of the attribute
   1636            * @param Attribute_Value_Length Length of Attribute_Value in octets
   1637            * @param Attribute_Value The attribute value will be a service declaration as defined in Bluetooth Core v4.0 spec
   1638           (vol.3, Part G, ch. 3.3.1), when a "Discover Characteristics By UUID" has been started.
   1639           It will be the value of the Characteristic if a "Read using Characteristic UUID" has been performed.
   1640            * @retval None
   1641          */
   1642          

   \                                 In section .text, align 2, keep-with-next
   1643          tBleStatus aci_gatt_disc_read_char_by_uuid_resp_event_process(uint8_t *buffer_in)
   1644          {
   \                     aci_gatt_disc_read_char_by_uuid_resp_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1645            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
   1646            /* Input params */
   1647            aci_gatt_disc_read_char_by_uuid_resp_event_rp0 *rp0 = (aci_gatt_disc_read_char_by_uuid_resp_event_rp0 *)buffer_in;
   1648            aci_gatt_disc_read_char_by_uuid_resp_event(rp0->Connection_Handle,
   1649                                                       rp0->Attribute_Handle,
   1650                                                       rp0->Attribute_Value_Length,
   1651                                                       rp0->Attribute_Value);
   \   00000006   0x1D63             ADDS     R3,R4,#+5
   \   00000008   0x7922             LDRB     R2,[R4, #+4]
   \   0000000A   0x8861             LDRH     R1,[R4, #+2]
   \   0000000C   0x8820             LDRH     R0,[R4, #+0]
   \   0000000E   0x.... 0x....      BL       aci_gatt_disc_read_char_by_uuid_resp_event
   1652          
   1653            return status;
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1654          }
   1655          /* aci_gatt_write_permit_req_event */
   1656          /* Event len: 2 + 2 + 1 + rp0->Data_Length * (sizeof(uint8_t)) */
   1657          /**
   1658            * @brief This event is given to the application when a write request, write command or signed write
   1659          command is received by the server from the client. This event will be given to the application
   1660          only if the event bit for this event generation is set when the characteristic was added.
   1661          When this event is received, the application has to check whether the value being requested
   1662          for write can be allowed to be written and respond with the command @ref aci_gatt_write_resp.
   1663          The details of the parameters of the command can be found. Based on the response from
   1664          the application, the attribute value will be modified by the stack. If the write is rejected by the
   1665          application, then the value of the attribute will not be modified. In case of a write REQ, an
   1666          error response will be sent to the client, with the error code as specified by the application.
   1667          In case of write/signed write commands, no response is sent to the client but the attribute is
   1668          not modified.
   1669            * @param Connection_Handle Handle of the connection on which there was the request to write the attribute
   1670            * @param Attribute_Handle The handle of the attribute
   1671            * @param Data_Length Length of Data field
   1672            * @param Data The data that the client has requested to write
   1673            * @retval None
   1674          */
   1675          

   \                                 In section .text, align 2, keep-with-next
   1676          tBleStatus aci_gatt_write_permit_req_event_process(uint8_t *buffer_in)
   1677          {
   \                     aci_gatt_write_permit_req_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1678            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
   1679            /* Input params */
   1680            aci_gatt_write_permit_req_event_rp0 *rp0 = (aci_gatt_write_permit_req_event_rp0 *)buffer_in;
   1681            aci_gatt_write_permit_req_event(rp0->Connection_Handle,
   1682                                            rp0->Attribute_Handle,
   1683                                            rp0->Data_Length,
   1684                                            rp0->Data);
   \   00000006   0x1D63             ADDS     R3,R4,#+5
   \   00000008   0x7922             LDRB     R2,[R4, #+4]
   \   0000000A   0x8861             LDRH     R1,[R4, #+2]
   \   0000000C   0x8820             LDRH     R0,[R4, #+0]
   \   0000000E   0x.... 0x....      BL       aci_gatt_write_permit_req_event
   1685          
   1686            return status;
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1687          }
   1688          /* aci_gatt_read_permit_req_event */
   1689          /* Event len: 2 + 2 + 2 */
   1690          /**
   1691            * @brief This event is given to the application when a read request or read blob request is received
   1692          by the server from the client. This event will be given to the application only if the event bit
   1693          for this event generation is set when the characteristic was added.
   1694          On receiving this event, the application can update the value of the handle if it desires and
   1695          when done, it has to send the @ref aci_gatt_allow_read command to indicate to the stack that it
   1696          can send the response to the client.
   1697            * @param Connection_Handle Connection handle related to the response
   1698            * @param Attribute_Handle The handle of the attribute
   1699            * @param Offset Contains the offset from which the read has been requested
   1700            * @retval None
   1701          */
   1702          

   \                                 In section .text, align 2, keep-with-next
   1703          tBleStatus aci_gatt_read_permit_req_event_process(uint8_t *buffer_in)
   1704          {
   \                     aci_gatt_read_permit_req_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1705            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
   1706            /* Input params */
   1707            aci_gatt_read_permit_req_event_rp0 *rp0 = (aci_gatt_read_permit_req_event_rp0 *)buffer_in;
   1708            aci_gatt_read_permit_req_event(rp0->Connection_Handle,
   1709                                           rp0->Attribute_Handle,
   1710                                           rp0->Offset);
   \   00000006   0x88A2             LDRH     R2,[R4, #+4]
   \   00000008   0x8861             LDRH     R1,[R4, #+2]
   \   0000000A   0x8820             LDRH     R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       aci_gatt_read_permit_req_event
   1711          
   1712            return status;
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1713          }
   1714          /* aci_gatt_read_multi_permit_req_event */
   1715          /* Event len: 2 + 1 + rp0->Number_of_Handles * (sizeof(Handle_Item_t)) */
   1716          /**
   1717            * @brief This event is given to the application when a read multiple request or read by type request is
   1718          received by the server from the client. This event will be given to the application only if the
   1719          event bit for this event generation is set when the characteristic was added.
   1720          On receiving this event, the application can update the values of the handles if it desires and
   1721          when done, it has to send the @ref aci_gatt_allow_read command to indicate to the stack that it
   1722          can send the response to the client.
   1723            * @param Connection_Handle Handle of the connection which requested to read the attribute
   1724            * @param Number_of_Handles 
   1725            * @param Handle_Item See @ref Handle_Item_t
   1726            * @retval None
   1727          */
   1728          

   \                                 In section .text, align 2, keep-with-next
   1729          tBleStatus aci_gatt_read_multi_permit_req_event_process(uint8_t *buffer_in)
   1730          {
   \                     aci_gatt_read_multi_permit_req_event_process: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB0A0             SUB      SP,SP,#+128
   \   00000006   0x0004             MOVS     R4,R0
   1731            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000008   0x2500             MOVS     R5,#+0
   1732            /* Input params */
   1733            aci_gatt_read_multi_permit_req_event_rp0 *rp0 = (aci_gatt_read_multi_permit_req_event_rp0 *)buffer_in;
   \   0000000A   0x0026             MOVS     R6,R4
   1734            uint8_t size = 3;
   \   0000000C   0x2703             MOVS     R7,#+3
   1735            int i;
   1736            Handle_Item_t Handle_Item[HCI_MAX_PAYLOAD_SIZE/sizeof(Handle_Item_t)];
   1737            for (i = 0; i < rp0->Number_of_Handles; i++) {
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x4680             MOV      R8,R0
   \                     ??aci_gatt_read_multi_permit_req_event_process_0: (+1)
   \   00000012   0x78B0             LDRB     R0,[R6, #+2]
   \   00000014   0x4580             CMP      R8,R0
   \   00000016   0xDA0A             BGE.N    ??aci_gatt_read_multi_permit_req_event_process_1
   1738              Handle_Item[i].Handle = rp0->Handle_Item[i].Handle;
   \   00000018   0xEB06 0x0048      ADD      R0,R6,R8, LSL #+1
   \   0000001C   0xF8B0 0x0003      LDRH     R0,[R0, #+3]
   \   00000020   0x4669             MOV      R1,SP
   \   00000022   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   1739              size += 2;
   \   00000026   0x1CBF             ADDS     R7,R7,#+2
   1740            }
   \   00000028   0xF118 0x0801      ADDS     R8,R8,#+1
   \   0000002C   0xE7F1             B.N      ??aci_gatt_read_multi_permit_req_event_process_0
   1741            aci_gatt_read_multi_permit_req_event(rp0->Connection_Handle,
   1742                                                 rp0->Number_of_Handles,
   1743                                                 Handle_Item);
   \                     ??aci_gatt_read_multi_permit_req_event_process_1: (+1)
   \   0000002E   0x466A             MOV      R2,SP
   \   00000030   0x78B1             LDRB     R1,[R6, #+2]
   \   00000032   0x8830             LDRH     R0,[R6, #+0]
   \   00000034   0x.... 0x....      BL       aci_gatt_read_multi_permit_req_event
   1744          
   1745            return status;
   \   00000038   0x0028             MOVS     R0,R5
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0xB020             ADD      SP,SP,#+128
   \   0000003E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1746          }
   1747          /* aci_gatt_tx_pool_available_event */
   1748          /* Event len: 2 + 2 */
   1749          /**
   1750            * @brief Each time BLE FW stack raises the error code
   1751          BLE_STATUS_INSUFFICIENT_RESOURCES (0x64), the
   1752          @ref aci_gatt_tx_pool_available_event event is generated as soon as there are at least two
   1753          buffers available for notifications or write commands.
   1754            * @param Connection_Handle Connection handle related to the request
   1755            * @param Available_Buffers Number of buffers available
   1756            * @retval None
   1757          */
   1758          

   \                                 In section .text, align 2, keep-with-next
   1759          tBleStatus aci_gatt_tx_pool_available_event_process(uint8_t *buffer_in)
   1760          {
   \                     aci_gatt_tx_pool_available_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1761            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
   1762            /* Input params */
   1763            aci_gatt_tx_pool_available_event_rp0 *rp0 = (aci_gatt_tx_pool_available_event_rp0 *)buffer_in;
   1764            aci_gatt_tx_pool_available_event(rp0->Connection_Handle,
   1765                                             rp0->Available_Buffers);
   \   00000006   0x8861             LDRH     R1,[R4, #+2]
   \   00000008   0x8820             LDRH     R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       aci_gatt_tx_pool_available_event
   1766          
   1767            return status;
   \   0000000E   0x0028             MOVS     R0,R5
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1768          }
   1769          /* aci_gatt_server_confirmation_event */
   1770          /* Event len: 2 */
   1771          /**
   1772            * @brief This event is generated when the client has sent the confirmation to a previously sent indication
   1773            * @param Connection_Handle Connection handle related to the event
   1774            * @retval None
   1775          */
   1776          

   \                                 In section .text, align 2, keep-with-next
   1777          tBleStatus aci_gatt_server_confirmation_event_process(uint8_t *buffer_in)
   1778          {
   \                     aci_gatt_server_confirmation_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1779            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
   1780            /* Input params */
   1781            aci_gatt_server_confirmation_event_rp0 *rp0 = (aci_gatt_server_confirmation_event_rp0 *)buffer_in;
   1782            aci_gatt_server_confirmation_event(rp0->Connection_Handle);
   \   00000006   0x8820             LDRH     R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       aci_gatt_server_confirmation_event
   1783          
   1784            return status;
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1785          }
   1786          /* aci_gatt_prepare_write_permit_req_event */
   1787          /* Event len: 2 + 2 + 2 + 1 + rp0->Data_Length * (sizeof(uint8_t)) */
   1788          /**
   1789            * @brief This event is given to the application when a prepare write request
   1790          is received by the server from the client. This event will be given to the application
   1791          only if the event bit for this event generation is set when the characteristic was added.
   1792          When this event is received, the application has to check whether the value being requested
   1793          for write can be allowed to be written and respond with the command @ref aci_gatt_write_resp.
   1794          Based on the response from the application, the attribute value will be modified by the stack.
   1795          If the write is rejected by the application, then the value of the attribute will not be modified
   1796          and an error response will be sent to the client, with the error code as specified by the application.
   1797            * @param Connection_Handle Handle of the connection on which there was the request to write the attribute
   1798            * @param Attribute_Handle The handle of the attribute
   1799            * @param Offset The offset from which the prepare write has been requested
   1800            * @param Data_Length Length of Data field
   1801            * @param Data The data that the client has requested to write
   1802            * @retval None
   1803          */
   1804          

   \                                 In section .text, align 2, keep-with-next
   1805          tBleStatus aci_gatt_prepare_write_permit_req_event_process(uint8_t *buffer_in)
   1806          {
   \                     aci_gatt_prepare_write_permit_req_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1807            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
   1808            /* Input params */
   1809            aci_gatt_prepare_write_permit_req_event_rp0 *rp0 = (aci_gatt_prepare_write_permit_req_event_rp0 *)buffer_in;
   1810            aci_gatt_prepare_write_permit_req_event(rp0->Connection_Handle,
   1811                                                    rp0->Attribute_Handle,
   1812                                                    rp0->Offset,
   1813                                                    rp0->Data_Length,
   1814                                                    rp0->Data);
   \   00000006   0x1DE0             ADDS     R0,R4,#+7
   \   00000008   0x9000             STR      R0,[SP, #+0]
   \   0000000A   0x79A3             LDRB     R3,[R4, #+6]
   \   0000000C   0x88A2             LDRH     R2,[R4, #+4]
   \   0000000E   0x8861             LDRH     R1,[R4, #+2]
   \   00000010   0x8820             LDRH     R0,[R4, #+0]
   \   00000012   0x.... 0x....      BL       aci_gatt_prepare_write_permit_req_event
   1815          
   1816            return status;
   \   00000016   0x0028             MOVS     R0,R5
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1817          }
   1818          /* hci_le_connection_complete_event */
   1819          /* Event len: 1 + 2 + 1 + 1 + 6 + 2 + 2 + 2 + 1 */
   1820          /**
   1821            * @brief The LE Connection Complete event indicates to both of the Hosts forming the
   1822          connection that a new connection has been created. Upon the creation of the
   1823          connection a Connection_Handle shall be assigned by the Controller, and
   1824          passed to the Host in this event. If the connection establishment fails this event
   1825          shall be provided to the Host that had issued the LE_Create_Connection command.
   1826          This event indicates to the Host which issued a LE_Create_Connection
   1827          command and received a Command Status event if the connection
   1828          establishment failed or was successful.
   1829          The Master_Clock_Accuracy parameter is only valid for a slave. On a master,
   1830          this parameter shall be set to 0x00.
   1831            * @param Status Error code. See Core v4.1, Vol. 2, part D.
   1832            * @param Connection_Handle Connection handle to be used to identify the connection with the peer device.
   1833            * Values:
   1834            - 0x0000 ... 0x0EFF
   1835            * @param Role Role of the local device in the connection.
   1836            * Values:
   1837            - 0x00: Master
   1838            - 0x01: Slave
   1839            * @param Peer_Address_Type The address type of the peer device.
   1840            * Values:
   1841            - 0x00: Public Device Address
   1842            - 0x01: Random Device Address
   1843            * @param Peer_Address Public Device Address or Random Device Address of the peer
   1844          device
   1845            * @param Conn_Interval Connection interval used on this connection.
   1846          Time = N * 1.25 msec
   1847            * Values:
   1848            - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
   1849            * @param Conn_Latency Slave latency for the connection in number of connection events.
   1850            * Values:
   1851            - 0x0000 ... 0x01F3
   1852            * @param Supervision_Timeout Supervision timeout for the LE Link.
   1853          It shall be a multiple of 10 ms and larger than (1 + connSlaveLatency) * connInterval * 2.
   1854          Time = N * 10 msec.
   1855            * Values:
   1856            - 0x000A (100 ms)  ... 0x0C80 (32000 ms) 
   1857            * @param Master_Clock_Accuracy Master clock accuracy. Only valid for a slave.
   1858            * Values:
   1859            - 0x00: 500 ppm
   1860            - 0x01: 250 ppm
   1861            - 0x02: 150 ppm
   1862            - 0x03: 100 ppm
   1863            - 0x04: 75 ppm
   1864            - 0x05: 50 ppm
   1865            - 0x06: 30 ppm
   1866            - 0x07: 20 ppm
   1867            * @retval None
   1868          */
   1869          

   \                                 In section .text, align 2, keep-with-next
   1870          tBleStatus hci_le_connection_complete_event_process(uint8_t *buffer_in)
   1871          {
   \                     hci_le_connection_complete_event_process: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
   1872            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000006   0x2500             MOVS     R5,#+0
   1873            /* Input params */
   1874            hci_le_connection_complete_event_rp0 *rp0 = (hci_le_connection_complete_event_rp0 *)buffer_in;
   1875            hci_le_connection_complete_event(rp0->Status,
   1876                                             rp0->Connection_Handle,
   1877                                             rp0->Role,
   1878                                             rp0->Peer_Address_Type,
   1879                                             rp0->Peer_Address,
   1880                                             rp0->Conn_Interval,
   1881                                             rp0->Conn_Latency,
   1882                                             rp0->Supervision_Timeout,
   1883                                             rp0->Master_Clock_Accuracy);
   \   00000008   0x7C60             LDRB     R0,[R4, #+17]
   \   0000000A   0x9004             STR      R0,[SP, #+16]
   \   0000000C   0xF8B4 0x000F      LDRH     R0,[R4, #+15]
   \   00000010   0x9003             STR      R0,[SP, #+12]
   \   00000012   0xF8B4 0x000D      LDRH     R0,[R4, #+13]
   \   00000016   0x9002             STR      R0,[SP, #+8]
   \   00000018   0xF8B4 0x000B      LDRH     R0,[R4, #+11]
   \   0000001C   0x9001             STR      R0,[SP, #+4]
   \   0000001E   0x1D60             ADDS     R0,R4,#+5
   \   00000020   0x9000             STR      R0,[SP, #+0]
   \   00000022   0x7923             LDRB     R3,[R4, #+4]
   \   00000024   0x78E2             LDRB     R2,[R4, #+3]
   \   00000026   0xF8B4 0x1001      LDRH     R1,[R4, #+1]
   \   0000002A   0x7820             LDRB     R0,[R4, #+0]
   \   0000002C   0x.... 0x....      BL       hci_le_connection_complete_event
   1884          
   1885            return status;
   \   00000030   0x0028             MOVS     R0,R5
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0xB005             ADD      SP,SP,#+20
   \   00000036   0xBD30             POP      {R4,R5,PC}       ;; return
   1886          }
   1887          /* hci_le_advertising_report_event */
   1888          /* Event len: 1 + rp0->Num_Reports * (sizeof(Advertising_Report_t)) */
   1889          /**
   1890            * @brief The LE Advertising Report event indicates that a Bluetooth device or multiple
   1891          Bluetooth devices have responded to an active scan or received some information
   1892          during a passive scan. The Controller may queue these advertising reports
   1893          and send information from multiple devices in one LE Advertising Report event.
   1894            * @param Num_Reports Number of responses in this event.
   1895            * Values:
   1896            - 0x01
   1897            * @param Advertising_Report See @ref Advertising_Report_t
   1898            * @retval None
   1899          */
   1900          

   \                                 In section .text, align 2, keep-with-next
   1901          tBleStatus hci_le_advertising_report_event_process(uint8_t *buffer_in)
   1902          {
   \                     hci_le_advertising_report_event_process: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB09E             SUB      SP,SP,#+120
   \   00000006   0x0004             MOVS     R4,R0
   1903            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000008   0x2500             MOVS     R5,#+0
   1904            /* Input params */
   1905            hci_le_advertising_report_event_rp0 *rp0 = (hci_le_advertising_report_event_rp0 *)buffer_in;
   \   0000000A   0x0026             MOVS     R6,R4
   1906            uint8_t size = 1;
   \   0000000C   0x2701             MOVS     R7,#+1
   1907            int i;
   1908            Advertising_Report_t Advertising_Report[HCI_MAX_PAYLOAD_SIZE/sizeof(Advertising_Report_t)];
   1909            for (i = 0; i < rp0->Num_Reports; i++) {
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x4680             MOV      R8,R0
   \                     ??hci_le_advertising_report_event_process_0: (+1)
   \   00000012   0x7830             LDRB     R0,[R6, #+0]
   \   00000014   0x4580             CMP      R8,R0
   \   00000016   0xDA4E             BGE.N    ??hci_le_advertising_report_event_process_1
   1910              Advertising_Report[i].Event_Type = rp0->Advertising_Report[i].Event_Type;
   \   00000018   0x200B             MOVS     R0,#+11
   \   0000001A   0xFB00 0xF008      MUL      R0,R0,R8
   \   0000001E   0x4430             ADD      R0,R6,R0
   \   00000020   0x7840             LDRB     R0,[R0, #+1]
   \   00000022   0x4669             MOV      R1,SP
   \   00000024   0x2214             MOVS     R2,#+20
   \   00000026   0xFB02 0xF208      MUL      R2,R2,R8
   \   0000002A   0x5488             STRB     R0,[R1, R2]
   1911              size += 1;
   \   0000002C   0x1C7F             ADDS     R7,R7,#+1
   1912              Advertising_Report[i].Address_Type = rp0->Advertising_Report[i].Address_Type;
   \   0000002E   0x200B             MOVS     R0,#+11
   \   00000030   0xFB00 0xF008      MUL      R0,R0,R8
   \   00000034   0x4430             ADD      R0,R6,R0
   \   00000036   0x7880             LDRB     R0,[R0, #+2]
   \   00000038   0x4669             MOV      R1,SP
   \   0000003A   0x2214             MOVS     R2,#+20
   \   0000003C   0xFB02 0xF208      MUL      R2,R2,R8
   \   00000040   0x4411             ADD      R1,R1,R2
   \   00000042   0x7048             STRB     R0,[R1, #+1]
   1913              size += 1;
   \   00000044   0x1C7F             ADDS     R7,R7,#+1
   1914              Osal_MemCpy((void *) Advertising_Report[i].Address, (const void *) rp0->Advertising_Report[i].Address, 6);
   \   00000046   0x2206             MOVS     R2,#+6
   \   00000048   0x200B             MOVS     R0,#+11
   \   0000004A   0xFB00 0xF008      MUL      R0,R0,R8
   \   0000004E   0x4430             ADD      R0,R6,R0
   \   00000050   0x1CC1             ADDS     R1,R0,#+3
   \   00000052   0x4668             MOV      R0,SP
   \   00000054   0x2314             MOVS     R3,#+20
   \   00000056   0xFB03 0xF308      MUL      R3,R3,R8
   \   0000005A   0x4418             ADD      R0,R0,R3
   \   0000005C   0x1C80             ADDS     R0,R0,#+2
   \   0000005E   0x.... 0x....      BL       Osal_MemCpy
   1915              size += 6;
   \   00000062   0x1DBF             ADDS     R7,R7,#+6
   1916              Advertising_Report[i].Length_Data = rp0->Advertising_Report[i].Length_Data;
   \   00000064   0x200B             MOVS     R0,#+11
   \   00000066   0xFB00 0xF008      MUL      R0,R0,R8
   \   0000006A   0x4430             ADD      R0,R6,R0
   \   0000006C   0x7A40             LDRB     R0,[R0, #+9]
   \   0000006E   0x4669             MOV      R1,SP
   \   00000070   0x2214             MOVS     R2,#+20
   \   00000072   0xFB02 0xF208      MUL      R2,R2,R8
   \   00000076   0x4411             ADD      R1,R1,R2
   \   00000078   0x7208             STRB     R0,[R1, #+8]
   1917              size += 1;
   \   0000007A   0x1C7F             ADDS     R7,R7,#+1
   1918              Advertising_Report[i].Data = rp0->Advertising_Report[i].Data;
   \   0000007C   0x200B             MOVS     R0,#+11
   \   0000007E   0xFB00 0xF008      MUL      R0,R0,R8
   \   00000082   0x4430             ADD      R0,R6,R0
   \   00000084   0x300A             ADDS     R0,R0,#+10
   \   00000086   0x4669             MOV      R1,SP
   \   00000088   0x2214             MOVS     R2,#+20
   \   0000008A   0xFB02 0xF208      MUL      R2,R2,R8
   \   0000008E   0x4411             ADD      R1,R1,R2
   \   00000090   0x60C8             STR      R0,[R1, #+12]
   1919              size += rp0->Advertising_Report[i].Length_Data;
   \   00000092   0x200B             MOVS     R0,#+11
   \   00000094   0xFB00 0xF008      MUL      R0,R0,R8
   \   00000098   0x4430             ADD      R0,R6,R0
   \   0000009A   0x7A40             LDRB     R0,[R0, #+9]
   \   0000009C   0x19C7             ADDS     R7,R0,R7
   1920              Advertising_Report[i].RSSI = (uint8_t)buffer_in[size];
   \   0000009E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000A0   0x5DE0             LDRB     R0,[R4, R7]
   \   000000A2   0x4669             MOV      R1,SP
   \   000000A4   0x2214             MOVS     R2,#+20
   \   000000A6   0xFB02 0xF208      MUL      R2,R2,R8
   \   000000AA   0x4411             ADD      R1,R1,R2
   \   000000AC   0x7408             STRB     R0,[R1, #+16]
   1921              size += 1;
   \   000000AE   0x1C7F             ADDS     R7,R7,#+1
   1922            }
   \   000000B0   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000000B4   0xE7AD             B.N      ??hci_le_advertising_report_event_process_0
   1923            hci_le_advertising_report_event(rp0->Num_Reports,
   1924                                            Advertising_Report);
   \                     ??hci_le_advertising_report_event_process_1: (+1)
   \   000000B6   0x4669             MOV      R1,SP
   \   000000B8   0x7830             LDRB     R0,[R6, #+0]
   \   000000BA   0x.... 0x....      BL       hci_le_advertising_report_event
   1925          
   1926            return status;
   \   000000BE   0x0028             MOVS     R0,R5
   \   000000C0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C2   0xB01E             ADD      SP,SP,#+120
   \   000000C4   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1927          }
   1928          /* hci_le_connection_update_complete_event */
   1929          /* Event len: 1 + 2 + 2 + 2 + 2 */
   1930          /**
   1931            * @brief The LE Connection Update Complete event is used to indicate that the Controller
   1932          process to update the connection has completed.
   1933          On a slave, if no connection parameters are updated, then this event shall not be issued.
   1934          On a master, this event shall be issued if the Connection_Update command was sent.
   1935            * @param Status Error code. See Core v4.1, Vol. 2, part D.
   1936            * @param Connection_Handle Connection handle to be used to identify the connection with the peer device.
   1937            * Values:
   1938            - 0x0000 ... 0x0EFF
   1939            * @param Conn_Interval Connection interval used on this connection.
   1940          Time = N * 1.25 msec
   1941            * Values:
   1942            - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
   1943            * @param Conn_Latency Slave latency for the connection in number of connection events.
   1944            * Values:
   1945            - 0x0000 ... 0x01F3
   1946            * @param Supervision_Timeout Supervision timeout for the LE Link.
   1947          It shall be a multiple of 10 ms and larger than (1 + connSlaveLatency) * connInterval * 2.
   1948          Time = N * 10 msec.
   1949            * Values:
   1950            - 0x000A (100 ms)  ... 0x0C80 (32000 ms) 
   1951            * @retval None
   1952          */
   1953          

   \                                 In section .text, align 2, keep-with-next
   1954          tBleStatus hci_le_connection_update_complete_event_process(uint8_t *buffer_in)
   1955          {
   \                     hci_le_connection_update_complete_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1956            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
   1957            /* Input params */
   1958            hci_le_connection_update_complete_event_rp0 *rp0 = (hci_le_connection_update_complete_event_rp0 *)buffer_in;
   1959            hci_le_connection_update_complete_event(rp0->Status,
   1960                                                    rp0->Connection_Handle,
   1961                                                    rp0->Conn_Interval,
   1962                                                    rp0->Conn_Latency,
   1963                                                    rp0->Supervision_Timeout);
   \   00000006   0xF8B4 0x0007      LDRH     R0,[R4, #+7]
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   \   0000000C   0xF8B4 0x3005      LDRH     R3,[R4, #+5]
   \   00000010   0xF8B4 0x2003      LDRH     R2,[R4, #+3]
   \   00000014   0xF8B4 0x1001      LDRH     R1,[R4, #+1]
   \   00000018   0x7820             LDRB     R0,[R4, #+0]
   \   0000001A   0x.... 0x....      BL       hci_le_connection_update_complete_event
   1964          
   1965            return status;
   \   0000001E   0x0028             MOVS     R0,R5
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1966          }
   1967          /* hci_le_read_remote_used_features_complete_event */
   1968          /* Event len: 1 + 2 + 8 */
   1969          /**
   1970            * @brief The LE Read Remote Used Features Complete event is used to indicate the
   1971          completion of the process of the Controller obtaining the used features of the
   1972          remote Bluetooth device specified by the Connection_Handle event parameter.
   1973            * @param Status Error code. See Core v4.1, Vol. 2, part D.
   1974            * @param Connection_Handle Connection handle to be used to identify the connection with the peer device.
   1975            * Values:
   1976            - 0x0000 ... 0x0EFF
   1977            * @param LE_Features Bit Mask List of used LE features. For details see LE Link Layer specification.
   1978            * @retval None
   1979          */
   1980          

   \                                 In section .text, align 2, keep-with-next
   1981          tBleStatus hci_le_read_remote_used_features_complete_event_process(uint8_t *buffer_in)
   1982          {
   \                     hci_le_read_remote_used_features_complete_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1983            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
   1984            /* Input params */
   1985            hci_le_read_remote_used_features_complete_event_rp0 *rp0 = (hci_le_read_remote_used_features_complete_event_rp0 *)buffer_in;
   1986            hci_le_read_remote_used_features_complete_event(rp0->Status,
   1987                                                            rp0->Connection_Handle,
   1988                                                            rp0->LE_Features);
   \   00000006   0x1CE2             ADDS     R2,R4,#+3
   \   00000008   0xF8B4 0x1001      LDRH     R1,[R4, #+1]
   \   0000000C   0x7820             LDRB     R0,[R4, #+0]
   \   0000000E   0x.... 0x....      BL       hci_le_read_remote_used_features_complete_event
   1989          
   1990            return status;
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1991          }
   1992          /* hci_le_long_term_key_request_event */
   1993          /* Event len: 2 + 8 + 2 */
   1994          /**
   1995            * @brief The LE Long Term Key Request event indicates that the master device is
   1996          attempting to encrypt or re-encrypt the link and is requesting the Long Term
   1997          Key from the Host. (See [Vol 6] Part B, Section 5.1.3).
   1998            * @param Connection_Handle Connection handle to be used to identify the connection with the peer device.
   1999            * Values:
   2000            - 0x0000 ... 0x0EFF
   2001            * @param Random_Number 64-bit random number
   2002            * @param Encrypted_Diversifier 16-bit encrypted diversifier
   2003            * @retval None
   2004          */
   2005          

   \                                 In section .text, align 2, keep-with-next
   2006          tBleStatus hci_le_long_term_key_request_event_process(uint8_t *buffer_in)
   2007          {
   \                     hci_le_long_term_key_request_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2008            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
   2009            /* Input params */
   2010            hci_le_long_term_key_request_event_rp0 *rp0 = (hci_le_long_term_key_request_event_rp0 *)buffer_in;
   2011            hci_le_long_term_key_request_event(rp0->Connection_Handle,
   2012                                               rp0->Random_Number,
   2013                                               rp0->Encrypted_Diversifier);
   \   00000006   0x8962             LDRH     R2,[R4, #+10]
   \   00000008   0x1CA1             ADDS     R1,R4,#+2
   \   0000000A   0x8820             LDRH     R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       hci_le_long_term_key_request_event
   2014          
   2015            return status;
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2016          }
   2017          /* hci_le_read_local_p256_public_key_complete_event */
   2018          /* Event len: 1 + 64 */
   2019          /**
   2020            * @brief This event is generated when local P-256 key generation is complete.
   2021            * @param Status Error code. See Core v4.1, Vol. 2, part D.
   2022            * @param Local_P256_Public_Key Local P-256 public key.
   2023            * @retval None
   2024          */
   2025          

   \                                 In section .text, align 2, keep-with-next
   2026          tBleStatus hci_le_read_local_p256_public_key_complete_event_process(uint8_t *buffer_in)
   2027          {
   \                     hci_le_read_local_p256_public_key_complete_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2028            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
   2029            /* Input params */
   2030            hci_le_read_local_p256_public_key_complete_event_rp0 *rp0 = (hci_le_read_local_p256_public_key_complete_event_rp0 *)buffer_in;
   2031            hci_le_read_local_p256_public_key_complete_event(rp0->Status,
   2032                                                             rp0->Local_P256_Public_Key);
   \   00000006   0x1C61             ADDS     R1,R4,#+1
   \   00000008   0x7820             LDRB     R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       hci_le_read_local_p256_public_key_complete_event
   2033          
   2034            return status;
   \   0000000E   0x0028             MOVS     R0,R5
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2035          }
   2036          /* hci_le_generate_dhkey_complete_event */
   2037          /* Event len: 1 + 32 */
   2038          /**
   2039            * @brief This event indicates that LE Diffie Hellman key generation has been completed
   2040          by the Controller.
   2041            * @param Status Error code. See Core v4.1, Vol. 2, part D.
   2042            * @param DHKey Diffie Hellman Key
   2043            * @retval None
   2044          */
   2045          

   \                                 In section .text, align 2, keep-with-next
   2046          tBleStatus hci_le_generate_dhkey_complete_event_process(uint8_t *buffer_in)
   2047          {
   \                     hci_le_generate_dhkey_complete_event_process: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2048            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000004   0x2500             MOVS     R5,#+0
   2049            /* Input params */
   2050            hci_le_generate_dhkey_complete_event_rp0 *rp0 = (hci_le_generate_dhkey_complete_event_rp0 *)buffer_in;
   2051            hci_le_generate_dhkey_complete_event(rp0->Status,
   2052                                                 rp0->DHKey);
   \   00000006   0x1C61             ADDS     R1,R4,#+1
   \   00000008   0x7820             LDRB     R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       hci_le_generate_dhkey_complete_event
   2053          
   2054            return status;
   \   0000000E   0x0028             MOVS     R0,R5
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2055          }
   2056          /* hci_le_enhanced_connection_complete_event */
   2057          /* Event len: 1 + 2 + 1 + 1 + 6 + 6 + 6 + 2 + 2 + 2 + 1 */
   2058          /**
   2059            * @brief The LE Enhanced Connection Complete event indicates to both of the Hosts
   2060          forming the connection that a new connection has been created. Upon the
   2061          creation of the connection a Connection_Handle shall be assigned by the
   2062          Controller, and passed to the Host in this event. If the connection establishment
   2063          fails, this event shall be provided to the Host that had issued the
   2064          LE_Create_Connection command.
   2065          If this event is unmasked and LE Connection Complete event is unmasked,
   2066          only the LE Enhanced Connection Complete event is sent when a new
   2067          connection has been completed.
   2068          This event indicates to the Host that issued a LE_Create_Connection
   2069          command and received a Command Status event if the connection
   2070          establishment failed or was successful.
   2071          The Master_Clock_Accuracy parameter is only valid for a slave. On a master,
   2072          this parameter shall be set to 0x00.
   2073            * @param Status Error code. See Core v4.1, Vol. 2, part D.
   2074            * @param Connection_Handle Connection handle to be used to identify the connection with the peer device.
   2075            * Values:
   2076            - 0x0000 ... 0x0EFF
   2077            * @param Role Role of the local device in the connection.
   2078            * Values:
   2079            - 0x00: Master
   2080            - 0x01: Slave
   2081            * @param Peer_Address_Type 0x00 Public Device Address
   2082          0x01 Random Device Address
   2083          0x02 Public Identity Address (Corresponds to Resolved Private Address)
   2084          0x03 Random (Static) Identity Address (Corresponds to Resolved Private Address)
   2085            * Values:
   2086            - 0x00: Public Device Address
   2087            - 0x01: Random Device Address
   2088            - 0x02: Public Identity Address
   2089            - 0x03: Random (Static) Identity Address
   2090            * @param Peer_Address Public Device Address, Random Device Address, Public Identity
   2091          Address or Random (static) Identity Address of the device to be connected.
   2092            * @param Local_Resolvable_Private_Address Resolvable Private Address being used by the local device for this connection.
   2093          This is only valid when the Own_Address_Type is set to 0x02 or 0x03. For other Own_Address_Type values,
   2094          the Controller shall return all zeros.
   2095            * @param Peer_Resolvable_Private_Address Resolvable Private Address being used by the peer device for this connection.
   2096          This is only valid for Peer_Address_Type 0x02 and 0x03. For
   2097          other Peer_Address_Type values, the Controller shall return all zeros.
   2098            * @param Conn_Interval Connection interval used on this connection.
   2099          Time = N * 1.25 msec
   2100            * Values:
   2101            - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
   2102            * @param Conn_Latency Slave latency for the connection in number of connection events.
   2103            * Values:
   2104            - 0x0000 ... 0x01F3
   2105            * @param Supervision_Timeout Supervision timeout for the LE Link.
   2106          It shall be a multiple of 10 ms and larger than (1 + connSlaveLatency) * connInterval * 2.
   2107          Time = N * 10 msec.
   2108            * Values:
   2109            - 0x000A (100 ms)  ... 0x0C80 (32000 ms) 
   2110            * @param Master_Clock_Accuracy Master clock accuracy. Only valid for a slave.
   2111            * Values:
   2112            - 0x00: 500 ppm
   2113            - 0x01: 250 ppm
   2114            - 0x02: 150 ppm
   2115            - 0x03: 100 ppm
   2116            - 0x04: 75 ppm
   2117            - 0x05: 50 ppm
   2118            - 0x06: 30 ppm
   2119            - 0x07: 20 ppm
   2120            * @retval None
   2121          */
   2122          

   \                                 In section .text, align 2, keep-with-next
   2123          tBleStatus hci_le_enhanced_connection_complete_event_process(uint8_t *buffer_in)
   2124          {
   \                     hci_le_enhanced_connection_complete_event_process: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x0004             MOVS     R4,R0
   2125            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000006   0x2500             MOVS     R5,#+0
   2126            /* Input params */
   2127            hci_le_enhanced_connection_complete_event_rp0 *rp0 = (hci_le_enhanced_connection_complete_event_rp0 *)buffer_in;
   2128            hci_le_enhanced_connection_complete_event(rp0->Status,
   2129                                                      rp0->Connection_Handle,
   2130                                                      rp0->Role,
   2131                                                      rp0->Peer_Address_Type,
   2132                                                      rp0->Peer_Address,
   2133                                                      rp0->Local_Resolvable_Private_Address,
   2134                                                      rp0->Peer_Resolvable_Private_Address,
   2135                                                      rp0->Conn_Interval,
   2136                                                      rp0->Conn_Latency,
   2137                                                      rp0->Supervision_Timeout,
   2138                                                      rp0->Master_Clock_Accuracy);
   \   00000008   0x7F60             LDRB     R0,[R4, #+29]
   \   0000000A   0x9006             STR      R0,[SP, #+24]
   \   0000000C   0xF8B4 0x001B      LDRH     R0,[R4, #+27]
   \   00000010   0x9005             STR      R0,[SP, #+20]
   \   00000012   0xF8B4 0x0019      LDRH     R0,[R4, #+25]
   \   00000016   0x9004             STR      R0,[SP, #+16]
   \   00000018   0xF8B4 0x0017      LDRH     R0,[R4, #+23]
   \   0000001C   0x9003             STR      R0,[SP, #+12]
   \   0000001E   0xF114 0x0011      ADDS     R0,R4,#+17
   \   00000022   0x9002             STR      R0,[SP, #+8]
   \   00000024   0xF114 0x000B      ADDS     R0,R4,#+11
   \   00000028   0x9001             STR      R0,[SP, #+4]
   \   0000002A   0x1D60             ADDS     R0,R4,#+5
   \   0000002C   0x9000             STR      R0,[SP, #+0]
   \   0000002E   0x7923             LDRB     R3,[R4, #+4]
   \   00000030   0x78E2             LDRB     R2,[R4, #+3]
   \   00000032   0xF8B4 0x1001      LDRH     R1,[R4, #+1]
   \   00000036   0x7820             LDRB     R0,[R4, #+0]
   \   00000038   0x.... 0x....      BL       hci_le_enhanced_connection_complete_event
   2139          
   2140            return status;
   \   0000003C   0x0028             MOVS     R0,R5
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0xB007             ADD      SP,SP,#+28
   \   00000042   0xBD30             POP      {R4,R5,PC}       ;; return
   2141          }
   2142          /* hci_le_direct_advertising_report_event */
   2143          /* Event len: 1 + rp0->Num_Reports * (sizeof(Direct_Advertising_Report_t)) */
   2144          /**
   2145            * @brief The LE Direct Advertising Report event indicates that directed advertisements
   2146          have been received where the advertiser is using a resolvable private address
   2147          for the InitA field in the ADV_DIRECT_IND PDU and the
   2148          Scanning_Filter_Policy is equal to 0x02 or 0x03, see HCI_LE_Set_Scan_Parameters.
   2149          Direct_Address_Type and Direct_Addres is the address the directed
   2150          advertisements are being directed to. Address_Type and Address is the
   2151          address of the advertiser sending the directed advertisements.
   2152            * @param Num_Reports Number of responses in this event.
   2153            * Values:
   2154            - 0x01
   2155            * @param Direct_Advertising_Report See @ref Direct_Advertising_Report_t
   2156            * @retval None
   2157          */
   2158          

   \                                 In section .text, align 2, keep-with-next
   2159          tBleStatus hci_le_direct_advertising_report_event_process(uint8_t *buffer_in)
   2160          {
   \                     hci_le_direct_advertising_report_event_process: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB0A0             SUB      SP,SP,#+128
   \   00000006   0x0004             MOVS     R4,R0
   2161            tBleStatus status = BLE_STATUS_SUCCESS;
   \   00000008   0x2500             MOVS     R5,#+0
   2162            /* Input params */
   2163            hci_le_direct_advertising_report_event_rp0 *rp0 = (hci_le_direct_advertising_report_event_rp0 *)buffer_in;
   \   0000000A   0x0026             MOVS     R6,R4
   2164            uint8_t size = 1;
   \   0000000C   0x2701             MOVS     R7,#+1
   2165            int i;
   2166            Direct_Advertising_Report_t Direct_Advertising_Report[HCI_MAX_PAYLOAD_SIZE/sizeof(Direct_Advertising_Report_t)];
   2167            for (i = 0; i < rp0->Num_Reports; i++) {
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x4680             MOV      R8,R0
   \                     ??hci_le_direct_advertising_report_event_proces_0: (+1)
   \   00000012   0x7830             LDRB     R0,[R6, #+0]
   \   00000014   0x4580             CMP      R8,R0
   \   00000016   0xDA44             BGE.N    ??hci_le_direct_advertising_report_event_proces_1
   2168              Direct_Advertising_Report[i].Event_Type = rp0->Direct_Advertising_Report[i].Event_Type;
   \   00000018   0xEA5F 0x1008      LSLS     R0,R8,#+4
   \   0000001C   0x4430             ADD      R0,R6,R0
   \   0000001E   0x7840             LDRB     R0,[R0, #+1]
   \   00000020   0x4669             MOV      R1,SP
   \   00000022   0xEA5F 0x1208      LSLS     R2,R8,#+4
   \   00000026   0x5488             STRB     R0,[R1, R2]
   2169              size += 1;
   \   00000028   0x1C7F             ADDS     R7,R7,#+1
   2170              Direct_Advertising_Report[i].Address_Type = rp0->Direct_Advertising_Report[i].Address_Type;
   \   0000002A   0xEA5F 0x1008      LSLS     R0,R8,#+4
   \   0000002E   0x4430             ADD      R0,R6,R0
   \   00000030   0x7880             LDRB     R0,[R0, #+2]
   \   00000032   0x4669             MOV      R1,SP
   \   00000034   0xEA5F 0x1208      LSLS     R2,R8,#+4
   \   00000038   0x4411             ADD      R1,R1,R2
   \   0000003A   0x7048             STRB     R0,[R1, #+1]
   2171              size += 1;
   \   0000003C   0x1C7F             ADDS     R7,R7,#+1
   2172              Osal_MemCpy((void *) Direct_Advertising_Report[i].Address, (const void *) rp0->Direct_Advertising_Report[i].Address, 6);
   \   0000003E   0x2206             MOVS     R2,#+6
   \   00000040   0xEA5F 0x1008      LSLS     R0,R8,#+4
   \   00000044   0x4430             ADD      R0,R6,R0
   \   00000046   0x1CC1             ADDS     R1,R0,#+3
   \   00000048   0x4668             MOV      R0,SP
   \   0000004A   0xEA5F 0x1308      LSLS     R3,R8,#+4
   \   0000004E   0x4418             ADD      R0,R0,R3
   \   00000050   0x1C80             ADDS     R0,R0,#+2
   \   00000052   0x.... 0x....      BL       Osal_MemCpy
   2173              size += 6;
   \   00000056   0x1DBF             ADDS     R7,R7,#+6
   2174              Direct_Advertising_Report[i].Direct_Address_Type = rp0->Direct_Advertising_Report[i].Direct_Address_Type;
   \   00000058   0xEA5F 0x1008      LSLS     R0,R8,#+4
   \   0000005C   0x4430             ADD      R0,R6,R0
   \   0000005E   0x7A40             LDRB     R0,[R0, #+9]
   \   00000060   0x4669             MOV      R1,SP
   \   00000062   0xEA5F 0x1208      LSLS     R2,R8,#+4
   \   00000066   0x4411             ADD      R1,R1,R2
   \   00000068   0x7208             STRB     R0,[R1, #+8]
   2175              size += 1;
   \   0000006A   0x1C7F             ADDS     R7,R7,#+1
   2176              Osal_MemCpy((void *) Direct_Advertising_Report[i].Direct_Address, (const void *) rp0->Direct_Advertising_Report[i].Direct_Address, 6);
   \   0000006C   0x2206             MOVS     R2,#+6
   \   0000006E   0xEA5F 0x1008      LSLS     R0,R8,#+4
   \   00000072   0x4430             ADD      R0,R6,R0
   \   00000074   0xF110 0x010A      ADDS     R1,R0,#+10
   \   00000078   0x4668             MOV      R0,SP
   \   0000007A   0xEA5F 0x1308      LSLS     R3,R8,#+4
   \   0000007E   0x4418             ADD      R0,R0,R3
   \   00000080   0x3009             ADDS     R0,R0,#+9
   \   00000082   0x.... 0x....      BL       Osal_MemCpy
   2177              size += 6;
   \   00000086   0x1DBF             ADDS     R7,R7,#+6
   2178              Direct_Advertising_Report[i].RSSI = rp0->Direct_Advertising_Report[i].RSSI;
   \   00000088   0xEA5F 0x1008      LSLS     R0,R8,#+4
   \   0000008C   0x4430             ADD      R0,R6,R0
   \   0000008E   0x7C00             LDRB     R0,[R0, #+16]
   \   00000090   0x4669             MOV      R1,SP
   \   00000092   0xEA5F 0x1208      LSLS     R2,R8,#+4
   \   00000096   0x4411             ADD      R1,R1,R2
   \   00000098   0x73C8             STRB     R0,[R1, #+15]
   2179              size += 1;
   \   0000009A   0x1C7F             ADDS     R7,R7,#+1
   2180            }
   \   0000009C   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000000A0   0xE7B7             B.N      ??hci_le_direct_advertising_report_event_proces_0
   2181            hci_le_direct_advertising_report_event(rp0->Num_Reports,
   2182                                                   Direct_Advertising_Report);
   \                     ??hci_le_direct_advertising_report_event_proces_1: (+1)
   \   000000A2   0x4669             MOV      R1,SP
   \   000000A4   0x7830             LDRB     R0,[R6, #+0]
   \   000000A6   0x.... 0x....      BL       hci_le_direct_advertising_report_event
   2183          
   2184            return status;
   \   000000AA   0x0028             MOVS     R0,R5
   \   000000AC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AE   0xB020             ADD      SP,SP,#+128
   \   000000B0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2185          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   aci_att_exchange_mtu_resp_event_process
        16   -> aci_att_exchange_mtu_resp_event
      16   aci_att_exec_write_resp_event_process
        16   -> aci_att_exec_write_resp_event
     152   aci_att_find_by_type_value_resp_event_process
       152   -> aci_att_find_by_type_value_resp_event
      16   aci_att_find_info_resp_event_process
        16   -> aci_att_find_info_resp_event
      16   aci_att_prepare_write_resp_event_process
        16   -> aci_att_prepare_write_resp_event
      16   aci_att_read_blob_resp_event_process
        16   -> aci_att_read_blob_resp_event
      16   aci_att_read_by_group_type_resp_event_process
        16   -> aci_att_read_by_group_type_resp_event
      16   aci_att_read_by_type_resp_event_process
        16   -> aci_att_read_by_type_resp_event
      16   aci_att_read_multiple_resp_event_process
        16   -> aci_att_read_multiple_resp_event
      16   aci_att_read_resp_event_process
        16   -> aci_att_read_resp_event
      48   aci_blue_crash_info_event_process
        48   -> aci_blue_crash_info_event
      16   aci_blue_events_lost_event_process
        16   -> aci_blue_events_lost_event
      16   aci_blue_initialized_event_process
        16   -> aci_blue_initialized_event
      16   aci_gap_addr_not_resolved_event_process
        16   -> aci_gap_addr_not_resolved_event
      16   aci_gap_authorization_req_event_process
        16   -> aci_gap_authorization_req_event
      16   aci_gap_bond_lost_event_process
        16   -> aci_gap_bond_lost_event
      16   aci_gap_keypress_notification_event_process
        16   -> aci_gap_keypress_notification_event
      16   aci_gap_limited_discoverable_event_process
        16   -> aci_gap_limited_discoverable_event
      16   aci_gap_numeric_comparison_value_event_process
        16   -> aci_gap_numeric_comparison_value_event
      16   aci_gap_pairing_complete_event_process
        16   -> aci_gap_pairing_complete_event
      16   aci_gap_pass_key_req_event_process
        16   -> aci_gap_pass_key_req_event
      16   aci_gap_proc_complete_event_process
        16   -> aci_gap_proc_complete_event
      16   aci_gap_slave_security_initiated_event_process
        16   -> aci_gap_slave_security_initiated_event
      16   aci_gatt_attribute_modified_event_process
        16   -> aci_gatt_attribute_modified_event
      16   aci_gatt_disc_read_char_by_uuid_resp_event_process
        16   -> aci_gatt_disc_read_char_by_uuid_resp_event
      16   aci_gatt_error_resp_event_process
        16   -> aci_gatt_error_resp_event
      16   aci_gatt_indication_event_process
        16   -> aci_gatt_indication_event
      16   aci_gatt_notification_event_process
        16   -> aci_gatt_notification_event
      16   aci_gatt_prepare_write_permit_req_event_process
        16   -> aci_gatt_prepare_write_permit_req_event
      16   aci_gatt_proc_complete_event_process
        16   -> aci_gatt_proc_complete_event
      16   aci_gatt_proc_timeout_event_process
        16   -> aci_gatt_proc_timeout_event
     152   aci_gatt_read_multi_permit_req_event_process
       152   -> aci_gatt_read_multi_permit_req_event
      16   aci_gatt_read_permit_req_event_process
        16   -> aci_gatt_read_permit_req_event
      16   aci_gatt_server_confirmation_event_process
        16   -> aci_gatt_server_confirmation_event
      16   aci_gatt_tx_pool_available_event_process
        16   -> aci_gatt_tx_pool_available_event
      16   aci_gatt_write_permit_req_event_process
        16   -> aci_gatt_write_permit_req_event
      16   aci_hal_end_of_radio_activity_event_process
        16   -> aci_hal_end_of_radio_activity_event
      16   aci_hal_scan_req_report_event_process
        16   -> aci_hal_scan_req_report_event
      16   aci_l2cap_command_reject_event_process
        16   -> aci_l2cap_command_reject_event
      24   aci_l2cap_connection_update_req_event_process
        24   -> aci_l2cap_connection_update_req_event
      16   aci_l2cap_connection_update_resp_event_process
        16   -> aci_l2cap_connection_update_resp_event
      16   aci_l2cap_proc_timeout_event_process
        16   -> aci_l2cap_proc_timeout_event
      16   hci_data_buffer_overflow_event_process
        16   -> hci_data_buffer_overflow_event
      16   hci_disconnection_complete_event_process
        16   -> hci_disconnection_complete_event
      16   hci_encryption_change_event_process
        16   -> hci_encryption_change_event
      16   hci_encryption_key_refresh_complete_event_process
        16   -> hci_encryption_key_refresh_complete_event
      16   hci_hardware_error_event_process
        16   -> hci_hardware_error_event
     144   hci_le_advertising_report_event_process
       144   -> Osal_MemCpy
       144   -> hci_le_advertising_report_event
      32   hci_le_connection_complete_event_process
        32   -> hci_le_connection_complete_event
      16   hci_le_connection_update_complete_event_process
        16   -> hci_le_connection_update_complete_event
     152   hci_le_direct_advertising_report_event_process
       152   -> Osal_MemCpy
       152   -> hci_le_direct_advertising_report_event
      40   hci_le_enhanced_connection_complete_event_process
        40   -> hci_le_enhanced_connection_complete_event
      16   hci_le_generate_dhkey_complete_event_process
        16   -> hci_le_generate_dhkey_complete_event
      16   hci_le_long_term_key_request_event_process
        16   -> hci_le_long_term_key_request_event
      16   hci_le_read_local_p256_public_key_complete_event_process
        16   -> hci_le_read_local_p256_public_key_complete_event
      16   hci_le_read_remote_used_features_complete_event_process
        16   -> hci_le_read_remote_used_features_complete_event
     152   hci_number_of_completed_packets_event_process
       152   -> hci_number_of_completed_packets_event
      16   hci_read_remote_version_information_complete_event_process
        16   -> hci_read_remote_version_information_complete_event


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      20  aci_att_exchange_mtu_resp_event_process
      18  aci_att_exec_write_resp_event_process
      84  aci_att_find_by_type_value_resp_event_process
      24  aci_att_find_info_resp_event_process
      28  aci_att_prepare_write_resp_event_process
      22  aci_att_read_blob_resp_event_process
      24  aci_att_read_by_group_type_resp_event_process
      24  aci_att_read_by_type_resp_event_process
      22  aci_att_read_multiple_resp_event_process
      22  aci_att_read_resp_event_process
      82  aci_blue_crash_info_event_process
      18  aci_blue_events_lost_event_process
      18  aci_blue_initialized_event_process
      18  aci_gap_addr_not_resolved_event_process
      18  aci_gap_authorization_req_event_process
      16  aci_gap_bond_lost_event_process
      20  aci_gap_keypress_notification_event_process
      16  aci_gap_limited_discoverable_event_process
      22  aci_gap_numeric_comparison_value_event_process
      22  aci_gap_pairing_complete_event_process
      18  aci_gap_pass_key_req_event_process
      24  aci_gap_proc_complete_event_process
      16  aci_gap_slave_security_initiated_event_process
      30  aci_gatt_attribute_modified_event_process
      24  aci_gatt_disc_read_char_by_uuid_resp_event_process
      26  aci_gatt_error_resp_event_process
      24  aci_gatt_indication_event_process
      24  aci_gatt_notification_event_process
      28  aci_gatt_prepare_write_permit_req_event_process
      20  aci_gatt_proc_complete_event_process
      18  aci_gatt_proc_timeout_event_process
      66  aci_gatt_read_multi_permit_req_event_process
      22  aci_gatt_read_permit_req_event_process
      18  aci_gatt_server_confirmation_event_process
      20  aci_gatt_tx_pool_available_event_process
      24  aci_gatt_write_permit_req_event_process
      24  aci_hal_end_of_radio_activity_event_process
      22  aci_hal_scan_req_report_event_process
      30  aci_l2cap_command_reject_event_process
      46  aci_l2cap_connection_update_req_event_process
      20  aci_l2cap_connection_update_resp_event_process
      22  aci_l2cap_proc_timeout_event_process
      18  hci_data_buffer_overflow_event_process
      24  hci_disconnection_complete_event_process
      24  hci_encryption_change_event_process
      22  hci_encryption_key_refresh_complete_event_process
      56  hci_events_table
      18  hci_hardware_error_event_process
     200  hci_le_advertising_report_event_process
      56  hci_le_connection_complete_event_process
      36  hci_le_connection_update_complete_event_process
     180  hci_le_direct_advertising_report_event_process
      68  hci_le_enhanced_connection_complete_event_process
      20  hci_le_generate_dhkey_complete_event_process
      22  hci_le_long_term_key_request_event_process
      72  hci_le_meta_events_table
      20  hci_le_read_local_p256_public_key_complete_event_process
      24  hci_le_read_remote_used_features_complete_event_process
      82  hci_number_of_completed_packets_event_process
      30  hci_read_remote_version_information_complete_event_process
     336  hci_vendor_specific_events_table

 
   464 bytes in section .rodata
 1 948 bytes in section .text
 
 1 948 bytes of CODE  memory
   464 bytes of CONST memory

Errors: none
Warnings: none
