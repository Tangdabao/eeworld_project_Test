###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       29/Nov/2017  10:11:21
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Library\CMSIS\Device\ST\BlueNRG1\Source\system_bluenrg1.c
#    Command line =  
#        "D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Library\CMSIS\Device\ST\BlueNRG1\Source\system_bluenrg1.c" -D
#        HS_SPEED_XTAL=HS_SPEED_XTAL_16MHZ -D
#        LS_SOURCE=LS_SOURCE_EXTERNAL_32KHZ -D SMPS_INDUCTOR=SMPS_INDUCTOR_10uH
#        --preprocess=cl "D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2
#        DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\Release\List"
#        -lCN "D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\Release\List"
#        -lb "D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\Release\List"
#        --diag_suppress Pe1665 -o "D:\Program Files
#        (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\Release\Obj"
#        --debug --endian=little --cpu=Cortex-M0 --diag_warning Pe1665
#        --diag_suppress Pe1665 -e --fpu=None --dlib_config
#        D:\Software\IAR_BlueNRG\arm\INC\c\DLib_Config_Normal.h -I "D:\Program
#        Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\..\..\"
#        -I "D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\..\..\..\..\..\..\Library\BlueNRG1_Periph_Driver\inc\"
#        -I "D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\..\..\..\..\..\..\Library\CMSIS\Device\ST\BlueNRG1\Include\"
#        -I "D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\..\..\..\..\..\..\Library\SDK_Eval_BlueNRG1\inc\"
#        -I "D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\..\..\..\..\..\..\Library\CMSIS\Include\"
#        -I "D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\..\..\..\..\..\..\Library\hal\inc\"
#        -I "D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\..\..\..\..\..\..\Library\Bluetooth_LE\inc\"
#        -Ohz
#    Locale       =  Chinese (Simplified)_China.936
#    List file    =  
#        D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\Release\List\system_bluenrg1.lst
#    Object file  =  
#        D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\Release\Obj\system_bluenrg1.o
#
###############################################################################

D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK 2.5.0\Library\CMSIS\Device\ST\BlueNRG1\Source\system_bluenrg1.c
      1          /******************** (C) COPYRIGHT 2015 STMicroelectronics ********************
      2          * File Name          : system_bluenrg1.h
      3          * Author             : AMS - VMA
      4          * Version            : V1.0.0
      5          * Date               : 19-May-2015
      6          * Description        : BlueNRG Low Level Init function
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          *******************************************************************************/
     15          
     16          #include "BlueNRG_x_device.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_SetPriority(IRQn_Type, uint32_t)
   \                     NVIC_SetPriority: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x00C2             LSLS     R2,R0,#+3
   \   00000004   0x2318             MOVS     R3,#+24
   \   00000006   0x4013             ANDS     R3,R3,R2
   \   00000008   0x24FF             MOVS     R4,#+255
   \   0000000A   0x409C             LSLS     R4,R4,R3
   \   0000000C   0x43E2             MVNS     R2,R4
   \   0000000E   0x0789             LSLS     R1,R1,#+30
   \   00000010   0x0E09             LSRS     R1,R1,#+24
   \   00000012   0x4099             LSLS     R1,R1,R3
   \   00000014   0x0003             MOVS     R3,R0
   \   00000016   0xD504             BPL      ??NVIC_SetPriority_0
   \   00000018   0x....             LDR      R0,??DataTable4  ;; 0xe000ed1c
   \   0000001A   0x071B             LSLS     R3,R3,#+28
   \   0000001C   0x0F1B             LSRS     R3,R3,#+28
   \   0000001E   0x3B08             SUBS     R3,R3,#+8
   \   00000020   0xE000             B        ??NVIC_SetPriority_1
   \                     ??NVIC_SetPriority_0: (+1)
   \   00000022   0x....             LDR      R0,??DataTable4_1  ;; 0xe000e400
   \                     ??NVIC_SetPriority_1: (+1)
   \   00000024   0x089B             LSRS     R3,R3,#+2
   \   00000026   0x009B             LSLS     R3,R3,#+2
   \   00000028   0x18C0             ADDS     R0,R0,R3
   \   0000002A   0x6803             LDR      R3,[R0, #+0]
   \   0000002C   0x401A             ANDS     R2,R2,R3
   \   0000002E   0x4311             ORRS     R1,R1,R2
   \   00000030   0x6001             STR      R1,[R0, #+0]
   \   00000032   0xBD10             POP      {R4,PC}          ;; return
     17          #include "BluenRG1_flash.h"
     18          #include "misc.h"
     19          #include "hal_types.h"
     20          
     21          #define RESET_WAKE_DEEPSLEEP_REASONS 0x05
     22          #define CRITICAL_PRIORITY 0
     23          /* OTA tag used to  tag a  valid application on interrupt vector table*/
     24          #if ST_OTA_SERVICE_MANAGER_APPLICATION
     25          #define OTA_VALID_APP_TAG (0xAABBCCDD) /* OTA Service Manager has a special valid tag */
     26          #else
     27          #define OTA_VALID_APP_TAG (0xAA5555AA) 
     28          #endif
     29          
     30          #define BLUE_FLAG_TAG   (0x424C5545)
     31          

   \                                 In section .text, align 2
     32          WEAK_FUNCTION(void NMI_Handler(void) {});
   \                     NMI_Handler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
     33          WEAK_FUNCTION(void HardFault_Handler(void) {});
   \                     HardFault_Handler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
     34          WEAK_FUNCTION(void SVC_Handler(void) {});
   \                     SVC_Handler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
     35          WEAK_FUNCTION(void PendSV_Handler(void) {});
   \                     PendSV_Handler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
     36          WEAK_FUNCTION(void SysTick_Handler(void) {});
   \                     SysTick_Handler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
     37          WEAK_FUNCTION(void GPIO_Handler(void) {});
   \                     GPIO_Handler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
     38          WEAK_FUNCTION(void NVM_Handler(void) {});
   \                     NVM_Handler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
     39          WEAK_FUNCTION(void UART_Handler(void) {});
   \                     UART_Handler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
     40          WEAK_FUNCTION(void SPI_Handler(void) {});
   \                     SPI_Handler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
     41          WEAK_FUNCTION(void Blue_Handler(void) {});
   \                     Blue_Handler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
     42          WEAK_FUNCTION(void BATTERY_LOW_Handler(void) {});
   \                     BATTERY_LOW_Handler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
     43          WEAK_FUNCTION(void ADV_Handler(void) {});
   \                     ADV_Handler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
     44          WEAK_FUNCTION(void MFT1A_Handler(void) {});
   \                     MFT1A_Handler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
     45          WEAK_FUNCTION(void MFT1B_Handler(void) {});
   \                     MFT1B_Handler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
     46          WEAK_FUNCTION(void MFT2A_Handler(void) {});
   \                     MFT2A_Handler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
     47          WEAK_FUNCTION(void MFT2B_Handler(void) {});
   \                     MFT2B_Handler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
     48          WEAK_FUNCTION(void RTC_Handler(void) {});
   \                     RTC_Handler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
     49          WEAK_FUNCTION(void WDG_Handler(void) {});
   \                     WDG_Handler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
     50          WEAK_FUNCTION(void ADC_Handler(void) {});
   \                     ADC_Handler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
     51          WEAK_FUNCTION(void I2C2_Handler(void) {});
   \                     I2C2_Handler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
     52          WEAK_FUNCTION(void I2C1_Handler(void) {});
   \                     I2C1_Handler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
     53          WEAK_FUNCTION(void DMA_Handler(void) {});
   \                     DMA_Handler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
     54          WEAK_FUNCTION(void PKA_Handler(void) {});
   \                     PKA_Handler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     55          
     56          
     57          
     58          //------------------------------------------------------------------------------
     59          //   uint32_t ota_sw_activation
     60          //
     61          // OTA SW activation
     62          //
     63          //------------------------------------------------------------------------------
     64          SECTION(".ota_sw_activation")

   \                                 In section .ota_sw_activation, align 4
     65          NO_INIT_ZERO(volatile uint32_t ota_sw_activation, ".ota_sw_activation");
   \                     ota_sw_activation:
   \   00000000                      DS8 4
     66          
     67          //------------------------------------------------------------------------------
     68          //   uint32_t savedMSP
     69          //
     70          // Private storage to hold the saved stack pointer.  This variable is only used
     71          // in this file and should not be extern'ed.  In our current design we
     72          // do not use real context switching, but only context saving and restoring.
     73          // As such, we only need to keep track of the Main Stack Pointer (MSP). This
     74          // variable is used to hold the MSP between a save and a restore.
     75          //------------------------------------------------------------------------------
     76          SECTION(".savedMSP")

   \                                 In section .savedMSP, align 4, root
     77          REQUIRED(uint32_t savedMSP);
   \                     savedMSP:
   \   00000000                      DS8 4
     78          
     79          
     80          //------------------------------------------------------------------------------
     81          //   uint8_t wakeupFromSleepFlag
     82          //
     83          // A simple flag used to indicate if the wakeup occurred from Sleep or Standby 
     84          // condition.
     85          // If this flag is zero, an interrupt has affected the WFI instruction and the
     86          // BlueNRG-1 doesn't enter in deep sleep state. So, no context restore is
     87          // necessary.
     88          // If this flag is non-zero, the WFI instruction puts the BlueNRG-1 in deep sleep.
     89          // So, at wakeup time a context restore is necessary.
     90          // Note: The smallest unit of storage is a single byte.
     91          //
     92          // NOTE: This flag must be cleared before the context restore is called
     93          //------------------------------------------------------------------------------
     94          SECTION(".wakeupFromSleepFlag")

   \                                 In section .wakeupFromSleepFlag, align 1, root
     95          REQUIRED(uint8_t wakeupFromSleepFlag);
   \                     wakeupFromSleepFlag:
   \   00000000                      DS8 1
     96            
     97          
     98          //------------------------------------------------------------------------------
     99          //   uint32_t __blueflag_RAM
    100          //
    101          // __blueflag_RAM
    102          //
    103          //------------------------------------------------------------------------------
    104          SECTION(".__blueflag_RAM")

   \                                 In section .__blueflag_RAM, align 4, root
    105          REQUIRED(uint32_t __blueflag_RAM);
   \                     __blueflag_RAM:
   \   00000000                      DS8 4
    106          
    107          //------------------------------------------------------------------------------
    108          //   uint32_t savedICSR
    109          //
    110          // Private storage to save the Interrupt Control State register, to check the 
    111          // SysTick and PendSV interrupt status
    112          // This variable is only used during the samrt power management 
    113          // procedure 
    114          //------------------------------------------------------------------------------

   \                                 In section .bss, align 4
    115          uint32_t savedICSR;
   \                     savedICSR:
   \   00000000                      DS8 4
    116          
    117          //------------------------------------------------------------------------------
    118          //   uint32_t savedSHCSR
    119          //
    120          // Private storage to save the System Handler Control and State register, 
    121          // to check the SVCall interrupt status
    122          // This variable is only used during the samrt power management 
    123          // procedure 
    124          //------------------------------------------------------------------------------

   \                                 In section .bss, align 4
    125          uint32_t savedSHCSR;
   \                     savedSHCSR:
   \   00000000                      DS8 4
    126          
    127          //------------------------------------------------------------------------------
    128          //   uint32_t savedNVIC_ISPR
    129          //
    130          // Private storage to save the Interrupt Set Pending register, 
    131          // to check the NVIC interrupt status
    132          // This variable is only used during the smart power management 
    133          // procedure 
    134          //------------------------------------------------------------------------------

   \                                 In section .bss, align 4
    135          uint32_t savedNVIC_ISPR;
   \                     savedNVIC_ISPR:
   \   00000000                      DS8 4
    136          
    137          

   \                                 In section .text, align 2, keep-with-next
    138          int __low_level_init(void) 
    139          {
   \                     __low_level_init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    140            // If the reset reason is a wakeup from sleep restore the context
    141            if ((CKGEN_SOC->REASON_RST == 0) && (CKGEN_BLE->REASON_RST > RESET_WAKE_DEEPSLEEP_REASONS)) {
   \   00000002   0x....             LDR      R0,??DataTable4_2  ;; 0x40900008
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD109             BNE      ??__low_level_init_0
   \   0000000A   0x....             LDR      R0,??DataTable4_3  ;; 0x48100008
   \   0000000C   0x8800             LDRH     R0,[R0, #+0]
   \   0000000E   0x2806             CMP      R0,#+6
   \   00000010   0xDB05             BLT      ??__low_level_init_0
    142          #ifndef NO_SMART_POWER_MANAGEMENT
    143                    
    144            void CS_contextRestore(void);
    145            wakeupFromSleepFlag = 1; //A wakeup from Standby or Sleep occurred
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x....             LDR      R1,??DataTable4_4
   \   00000016   0x7008             STRB     R0,[R1, #+0]
    146            CS_contextRestore(); // Restore the context
   \   00000018   0x.... 0x....      BL       CS_contextRestore
    147            //if the context restore worked properly, we should never return here
    148            while(1) { ; }
   \                     ??__low_level_init_1: (+1)
   \   0000001C   0xE7FE             B        ??__low_level_init_1
    149          #else
    150            return 0;
    151          #endif   
    152            }
    153            return 1;
   \                     ??__low_level_init_0: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xBD02             POP      {R1,PC}          ;; return
    154          }
    155          
    156          #ifdef __CC_ARM
    157          
    158          void RESET_HANDLER(void)
    159          {
    160            if(__low_level_init()==1)
    161              __main();
    162            else {
    163              __set_MSP((uint32_t)_INITIAL_SP);
    164              main();
    165            }
    166          }
    167          
    168          
    169          #else /* __CC_ARM */
    170          #ifdef __GNUC__
    171          
    172          extern unsigned long _etext;
    173          extern unsigned long _sidata;		/* start address for the initialization values of the .data section. defined in linker script */
    174          extern unsigned long _sdata;		/* start address for the .data section. defined in linker script */
    175          extern unsigned long _edata;		/* end address for the .data section. defined in linker script */
    176          extern unsigned long _sbss;			/* start address for the .bss section. defined in linker script */
    177          extern unsigned long _ebss;			/* end address for the .bss section. defined in linker script */
    178          extern unsigned long _estack;		/* init value for the stack pointer. defined in linker script */
    179          extern unsigned long _sidata2;		/* start address for the initialization values of the special ram_preamble */
    180          extern unsigned long _sdata2;		/* start address the special ram_preamble defined in linker script */
    181          extern unsigned long _edata2;		/* end address the special ram_preamble defined in linker script */
    182          
    183          extern int main(void);
    184          
    185          void RESET_HANDLER(void)
    186          {
    187            if(__low_level_init()==1)	{
    188              unsigned long *pulSrc, *pulDest;
    189              
    190              // Copy the data segment initializers from flash to SRAM.
    191              pulSrc = &_sidata;
    192              for(pulDest = &_sdata; pulDest < &_edata; )
    193              {
    194                *(pulDest++) = *(pulSrc++);
    195              }
    196              
    197              pulSrc = &_sidata2;
    198              for(pulDest = &_sdata2; pulDest < &_edata2; )
    199              {
    200                if (pulDest < (unsigned long *) 0x20000004) {
    201              	  pulDest++;
    202              	  pulSrc++;
    203                } else {
    204              	  *(pulDest++) = *(pulSrc++);
    205                }
    206              }
    207          
    208              // Zero fill the bss segment.
    209              for(pulDest = &_sbss; pulDest < &_ebss; )
    210              {
    211                *(pulDest++) = 0;
    212              }
    213            }
    214            // Call the application's entry point.
    215            __set_MSP((uint32_t)_INITIAL_SP);
    216            main();
    217          }
    218          
    219          #endif /* __GNUC__ */
    220          #endif /* __CC_ARM */
    221          
    222          
    223          SECTION(".intvec")

   \                                 In section .intvec, align 4, root
    224          REQUIRED(const intvec_elem __vector_table[]) = {
   \                     __vector_table:
   \   00000000   0x........         DC32 SFE(CSTACK), __iar_program_start, NMI_Handler, HardFault_Handler
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000010   0xAA5555AA         DC32 0AA5555AAH, 424C5545H, 0H, 0H, 0H, 0H, 0H, SVC_Handler, 0H, 0H
   \              0x424C5545   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x........   
   \              0x00000000   
   \              0x00000000   
   \   00000038   0x........         DC32 PendSV_Handler, SysTick_Handler, GPIO_Handler, NVM_Handler, 0H, 0H
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x00000000   
   \              0x00000000   
   \   00000050   0x........         DC32 UART_Handler, SPI_Handler, Blue_Handler, WDG_Handler, 0H, 0H, 0H
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \   0000006C   0x00000000         DC32 0H, 0H, ADC_Handler, I2C2_Handler, I2C1_Handler, 0H, MFT1A_Handler
   \              0x00000000   
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x00000000   
   \              0x........   
   \   00000088   0x........         DC32 MFT1B_Handler, MFT2A_Handler, MFT2B_Handler, RTC_Handler
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000098   0x........         DC32 PKA_Handler, DMA_Handler, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H
   \              0x........   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
    225              _INITIAL_SP,                            /* Stack address                      */
    226              RESET_HANDLER,           		    /* Reset handler is C initialization. */
    227              NMI_Handler,                            /* The NMI handler                    */ 
    228              HardFault_Handler,                      /* The hard fault handler             */ 
    229              (intfunc) OTA_VALID_APP_TAG,            /* OTA Application                    */
    230              (intfunc) BLUE_FLAG_TAG,                /* Reserved for blue flag DTM updater */ 
    231              0x00000000,                             /* Reserved                           */ 
    232              0x00000000,                             /* Reserved                           */ 
    233              0x00000000,                             /* Reserved                           */ 
    234              0x00000000,                             /* Reserved                           */ 
    235              0x00000000,                             /* Reserved                           */ 
    236              SVC_Handler,                            /* SVCall                             */ 
    237              0x00000000,                             /* Reserved                           */ 
    238              0x00000000,                             /* Reserved                           */ 
    239              PendSV_Handler,                         /* PendSV                             */ 
    240              SysTick_Handler,                        /* SysTick_Handler                    */ 
    241              GPIO_Handler,                           /* IRQ0:  GPIO                        */ 
    242              NVM_Handler,                            /* IRQ1:  NVM                         */ 
    243              0x00000000,                             /* IRQ2:                              */ 
    244              0x00000000,                             /* IRQ3:                              */ 
    245              UART_Handler,                           /* IRQ4:  UART                        */ 
    246              SPI_Handler,                            /* IRQ5:  SPI                         */ 
    247              Blue_Handler,                           /* IRQ6:  Blue                        */ 
    248              WDG_Handler,                            /* IRQ7:  Watchdog                    */ 
    249              0x00000000,                             /* IRQ8:                              */ 
    250              0x00000000,                             /* IRQ9:                              */ 
    251              0x00000000,                             /* IRQ10:                             */ 
    252              0x00000000,                             /* IRQ11:                             */ 
    253              0x00000000,                             /* IRQ12:                             */ 
    254              ADC_Handler,                            /* IRQ13  ADC                         */ 
    255              I2C2_Handler,                           /* IRQ14  I2C2                        */ 
    256              I2C1_Handler,                           /* IRQ15  I2C1                        */ 
    257              0x00000000,                             /* IRQ16                              */ 
    258              MFT1A_Handler,                          /* IRQ17  MFT1 irq1                   */ 
    259              MFT1B_Handler,                          /* IRQ18  MFT1 irq2                   */ 
    260              MFT2A_Handler,                          /* IRQ19  MFT2 irq1                   */ 
    261              MFT2B_Handler,                          /* IRQ20  MFT2 irq2                   */ 
    262              RTC_Handler,                            /* IRQ21  RTC                         */ 
    263              PKA_Handler,                            /* IRQ22  PKA                         */ 
    264              DMA_Handler,                            /* IRQ23  DMA                         */ 
    265              0x00000000,                             /* IRQ24                              */ 
    266              0x00000000,                             /* IRQ25                              */ 
    267              0x00000000,                             /* IRQ26                              */ 
    268              0x00000000,                             /* IRQ27                              */ 
    269              0x00000000,                             /* IRQ28                              */ 
    270              0x00000000,                             /* IRQ29                              */ 
    271              0x00000000,                             /* IRQ30                              */ 
    272              0x00000000                              /* IRQ31                              */ 
    273          };
    274          
    275          	
    276          
    277          //------------------------------------------------------------------------------
    278          //   uint32_t *app_base
    279          //
    280          // The application base address. Used by OTA IRQ stub file to determine the
    281          // effective application base address and jump to the proper IRQ handler.
    282          //
    283          //------------------------------------------------------------------------------
    284          SECTION(".app_base")

   \                                 In section .app_base, align 4, root
    285          REQUIRED(uint32_t *app_base) = (uint32_t *) __vector_table;
   \                     app_base:
   \   00000000   0x........         DC32 __vector_table
    286          
    287          
    288          SECTION(".bss.__blue_RAM")

   \                                 In section .bss.__blue_RAM, align 4, root
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000017   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   0000002E   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000045   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   0000005C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000073   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   0000008A   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   000000A1   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   000000B8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   000000CF   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   000000E6   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   000000FD   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000114   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   0000012B   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000142   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000159   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000170   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000187   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   0000019E   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   000001B5   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   000001CC   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   000001E3   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   000001FA   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    289          REQUIRED(static uint8_t __blue_RAM[8*64+12]) = {0,};
    290          
    291          /**
    292           * @name Device Configuration Registers
    293           *@{
    294           */
    295          
    296          /**
    297           *@brief Analog Test Bus 0 register settings
    298           */
    299          #define ATB0_ANA_ENG_REG    0x3F
    300          /**
    301           *@brief Analog Test Bus 1 register settings
    302           */
    303          #define ATB1_ANA_ENG_REG    0x3E
    304          /**
    305           *@brief Rate Multiplier 1 register settings 
    306           */
    307          #define RM1_DIG_ENG_REG     0x3C
    308          /**
    309           *@brief Low Frequency Clock and SMPS register settings
    310           */
    311          #define CLOCK_LOW_ENG_REG   0x3B
    312          /**
    313           *@brief High Frequency Clock register settings
    314           */
    315          #define CLOCK_HIGH_ENG_REG  0x3A
    316          /**
    317           *@brief Power Management register settings
    318           */
    319          #define PMU_ANA_ENG_REG     0x39
    320          /**
    321           *@brief System Clock register settings
    322           */
    323          #define CLOCK_ANA_USER_REG  0x34
    324          /**
    325           *@brief System Power Management register settings
    326           */
    327          #define PMU_ANA_USER_REG    0x35
    328          //@} \\Device Configuration Registers
    329          
    330          /**
    331           * @name Device Configuration values
    332           *@{
    333           */
    334          
    335          /**
    336           * @brief Enable the low frequency RO
    337           */
    338          #define LOW_FREQ_RO                 0x1B
    339          /**
    340           * @brief Enable the external low frequency XO
    341           */
    342          #define LOW_FREQ_XO                 0x5B
    343          /**
    344           * @brief Enable the high frequency 16 MHz
    345           */
    346          #define HIGH_FREQ_16M               0x40
    347          /**
    348           * @brief Enable the high frequrency 32 MHz
    349           */
    350          #define HIGH_FREQ_32M               0x44
    351          /**
    352           * @brief Enable the SMPS
    353           */
    354          #define SMPS_ON                     0x4C
    355          /**
    356           * @brief Disable the SMPS
    357           */
    358          #define SMPS_OFF                    0x6C
    359          /**
    360           * @brief SMPS clock frequency value for 4.7 uH inductor
    361           */
    362          #define SMPS_4_7uH_RM1              0x40
    363          /**
    364           * @brief Power management configuration for 4.7 uH inductor
    365           */
    366          #define SMPS_4_7uH_PMU              0xBE
    367          /**
    368           * @brief SMPS clock frequency value for 10 uH inductor
    369           */
    370          #define SMPS_10uH_RM1               0x20
    371          /**
    372           * @brief Power management configuration for 10 uH inductor
    373           */
    374          #define SMPS_10uH_PMU               0xB2
    375          /**
    376           * @brief RCO32 trimming default values
    377           */
    378          #define PMU_ANA_USER_RESET_VALUE    0x0B
    379          /**
    380           * @brief Analog test bus 0 settings for 
    381           * normal application mode
    382           */
    383          #define USER_MODE_ATB0              0x00
    384          /**
    385           * @brief Analog test bus 1 settings for 
    386           * normal application mode
    387           */
    388          #define USER_MODE_ATB1              0x30
    389          /**
    390           * @brief Analog test bus 0 settings for 
    391           * low speed crystal measurement
    392           */
    393          #define LS_XTAL_MEAS_ATB0           0x37
    394          /**
    395           * @brief Analog test bus 1 settings for 
    396           * low speed crystal measurement
    397           */
    398          #define LS_XTAL_MEAS_ATB1           0x34
    399          /**
    400           * @brief Analog test bus 0 settings for 
    401           * high speed crystal startup time measurement
    402           */
    403          #define HS_STARTUP_TIME_MEAS_ATB0   0x04
    404          /**
    405           * @brief Analog test bus 1 settings for 
    406           * high speed crystal startup time measurement
    407           */
    408          #define HS_STARTUP_TIME_MEAS_ATB1   0x34
    409          /**
    410           * @brief Analog test bus 0 settings for 
    411           * Tx/Rx start stop signal measurement
    412           */
    413          #define TX_RX_START_STOP_MEAS_ATB0  0x38
    414          /**
    415           * @brief Analog test bus 1 settings for 
    416           * Tx/Rx start stop signal measurement
    417           */
    418          #define TX_RX_START_STOP_MEAS_ATB1  0x34
    419          //@} \\Device Configuration values
    420          
    421          /**
    422           *@brief Number of configuration bytes to send over Blue SPI
    423           */
    424          #define NUMBER_CONFIG_BYTE  0x02
    425          /**
    426           *@brief End Configuration Tag
    427           */
    428          #define END_CONFIG          0x00
    429          
    430          /**
    431           * @brief Cold start configuration register table
    432           */
    433          #define COLD_START_CONFIGURATION                                      \
    434          {                                                                     \
    435            NUMBER_CONFIG_BYTE, ATB0_ANA_ENG_REG,   USER_MODE_ATB0,             \
    436            NUMBER_CONFIG_BYTE, ATB1_ANA_ENG_REG,   USER_MODE_ATB1,             \
    437            NUMBER_CONFIG_BYTE, RM1_DIG_ENG_REG,    SMPS_10uH_RM1,              \
    438            NUMBER_CONFIG_BYTE, CLOCK_LOW_ENG_REG,  SMPS_ON,                    \
    439            NUMBER_CONFIG_BYTE, CLOCK_HIGH_ENG_REG, HIGH_FREQ_16M,              \
    440            NUMBER_CONFIG_BYTE, PMU_ANA_ENG_REG,    SMPS_10uH_PMU,              \
    441            NUMBER_CONFIG_BYTE, CLOCK_ANA_USER_REG, LOW_FREQ_XO,                \
    442            NUMBER_CONFIG_BYTE, PMU_ANA_USER_REG,   PMU_ANA_USER_RESET_VALUE,   \
    443            END_CONFIG                                                          \
    444          }
    445          
    446          /**
    447           * @brief RCO32K trimming value flash location
    448           */
    449          #define RCO32K_TRIMMING_FLASH_ADDR 0x100007E8
    450          /**
    451           * @brief LDO1V2 trimming value flash location
    452           */
    453          #define LDO1V2_TRIMMING_FLASH_ADDR 0x100007E4
    454          /**
    455           * @brief Check bytes tag
    456           */
    457          #define CHECK_BYTES                0xAA55
    458          
    459          

   \                                 In section .text, align 4, keep-with-next
    460          void DeviceConfiguration(BOOL coldStart, BOOL waitLS_Ready)
    461          {
   \                     DeviceConfiguration: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000C             MOVS     R4,R1
    462            uint32_t current_time;
    463            uint32_t Trimm_config; 
    464            volatile uint8_t cold_start_config[] = COLD_START_CONFIGURATION;
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0xBF00             Nop      
   \   0000000C   0x....             ADR.N    R1,?_0
   \   0000000E   0x221C             MOVS     R2,#+28
   \   00000010   0x.... 0x....      BL       __aeabi_memcpy4
    465          
    466            if (coldStart) {    
   \   00000014   0x....             LDR      R0,??DataTable4_5  ;; 0x4800000c
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD02D             BEQ      ??DeviceConfiguration_0
    467              /* High Speed Crystal Configuration */
    468          #if (HS_SPEED_XTAL == HS_SPEED_XTAL_32MHZ)
    469              cold_start_config[14] = HIGH_FREQ_32M;
    470              /* Set 32MHz_SEL bit in the System controller register */
    471              SYSTEM_CTRL->CTRL_b.MHZ32_SEL = 1;
    472          #elif (HS_SPEED_XTAL == HS_SPEED_XTAL_16MHZ)
    473              cold_start_config[14] = HIGH_FREQ_16M;
   \   0000001A   0x4669             MOV      R1,SP
   \   0000001C   0x2240             MOVS     R2,#+64
   \   0000001E   0x738A             STRB     R2,[R1, #+14]
    474          #else
    475          #error "No definition for High Speed Crystal"
    476          #endif
    477            
    478              /* Low Speed Crystal Source */
    479          #if (LS_SOURCE == LS_SOURCE_EXTERNAL_32KHZ)
    480              cold_start_config[20] = LOW_FREQ_XO;
   \   00000020   0x225B             MOVS     R2,#+91
   \   00000022   0x750A             STRB     R2,[R1, #+20]
    481          #elif (LS_SOURCE == LS_SOURCE_INTERNAL_RO)
    482              cold_start_config[20] = LOW_FREQ_RO;
    483          #else
    484          #error "No definition for Low Speed Crystal Source"
    485          #endif
    486            
    487              /* SMPS configuration */
    488          #if (SMPS_INDUCTOR == SMPS_INDUCTOR_10uH)
    489              cold_start_config[11] = SMPS_ON;
   \   00000024   0x224C             MOVS     R2,#+76
   \   00000026   0x72CA             STRB     R2,[R1, #+11]
    490              cold_start_config[8] = SMPS_10uH_RM1;
   \   00000028   0x2220             MOVS     R2,#+32
   \   0000002A   0x720A             STRB     R2,[R1, #+8]
    491              cold_start_config[17] = SMPS_10uH_PMU;
   \   0000002C   0x22B2             MOVS     R2,#+178
   \   0000002E   0x744A             STRB     R2,[R1, #+17]
    492          #elif (SMPS_INDUCTOR == SMPS_INDUCTOR_4_7uH)
    493              cold_start_config[11] = SMPS_ON;
    494              cold_start_config[8] = SMPS_4_7uH_RM1;
    495              cold_start_config[17] = SMPS_4_7uH_PMU;
    496          #elif (SMPS_INDUCTOR == SMPS_INDUCTOR_NONE)
    497              cold_start_config[11] = SMPS_OFF;
    498          #else
    499          #error "No definition for SMPS Configuration"
    500          #endif
    501          
    502              /* BOR configuration. Note: this setup shall be executed after the SMPS configuration*/
    503          #if (BOR_CONFIG == BOR_ON)
    504              /* Clear the 3 bit of the CLOCK_LOW_ENG_REG register */
    505              cold_start_config[11] &= ~(1<<2);
    506          #elif (BOR_CONFIG == BOR_OFF)
    507              /* Nothing to do because the BOR is disabled by default */
    508          #else
    509          #error "No definition for BOR Configuration"
    510          #endif
    511          
    512              /* Setup RCO32K trimming value in PMU_ANA_USER_REG  */
    513              Trimm_config = *(volatile uint32_t*)RCO32K_TRIMMING_FLASH_ADDR;
   \   00000030   0x....             LDR      R3,??DataTable4_6  ;; 0x100007e4
   \   00000032   0x685D             LDR      R5,[R3, #+4]
    514              if ((Trimm_config >> 16) == CHECK_BYTES)
   \   00000034   0x....             LDR      R2,??DataTable4_7  ;; 0xaa55
   \   00000036   0x0C2E             LSRS     R6,R5,#+16
   \   00000038   0x4296             CMP      R6,R2
   \   0000003A   0xD105             BNE      ??DeviceConfiguration_1
    515                cold_start_config[23] = ((Trimm_config&0x7)<<4)|PMU_ANA_USER_RESET_VALUE;
   \   0000003C   0x012D             LSLS     R5,R5,#+4
   \   0000003E   0x2670             MOVS     R6,#+112
   \   00000040   0x402E             ANDS     R6,R6,R5
   \   00000042   0x250B             MOVS     R5,#+11
   \   00000044   0x4335             ORRS     R5,R5,R6
   \   00000046   0x75CD             STRB     R5,[R1, #+23]
    516           
    517              /* Setup LDO1V2 trimming value in ATB1_ANA_ENG_REG  */
    518              Trimm_config = *(volatile uint32_t*)LDO1V2_TRIMMING_FLASH_ADDR;
   \                     ??DeviceConfiguration_1: (+1)
   \   00000048   0x681B             LDR      R3,[R3, #+0]
    519              if ((Trimm_config >> 16) == CHECK_BYTES) {
   \   0000004A   0x0C1D             LSRS     R5,R3,#+16
   \   0000004C   0x4295             CMP      R5,R2
   \   0000004E   0xD109             BNE      ??DeviceConfiguration_2
    520                cold_start_config[5] &= ~0x30;                 // Clear the register content of bit 4 and 5
   \   00000050   0x794A             LDRB     R2,[R1, #+5]
   \   00000052   0x25CF             MOVS     R5,#+207
   \   00000054   0x4015             ANDS     R5,R5,R2
   \   00000056   0x714D             STRB     R5,[R1, #+5]
    521                cold_start_config[5] |= (Trimm_config&0x3)<<4; // Store the LDO1V2 trimming value in bit 4 and 5
   \   00000058   0x794A             LDRB     R2,[R1, #+5]
   \   0000005A   0x011B             LSLS     R3,R3,#+4
   \   0000005C   0x2530             MOVS     R5,#+48
   \   0000005E   0x401D             ANDS     R5,R5,R3
   \   00000060   0x4315             ORRS     R5,R5,R2
   \   00000062   0x714D             STRB     R5,[R1, #+5]
    522              }
    523              
    524              /* Cold start configuration device */
    525              BLUE_CTRL->RADIO_CONFIG = 0x10000U | (uint16_t)((uint32_t)cold_start_config & 0x0000FFFFU);
   \                     ??DeviceConfiguration_2: (+1)
   \   00000064   0x2180             MOVS     R1,#+128
   \   00000066   0x0249             LSLS     R1,R1,#+9        ;; #+65536
   \   00000068   0x466A             MOV      R2,SP
   \   0000006A   0xB292             UXTH     R2,R2
   \   0000006C   0x430A             ORRS     R2,R2,R1
   \   0000006E   0x6002             STR      R2,[R0, #+0]
    526              while ((BLUE_CTRL->RADIO_CONFIG & 0x10000) != 0);
   \                     ??DeviceConfiguration_3: (+1)
   \   00000070   0x6802             LDR      R2,[R0, #+0]
   \   00000072   0x400A             ANDS     R2,R2,R1
   \   00000074   0xD1FC             BNE      ??DeviceConfiguration_3
    527            }
    528            
    529            /* Wait until HS is ready. The slow clock period 
    530            * measurement is done automatically each time the
    531            * device enters in active2 state and the HS is ready.
    532            * The interrupt signals that a measurement is done.
    533            */
    534            while(CKGEN_BLE->CLK32K_IT == 0);
   \                     ??DeviceConfiguration_0: (+1)
   \   00000076   0x....             LDR      R1,??DataTable4_8  ;; 0x4810000c
   \   00000078   0x898A             LDRH     R2,[R1, #+12]
   \   0000007A   0x2A00             CMP      R2,#+0
   \   0000007C   0xD0FB             BEQ      ??DeviceConfiguration_0
    535            CKGEN_BLE->CLK32K_IT = 1;
   \   0000007E   0x2201             MOVS     R2,#+1
   \   00000080   0x818A             STRH     R2,[R1, #+12]
    536            CKGEN_BLE->CLK32K_COUNT = 23; //Restore the window length for slow clock measurement.
   \   00000082   0x2217             MOVS     R2,#+23
   \   00000084   0x800A             STRH     R2,[R1, #+0]
    537            CKGEN_BLE->CLK32K_PERIOD = 0;
   \   00000086   0x2200             MOVS     R2,#+0
   \   00000088   0x604A             STR      R2,[R1, #+4]
    538            
    539            
    540            /* Wait until the RO or 32KHz is ready */
    541            if (waitLS_Ready) {
   \   0000008A   0x2C00             CMP      R4,#+0
   \   0000008C   0xD007             BEQ      ??DeviceConfiguration_4
    542              current_time = *(volatile uint32_t *)0x48000010;
   \   0000008E   0x6841             LDR      R1,[R0, #+4]
   \   00000090   0x2210             MOVS     R2,#+16
    543              while(((*(volatile uint32_t *)0x48000010)&0x10) == (current_time&0x10));
   \                     ??DeviceConfiguration_5: (+1)
   \   00000092   0x6843             LDR      R3,[R0, #+4]
   \   00000094   0x4013             ANDS     R3,R3,R2
   \   00000096   0x2410             MOVS     R4,#+16
   \   00000098   0x400C             ANDS     R4,R4,R1
   \   0000009A   0x42A3             CMP      R3,R4
   \   0000009C   0xD0F9             BEQ      ??DeviceConfiguration_5
    544            }
    545          
    546            if (coldStart) {
    547          #if (HS_SPEED_XTAL == HS_SPEED_XTAL_32MHZ)
    548              /* AHB up converter command register write*/
    549              AHBUPCONV->COMMAND = 0x15;
    550          #endif
    551            }
    552            
    553          }
   \                     ??DeviceConfiguration_4: (+1)
   \   0000009E   0xB008             ADD      SP,SP,#+32
   \   000000A0   0xBD70             POP      {R4-R6,PC}       ;; return
    554          

   \                                 In section .text, align 2, keep-with-next
    555          void SystemInit(void)
    556          {
   \                     SystemInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    557            /* Remap the vector table */
    558            FLASH->CONFIG = FLASH_PREMAP_MAIN;
   \   00000002   0x2008             MOVS     R0,#+8
   \   00000004   0x....             LDR      R1,??DataTable4_9  ;; 0x40100004
   \   00000006   0x8008             STRH     R0,[R1, #+0]
    559          
    560            /* Configure all the interrupts priority. 
    561            * The application can modify the interrupts priority.
    562            * The  PendSV_IRQn and BLUE_CTRL_IRQn SHALL maintain the highest priority
    563            */
    564            NVIC_SetPriority(PendSV_IRQn,    LOW_PRIORITY);
   \   00000008   0x2103             MOVS     R1,#+3
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x43C0             MVNS     R0,R0            ;; #-2
   \   0000000E   0x.... 0x....      BL       NVIC_SetPriority
    565            NVIC_SetPriority(SysTick_IRQn,   LOW_PRIORITY);
   \   00000012   0x2103             MOVS     R1,#+3
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000018   0x.... 0x....      BL       NVIC_SetPriority
    566            NVIC_SetPriority(GPIO_IRQn,      LOW_PRIORITY);
   \   0000001C   0x2103             MOVS     R1,#+3
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x.... 0x....      BL       NVIC_SetPriority
    567            NVIC_SetPriority(NVM_IRQn,       LOW_PRIORITY);
   \   00000024   0x2103             MOVS     R1,#+3
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x.... 0x....      BL       NVIC_SetPriority
    568            NVIC_SetPriority(UART_IRQn,      LOW_PRIORITY);
   \   0000002C   0x2103             MOVS     R1,#+3
   \   0000002E   0x2004             MOVS     R0,#+4
   \   00000030   0x.... 0x....      BL       NVIC_SetPriority
    569            NVIC_SetPriority(SPI_IRQn,       LOW_PRIORITY);
   \   00000034   0x2103             MOVS     R1,#+3
   \   00000036   0x2005             MOVS     R0,#+5
   \   00000038   0x.... 0x....      BL       NVIC_SetPriority
    570            NVIC_SetPriority(BLUE_CTRL_IRQn, CRITICAL_PRIORITY);
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x2006             MOVS     R0,#+6
   \   00000040   0x.... 0x....      BL       NVIC_SetPriority
    571            NVIC_SetPriority(WDG_IRQn,       LOW_PRIORITY);
   \   00000044   0x2103             MOVS     R1,#+3
   \   00000046   0x2007             MOVS     R0,#+7
   \   00000048   0x.... 0x....      BL       NVIC_SetPriority
    572            NVIC_SetPriority(ADC_IRQn,       LOW_PRIORITY);
   \   0000004C   0x2103             MOVS     R1,#+3
   \   0000004E   0x200D             MOVS     R0,#+13
   \   00000050   0x.... 0x....      BL       NVIC_SetPriority
    573            NVIC_SetPriority(I2C2_IRQn,      LOW_PRIORITY);
   \   00000054   0x2103             MOVS     R1,#+3
   \   00000056   0x200E             MOVS     R0,#+14
   \   00000058   0x.... 0x....      BL       NVIC_SetPriority
    574            NVIC_SetPriority(I2C1_IRQn,      LOW_PRIORITY);
   \   0000005C   0x2103             MOVS     R1,#+3
   \   0000005E   0x200F             MOVS     R0,#+15
   \   00000060   0x.... 0x....      BL       NVIC_SetPriority
    575            NVIC_SetPriority(MFT1A_IRQn,    LOW_PRIORITY);
   \   00000064   0x2103             MOVS     R1,#+3
   \   00000066   0x2011             MOVS     R0,#+17
   \   00000068   0x.... 0x....      BL       NVIC_SetPriority
    576            NVIC_SetPriority(MFT1B_IRQn,    LOW_PRIORITY);
   \   0000006C   0x2103             MOVS     R1,#+3
   \   0000006E   0x2012             MOVS     R0,#+18
   \   00000070   0x.... 0x....      BL       NVIC_SetPriority
    577            NVIC_SetPriority(MFT2A_IRQn,    LOW_PRIORITY);
   \   00000074   0x2103             MOVS     R1,#+3
   \   00000076   0x2013             MOVS     R0,#+19
   \   00000078   0x.... 0x....      BL       NVIC_SetPriority
    578            NVIC_SetPriority(MFT2B_IRQn,    LOW_PRIORITY);
   \   0000007C   0x2103             MOVS     R1,#+3
   \   0000007E   0x2014             MOVS     R0,#+20
   \   00000080   0x.... 0x....      BL       NVIC_SetPriority
    579            NVIC_SetPriority(RTC_IRQn,       LOW_PRIORITY);
   \   00000084   0x2103             MOVS     R1,#+3
   \   00000086   0x2015             MOVS     R0,#+21
   \   00000088   0x.... 0x....      BL       NVIC_SetPriority
    580            NVIC_SetPriority(PKA_IRQn,       LOW_PRIORITY);
   \   0000008C   0x2103             MOVS     R1,#+3
   \   0000008E   0x2016             MOVS     R0,#+22
   \   00000090   0x.... 0x....      BL       NVIC_SetPriority
    581            NVIC_SetPriority(DMA_IRQn,       LOW_PRIORITY);
   \   00000094   0x2103             MOVS     R1,#+3
   \   00000096   0x2017             MOVS     R0,#+23
   \   00000098   0x.... 0x....      BL       NVIC_SetPriority
    582          
    583            /* Device Configuration */
    584            DeviceConfiguration(TRUE, TRUE);
   \   0000009C   0x2101             MOVS     R1,#+1
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0x.... 0x....      BL       DeviceConfiguration
    585            /* Disable all the peripherals clock except NVM, SYSCTR, PKA and RNG */
    586            CKGEN_SOC->CLOCK_EN = 0xE0066;
   \   000000A4   0x....             LDR      R0,??DataTable4_10  ;; 0xe0066
   \   000000A6   0x....             LDR      R1,??DataTable4_11  ;; 0x40900020
   \   000000A8   0x6008             STR      R0,[R1, #+0]
    587            __enable_irq();
   \   000000AA   0xB662             CPSIE    I
    588          }
   \   000000AC   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0xE000ED1C         DC32     0xe000ed1c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0xE000E400         DC32     0xe000e400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x40900008         DC32     0x40900008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x48100008         DC32     0x48100008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x........         DC32     wakeupFromSleepFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x4800000C         DC32     0x4800000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x100007E4         DC32     0x100007e4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0x0000AA55         DC32     0xaa55

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   0x4810000C         DC32     0x4810000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   0x40100004         DC32     0x40100004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \   00000000   0x000E0066         DC32     0xe0066

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_11:
   \   00000000   0x40900020         DC32     0x40900020

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x02 0x3F          DC8 2, 63, 0, 2, 62, 48, 2, 60, 32, 2, 59, 76, 2, 58, 64, 2, 57, 178, 2
   \              0x00 0x02    
   \              0x3E 0x30    
   \              0x02 0x3C    
   \              0x20 0x02    
   \              0x3B 0x4C    
   \              0x02 0x3A    
   \              0x40 0x02    
   \              0x39 0xB2    
   \              0x02         
   \   00000013   0x34 0x5B          DC8 52, 91, 2, 53, 11, 0, 0, 0, 0
   \              0x02 0x35    
   \              0x0B 0x00    
   \              0x00 0x00    
   \              0x00         
    589          
    590          
    591          /******************* (C) COPYRIGHT 2015 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   ADC_Handler
       0   ADV_Handler
       0   BATTERY_LOW_Handler
       0   Blue_Handler
       0   DMA_Handler
      48   DeviceConfiguration
        48   -> __aeabi_memcpy4
       0   GPIO_Handler
       0   HardFault_Handler
       0   I2C1_Handler
       0   I2C2_Handler
       0   MFT1A_Handler
       0   MFT1B_Handler
       0   MFT2A_Handler
       0   MFT2B_Handler
       0   NMI_Handler
       8   NVIC_SetPriority
       0   NVM_Handler
       0   PKA_Handler
       0   PendSV_Handler
       0   RTC_Handler
       0   SPI_Handler
       0   SVC_Handler
       0   SysTick_Handler
       8   SystemInit
         8   -> DeviceConfiguration
         8   -> NVIC_SetPriority
       0   UART_Handler
       0   WDG_Handler
       8   __low_level_init
         8   -> CS_contextRestore


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
      28  ?_0
       2  ADC_Handler
       2  ADV_Handler
       2  BATTERY_LOW_Handler
       2  Blue_Handler
       2  DMA_Handler
     162  DeviceConfiguration
       2  GPIO_Handler
       2  HardFault_Handler
       2  I2C1_Handler
       2  I2C2_Handler
       2  MFT1A_Handler
       2  MFT1B_Handler
       2  MFT2A_Handler
       2  MFT2B_Handler
       2  NMI_Handler
      52  NVIC_SetPriority
       2  NVM_Handler
       2  PKA_Handler
       2  PendSV_Handler
       2  RTC_Handler
       2  SPI_Handler
       2  SVC_Handler
       2  SysTick_Handler
     174  SystemInit
       2  UART_Handler
       2  WDG_Handler
     524  __blue_RAM
       4  __blueflag_RAM
      34  __low_level_init
     192  __vector_table
       4  app_base
       4  ota_sw_activation
       4  savedICSR
       4  savedMSP
       4  savedNVIC_ISPR
       4  savedSHCSR
       1  wakeupFromSleepFlag

 
   4 bytes in section .__blueflag_RAM
   4 bytes in section .app_base
  12 bytes in section .bss
 524 bytes in section .bss.__blue_RAM
 192 bytes in section .intvec
   4 bytes in section .ota_sw_activation
   4 bytes in section .savedMSP
 544 bytes in section .text
   1 byte  in section .wakeupFromSleepFlag
 
 498 bytes of CODE  memory (+ 46 bytes shared)
 192 bytes of CONST memory
 553 bytes of DATA  memory

Errors: none
Warnings: none
