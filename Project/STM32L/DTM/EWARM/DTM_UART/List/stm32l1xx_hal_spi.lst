###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       29/Jan/2018  14:45:27
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_spi.c
#    Command line =  
#        "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_spi.c"
#        -D STM32L151xB -D STM32L1XX_XL -D USE_STM32L1XX_STEVAL_IDB00xV1 -D
#        USE_HAL_DRIVER -D HCLK_32MHZ=1 -D SYSCLK_MSI=1 -D ENABLE_USART -D
#        USER_DEFINED_PLATFORM=USER_EVAL_PLATFORM -D IRQ_RESET_PIN -D DTM_UART
#        -lC "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\List"
#        -o "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        D:\Software\IAR_BlueNRG\arm\INC\c\DLib_Config_Normal.h -I
#        "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\HAL\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\BSP\STM32L1xx_BlueNRG1\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\BSP\STM32L1xx_Nucleo\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\CMSIS\Device\ST\STM32L1xx\Include\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\STM32L1xx_HAL_BlueNRG1_Drivers\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\SimpleBlueNRG1_HCI\includes\"
#        -On --use_c++_inline -I D:\Software\IAR_BlueNRG\arm\CMSIS\Include\
#    Locale       =  Chinese (Simplified)_China.936
#    List file    =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\List\stm32l1xx_hal_spi.lst
#    Object file  =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\Obj\stm32l1xx_hal_spi.o
#
###############################################################################

C:\Users\Administrator\Desktop\Temporary Files\eeworld_project\Project_Test\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_spi.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_hal_spi.c
      4            * @author  MCD Application Team
      5            * @version V1.1.1
      6            * @date    31-March-2015
      7            * @brief   SPI HAL module driver.
      8            *    
      9            *          This file provides firmware functions to manage the following 
     10            *          functionalities of the Serial Peripheral Interface (SPI) peripheral:
     11            *           + Initialization and de-initialization functions
     12            *           + IO operation functions
     13            *           + Peripheral Control functions 
     14            *           + Peripheral State functions
     15            @verbatim
     16            ==============================================================================
     17                                  ##### How to use this driver #####
     18            ==============================================================================
     19              [..]
     20                The SPI HAL driver can be used as follows:
     21          
     22                (#) Declare a SPI_HandleTypeDef handle structure, for example:
     23                    SPI_HandleTypeDef  hspi; 
     24          
     25                (#)Initialize the SPI low level resources by implementing the HAL_SPI_MspInit ()API:
     26                    (##) Enable the SPIx interface clock 
     27                    (##) SPI pins configuration
     28                        (+++) Enable the clock for the SPI GPIOs 
     29                        (+++) Configure these SPI pins as alternate function push-pull
     30                    (##) NVIC configuration if you need to use interrupt process
     31                        (+++) Configure the SPIx interrupt priority
     32                        (+++) Enable the NVIC SPI IRQ handle
     33                    (##) DMA Configuration if you need to use DMA process
     34                        (+++) Declare a DMA_HandleTypeDef handle structure for the transmit or receive Channel
     35                        (+++) Enable the DMAx clock
     36                        (+++) Configure the DMA handle parameters 
     37                        (+++) Configure the DMA Tx or Rx Channel
     38                        (+++) Associate the initilalized hdma_tx(or _rx) handle to the hspi DMA Tx (or Rx) handle
     39                        (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on the DMA Tx or Rx Channel
     40          
     41                (#) Program the Mode, Direction , Data size, Baudrate Prescaler, NSS 
     42                    management, Clock polarity and phase, FirstBit and CRC configuration in the hspi Init structure.
     43          
     44                (#) Initialize the SPI registers by calling the HAL_SPI_Init() API:
     45                    (++) This API configures also the low level Hardware GPIO, CLOCK, CORTEX...etc)
     46                        by calling the customed HAL_SPI_MspInit() API.
     47               [..]
     48                 Circular mode restriction:
     49                (#) The DMA circular mode cannot be used when the SPI is configured in these modes:
     50                    (##) Master 2Lines RxOnly
     51                    (##) Master 1Line Rx
     52                (#) The CRC feature is not managed when the DMA circular mode is enabled
     53                (#) When the SPI DMA Pause/Stop features are used, we must use the following APIs 
     54                    the HAL_SPI_DMAPause()/ HAL_SPI_DMAStop() only under the SPI callbacks
     55          
     56          
     57                      
     58            @endverbatim
     59            ******************************************************************************
     60            * @attention
     61            *
     62            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     63            *
     64            * Redistribution and use in source and binary forms, with or without modification,
     65            * are permitted provided that the following conditions are met:
     66            *   1. Redistributions of source code must retain the above copyright notice,
     67            *      this list of conditions and the following disclaimer.
     68            *   2. Redistributions in binary form must reproduce the above copyright notice,
     69            *      this list of conditions and the following disclaimer in the documentation
     70            *      and/or other materials provided with the distribution.
     71            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     72            *      may be used to endorse or promote products derived from this software
     73            *      without specific prior written permission.
     74            *
     75            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     76            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     77            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     78            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     79            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     80            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     81            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     82            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     83            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     84            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     85            *
     86            ******************************************************************************
     87            */
     88          
     89          /* Includes ------------------------------------------------------------------*/
     90          #include "stm32l1xx_hal.h"
     91          
     92          /** @addtogroup STM32L1xx_HAL_Driver
     93            * @{
     94            */
     95          
     96          /** @defgroup SPI SPI
     97            * @brief SPI HAL module driver
     98            * @{
     99            */
    100          
    101          #ifdef HAL_SPI_MODULE_ENABLED
    102          
    103          /* Private typedef -----------------------------------------------------------*/
    104          /* Private define ------------------------------------------------------------*/
    105          /** @defgroup SPI_Private_Constants SPI Private Constants
    106            * @{
    107            */
    108          #define SPI_TIMEOUT_VALUE  10
    109          /**
    110            * @}
    111            */
    112          
    113          /* Private macro -------------------------------------------------------------*/
    114          /* Private variables ---------------------------------------------------------*/
    115          /* Private function prototypes -----------------------------------------------*/
    116          /** @defgroup SPI_Private_Functions SPI Private Functions
    117            * @{
    118            */
    119          
    120          static void SPI_TxCloseIRQHandler(struct __SPI_HandleTypeDef *hspi);
    121          static void SPI_TxISR(struct __SPI_HandleTypeDef *hspi);
    122          static void SPI_RxCloseIRQHandler(struct __SPI_HandleTypeDef *hspi);
    123          static void SPI_2LinesRxISR(struct __SPI_HandleTypeDef *hspi);
    124          static void SPI_RxISR(struct __SPI_HandleTypeDef *hspi);
    125          static void SPI_DMATransmitCplt(struct __DMA_HandleTypeDef *hdma);
    126          static void SPI_DMAReceiveCplt(struct __DMA_HandleTypeDef *hdma);
    127          static void SPI_DMATransmitReceiveCplt(struct __DMA_HandleTypeDef *hdma);
    128          static void SPI_DMAHalfTransmitCplt(struct __DMA_HandleTypeDef *hdma);
    129          static void SPI_DMAHalfReceiveCplt(struct __DMA_HandleTypeDef *hdma);
    130          static void SPI_DMAHalfTransmitReceiveCplt(struct __DMA_HandleTypeDef *hdma);
    131          static void SPI_DMAError(struct __DMA_HandleTypeDef *hdma);
    132          static HAL_StatusTypeDef SPI_WaitOnFlagUntilTimeout(struct __SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus Status, uint32_t Timeout);
    133          /**
    134            * @}
    135            */
    136          
    137          /* Exported functions ---------------------------------------------------------*/
    138          
    139          /** @defgroup SPI_Exported_Functions SPI Exported Functions
    140            * @{
    141            */
    142          
    143          /** @defgroup SPI_Exported_Functions_Group1 Initialization and de-initialization functions 
    144           *  @brief    Initialization and Configuration functions 
    145           *
    146          @verbatim
    147           ===============================================================================
    148                        ##### Initialization and de-initialization functions #####
    149           ===============================================================================
    150              [..]  This subsection provides a set of functions allowing to initialize and 
    151                    de-initialiaze the SPIx peripheral:
    152          
    153                (+) User must implement HAL_SPI_MspInit() function in which he configures 
    154                    all related peripherals resources (CLOCK, GPIO, DMA, IT and NVIC ).
    155          
    156                (+) Call the function HAL_SPI_Init() to configure the selected device with 
    157                    the selected configuration:
    158                  (++) Mode
    159                  (++) Direction 
    160                  (++) Data Size
    161                  (++) Clock Polarity and Phase
    162                  (++) NSS Management
    163                  (++) BaudRate Prescaler
    164                  (++) FirstBit
    165                  (++) TIMode
    166                  (++) CRC Calculation
    167                  (++) CRC Polynomial if CRC enabled
    168          
    169                (+) Call the function HAL_SPI_DeInit() to restore the default configuration 
    170                    of the selected SPIx periperal.       
    171          
    172          @endverbatim
    173            * @{
    174            */
    175          
    176          /**
    177            * @brief  Initializes the SPI according to the specified parameters 
    178            *         in the SPI_InitTypeDef and create the associated handle.
    179            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    180            *                the configuration information for SPI module.
    181            * @retval HAL status
    182            */

   \                                 In section .text, align 2
    183          __weak HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
    184          {
   \                     HAL_SPI_Init: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    185            return HAL_ERROR;
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x4770             BX       LR               ;; return
    186          }
    187          
    188          /**
    189            * @brief  DeInitializes the SPI peripheral 
    190            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    191            *                the configuration information for SPI module.
    192            * @retval HAL status
    193            */

   \                                 In section .text, align 2, keep-with-next
    194          HAL_StatusTypeDef HAL_SPI_DeInit(SPI_HandleTypeDef *hspi)
    195          {
   \                     HAL_SPI_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    196            /* Check the SPI handle allocation */
    197            if(hspi == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_SPI_DeInit_0
    198            {
    199              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE011             B.N      ??HAL_SPI_DeInit_1
    200            }
    201          
    202            /* Disable the SPI Peripheral Clock */
    203            __HAL_SPI_DISABLE(hspi);
   \                     ??HAL_SPI_DeInit_0: (+1)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF030 0x0040      BICS     R0,R0,#0x40
   \   00000014   0x6821             LDR      R1,[R4, #+0]
   \   00000016   0x6008             STR      R0,[R1, #+0]
    204          
    205            /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
    206            HAL_SPI_MspDeInit(hspi);
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       HAL_SPI_MspDeInit
    207          
    208            hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x6560             STR      R0,[R4, #+84]
    209            hspi->State = HAL_SPI_STATE_RESET;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xF884 0x0051      STRB     R0,[R4, #+81]
    210          
    211            /* Release Lock */
    212            __HAL_UNLOCK(hspi);
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF884 0x0050      STRB     R0,[R4, #+80]
    213          
    214            return HAL_OK;
   \   0000002E   0x2000             MOVS     R0,#+0
   \                     ??HAL_SPI_DeInit_1: (+1)
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    215          }
    216          
    217          /**
    218            * @brief SPI MSP Init
    219            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    220            *                the configuration information for SPI module.
    221            * @retval None
    222            */

   \                                 In section .text, align 2
    223           __weak void HAL_SPI_MspInit(SPI_HandleTypeDef *hspi)
    224           {
    225             /* NOTE : This function Should not be modified, when the callback is needed,
    226                      the HAL_SPI_MspInit could be implenetd in the user file
    227             */
    228          }
   \                     HAL_SPI_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    229          
    230          /**
    231            * @brief SPI MSP DeInit
    232            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    233            *                the configuration information for SPI module.
    234            * @retval None
    235            */

   \                                 In section .text, align 2
    236           __weak void HAL_SPI_MspDeInit(SPI_HandleTypeDef *hspi)
    237          {
    238            /* NOTE : This function Should not be modified, when the callback is needed,
    239                      the HAL_SPI_MspDeInit could be implenetd in the user file
    240             */
    241          }
   \                     HAL_SPI_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    242          
    243          /**
    244            * @}
    245            */
    246          
    247          /** @defgroup SPI_Exported_Functions_Group2 IO operation functions
    248           *  @brief   Data transfers functions
    249           *
    250          @verbatim
    251            ==============================================================================
    252                                ##### IO operation functions #####
    253           ===============================================================================
    254              This subsection provides a set of functions allowing to manage the SPI
    255              data transfers.
    256          
    257              [..] The SPI supports master and slave mode :
    258          
    259              (#) There are two modes of transfer:
    260                 (++) Blocking mode: The communication is performed in polling mode.
    261                      The HAL status of all data processing is returned by the same function
    262                      after finishing transfer.
    263                 (++) No-Blocking mode: The communication is performed using Interrupts
    264                      or DMA, These APIs return the HAL status.
    265                      The end of the data processing will be indicated through the 
    266                      dedicated SPI IRQ when using Interrupt mode or the DMA IRQ when 
    267                      using DMA mode.
    268                      The HAL_SPI_TxCpltCallback(), HAL_SPI_RxCpltCallback() and HAL_SPI_TxRxCpltCallback() user callbacks 
    269                      will be executed respectivelly at the end of the transmit or Receive process
    270                      The HAL_SPI_ErrorCallback()user callback will be executed when a communication error is detected
    271          
    272              (#) APIs provided for these 2 transfer modes (Blocking mode or Non blocking mode using either Interrupt or DMA)
    273                  exist for 1Line (simplex) and 2Lines (full duplex) modes.
    274          
    275          @endverbatim
    276            * @{
    277            */
    278          
    279          /**
    280            * @brief  Transmit an amount of data in blocking mode
    281            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    282            *                the configuration information for SPI module.
    283            * @param  pData: pointer to data buffer
    284            * @param  Size: amount of data to be sent
    285            * @param  Timeout: Timeout duration
    286            * @retval HAL status
    287            */

   \                                 In section .text, align 2, keep-with-next
    288          HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    289          {
   \                     HAL_SPI_Transmit: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    290          
    291            if(hspi->State == HAL_SPI_STATE_READY)
   \   0000000A   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xF040 0x80DA      BNE.W    ??HAL_SPI_Transmit_0
    292            {
    293              if((pData == NULL ) || (Size == 0)) 
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD002             BEQ.N    ??HAL_SPI_Transmit_1
   \   00000018   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xD101             BNE.N    ??HAL_SPI_Transmit_2
    294              {
    295                return  HAL_ERROR;
   \                     ??HAL_SPI_Transmit_1: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE0D3             B.N      ??HAL_SPI_Transmit_3
    296              }
    297          
    298              /* Check the parameters */
    299              assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
    300          
    301              /* Process Locked */
    302              __HAL_LOCK(hspi);
   \                     ??HAL_SPI_Transmit_2: (+1)
   \   00000022   0xF894 0x0050      LDRB     R0,[R4, #+80]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD101             BNE.N    ??HAL_SPI_Transmit_4
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0xE0CD             B.N      ??HAL_SPI_Transmit_3
   \                     ??HAL_SPI_Transmit_4: (+1)
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF884 0x0050      STRB     R0,[R4, #+80]
    303          
    304              /* Configure communication */
    305              hspi->State = HAL_SPI_STATE_BUSY_TX;
   \   00000034   0x2012             MOVS     R0,#+18
   \   00000036   0xF884 0x0051      STRB     R0,[R4, #+81]
    306              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x6560             STR      R0,[R4, #+84]
    307          
    308              hspi->pTxBuffPtr  = pData;
   \   0000003E   0x6325             STR      R5,[R4, #+48]
    309              hspi->TxXferSize  = Size;
   \   00000040   0x86A6             STRH     R6,[R4, #+52]
    310              hspi->TxXferCount = Size;
   \   00000042   0x86E6             STRH     R6,[R4, #+54]
    311          
    312              /*Init field not used in handle to zero */
    313              hspi->TxISR = 0;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x64E0             STR      R0,[R4, #+76]
    314              hspi->RxISR = 0;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x64A0             STR      R0,[R4, #+72]
    315              hspi->pRxBuffPtr  = NULL;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x63A0             STR      R0,[R4, #+56]
    316              hspi->RxXferSize  = 0;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x87A0             STRH     R0,[R4, #+60]
    317              hspi->RxXferCount = 0;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x87E0             STRH     R0,[R4, #+62]
    318          
    319              /* Reset CRC Calculation */
    320              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000058   0x6AA0             LDR      R0,[R4, #+40]
   \   0000005A   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000005E   0xD10B             BNE.N    ??HAL_SPI_Transmit_5
    321              {
    322                SPI_RESET_CRC(hspi);
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   00000068   0x6821             LDR      R1,[R4, #+0]
   \   0000006A   0x6008             STR      R0,[R1, #+0]
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   00000074   0x6821             LDR      R1,[R4, #+0]
   \   00000076   0x6008             STR      R0,[R1, #+0]
    323              }
    324          
    325              if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \                     ??HAL_SPI_Transmit_5: (+1)
   \   00000078   0x68A0             LDR      R0,[R4, #+8]
   \   0000007A   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000007E   0xD105             BNE.N    ??HAL_SPI_Transmit_6
    326              {
    327                /* Configure communication direction : 1Line */
    328                SPI_1LINE_TX(hspi);
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   00000088   0x6821             LDR      R1,[R4, #+0]
   \   0000008A   0x6008             STR      R0,[R1, #+0]
    329              }
    330          
    331              /* Check if the SPI is already enabled */ 
    332              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \                     ??HAL_SPI_Transmit_6: (+1)
   \   0000008C   0x6820             LDR      R0,[R4, #+0]
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0x0640             LSLS     R0,R0,#+25
   \   00000092   0xD405             BMI.N    ??HAL_SPI_Transmit_7
    333              {
    334                /* Enable SPI peripheral */
    335                __HAL_SPI_ENABLE(hspi);
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x6800             LDR      R0,[R0, #+0]
   \   00000098   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000009C   0x6821             LDR      R1,[R4, #+0]
   \   0000009E   0x6008             STR      R0,[R1, #+0]
    336              }
    337          
    338              /* Transmit data in 8 Bit mode */
    339              if(hspi->Init.DataSize == SPI_DATASIZE_8BIT)
   \                     ??HAL_SPI_Transmit_7: (+1)
   \   000000A0   0x68E0             LDR      R0,[R4, #+12]
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD130             BNE.N    ??HAL_SPI_Transmit_8
    340              {
    341                if((hspi->Init.Mode == SPI_MODE_SLAVE)|| (hspi->TxXferCount == 0x01))
   \   000000A6   0x6860             LDR      R0,[R4, #+4]
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD002             BEQ.N    ??HAL_SPI_Transmit_9
   \   000000AC   0x8EE0             LDRH     R0,[R4, #+54]
   \   000000AE   0x2801             CMP      R0,#+1
   \   000000B0   0xD108             BNE.N    ??HAL_SPI_Transmit_10
    342                {
    343                  hspi->Instance->DR = (*hspi->pTxBuffPtr++);
   \                     ??HAL_SPI_Transmit_9: (+1)
   \   000000B2   0x6B20             LDR      R0,[R4, #+48]
   \   000000B4   0x1C41             ADDS     R1,R0,#+1
   \   000000B6   0x6321             STR      R1,[R4, #+48]
   \   000000B8   0x7800             LDRB     R0,[R0, #+0]
   \   000000BA   0x6821             LDR      R1,[R4, #+0]
   \   000000BC   0x60C8             STR      R0,[R1, #+12]
    344                  hspi->TxXferCount--;
   \   000000BE   0x8EE0             LDRH     R0,[R4, #+54]
   \   000000C0   0x1E40             SUBS     R0,R0,#+1
   \   000000C2   0x86E0             STRH     R0,[R4, #+54]
    345                }
    346                while(hspi->TxXferCount > 0)
   \                     ??HAL_SPI_Transmit_10: (+1)
   \   000000C4   0x8EE0             LDRH     R0,[R4, #+54]
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD013             BEQ.N    ??HAL_SPI_Transmit_11
    347                {
    348                  /* Wait until TXE flag is set to send data */
    349                  if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, Timeout) != HAL_OK)
   \   000000CA   0x003B             MOVS     R3,R7
   \   000000CC   0x2200             MOVS     R2,#+0
   \   000000CE   0x2102             MOVS     R1,#+2
   \   000000D0   0x0020             MOVS     R0,R4
   \   000000D2   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   000000D6   0x2800             CMP      R0,#+0
   \   000000D8   0xD001             BEQ.N    ??HAL_SPI_Transmit_12
    350                  { 
    351                    return HAL_TIMEOUT;
   \   000000DA   0x2003             MOVS     R0,#+3
   \   000000DC   0xE075             B.N      ??HAL_SPI_Transmit_3
    352                  }
    353                  hspi->Instance->DR = (*hspi->pTxBuffPtr++);
   \                     ??HAL_SPI_Transmit_12: (+1)
   \   000000DE   0x6B20             LDR      R0,[R4, #+48]
   \   000000E0   0x1C41             ADDS     R1,R0,#+1
   \   000000E2   0x6321             STR      R1,[R4, #+48]
   \   000000E4   0x7800             LDRB     R0,[R0, #+0]
   \   000000E6   0x6821             LDR      R1,[R4, #+0]
   \   000000E8   0x60C8             STR      R0,[R1, #+12]
    354                  hspi->TxXferCount--;
   \   000000EA   0x8EE0             LDRH     R0,[R4, #+54]
   \   000000EC   0x1E40             SUBS     R0,R0,#+1
   \   000000EE   0x86E0             STRH     R0,[R4, #+54]
   \   000000F0   0xE7E8             B.N      ??HAL_SPI_Transmit_10
    355                }
    356                /* Enable CRC Transmission */
    357                if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE) 
   \                     ??HAL_SPI_Transmit_11: (+1)
   \   000000F2   0x6AA0             LDR      R0,[R4, #+40]
   \   000000F4   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000000F8   0xD138             BNE.N    ??HAL_SPI_Transmit_13
    358                {
    359                  SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   \   000000FA   0x6820             LDR      R0,[R4, #+0]
   \   000000FC   0x6800             LDR      R0,[R0, #+0]
   \   000000FE   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   00000102   0x6821             LDR      R1,[R4, #+0]
   \   00000104   0x6008             STR      R0,[R1, #+0]
   \   00000106   0xE031             B.N      ??HAL_SPI_Transmit_13
    360                }
    361              }
    362              /* Transmit data in 16 Bit mode */
    363              else
    364              {
    365                if((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01))
   \                     ??HAL_SPI_Transmit_8: (+1)
   \   00000108   0x6860             LDR      R0,[R4, #+4]
   \   0000010A   0x2800             CMP      R0,#+0
   \   0000010C   0xD002             BEQ.N    ??HAL_SPI_Transmit_14
   \   0000010E   0x8EE0             LDRH     R0,[R4, #+54]
   \   00000110   0x2801             CMP      R0,#+1
   \   00000112   0xD109             BNE.N    ??HAL_SPI_Transmit_15
    366                {
    367                  hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
   \                     ??HAL_SPI_Transmit_14: (+1)
   \   00000114   0x6B20             LDR      R0,[R4, #+48]
   \   00000116   0x8800             LDRH     R0,[R0, #+0]
   \   00000118   0x6821             LDR      R1,[R4, #+0]
   \   0000011A   0x60C8             STR      R0,[R1, #+12]
    368                  hspi->pTxBuffPtr+=2;
   \   0000011C   0x6B20             LDR      R0,[R4, #+48]
   \   0000011E   0x1C80             ADDS     R0,R0,#+2
   \   00000120   0x6320             STR      R0,[R4, #+48]
    369                  hspi->TxXferCount--;
   \   00000122   0x8EE0             LDRH     R0,[R4, #+54]
   \   00000124   0x1E40             SUBS     R0,R0,#+1
   \   00000126   0x86E0             STRH     R0,[R4, #+54]
    370                }
    371                while(hspi->TxXferCount > 0)
   \                     ??HAL_SPI_Transmit_15: (+1)
   \   00000128   0x8EE0             LDRH     R0,[R4, #+54]
   \   0000012A   0x2800             CMP      R0,#+0
   \   0000012C   0xD014             BEQ.N    ??HAL_SPI_Transmit_16
    372                {
    373                  /* Wait until TXE flag is set to send data */
    374                  if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, Timeout) != HAL_OK)
   \   0000012E   0x003B             MOVS     R3,R7
   \   00000130   0x2200             MOVS     R2,#+0
   \   00000132   0x2102             MOVS     R1,#+2
   \   00000134   0x0020             MOVS     R0,R4
   \   00000136   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   0000013A   0x2800             CMP      R0,#+0
   \   0000013C   0xD001             BEQ.N    ??HAL_SPI_Transmit_17
    375                  { 
    376                    return HAL_TIMEOUT;
   \   0000013E   0x2003             MOVS     R0,#+3
   \   00000140   0xE043             B.N      ??HAL_SPI_Transmit_3
    377                  }
    378                  hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
   \                     ??HAL_SPI_Transmit_17: (+1)
   \   00000142   0x6B20             LDR      R0,[R4, #+48]
   \   00000144   0x8800             LDRH     R0,[R0, #+0]
   \   00000146   0x6821             LDR      R1,[R4, #+0]
   \   00000148   0x60C8             STR      R0,[R1, #+12]
    379                  hspi->pTxBuffPtr+=2;
   \   0000014A   0x6B20             LDR      R0,[R4, #+48]
   \   0000014C   0x1C80             ADDS     R0,R0,#+2
   \   0000014E   0x6320             STR      R0,[R4, #+48]
    380                  hspi->TxXferCount--;
   \   00000150   0x8EE0             LDRH     R0,[R4, #+54]
   \   00000152   0x1E40             SUBS     R0,R0,#+1
   \   00000154   0x86E0             STRH     R0,[R4, #+54]
   \   00000156   0xE7E7             B.N      ??HAL_SPI_Transmit_15
    381                }
    382                /* Enable CRC Transmission */
    383                if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE) 
   \                     ??HAL_SPI_Transmit_16: (+1)
   \   00000158   0x6AA0             LDR      R0,[R4, #+40]
   \   0000015A   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000015E   0xD105             BNE.N    ??HAL_SPI_Transmit_13
    384                {
    385                  SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   \   00000160   0x6820             LDR      R0,[R4, #+0]
   \   00000162   0x6800             LDR      R0,[R0, #+0]
   \   00000164   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   00000168   0x6821             LDR      R1,[R4, #+0]
   \   0000016A   0x6008             STR      R0,[R1, #+0]
    386                }
    387              }
    388          
    389              /* Wait until TXE flag is set to send data */
    390              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, Timeout) != HAL_OK)
   \                     ??HAL_SPI_Transmit_13: (+1)
   \   0000016C   0x003B             MOVS     R3,R7
   \   0000016E   0x2200             MOVS     R2,#+0
   \   00000170   0x2102             MOVS     R1,#+2
   \   00000172   0x0020             MOVS     R0,R4
   \   00000174   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000178   0x2800             CMP      R0,#+0
   \   0000017A   0xD005             BEQ.N    ??HAL_SPI_Transmit_18
    391              {
    392                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   0000017C   0x6D60             LDR      R0,[R4, #+84]
   \   0000017E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000182   0x6560             STR      R0,[R4, #+84]
    393                return HAL_TIMEOUT;
   \   00000184   0x2003             MOVS     R0,#+3
   \   00000186   0xE020             B.N      ??HAL_SPI_Transmit_3
    394              }
    395          
    396              /* Wait until Busy flag is reset before disabling SPI */
    397              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_BSY, SET, Timeout) != HAL_OK)
   \                     ??HAL_SPI_Transmit_18: (+1)
   \   00000188   0x003B             MOVS     R3,R7
   \   0000018A   0x2201             MOVS     R2,#+1
   \   0000018C   0x2180             MOVS     R1,#+128
   \   0000018E   0x0020             MOVS     R0,R4
   \   00000190   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000194   0x2800             CMP      R0,#+0
   \   00000196   0xD005             BEQ.N    ??HAL_SPI_Transmit_19
    398              { 
    399                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   00000198   0x6D60             LDR      R0,[R4, #+84]
   \   0000019A   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000019E   0x6560             STR      R0,[R4, #+84]
    400                return HAL_TIMEOUT;
   \   000001A0   0x2003             MOVS     R0,#+3
   \   000001A2   0xE012             B.N      ??HAL_SPI_Transmit_3
    401              }
    402           
    403              /* Clear OVERUN flag in 2 Lines communication mode because received is not read */
    404              if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \                     ??HAL_SPI_Transmit_19: (+1)
   \   000001A4   0x68A0             LDR      R0,[R4, #+8]
   \   000001A6   0x2800             CMP      R0,#+0
   \   000001A8   0xD106             BNE.N    ??HAL_SPI_Transmit_20
    405              {
    406                __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \   000001AA   0x6820             LDR      R0,[R4, #+0]
   \   000001AC   0x68C0             LDR      R0,[R0, #+12]
   \   000001AE   0x9000             STR      R0,[SP, #+0]
   \   000001B0   0x6820             LDR      R0,[R4, #+0]
   \   000001B2   0x6880             LDR      R0,[R0, #+8]
   \   000001B4   0x9000             STR      R0,[SP, #+0]
   \   000001B6   0x9800             LDR      R0,[SP, #+0]
    407              }
    408          
    409              hspi->State = HAL_SPI_STATE_READY; 
   \                     ??HAL_SPI_Transmit_20: (+1)
   \   000001B8   0x2001             MOVS     R0,#+1
   \   000001BA   0xF884 0x0051      STRB     R0,[R4, #+81]
    410          
    411              /* Process Unlocked */
    412              __HAL_UNLOCK(hspi);
   \   000001BE   0x2000             MOVS     R0,#+0
   \   000001C0   0xF884 0x0050      STRB     R0,[R4, #+80]
    413          
    414              return HAL_OK;
   \   000001C4   0x2000             MOVS     R0,#+0
   \   000001C6   0xE000             B.N      ??HAL_SPI_Transmit_3
    415            }
    416            else
    417            {
    418              return HAL_BUSY;
   \                     ??HAL_SPI_Transmit_0: (+1)
   \   000001C8   0x2002             MOVS     R0,#+2
   \                     ??HAL_SPI_Transmit_3: (+1)
   \   000001CA   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    419            }
    420          }
    421          
    422          /**
    423            * @brief  Receive an amount of data in blocking mode 
    424            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    425            *                the configuration information for SPI module.
    426            * @param  pData: pointer to data buffer
    427            * @param  Size: amount of data to be sent
    428            * @param  Timeout: Timeout duration
    429            * @retval HAL status
    430            */

   \                                 In section .text, align 2, keep-with-next
    431          HAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    432          {
   \                     HAL_SPI_Receive: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    433            __IO uint16_t tmpreg = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    434          
    435            if(hspi->State == HAL_SPI_STATE_READY)
   \   00000012   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xF040 0x810D      BNE.W    ??HAL_SPI_Receive_0
    436            {
    437              if((pData == NULL ) || (Size == 0)) 
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD002             BEQ.N    ??HAL_SPI_Receive_1
   \   00000020   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000022   0x2E00             CMP      R6,#+0
   \   00000024   0xD101             BNE.N    ??HAL_SPI_Receive_2
    438              {
    439                return  HAL_ERROR;
   \                     ??HAL_SPI_Receive_1: (+1)
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE106             B.N      ??HAL_SPI_Receive_3
    440              }
    441          
    442              /* Process Locked */
    443              __HAL_LOCK(hspi);
   \                     ??HAL_SPI_Receive_2: (+1)
   \   0000002A   0xF894 0x0050      LDRB     R0,[R4, #+80]
   \   0000002E   0x2801             CMP      R0,#+1
   \   00000030   0xD101             BNE.N    ??HAL_SPI_Receive_4
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0xE100             B.N      ??HAL_SPI_Receive_3
   \                     ??HAL_SPI_Receive_4: (+1)
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xF884 0x0050      STRB     R0,[R4, #+80]
    444          
    445              /* Configure communication */
    446              hspi->State       = HAL_SPI_STATE_BUSY_RX;
   \   0000003C   0x2022             MOVS     R0,#+34
   \   0000003E   0xF884 0x0051      STRB     R0,[R4, #+81]
    447              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x6560             STR      R0,[R4, #+84]
    448          
    449              hspi->pRxBuffPtr  = pData;
   \   00000046   0x63A5             STR      R5,[R4, #+56]
    450              hspi->RxXferSize  = Size;
   \   00000048   0x87A6             STRH     R6,[R4, #+60]
    451              hspi->RxXferCount = Size;
   \   0000004A   0x87E6             STRH     R6,[R4, #+62]
    452          
    453              /*Init field not used in handle to zero */
    454              hspi->RxISR = 0;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x64A0             STR      R0,[R4, #+72]
    455              hspi->TxISR = 0;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x64E0             STR      R0,[R4, #+76]
    456              hspi->pTxBuffPtr  = NULL;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x6320             STR      R0,[R4, #+48]
    457              hspi->TxXferSize  = 0;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x86A0             STRH     R0,[R4, #+52]
    458              hspi->TxXferCount = 0;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x86E0             STRH     R0,[R4, #+54]
    459          
    460              /* Configure communication direction : 1Line */
    461              if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \   00000060   0x68A0             LDR      R0,[R4, #+8]
   \   00000062   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000066   0xD105             BNE.N    ??HAL_SPI_Receive_5
    462              {
    463                SPI_1LINE_RX(hspi);
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0xF430 0x4080      BICS     R0,R0,#0x4000
   \   00000070   0x6821             LDR      R1,[R4, #+0]
   \   00000072   0x6008             STR      R0,[R1, #+0]
    464              }
    465          
    466              /* Reset CRC Calculation */
    467              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Receive_5: (+1)
   \   00000074   0x6AA0             LDR      R0,[R4, #+40]
   \   00000076   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000007A   0xD10B             BNE.N    ??HAL_SPI_Receive_6
    468              {
    469                SPI_RESET_CRC(hspi);
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   00000084   0x6821             LDR      R1,[R4, #+0]
   \   00000086   0x6008             STR      R0,[R1, #+0]
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   00000090   0x6821             LDR      R1,[R4, #+0]
   \   00000092   0x6008             STR      R0,[R1, #+0]
    470              }
    471              
    472              if((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
   \                     ??HAL_SPI_Receive_6: (+1)
   \   00000094   0x6860             LDR      R0,[R4, #+4]
   \   00000096   0xF5B0 0x7F82      CMP      R0,#+260
   \   0000009A   0xD10E             BNE.N    ??HAL_SPI_Receive_7
   \   0000009C   0x68A0             LDR      R0,[R4, #+8]
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD10B             BNE.N    ??HAL_SPI_Receive_7
    473              {
    474                /* Process Unlocked */
    475                __HAL_UNLOCK(hspi);
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0xF884 0x0050      STRB     R0,[R4, #+80]
    476          
    477                /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
    478                return HAL_SPI_TransmitReceive(hspi, pData, pData, Size, Timeout);
   \   000000A8   0x9700             STR      R7,[SP, #+0]
   \   000000AA   0x0033             MOVS     R3,R6
   \   000000AC   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000AE   0x002A             MOVS     R2,R5
   \   000000B0   0x0029             MOVS     R1,R5
   \   000000B2   0x0020             MOVS     R0,R4
   \   000000B4   0x.... 0x....      BL       HAL_SPI_TransmitReceive
   \   000000B8   0xE0BE             B.N      ??HAL_SPI_Receive_3
    479              }
    480          
    481              /* Check if the SPI is already enabled */ 
    482              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \                     ??HAL_SPI_Receive_7: (+1)
   \   000000BA   0x6820             LDR      R0,[R4, #+0]
   \   000000BC   0x6800             LDR      R0,[R0, #+0]
   \   000000BE   0x0640             LSLS     R0,R0,#+25
   \   000000C0   0xD405             BMI.N    ??HAL_SPI_Receive_8
    483              {
    484                /* Enable SPI peripheral */
    485                __HAL_SPI_ENABLE(hspi);
   \   000000C2   0x6820             LDR      R0,[R4, #+0]
   \   000000C4   0x6800             LDR      R0,[R0, #+0]
   \   000000C6   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   000000CA   0x6821             LDR      R1,[R4, #+0]
   \   000000CC   0x6008             STR      R0,[R1, #+0]
    486              }
    487          
    488              /* Receive data in 8 Bit mode */
    489              if(hspi->Init.DataSize == SPI_DATASIZE_8BIT)
   \                     ??HAL_SPI_Receive_8: (+1)
   \   000000CE   0x68E0             LDR      R0,[R4, #+12]
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD121             BNE.N    ??HAL_SPI_Receive_9
    490              {
    491                while(hspi->RxXferCount > 1)
   \                     ??HAL_SPI_Receive_10: (+1)
   \   000000D4   0x8FE0             LDRH     R0,[R4, #+62]
   \   000000D6   0x2802             CMP      R0,#+2
   \   000000D8   0xDB13             BLT.N    ??HAL_SPI_Receive_11
    492                {
    493                  /* Wait until RXNE flag is set */
    494                  if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \   000000DA   0x003B             MOVS     R3,R7
   \   000000DC   0x2200             MOVS     R2,#+0
   \   000000DE   0x2101             MOVS     R1,#+1
   \   000000E0   0x0020             MOVS     R0,R4
   \   000000E2   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xD001             BEQ.N    ??HAL_SPI_Receive_12
    495                  { 
    496                    return HAL_TIMEOUT;
   \   000000EA   0x2003             MOVS     R0,#+3
   \   000000EC   0xE0A4             B.N      ??HAL_SPI_Receive_3
    497                  }
    498          
    499                  (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
   \                     ??HAL_SPI_Receive_12: (+1)
   \   000000EE   0x6BA0             LDR      R0,[R4, #+56]
   \   000000F0   0x1C41             ADDS     R1,R0,#+1
   \   000000F2   0x63A1             STR      R1,[R4, #+56]
   \   000000F4   0x6821             LDR      R1,[R4, #+0]
   \   000000F6   0x68C9             LDR      R1,[R1, #+12]
   \   000000F8   0x7001             STRB     R1,[R0, #+0]
    500                  hspi->RxXferCount--;
   \   000000FA   0x8FE0             LDRH     R0,[R4, #+62]
   \   000000FC   0x1E40             SUBS     R0,R0,#+1
   \   000000FE   0x87E0             STRH     R0,[R4, #+62]
   \   00000100   0xE7E8             B.N      ??HAL_SPI_Receive_10
    501                }
    502                /* Enable CRC Transmission */
    503                if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE) 
   \                     ??HAL_SPI_Receive_11: (+1)
   \   00000102   0x6AA0             LDR      R0,[R4, #+40]
   \   00000104   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000108   0xD128             BNE.N    ??HAL_SPI_Receive_13
    504                {
    505                  SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   \   0000010A   0x6820             LDR      R0,[R4, #+0]
   \   0000010C   0x6800             LDR      R0,[R0, #+0]
   \   0000010E   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   00000112   0x6821             LDR      R1,[R4, #+0]
   \   00000114   0x6008             STR      R0,[R1, #+0]
   \   00000116   0xE021             B.N      ??HAL_SPI_Receive_13
    506                }
    507              }
    508              /* Receive data in 16 Bit mode */
    509              else
    510              {
    511                while(hspi->RxXferCount > 1)
   \                     ??HAL_SPI_Receive_9: (+1)
   \   00000118   0x8FE0             LDRH     R0,[R4, #+62]
   \   0000011A   0x2802             CMP      R0,#+2
   \   0000011C   0xDB14             BLT.N    ??HAL_SPI_Receive_14
    512                {
    513                  /* Wait until RXNE flag is set to read data */
    514                  if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \   0000011E   0x003B             MOVS     R3,R7
   \   00000120   0x2200             MOVS     R2,#+0
   \   00000122   0x2101             MOVS     R1,#+1
   \   00000124   0x0020             MOVS     R0,R4
   \   00000126   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   0000012A   0x2800             CMP      R0,#+0
   \   0000012C   0xD001             BEQ.N    ??HAL_SPI_Receive_15
    515                  { 
    516                    return HAL_TIMEOUT;
   \   0000012E   0x2003             MOVS     R0,#+3
   \   00000130   0xE082             B.N      ??HAL_SPI_Receive_3
    517                  }
    518          
    519                  *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \                     ??HAL_SPI_Receive_15: (+1)
   \   00000132   0x6820             LDR      R0,[R4, #+0]
   \   00000134   0x68C0             LDR      R0,[R0, #+12]
   \   00000136   0x6BA1             LDR      R1,[R4, #+56]
   \   00000138   0x8008             STRH     R0,[R1, #+0]
    520                  hspi->pRxBuffPtr+=2;
   \   0000013A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000013C   0x1C80             ADDS     R0,R0,#+2
   \   0000013E   0x63A0             STR      R0,[R4, #+56]
    521                  hspi->RxXferCount--;
   \   00000140   0x8FE0             LDRH     R0,[R4, #+62]
   \   00000142   0x1E40             SUBS     R0,R0,#+1
   \   00000144   0x87E0             STRH     R0,[R4, #+62]
   \   00000146   0xE7E7             B.N      ??HAL_SPI_Receive_9
    522                }
    523                /* Enable CRC Transmission */
    524                if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE) 
   \                     ??HAL_SPI_Receive_14: (+1)
   \   00000148   0x6AA0             LDR      R0,[R4, #+40]
   \   0000014A   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000014E   0xD105             BNE.N    ??HAL_SPI_Receive_13
    525                {
    526                  SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   \   00000150   0x6820             LDR      R0,[R4, #+0]
   \   00000152   0x6800             LDR      R0,[R0, #+0]
   \   00000154   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   00000158   0x6821             LDR      R1,[R4, #+0]
   \   0000015A   0x6008             STR      R0,[R1, #+0]
    527                }
    528              }
    529          
    530              /* Wait until RXNE flag is set */
    531              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \                     ??HAL_SPI_Receive_13: (+1)
   \   0000015C   0x003B             MOVS     R3,R7
   \   0000015E   0x2200             MOVS     R2,#+0
   \   00000160   0x2101             MOVS     R1,#+1
   \   00000162   0x0020             MOVS     R0,R4
   \   00000164   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000168   0x2800             CMP      R0,#+0
   \   0000016A   0xD001             BEQ.N    ??HAL_SPI_Receive_16
    532              { 
    533                return HAL_TIMEOUT;
   \   0000016C   0x2003             MOVS     R0,#+3
   \   0000016E   0xE063             B.N      ??HAL_SPI_Receive_3
    534              }
    535          
    536              /* Receive last data in 8 Bit mode */
    537              if(hspi->Init.DataSize == SPI_DATASIZE_8BIT)
   \                     ??HAL_SPI_Receive_16: (+1)
   \   00000170   0x68E0             LDR      R0,[R4, #+12]
   \   00000172   0x2800             CMP      R0,#+0
   \   00000174   0xD106             BNE.N    ??HAL_SPI_Receive_17
    538              {
    539                (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
   \   00000176   0x6BA0             LDR      R0,[R4, #+56]
   \   00000178   0x1C41             ADDS     R1,R0,#+1
   \   0000017A   0x63A1             STR      R1,[R4, #+56]
   \   0000017C   0x6821             LDR      R1,[R4, #+0]
   \   0000017E   0x68C9             LDR      R1,[R1, #+12]
   \   00000180   0x7001             STRB     R1,[R0, #+0]
   \   00000182   0xE006             B.N      ??HAL_SPI_Receive_18
    540              }
    541              /* Receive last data in 16 Bit mode */
    542              else
    543              {
    544                *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \                     ??HAL_SPI_Receive_17: (+1)
   \   00000184   0x6820             LDR      R0,[R4, #+0]
   \   00000186   0x68C0             LDR      R0,[R0, #+12]
   \   00000188   0x6BA1             LDR      R1,[R4, #+56]
   \   0000018A   0x8008             STRH     R0,[R1, #+0]
    545                hspi->pRxBuffPtr+=2;
   \   0000018C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000018E   0x1C80             ADDS     R0,R0,#+2
   \   00000190   0x63A0             STR      R0,[R4, #+56]
    546              }
    547              hspi->RxXferCount--;
   \                     ??HAL_SPI_Receive_18: (+1)
   \   00000192   0x8FE0             LDRH     R0,[R4, #+62]
   \   00000194   0x1E40             SUBS     R0,R0,#+1
   \   00000196   0x87E0             STRH     R0,[R4, #+62]
    548          
    549              /* Wait until RXNE flag is set: CRC Received */
    550              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000198   0x6AA0             LDR      R0,[R4, #+40]
   \   0000019A   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000019E   0xD113             BNE.N    ??HAL_SPI_Receive_19
    551              {
    552                if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \   000001A0   0x003B             MOVS     R3,R7
   \   000001A2   0x2200             MOVS     R2,#+0
   \   000001A4   0x2101             MOVS     R1,#+1
   \   000001A6   0x0020             MOVS     R0,R4
   \   000001A8   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   000001AC   0x2800             CMP      R0,#+0
   \   000001AE   0xD005             BEQ.N    ??HAL_SPI_Receive_20
    553                {
    554                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   \   000001B0   0x6D60             LDR      R0,[R4, #+84]
   \   000001B2   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000001B6   0x6560             STR      R0,[R4, #+84]
    555                  return HAL_TIMEOUT;
   \   000001B8   0x2003             MOVS     R0,#+3
   \   000001BA   0xE03D             B.N      ??HAL_SPI_Receive_3
    556                }
    557          
    558                /* Read CRC to Flush RXNE flag */
    559                tmpreg = hspi->Instance->DR;
   \                     ??HAL_SPI_Receive_20: (+1)
   \   000001BC   0x6820             LDR      R0,[R4, #+0]
   \   000001BE   0x68C0             LDR      R0,[R0, #+12]
   \   000001C0   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    560                UNUSED(tmpreg);
   \   000001C4   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
    561              }
    562              
    563              if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
   \                     ??HAL_SPI_Receive_19: (+1)
   \   000001C8   0x6860             LDR      R0,[R4, #+4]
   \   000001CA   0xF5B0 0x7F82      CMP      R0,#+260
   \   000001CE   0xD10D             BNE.N    ??HAL_SPI_Receive_21
   \   000001D0   0x68A0             LDR      R0,[R4, #+8]
   \   000001D2   0xF5B0 0x4F00      CMP      R0,#+32768
   \   000001D6   0xD003             BEQ.N    ??HAL_SPI_Receive_22
   \   000001D8   0x68A0             LDR      R0,[R4, #+8]
   \   000001DA   0xF5B0 0x6F80      CMP      R0,#+1024
   \   000001DE   0xD105             BNE.N    ??HAL_SPI_Receive_21
    564              {
    565                /* Disable SPI peripheral */
    566                __HAL_SPI_DISABLE(hspi);
   \                     ??HAL_SPI_Receive_22: (+1)
   \   000001E0   0x6820             LDR      R0,[R4, #+0]
   \   000001E2   0x6800             LDR      R0,[R0, #+0]
   \   000001E4   0xF030 0x0040      BICS     R0,R0,#0x40
   \   000001E8   0x6821             LDR      R1,[R4, #+0]
   \   000001EA   0x6008             STR      R0,[R1, #+0]
    567              }
    568          
    569              hspi->State = HAL_SPI_STATE_READY;
   \                     ??HAL_SPI_Receive_21: (+1)
   \   000001EC   0x2001             MOVS     R0,#+1
   \   000001EE   0xF884 0x0051      STRB     R0,[R4, #+81]
    570          
    571              /* Check if CRC error occurred */
    572              if((hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET))
   \   000001F2   0x6AA0             LDR      R0,[R4, #+40]
   \   000001F4   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000001F8   0xD118             BNE.N    ??HAL_SPI_Receive_23
   \   000001FA   0x6820             LDR      R0,[R4, #+0]
   \   000001FC   0x6880             LDR      R0,[R0, #+8]
   \   000001FE   0x06C0             LSLS     R0,R0,#+27
   \   00000200   0xD514             BPL.N    ??HAL_SPI_Receive_23
    573              {  
    574                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   \   00000202   0x6D60             LDR      R0,[R4, #+84]
   \   00000204   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000208   0x6560             STR      R0,[R4, #+84]
    575          
    576                /* Reset CRC Calculation */
    577                SPI_RESET_CRC(hspi);
   \   0000020A   0x6820             LDR      R0,[R4, #+0]
   \   0000020C   0x6800             LDR      R0,[R0, #+0]
   \   0000020E   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   00000212   0x6821             LDR      R1,[R4, #+0]
   \   00000214   0x6008             STR      R0,[R1, #+0]
   \   00000216   0x6820             LDR      R0,[R4, #+0]
   \   00000218   0x6800             LDR      R0,[R0, #+0]
   \   0000021A   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   0000021E   0x6821             LDR      R1,[R4, #+0]
   \   00000220   0x6008             STR      R0,[R1, #+0]
    578          
    579                /* Process Unlocked */
    580                __HAL_UNLOCK(hspi);
   \   00000222   0x2000             MOVS     R0,#+0
   \   00000224   0xF884 0x0050      STRB     R0,[R4, #+80]
    581          
    582                return HAL_ERROR; 
   \   00000228   0x2001             MOVS     R0,#+1
   \   0000022A   0xE005             B.N      ??HAL_SPI_Receive_3
    583              }
    584          
    585              /* Process Unlocked */
    586              __HAL_UNLOCK(hspi);
   \                     ??HAL_SPI_Receive_23: (+1)
   \   0000022C   0x2000             MOVS     R0,#+0
   \   0000022E   0xF884 0x0050      STRB     R0,[R4, #+80]
    587          
    588              return HAL_OK;
   \   00000232   0x2000             MOVS     R0,#+0
   \   00000234   0xE000             B.N      ??HAL_SPI_Receive_3
    589            }
    590            else
    591            {
    592              return HAL_BUSY;
   \                     ??HAL_SPI_Receive_0: (+1)
   \   00000236   0x2002             MOVS     R0,#+2
   \                     ??HAL_SPI_Receive_3: (+1)
   \   00000238   0xBDFE             POP      {R1-R7,PC}       ;; return
    593            }
    594          }
    595          
    596          /**
    597            * @brief  Transmit and Receive an amount of data in blocking mode 
    598            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    599            *                the configuration information for SPI module.
    600            * @param  pTxData: pointer to transmission data buffer
    601            * @param  pRxData: pointer to reception data buffer to be
    602            * @param  Size: amount of data to be sent
    603            * @param  Timeout: Timeout duration
    604            * @retval HAL status
    605            */

   \                                 In section .text, align 2, keep-with-next
    606          HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
    607          {
   \                     HAL_SPI_TransmitReceive: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8020      LDR      R8,[SP, #+32]
    608            __IO uint16_t tmpreg = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    609          
    610            if((hspi->State == HAL_SPI_STATE_READY) || (hspi->State == HAL_SPI_STATE_BUSY_RX))
   \   00000018   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD004             BEQ.N    ??HAL_SPI_TransmitReceive_0
   \   00000020   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \   00000024   0x2822             CMP      R0,#+34
   \   00000026   0xF040 0x819A      BNE.W    ??HAL_SPI_TransmitReceive_1
    611            {
    612              if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0))
   \                     ??HAL_SPI_TransmitReceive_0: (+1)
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD004             BEQ.N    ??HAL_SPI_TransmitReceive_2
   \   0000002E   0x2E00             CMP      R6,#+0
   \   00000030   0xD002             BEQ.N    ??HAL_SPI_TransmitReceive_2
   \   00000032   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000034   0x2F00             CMP      R7,#+0
   \   00000036   0xD101             BNE.N    ??HAL_SPI_TransmitReceive_3
    613              {
    614                return  HAL_ERROR;
   \                     ??HAL_SPI_TransmitReceive_2: (+1)
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0xE191             B.N      ??HAL_SPI_TransmitReceive_4
    615              }
    616          
    617              /* Check the parameters */
    618              assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
    619          
    620              /* Process Locked */
    621              __HAL_LOCK(hspi);
   \                     ??HAL_SPI_TransmitReceive_3: (+1)
   \   0000003C   0xF894 0x0050      LDRB     R0,[R4, #+80]
   \   00000040   0x2801             CMP      R0,#+1
   \   00000042   0xD101             BNE.N    ??HAL_SPI_TransmitReceive_5
   \   00000044   0x2002             MOVS     R0,#+2
   \   00000046   0xE18B             B.N      ??HAL_SPI_TransmitReceive_4
   \                     ??HAL_SPI_TransmitReceive_5: (+1)
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0xF884 0x0050      STRB     R0,[R4, #+80]
    622           
    623              /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
    624              if(hspi->State == HAL_SPI_STATE_READY)
   \   0000004E   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \   00000052   0x2801             CMP      R0,#+1
   \   00000054   0xD102             BNE.N    ??HAL_SPI_TransmitReceive_6
    625              {
    626                hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
   \   00000056   0x2032             MOVS     R0,#+50
   \   00000058   0xF884 0x0051      STRB     R0,[R4, #+81]
    627              }
    628          
    629               /* Configure communication */   
    630              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \                     ??HAL_SPI_TransmitReceive_6: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x6560             STR      R0,[R4, #+84]
    631          
    632              hspi->pRxBuffPtr  = pRxData;
   \   00000060   0x63A6             STR      R6,[R4, #+56]
    633              hspi->RxXferSize  = Size;
   \   00000062   0x87A7             STRH     R7,[R4, #+60]
    634              hspi->RxXferCount = Size;  
   \   00000064   0x87E7             STRH     R7,[R4, #+62]
    635              
    636              hspi->pTxBuffPtr  = pTxData;
   \   00000066   0x6325             STR      R5,[R4, #+48]
    637              hspi->TxXferSize  = Size; 
   \   00000068   0x86A7             STRH     R7,[R4, #+52]
    638              hspi->TxXferCount = Size;
   \   0000006A   0x86E7             STRH     R7,[R4, #+54]
    639          
    640              /*Init field not used in handle to zero */
    641              hspi->RxISR = 0;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x64A0             STR      R0,[R4, #+72]
    642              hspi->TxISR = 0;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x64E0             STR      R0,[R4, #+76]
    643          
    644              /* Reset CRC Calculation */
    645              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000074   0x6AA0             LDR      R0,[R4, #+40]
   \   00000076   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000007A   0xD10B             BNE.N    ??HAL_SPI_TransmitReceive_7
    646              {
    647                SPI_RESET_CRC(hspi);
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   00000084   0x6821             LDR      R1,[R4, #+0]
   \   00000086   0x6008             STR      R0,[R1, #+0]
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   00000090   0x6821             LDR      R1,[R4, #+0]
   \   00000092   0x6008             STR      R0,[R1, #+0]
    648              }
    649          
    650              /* Check if the SPI is already enabled */ 
    651              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \                     ??HAL_SPI_TransmitReceive_7: (+1)
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x6800             LDR      R0,[R0, #+0]
   \   00000098   0x0640             LSLS     R0,R0,#+25
   \   0000009A   0xD405             BMI.N    ??HAL_SPI_TransmitReceive_8
    652              {
    653                /* Enable SPI peripheral */
    654                __HAL_SPI_ENABLE(hspi);
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0x6800             LDR      R0,[R0, #+0]
   \   000000A0   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   000000A4   0x6821             LDR      R1,[R4, #+0]
   \   000000A6   0x6008             STR      R0,[R1, #+0]
    655              }
    656          
    657              /* Transmit and Receive data in 16 Bit mode */
    658              if(hspi->Init.DataSize == SPI_DATASIZE_16BIT)
   \                     ??HAL_SPI_TransmitReceive_8: (+1)
   \   000000A8   0x68E0             LDR      R0,[R4, #+12]
   \   000000AA   0xF5B0 0x6F00      CMP      R0,#+2048
   \   000000AE   0xF040 0x8088      BNE.W    ??HAL_SPI_TransmitReceive_9
    659              {
    660                if((hspi->Init.Mode == SPI_MODE_SLAVE) || ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->TxXferCount == 0x01)))
   \   000000B2   0x6860             LDR      R0,[R4, #+4]
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD006             BEQ.N    ??HAL_SPI_TransmitReceive_10
   \   000000B8   0x6860             LDR      R0,[R4, #+4]
   \   000000BA   0xF5B0 0x7F82      CMP      R0,#+260
   \   000000BE   0xD10C             BNE.N    ??HAL_SPI_TransmitReceive_11
   \   000000C0   0x8EE0             LDRH     R0,[R4, #+54]
   \   000000C2   0x2801             CMP      R0,#+1
   \   000000C4   0xD109             BNE.N    ??HAL_SPI_TransmitReceive_11
    661                {
    662                  hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
   \                     ??HAL_SPI_TransmitReceive_10: (+1)
   \   000000C6   0x6B20             LDR      R0,[R4, #+48]
   \   000000C8   0x8800             LDRH     R0,[R0, #+0]
   \   000000CA   0x6821             LDR      R1,[R4, #+0]
   \   000000CC   0x60C8             STR      R0,[R1, #+12]
    663                  hspi->pTxBuffPtr+=2;
   \   000000CE   0x6B20             LDR      R0,[R4, #+48]
   \   000000D0   0x1C80             ADDS     R0,R0,#+2
   \   000000D2   0x6320             STR      R0,[R4, #+48]
    664                  hspi->TxXferCount--;
   \   000000D4   0x8EE0             LDRH     R0,[R4, #+54]
   \   000000D6   0x1E40             SUBS     R0,R0,#+1
   \   000000D8   0x86E0             STRH     R0,[R4, #+54]
    665                }
    666                if(hspi->TxXferCount == 0)
   \                     ??HAL_SPI_TransmitReceive_11: (+1)
   \   000000DA   0x8EE0             LDRH     R0,[R4, #+54]
   \   000000DC   0x2800             CMP      R0,#+0
   \   000000DE   0xD11E             BNE.N    ??HAL_SPI_TransmitReceive_12
    667                {
    668                  /* Enable CRC Transmission */
    669                  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   000000E0   0x6AA0             LDR      R0,[R4, #+40]
   \   000000E2   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000000E6   0xD105             BNE.N    ??HAL_SPI_TransmitReceive_13
    670                  {
    671                    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   \   000000E8   0x6820             LDR      R0,[R4, #+0]
   \   000000EA   0x6800             LDR      R0,[R0, #+0]
   \   000000EC   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   000000F0   0x6821             LDR      R1,[R4, #+0]
   \   000000F2   0x6008             STR      R0,[R1, #+0]
    672                  }
    673          
    674                  /* Wait until RXNE flag is set */
    675                  if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \                     ??HAL_SPI_TransmitReceive_13: (+1)
   \   000000F4   0x4643             MOV      R3,R8
   \   000000F6   0x2200             MOVS     R2,#+0
   \   000000F8   0x2101             MOVS     R1,#+1
   \   000000FA   0x0020             MOVS     R0,R4
   \   000000FC   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xD001             BEQ.N    ??HAL_SPI_TransmitReceive_14
    676                  { 
    677                    return HAL_TIMEOUT;
   \   00000104   0x2003             MOVS     R0,#+3
   \   00000106   0xE12B             B.N      ??HAL_SPI_TransmitReceive_4
    678                  }
    679          
    680                  *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \                     ??HAL_SPI_TransmitReceive_14: (+1)
   \   00000108   0x6820             LDR      R0,[R4, #+0]
   \   0000010A   0x68C0             LDR      R0,[R0, #+12]
   \   0000010C   0x6BA1             LDR      R1,[R4, #+56]
   \   0000010E   0x8008             STRH     R0,[R1, #+0]
    681                  hspi->pRxBuffPtr+=2;
   \   00000110   0x6BA0             LDR      R0,[R4, #+56]
   \   00000112   0x1C80             ADDS     R0,R0,#+2
   \   00000114   0x63A0             STR      R0,[R4, #+56]
    682                  hspi->RxXferCount--;
   \   00000116   0x8FE0             LDRH     R0,[R4, #+62]
   \   00000118   0x1E40             SUBS     R0,R0,#+1
   \   0000011A   0x87E0             STRH     R0,[R4, #+62]
   \   0000011C   0xE0D0             B.N      ??HAL_SPI_TransmitReceive_15
    683                }
    684                else
    685                {
    686                  while(hspi->TxXferCount > 0)
   \                     ??HAL_SPI_TransmitReceive_12: (+1)
   \   0000011E   0x8EE0             LDRH     R0,[R4, #+54]
   \   00000120   0x2800             CMP      R0,#+0
   \   00000122   0xD035             BEQ.N    ??HAL_SPI_TransmitReceive_16
    687                  {
    688                    /* Wait until TXE flag is set to send data */
    689                    if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, Timeout) != HAL_OK)
   \   00000124   0x4643             MOV      R3,R8
   \   00000126   0x2200             MOVS     R2,#+0
   \   00000128   0x2102             MOVS     R1,#+2
   \   0000012A   0x0020             MOVS     R0,R4
   \   0000012C   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000130   0x2800             CMP      R0,#+0
   \   00000132   0xD001             BEQ.N    ??HAL_SPI_TransmitReceive_17
    690                    { 
    691                      return HAL_TIMEOUT;
   \   00000134   0x2003             MOVS     R0,#+3
   \   00000136   0xE113             B.N      ??HAL_SPI_TransmitReceive_4
    692                    }
    693          
    694                    hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
   \                     ??HAL_SPI_TransmitReceive_17: (+1)
   \   00000138   0x6B20             LDR      R0,[R4, #+48]
   \   0000013A   0x8800             LDRH     R0,[R0, #+0]
   \   0000013C   0x6821             LDR      R1,[R4, #+0]
   \   0000013E   0x60C8             STR      R0,[R1, #+12]
    695                    hspi->pTxBuffPtr+=2;
   \   00000140   0x6B20             LDR      R0,[R4, #+48]
   \   00000142   0x1C80             ADDS     R0,R0,#+2
   \   00000144   0x6320             STR      R0,[R4, #+48]
    696                    hspi->TxXferCount--;
   \   00000146   0x8EE0             LDRH     R0,[R4, #+54]
   \   00000148   0x1E40             SUBS     R0,R0,#+1
   \   0000014A   0x86E0             STRH     R0,[R4, #+54]
    697          
    698                    /* Enable CRC Transmission */
    699                    if((hspi->TxXferCount == 0) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
   \   0000014C   0x8EE0             LDRH     R0,[R4, #+54]
   \   0000014E   0x2800             CMP      R0,#+0
   \   00000150   0xD109             BNE.N    ??HAL_SPI_TransmitReceive_18
   \   00000152   0x6AA0             LDR      R0,[R4, #+40]
   \   00000154   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000158   0xD105             BNE.N    ??HAL_SPI_TransmitReceive_18
    700                    {
    701                      SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   \   0000015A   0x6820             LDR      R0,[R4, #+0]
   \   0000015C   0x6800             LDR      R0,[R0, #+0]
   \   0000015E   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   00000162   0x6821             LDR      R1,[R4, #+0]
   \   00000164   0x6008             STR      R0,[R1, #+0]
    702                    }
    703          
    704                    /* Wait until RXNE flag is set */
    705                    if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \                     ??HAL_SPI_TransmitReceive_18: (+1)
   \   00000166   0x4643             MOV      R3,R8
   \   00000168   0x2200             MOVS     R2,#+0
   \   0000016A   0x2101             MOVS     R1,#+1
   \   0000016C   0x0020             MOVS     R0,R4
   \   0000016E   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000172   0x2800             CMP      R0,#+0
   \   00000174   0xD001             BEQ.N    ??HAL_SPI_TransmitReceive_19
    706                    { 
    707                      return HAL_TIMEOUT;
   \   00000176   0x2003             MOVS     R0,#+3
   \   00000178   0xE0F2             B.N      ??HAL_SPI_TransmitReceive_4
    708                    }
    709          
    710                    *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \                     ??HAL_SPI_TransmitReceive_19: (+1)
   \   0000017A   0x6820             LDR      R0,[R4, #+0]
   \   0000017C   0x68C0             LDR      R0,[R0, #+12]
   \   0000017E   0x6BA1             LDR      R1,[R4, #+56]
   \   00000180   0x8008             STRH     R0,[R1, #+0]
    711                    hspi->pRxBuffPtr+=2;
   \   00000182   0x6BA0             LDR      R0,[R4, #+56]
   \   00000184   0x1C80             ADDS     R0,R0,#+2
   \   00000186   0x63A0             STR      R0,[R4, #+56]
    712                    hspi->RxXferCount--;
   \   00000188   0x8FE0             LDRH     R0,[R4, #+62]
   \   0000018A   0x1E40             SUBS     R0,R0,#+1
   \   0000018C   0x87E0             STRH     R0,[R4, #+62]
   \   0000018E   0xE7C6             B.N      ??HAL_SPI_TransmitReceive_12
    713                  }
    714                  /* Receive the last byte */
    715                  if(hspi->Init.Mode == SPI_MODE_SLAVE)
   \                     ??HAL_SPI_TransmitReceive_16: (+1)
   \   00000190   0x6860             LDR      R0,[R4, #+4]
   \   00000192   0x2800             CMP      R0,#+0
   \   00000194   0xF040 0x8094      BNE.W    ??HAL_SPI_TransmitReceive_15
    716                  {
    717                    /* Wait until RXNE flag is set */
    718                    if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \   00000198   0x4643             MOV      R3,R8
   \   0000019A   0x2200             MOVS     R2,#+0
   \   0000019C   0x2101             MOVS     R1,#+1
   \   0000019E   0x0020             MOVS     R0,R4
   \   000001A0   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   000001A4   0x2800             CMP      R0,#+0
   \   000001A6   0xD001             BEQ.N    ??HAL_SPI_TransmitReceive_20
    719                    {
    720                      return HAL_TIMEOUT;
   \   000001A8   0x2003             MOVS     R0,#+3
   \   000001AA   0xE0D9             B.N      ??HAL_SPI_TransmitReceive_4
    721                    }
    722                    
    723                    *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \                     ??HAL_SPI_TransmitReceive_20: (+1)
   \   000001AC   0x6820             LDR      R0,[R4, #+0]
   \   000001AE   0x68C0             LDR      R0,[R0, #+12]
   \   000001B0   0x6BA1             LDR      R1,[R4, #+56]
   \   000001B2   0x8008             STRH     R0,[R1, #+0]
    724                    hspi->pRxBuffPtr+=2;
   \   000001B4   0x6BA0             LDR      R0,[R4, #+56]
   \   000001B6   0x1C80             ADDS     R0,R0,#+2
   \   000001B8   0x63A0             STR      R0,[R4, #+56]
    725                    hspi->RxXferCount--;
   \   000001BA   0x8FE0             LDRH     R0,[R4, #+62]
   \   000001BC   0x1E40             SUBS     R0,R0,#+1
   \   000001BE   0x87E0             STRH     R0,[R4, #+62]
   \   000001C0   0xE07E             B.N      ??HAL_SPI_TransmitReceive_15
    726                  }
    727                }
    728              }
    729              /* Transmit and Receive data in 8 Bit mode */
    730              else
    731              {
    732                if((hspi->Init.Mode == SPI_MODE_SLAVE) || ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->TxXferCount == 0x01)))
   \                     ??HAL_SPI_TransmitReceive_9: (+1)
   \   000001C2   0x6860             LDR      R0,[R4, #+4]
   \   000001C4   0x2800             CMP      R0,#+0
   \   000001C6   0xD006             BEQ.N    ??HAL_SPI_TransmitReceive_21
   \   000001C8   0x6860             LDR      R0,[R4, #+4]
   \   000001CA   0xF5B0 0x7F82      CMP      R0,#+260
   \   000001CE   0xD10B             BNE.N    ??HAL_SPI_TransmitReceive_22
   \   000001D0   0x8EE0             LDRH     R0,[R4, #+54]
   \   000001D2   0x2801             CMP      R0,#+1
   \   000001D4   0xD108             BNE.N    ??HAL_SPI_TransmitReceive_22
    733                {
    734                  hspi->Instance->DR = (*hspi->pTxBuffPtr++);
   \                     ??HAL_SPI_TransmitReceive_21: (+1)
   \   000001D6   0x6B20             LDR      R0,[R4, #+48]
   \   000001D8   0x1C41             ADDS     R1,R0,#+1
   \   000001DA   0x6321             STR      R1,[R4, #+48]
   \   000001DC   0x7800             LDRB     R0,[R0, #+0]
   \   000001DE   0x6821             LDR      R1,[R4, #+0]
   \   000001E0   0x60C8             STR      R0,[R1, #+12]
    735                  hspi->TxXferCount--;
   \   000001E2   0x8EE0             LDRH     R0,[R4, #+54]
   \   000001E4   0x1E40             SUBS     R0,R0,#+1
   \   000001E6   0x86E0             STRH     R0,[R4, #+54]
    736                }
    737                if(hspi->TxXferCount == 0)
   \                     ??HAL_SPI_TransmitReceive_22: (+1)
   \   000001E8   0x8EE0             LDRH     R0,[R4, #+54]
   \   000001EA   0x2800             CMP      R0,#+0
   \   000001EC   0xD11B             BNE.N    ??HAL_SPI_TransmitReceive_23
    738                {
    739                  /* Enable CRC Transmission */
    740                  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   000001EE   0x6AA0             LDR      R0,[R4, #+40]
   \   000001F0   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000001F4   0xD105             BNE.N    ??HAL_SPI_TransmitReceive_24
    741                  {
    742                    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   \   000001F6   0x6820             LDR      R0,[R4, #+0]
   \   000001F8   0x6800             LDR      R0,[R0, #+0]
   \   000001FA   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   000001FE   0x6821             LDR      R1,[R4, #+0]
   \   00000200   0x6008             STR      R0,[R1, #+0]
    743                  }
    744          
    745                  /* Wait until RXNE flag is set */
    746                  if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \                     ??HAL_SPI_TransmitReceive_24: (+1)
   \   00000202   0x4643             MOV      R3,R8
   \   00000204   0x2200             MOVS     R2,#+0
   \   00000206   0x2101             MOVS     R1,#+1
   \   00000208   0x0020             MOVS     R0,R4
   \   0000020A   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   0000020E   0x2800             CMP      R0,#+0
   \   00000210   0xD001             BEQ.N    ??HAL_SPI_TransmitReceive_25
    747                  {
    748                    return HAL_TIMEOUT;
   \   00000212   0x2003             MOVS     R0,#+3
   \   00000214   0xE0A4             B.N      ??HAL_SPI_TransmitReceive_4
    749                  }
    750          
    751                  (*hspi->pRxBuffPtr) = hspi->Instance->DR;
   \                     ??HAL_SPI_TransmitReceive_25: (+1)
   \   00000216   0x6820             LDR      R0,[R4, #+0]
   \   00000218   0x68C0             LDR      R0,[R0, #+12]
   \   0000021A   0x6BA1             LDR      R1,[R4, #+56]
   \   0000021C   0x7008             STRB     R0,[R1, #+0]
    752                  hspi->RxXferCount--;
   \   0000021E   0x8FE0             LDRH     R0,[R4, #+62]
   \   00000220   0x1E40             SUBS     R0,R0,#+1
   \   00000222   0x87E0             STRH     R0,[R4, #+62]
   \   00000224   0xE04C             B.N      ??HAL_SPI_TransmitReceive_15
    753                }
    754                else
    755                {
    756                  while(hspi->TxXferCount > 0)
   \                     ??HAL_SPI_TransmitReceive_23: (+1)
   \   00000226   0x8EE0             LDRH     R0,[R4, #+54]
   \   00000228   0x2800             CMP      R0,#+0
   \   0000022A   0xD033             BEQ.N    ??HAL_SPI_TransmitReceive_26
    757                  {
    758                    /* Wait until TXE flag is set to send data */
    759                    if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, Timeout) != HAL_OK)
   \   0000022C   0x4643             MOV      R3,R8
   \   0000022E   0x2200             MOVS     R2,#+0
   \   00000230   0x2102             MOVS     R1,#+2
   \   00000232   0x0020             MOVS     R0,R4
   \   00000234   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000238   0x2800             CMP      R0,#+0
   \   0000023A   0xD001             BEQ.N    ??HAL_SPI_TransmitReceive_27
    760                    {
    761                      return HAL_TIMEOUT;
   \   0000023C   0x2003             MOVS     R0,#+3
   \   0000023E   0xE08F             B.N      ??HAL_SPI_TransmitReceive_4
    762                    }
    763          
    764                    hspi->Instance->DR = (*hspi->pTxBuffPtr++);
   \                     ??HAL_SPI_TransmitReceive_27: (+1)
   \   00000240   0x6B20             LDR      R0,[R4, #+48]
   \   00000242   0x1C41             ADDS     R1,R0,#+1
   \   00000244   0x6321             STR      R1,[R4, #+48]
   \   00000246   0x7800             LDRB     R0,[R0, #+0]
   \   00000248   0x6821             LDR      R1,[R4, #+0]
   \   0000024A   0x60C8             STR      R0,[R1, #+12]
    765                    hspi->TxXferCount--;
   \   0000024C   0x8EE0             LDRH     R0,[R4, #+54]
   \   0000024E   0x1E40             SUBS     R0,R0,#+1
   \   00000250   0x86E0             STRH     R0,[R4, #+54]
    766          
    767                    /* Enable CRC Transmission */
    768                    if((hspi->TxXferCount == 0) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
   \   00000252   0x8EE0             LDRH     R0,[R4, #+54]
   \   00000254   0x2800             CMP      R0,#+0
   \   00000256   0xD109             BNE.N    ??HAL_SPI_TransmitReceive_28
   \   00000258   0x6AA0             LDR      R0,[R4, #+40]
   \   0000025A   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000025E   0xD105             BNE.N    ??HAL_SPI_TransmitReceive_28
    769                    {
    770                      SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   \   00000260   0x6820             LDR      R0,[R4, #+0]
   \   00000262   0x6800             LDR      R0,[R0, #+0]
   \   00000264   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   00000268   0x6821             LDR      R1,[R4, #+0]
   \   0000026A   0x6008             STR      R0,[R1, #+0]
    771                    }
    772          
    773                    /* Wait until RXNE flag is set */
    774                    if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \                     ??HAL_SPI_TransmitReceive_28: (+1)
   \   0000026C   0x4643             MOV      R3,R8
   \   0000026E   0x2200             MOVS     R2,#+0
   \   00000270   0x2101             MOVS     R1,#+1
   \   00000272   0x0020             MOVS     R0,R4
   \   00000274   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000278   0x2800             CMP      R0,#+0
   \   0000027A   0xD001             BEQ.N    ??HAL_SPI_TransmitReceive_29
    775                    {
    776                      return HAL_TIMEOUT;
   \   0000027C   0x2003             MOVS     R0,#+3
   \   0000027E   0xE06F             B.N      ??HAL_SPI_TransmitReceive_4
    777                    }
    778          
    779                    (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
   \                     ??HAL_SPI_TransmitReceive_29: (+1)
   \   00000280   0x6BA0             LDR      R0,[R4, #+56]
   \   00000282   0x1C41             ADDS     R1,R0,#+1
   \   00000284   0x63A1             STR      R1,[R4, #+56]
   \   00000286   0x6821             LDR      R1,[R4, #+0]
   \   00000288   0x68C9             LDR      R1,[R1, #+12]
   \   0000028A   0x7001             STRB     R1,[R0, #+0]
    780                    hspi->RxXferCount--;
   \   0000028C   0x8FE0             LDRH     R0,[R4, #+62]
   \   0000028E   0x1E40             SUBS     R0,R0,#+1
   \   00000290   0x87E0             STRH     R0,[R4, #+62]
   \   00000292   0xE7C8             B.N      ??HAL_SPI_TransmitReceive_23
    781                  }
    782                  if(hspi->Init.Mode == SPI_MODE_SLAVE)
   \                     ??HAL_SPI_TransmitReceive_26: (+1)
   \   00000294   0x6860             LDR      R0,[R4, #+4]
   \   00000296   0x2800             CMP      R0,#+0
   \   00000298   0xD112             BNE.N    ??HAL_SPI_TransmitReceive_15
    783                  {
    784                    /* Wait until RXNE flag is set */
    785                    if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \   0000029A   0x4643             MOV      R3,R8
   \   0000029C   0x2200             MOVS     R2,#+0
   \   0000029E   0x2101             MOVS     R1,#+1
   \   000002A0   0x0020             MOVS     R0,R4
   \   000002A2   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   000002A6   0x2800             CMP      R0,#+0
   \   000002A8   0xD001             BEQ.N    ??HAL_SPI_TransmitReceive_30
    786                    {
    787                      return HAL_TIMEOUT;
   \   000002AA   0x2003             MOVS     R0,#+3
   \   000002AC   0xE058             B.N      ??HAL_SPI_TransmitReceive_4
    788                    }
    789                    
    790                    (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
   \                     ??HAL_SPI_TransmitReceive_30: (+1)
   \   000002AE   0x6BA0             LDR      R0,[R4, #+56]
   \   000002B0   0x1C41             ADDS     R1,R0,#+1
   \   000002B2   0x63A1             STR      R1,[R4, #+56]
   \   000002B4   0x6821             LDR      R1,[R4, #+0]
   \   000002B6   0x68C9             LDR      R1,[R1, #+12]
   \   000002B8   0x7001             STRB     R1,[R0, #+0]
    791                    hspi->RxXferCount--;
   \   000002BA   0x8FE0             LDRH     R0,[R4, #+62]
   \   000002BC   0x1E40             SUBS     R0,R0,#+1
   \   000002BE   0x87E0             STRH     R0,[R4, #+62]
    792                  }
    793                }
    794              }
    795          
    796              /* Read CRC from DR to close CRC calculation process */
    797              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_TransmitReceive_15: (+1)
   \   000002C0   0x6AA0             LDR      R0,[R4, #+40]
   \   000002C2   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000002C6   0xD113             BNE.N    ??HAL_SPI_TransmitReceive_31
    798              {
    799                /* Wait until RXNE flag is set */
    800                if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \   000002C8   0x4643             MOV      R3,R8
   \   000002CA   0x2200             MOVS     R2,#+0
   \   000002CC   0x2101             MOVS     R1,#+1
   \   000002CE   0x0020             MOVS     R0,R4
   \   000002D0   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   000002D4   0x2800             CMP      R0,#+0
   \   000002D6   0xD005             BEQ.N    ??HAL_SPI_TransmitReceive_32
    801                {
    802                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   \   000002D8   0x6D60             LDR      R0,[R4, #+84]
   \   000002DA   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000002DE   0x6560             STR      R0,[R4, #+84]
    803                  return HAL_TIMEOUT;
   \   000002E0   0x2003             MOVS     R0,#+3
   \   000002E2   0xE03D             B.N      ??HAL_SPI_TransmitReceive_4
    804                }
    805                /* Read CRC */
    806                tmpreg = hspi->Instance->DR;
   \                     ??HAL_SPI_TransmitReceive_32: (+1)
   \   000002E4   0x6820             LDR      R0,[R4, #+0]
   \   000002E6   0x68C0             LDR      R0,[R0, #+12]
   \   000002E8   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    807                UNUSED(tmpreg);
   \   000002EC   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
    808              }
    809          
    810              /* Wait until Busy flag is reset before disabling SPI */
    811              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_BSY, SET, Timeout) != HAL_OK)
   \                     ??HAL_SPI_TransmitReceive_31: (+1)
   \   000002F0   0x4643             MOV      R3,R8
   \   000002F2   0x2201             MOVS     R2,#+1
   \   000002F4   0x2180             MOVS     R1,#+128
   \   000002F6   0x0020             MOVS     R0,R4
   \   000002F8   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   000002FC   0x2800             CMP      R0,#+0
   \   000002FE   0xD005             BEQ.N    ??HAL_SPI_TransmitReceive_33
    812              {
    813                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   00000300   0x6D60             LDR      R0,[R4, #+84]
   \   00000302   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000306   0x6560             STR      R0,[R4, #+84]
    814                return HAL_TIMEOUT;
   \   00000308   0x2003             MOVS     R0,#+3
   \   0000030A   0xE029             B.N      ??HAL_SPI_TransmitReceive_4
    815              }
    816              
    817              hspi->State = HAL_SPI_STATE_READY;
   \                     ??HAL_SPI_TransmitReceive_33: (+1)
   \   0000030C   0x2001             MOVS     R0,#+1
   \   0000030E   0xF884 0x0051      STRB     R0,[R4, #+81]
    818          
    819              /* Check if CRC error occurred */
    820              if((hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET))
   \   00000312   0x6AA0             LDR      R0,[R4, #+40]
   \   00000314   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000318   0xD11C             BNE.N    ??HAL_SPI_TransmitReceive_34
   \   0000031A   0x6820             LDR      R0,[R4, #+0]
   \   0000031C   0x6880             LDR      R0,[R0, #+8]
   \   0000031E   0x06C0             LSLS     R0,R0,#+27
   \   00000320   0xD518             BPL.N    ??HAL_SPI_TransmitReceive_34
    821              {
    822                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   \   00000322   0x6D60             LDR      R0,[R4, #+84]
   \   00000324   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000328   0x6560             STR      R0,[R4, #+84]
    823          
    824                /* Reset CRC Calculation */
    825                if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   0000032A   0x6AA0             LDR      R0,[R4, #+40]
   \   0000032C   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000330   0xD10B             BNE.N    ??HAL_SPI_TransmitReceive_35
    826                {
    827                  SPI_RESET_CRC(hspi);
   \   00000332   0x6820             LDR      R0,[R4, #+0]
   \   00000334   0x6800             LDR      R0,[R0, #+0]
   \   00000336   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   0000033A   0x6821             LDR      R1,[R4, #+0]
   \   0000033C   0x6008             STR      R0,[R1, #+0]
   \   0000033E   0x6820             LDR      R0,[R4, #+0]
   \   00000340   0x6800             LDR      R0,[R0, #+0]
   \   00000342   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   00000346   0x6821             LDR      R1,[R4, #+0]
   \   00000348   0x6008             STR      R0,[R1, #+0]
    828                }
    829          
    830                /* Process Unlocked */
    831                __HAL_UNLOCK(hspi);
   \                     ??HAL_SPI_TransmitReceive_35: (+1)
   \   0000034A   0x2000             MOVS     R0,#+0
   \   0000034C   0xF884 0x0050      STRB     R0,[R4, #+80]
    832                
    833                return HAL_ERROR; 
   \   00000350   0x2001             MOVS     R0,#+1
   \   00000352   0xE005             B.N      ??HAL_SPI_TransmitReceive_4
    834              }
    835          
    836              /* Process Unlocked */
    837              __HAL_UNLOCK(hspi);
   \                     ??HAL_SPI_TransmitReceive_34: (+1)
   \   00000354   0x2000             MOVS     R0,#+0
   \   00000356   0xF884 0x0050      STRB     R0,[R4, #+80]
    838          
    839              return HAL_OK;
   \   0000035A   0x2000             MOVS     R0,#+0
   \   0000035C   0xE000             B.N      ??HAL_SPI_TransmitReceive_4
    840            }
    841            else
    842            {
    843              return HAL_BUSY;
   \                     ??HAL_SPI_TransmitReceive_1: (+1)
   \   0000035E   0x2002             MOVS     R0,#+2
   \                     ??HAL_SPI_TransmitReceive_4: (+1)
   \   00000360   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    844            }
    845          }
    846          
    847          /**
    848            * @brief  Transmit an amount of data in no-blocking mode with Interrupt
    849            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    850            *                the configuration information for SPI module.
    851            * @param  pData: pointer to data buffer
    852            * @param  Size: amount of data to be sent
    853            * @retval HAL status
    854            */

   \                                 In section .text, align 2, keep-with-next
    855          HAL_StatusTypeDef HAL_SPI_Transmit_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
    856          {
   \                     HAL_SPI_Transmit_IT: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0003             MOVS     R3,R0
    857            if(hspi->State == HAL_SPI_STATE_READY)
   \   00000004   0xF893 0x0051      LDRB     R0,[R3, #+81]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD15B             BNE.N    ??HAL_SPI_Transmit_IT_0
    858            {
    859              if((pData == NULL) || (Size == 0))
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD002             BEQ.N    ??HAL_SPI_Transmit_IT_1
   \   00000010   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xD101             BNE.N    ??HAL_SPI_Transmit_IT_2
    860              {
    861                return  HAL_ERROR;
   \                     ??HAL_SPI_Transmit_IT_1: (+1)
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE055             B.N      ??HAL_SPI_Transmit_IT_3
    862              }
    863          
    864              /* Check the parameters */
    865              assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
    866          
    867              /* Process Locked */
    868              __HAL_LOCK(hspi);
   \                     ??HAL_SPI_Transmit_IT_2: (+1)
   \   0000001A   0xF893 0x0050      LDRB     R0,[R3, #+80]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD101             BNE.N    ??HAL_SPI_Transmit_IT_4
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xE04F             B.N      ??HAL_SPI_Transmit_IT_3
   \                     ??HAL_SPI_Transmit_IT_4: (+1)
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xF883 0x0050      STRB     R0,[R3, #+80]
    869          
    870              /* Configure communication */
    871              hspi->State        = HAL_SPI_STATE_BUSY_TX;
   \   0000002C   0x2012             MOVS     R0,#+18
   \   0000002E   0xF883 0x0051      STRB     R0,[R3, #+81]
    872              hspi->ErrorCode    = HAL_SPI_ERROR_NONE;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x6558             STR      R0,[R3, #+84]
    873          
    874              hspi->TxISR = &SPI_TxISR;
   \   00000036   0x.... 0x....      ADR.W    R0,SPI_TxISR
   \   0000003A   0x64D8             STR      R0,[R3, #+76]
    875              hspi->pTxBuffPtr   = pData;
   \   0000003C   0x6319             STR      R1,[R3, #+48]
    876              hspi->TxXferSize   = Size;
   \   0000003E   0x869A             STRH     R2,[R3, #+52]
    877              hspi->TxXferCount  = Size;
   \   00000040   0x86DA             STRH     R2,[R3, #+54]
    878          
    879              /*Init field not used in handle to zero */
    880              hspi->RxISR = 0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x6498             STR      R0,[R3, #+72]
    881              hspi->pRxBuffPtr   = NULL;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x6398             STR      R0,[R3, #+56]
    882              hspi->RxXferSize   = 0;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x8798             STRH     R0,[R3, #+60]
    883              hspi->RxXferCount  = 0;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x87D8             STRH     R0,[R3, #+62]
    884          
    885              /* Configure communication direction : 1Line */
    886              if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \   00000052   0x6898             LDR      R0,[R3, #+8]
   \   00000054   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000058   0xD105             BNE.N    ??HAL_SPI_Transmit_IT_5
    887              {
    888                SPI_1LINE_TX(hspi);
   \   0000005A   0x6818             LDR      R0,[R3, #+0]
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   00000062   0x681C             LDR      R4,[R3, #+0]
   \   00000064   0x6020             STR      R0,[R4, #+0]
    889              }
    890          
    891              /* Reset CRC Calculation */
    892              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Transmit_IT_5: (+1)
   \   00000066   0x6A98             LDR      R0,[R3, #+40]
   \   00000068   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000006C   0xD10B             BNE.N    ??HAL_SPI_Transmit_IT_6
    893              {
    894                SPI_RESET_CRC(hspi);
   \   0000006E   0x6818             LDR      R0,[R3, #+0]
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   00000076   0x681C             LDR      R4,[R3, #+0]
   \   00000078   0x6020             STR      R0,[R4, #+0]
   \   0000007A   0x6818             LDR      R0,[R3, #+0]
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   00000082   0x681C             LDR      R4,[R3, #+0]
   \   00000084   0x6020             STR      R0,[R4, #+0]
    895              }
    896          
    897              if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \                     ??HAL_SPI_Transmit_IT_6: (+1)
   \   00000086   0x6898             LDR      R0,[R3, #+8]
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD106             BNE.N    ??HAL_SPI_Transmit_IT_7
    898              {
    899                __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE));
   \   0000008C   0x6818             LDR      R0,[R3, #+0]
   \   0000008E   0x6840             LDR      R0,[R0, #+4]
   \   00000090   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000094   0x681C             LDR      R4,[R3, #+0]
   \   00000096   0x6060             STR      R0,[R4, #+4]
   \   00000098   0xE005             B.N      ??HAL_SPI_Transmit_IT_8
    900              }else
    901              {
    902                /* Enable TXE and ERR interrupt */
    903                __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));
   \                     ??HAL_SPI_Transmit_IT_7: (+1)
   \   0000009A   0x6818             LDR      R0,[R3, #+0]
   \   0000009C   0x6840             LDR      R0,[R0, #+4]
   \   0000009E   0xF050 0x00A0      ORRS     R0,R0,#0xA0
   \   000000A2   0x681C             LDR      R4,[R3, #+0]
   \   000000A4   0x6060             STR      R0,[R4, #+4]
    904              }
    905              /* Process Unlocked */
    906              __HAL_UNLOCK(hspi);
   \                     ??HAL_SPI_Transmit_IT_8: (+1)
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0xF883 0x0050      STRB     R0,[R3, #+80]
    907          
    908              /* Check if the SPI is already enabled */ 
    909              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \   000000AC   0x6818             LDR      R0,[R3, #+0]
   \   000000AE   0x6800             LDR      R0,[R0, #+0]
   \   000000B0   0x0640             LSLS     R0,R0,#+25
   \   000000B2   0xD405             BMI.N    ??HAL_SPI_Transmit_IT_9
    910              {
    911                /* Enable SPI peripheral */
    912                __HAL_SPI_ENABLE(hspi);
   \   000000B4   0x6818             LDR      R0,[R3, #+0]
   \   000000B6   0x6800             LDR      R0,[R0, #+0]
   \   000000B8   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   000000BC   0x681C             LDR      R4,[R3, #+0]
   \   000000BE   0x6020             STR      R0,[R4, #+0]
    913              }
    914          
    915              return HAL_OK;
   \                     ??HAL_SPI_Transmit_IT_9: (+1)
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xE000             B.N      ??HAL_SPI_Transmit_IT_3
    916            }
    917            else
    918            {
    919              return HAL_BUSY;
   \                     ??HAL_SPI_Transmit_IT_0: (+1)
   \   000000C4   0x2002             MOVS     R0,#+2
   \                     ??HAL_SPI_Transmit_IT_3: (+1)
   \   000000C6   0xBC10             POP      {R4}
   \   000000C8   0x4770             BX       LR               ;; return
    920            }
    921          }
    922          
    923          /**
    924            * @brief  Receive an amount of data in no-blocking mode with Interrupt
    925            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    926            *                the configuration information for SPI module.
    927            * @param  pData: pointer to data buffer
    928            * @param  Size: amount of data to be sent
    929            * @retval HAL status
    930            */

   \                                 In section .text, align 2, keep-with-next
    931          HAL_StatusTypeDef HAL_SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
    932          {
   \                     HAL_SPI_Receive_IT: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    933            if(hspi->State == HAL_SPI_STATE_READY)
   \   00000008   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD164             BNE.N    ??HAL_SPI_Receive_IT_0
    934            {
    935              if((pData == NULL) || (Size == 0)) 
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD002             BEQ.N    ??HAL_SPI_Receive_IT_1
   \   00000014   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xD101             BNE.N    ??HAL_SPI_Receive_IT_2
    936              {
    937                return  HAL_ERROR;
   \                     ??HAL_SPI_Receive_IT_1: (+1)
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xE05E             B.N      ??HAL_SPI_Receive_IT_3
    938              }
    939          
    940              /* Process Locked */
    941              __HAL_LOCK(hspi);
   \                     ??HAL_SPI_Receive_IT_2: (+1)
   \   0000001E   0xF894 0x0050      LDRB     R0,[R4, #+80]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD101             BNE.N    ??HAL_SPI_Receive_IT_4
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0xE058             B.N      ??HAL_SPI_Receive_IT_3
   \                     ??HAL_SPI_Receive_IT_4: (+1)
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xF884 0x0050      STRB     R0,[R4, #+80]
    942          
    943              /* Configure communication */
    944              hspi->State        = HAL_SPI_STATE_BUSY_RX;
   \   00000030   0x2022             MOVS     R0,#+34
   \   00000032   0xF884 0x0051      STRB     R0,[R4, #+81]
    945              hspi->ErrorCode    = HAL_SPI_ERROR_NONE;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x6560             STR      R0,[R4, #+84]
    946          
    947              hspi->RxISR = &SPI_RxISR;
   \   0000003A   0x.... 0x....      ADR.W    R0,SPI_RxISR
   \   0000003E   0x64A0             STR      R0,[R4, #+72]
    948              hspi->pRxBuffPtr   = pData;
   \   00000040   0x63A5             STR      R5,[R4, #+56]
    949              hspi->RxXferSize   = Size;
   \   00000042   0x87A6             STRH     R6,[R4, #+60]
    950              hspi->RxXferCount  = Size ; 
   \   00000044   0x87E6             STRH     R6,[R4, #+62]
    951          
    952             /*Init field not used in handle to zero */
    953              hspi->TxISR = 0;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x64E0             STR      R0,[R4, #+76]
    954              hspi->pTxBuffPtr   = NULL;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x6320             STR      R0,[R4, #+48]
    955              hspi->TxXferSize   = 0;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x86A0             STRH     R0,[R4, #+52]
    956              hspi->TxXferCount  = 0;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x86E0             STRH     R0,[R4, #+54]
    957          
    958              /* Configure communication direction : 1Line */
    959              if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \   00000056   0x68A0             LDR      R0,[R4, #+8]
   \   00000058   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000005C   0xD106             BNE.N    ??HAL_SPI_Receive_IT_5
    960              {
    961                 SPI_1LINE_RX(hspi);
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0xF430 0x4080      BICS     R0,R0,#0x4000
   \   00000066   0x6821             LDR      R1,[R4, #+0]
   \   00000068   0x6008             STR      R0,[R1, #+0]
   \   0000006A   0xE011             B.N      ??HAL_SPI_Receive_IT_6
    962              }
    963              else if((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
   \                     ??HAL_SPI_Receive_IT_5: (+1)
   \   0000006C   0x68A0             LDR      R0,[R4, #+8]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD10E             BNE.N    ??HAL_SPI_Receive_IT_6
   \   00000072   0x6860             LDR      R0,[R4, #+4]
   \   00000074   0xF5B0 0x7F82      CMP      R0,#+260
   \   00000078   0xD10A             BNE.N    ??HAL_SPI_Receive_IT_6
    964              {
    965                 /* Process Unlocked */
    966                 __HAL_UNLOCK(hspi);
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xF884 0x0050      STRB     R0,[R4, #+80]
    967          
    968                 /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
    969                 return HAL_SPI_TransmitReceive_IT(hspi, pData, pData, Size);
   \   00000080   0x0033             MOVS     R3,R6
   \   00000082   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000084   0x002A             MOVS     R2,R5
   \   00000086   0x0029             MOVS     R1,R5
   \   00000088   0x0020             MOVS     R0,R4
   \   0000008A   0x.... 0x....      BL       HAL_SPI_TransmitReceive_IT
   \   0000008E   0xE025             B.N      ??HAL_SPI_Receive_IT_3
    970              }
    971          
    972              /* Reset CRC Calculation */
    973              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Receive_IT_6: (+1)
   \   00000090   0x6AA0             LDR      R0,[R4, #+40]
   \   00000092   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000096   0xD10B             BNE.N    ??HAL_SPI_Receive_IT_7
    974              {
    975                SPI_RESET_CRC(hspi);
   \   00000098   0x6820             LDR      R0,[R4, #+0]
   \   0000009A   0x6800             LDR      R0,[R0, #+0]
   \   0000009C   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   000000A0   0x6821             LDR      R1,[R4, #+0]
   \   000000A2   0x6008             STR      R0,[R1, #+0]
   \   000000A4   0x6820             LDR      R0,[R4, #+0]
   \   000000A6   0x6800             LDR      R0,[R0, #+0]
   \   000000A8   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   000000AC   0x6821             LDR      R1,[R4, #+0]
   \   000000AE   0x6008             STR      R0,[R1, #+0]
    976              }
    977          
    978              /* Enable TXE and ERR interrupt */
    979              __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   \                     ??HAL_SPI_Receive_IT_7: (+1)
   \   000000B0   0x6820             LDR      R0,[R4, #+0]
   \   000000B2   0x6840             LDR      R0,[R0, #+4]
   \   000000B4   0xF050 0x0060      ORRS     R0,R0,#0x60
   \   000000B8   0x6821             LDR      R1,[R4, #+0]
   \   000000BA   0x6048             STR      R0,[R1, #+4]
    980          
    981              /* Process Unlocked */
    982              __HAL_UNLOCK(hspi);
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0xF884 0x0050      STRB     R0,[R4, #+80]
    983          
    984              /* Note : The SPI must be enabled after unlocking current process 
    985                        to avoid the risk of SPI interrupt handle execution before current
    986                        process unlock */
    987          
    988                  /* Check if the SPI is already enabled */ 
    989              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \   000000C2   0x6820             LDR      R0,[R4, #+0]
   \   000000C4   0x6800             LDR      R0,[R0, #+0]
   \   000000C6   0x0640             LSLS     R0,R0,#+25
   \   000000C8   0xD405             BMI.N    ??HAL_SPI_Receive_IT_8
    990              {
    991                /* Enable SPI peripheral */
    992                __HAL_SPI_ENABLE(hspi);
   \   000000CA   0x6820             LDR      R0,[R4, #+0]
   \   000000CC   0x6800             LDR      R0,[R0, #+0]
   \   000000CE   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   000000D2   0x6821             LDR      R1,[R4, #+0]
   \   000000D4   0x6008             STR      R0,[R1, #+0]
    993              }
    994          
    995              return HAL_OK;
   \                     ??HAL_SPI_Receive_IT_8: (+1)
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0xE000             B.N      ??HAL_SPI_Receive_IT_3
    996            }
    997            else
    998            {
    999              return HAL_BUSY; 
   \                     ??HAL_SPI_Receive_IT_0: (+1)
   \   000000DA   0x2002             MOVS     R0,#+2
   \                     ??HAL_SPI_Receive_IT_3: (+1)
   \   000000DC   0xBD70             POP      {R4-R6,PC}       ;; return
   1000            }
   1001          }
   1002          
   1003          /**
   1004            * @brief  Transmit and Receive an amount of data in no-blocking mode with Interrupt 
   1005            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1006            *                the configuration information for SPI module.
   1007            * @param  pTxData: pointer to transmission data buffer
   1008            * @param  pRxData: pointer to reception data buffer to be
   1009            * @param  Size: amount of data to be sent
   1010            * @retval HAL status
   1011            */

   \                                 In section .text, align 2, keep-with-next
   1012          HAL_StatusTypeDef HAL_SPI_TransmitReceive_IT(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
   1013          {
   \                     HAL_SPI_TransmitReceive_IT: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0004             MOVS     R4,R0
   1014          
   1015            if((hspi->State == HAL_SPI_STATE_READY) || \
   1016               ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->State == HAL_SPI_STATE_BUSY_RX)))
   \   00000004   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD00A             BEQ.N    ??HAL_SPI_TransmitReceive_IT_0
   \   0000000C   0x6860             LDR      R0,[R4, #+4]
   \   0000000E   0xF5B0 0x7F82      CMP      R0,#+260
   \   00000012   0xD152             BNE.N    ??HAL_SPI_TransmitReceive_IT_1
   \   00000014   0x68A0             LDR      R0,[R4, #+8]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD14F             BNE.N    ??HAL_SPI_TransmitReceive_IT_1
   \   0000001A   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \   0000001E   0x2822             CMP      R0,#+34
   \   00000020   0xD14B             BNE.N    ??HAL_SPI_TransmitReceive_IT_1
   1017            {
   1018              if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0)) 
   \                     ??HAL_SPI_TransmitReceive_IT_0: (+1)
   \   00000022   0x2900             CMP      R1,#+0
   \   00000024   0xD004             BEQ.N    ??HAL_SPI_TransmitReceive_IT_2
   \   00000026   0x2A00             CMP      R2,#+0
   \   00000028   0xD002             BEQ.N    ??HAL_SPI_TransmitReceive_IT_2
   \   0000002A   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000002C   0x2B00             CMP      R3,#+0
   \   0000002E   0xD101             BNE.N    ??HAL_SPI_TransmitReceive_IT_3
   1019              {
   1020                return  HAL_ERROR;
   \                     ??HAL_SPI_TransmitReceive_IT_2: (+1)
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0xE043             B.N      ??HAL_SPI_TransmitReceive_IT_4
   1021              }
   1022          
   1023              /* Check the parameters */
   1024              assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
   1025          
   1026              /* Process locked */
   1027              __HAL_LOCK(hspi);
   \                     ??HAL_SPI_TransmitReceive_IT_3: (+1)
   \   00000034   0xF894 0x0050      LDRB     R0,[R4, #+80]
   \   00000038   0x2801             CMP      R0,#+1
   \   0000003A   0xD101             BNE.N    ??HAL_SPI_TransmitReceive_IT_5
   \   0000003C   0x2002             MOVS     R0,#+2
   \   0000003E   0xE03D             B.N      ??HAL_SPI_TransmitReceive_IT_4
   \                     ??HAL_SPI_TransmitReceive_IT_5: (+1)
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xF884 0x0050      STRB     R0,[R4, #+80]
   1028          
   1029              /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
   1030              if(hspi->State != HAL_SPI_STATE_BUSY_RX)
   \   00000046   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \   0000004A   0x2822             CMP      R0,#+34
   \   0000004C   0xD002             BEQ.N    ??HAL_SPI_TransmitReceive_IT_6
   1031              {
   1032                hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
   \   0000004E   0x2032             MOVS     R0,#+50
   \   00000050   0xF884 0x0051      STRB     R0,[R4, #+81]
   1033              }
   1034          
   1035              /* Configure communication */
   1036              hspi->ErrorCode    = HAL_SPI_ERROR_NONE;
   \                     ??HAL_SPI_TransmitReceive_IT_6: (+1)
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x6560             STR      R0,[R4, #+84]
   1037          
   1038              hspi->TxISR = &SPI_TxISR;
   \   00000058   0x.... 0x....      ADR.W    R0,SPI_TxISR
   \   0000005C   0x64E0             STR      R0,[R4, #+76]
   1039              hspi->pTxBuffPtr   = pTxData;
   \   0000005E   0x6321             STR      R1,[R4, #+48]
   1040              hspi->TxXferSize   = Size;
   \   00000060   0x86A3             STRH     R3,[R4, #+52]
   1041              hspi->TxXferCount  = Size;
   \   00000062   0x86E3             STRH     R3,[R4, #+54]
   1042          
   1043              hspi->RxISR = &SPI_2LinesRxISR;
   \   00000064   0x.... 0x....      ADR.W    R0,SPI_2LinesRxISR
   \   00000068   0x64A0             STR      R0,[R4, #+72]
   1044              hspi->pRxBuffPtr   = pRxData;
   \   0000006A   0x63A2             STR      R2,[R4, #+56]
   1045              hspi->RxXferSize   = Size;
   \   0000006C   0x87A3             STRH     R3,[R4, #+60]
   1046              hspi->RxXferCount  = Size;
   \   0000006E   0x87E3             STRH     R3,[R4, #+62]
   1047          
   1048              /* Reset CRC Calculation */
   1049              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000070   0x6AA0             LDR      R0,[R4, #+40]
   \   00000072   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000076   0xD10B             BNE.N    ??HAL_SPI_TransmitReceive_IT_7
   1050              {
   1051                SPI_RESET_CRC(hspi);
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   00000080   0x6825             LDR      R5,[R4, #+0]
   \   00000082   0x6028             STR      R0,[R5, #+0]
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   0000008C   0x6825             LDR      R5,[R4, #+0]
   \   0000008E   0x6028             STR      R0,[R5, #+0]
   1052              }
   1053          
   1054              /* Enable TXE, RXNE and ERR interrupt */
   1055              __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
   \                     ??HAL_SPI_TransmitReceive_IT_7: (+1)
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0x6840             LDR      R0,[R0, #+4]
   \   00000094   0xF050 0x00E0      ORRS     R0,R0,#0xE0
   \   00000098   0x6825             LDR      R5,[R4, #+0]
   \   0000009A   0x6068             STR      R0,[R5, #+4]
   1056          
   1057              /* Process Unlocked */
   1058              __HAL_UNLOCK(hspi);
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0xF884 0x0050      STRB     R0,[R4, #+80]
   1059          
   1060              /* Check if the SPI is already enabled */ 
   1061              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x6800             LDR      R0,[R0, #+0]
   \   000000A6   0x0640             LSLS     R0,R0,#+25
   \   000000A8   0xD405             BMI.N    ??HAL_SPI_TransmitReceive_IT_8
   1062              {
   1063                /* Enable SPI peripheral */
   1064                __HAL_SPI_ENABLE(hspi);
   \   000000AA   0x6820             LDR      R0,[R4, #+0]
   \   000000AC   0x6800             LDR      R0,[R0, #+0]
   \   000000AE   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   000000B2   0x6825             LDR      R5,[R4, #+0]
   \   000000B4   0x6028             STR      R0,[R5, #+0]
   1065              }
   1066          
   1067              return HAL_OK;
   \                     ??HAL_SPI_TransmitReceive_IT_8: (+1)
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0xE000             B.N      ??HAL_SPI_TransmitReceive_IT_4
   1068            }
   1069            else
   1070            {
   1071              return HAL_BUSY; 
   \                     ??HAL_SPI_TransmitReceive_IT_1: (+1)
   \   000000BA   0x2002             MOVS     R0,#+2
   \                     ??HAL_SPI_TransmitReceive_IT_4: (+1)
   \   000000BC   0xBC30             POP      {R4,R5}
   \   000000BE   0x4770             BX       LR               ;; return
   1072            }
   1073          }
   1074          
   1075          /**
   1076            * @brief  Transmit an amount of data in no-blocking mode with DMA
   1077            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1078            *                the configuration information for SPI module.
   1079            * @param  pData: pointer to data buffer
   1080            * @param  Size: amount of data to be sent
   1081            * @retval HAL status
   1082            */

   \                                 In section .text, align 2, keep-with-next
   1083          HAL_StatusTypeDef HAL_SPI_Transmit_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1084          {
   \                     HAL_SPI_Transmit_DMA: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1085            if(hspi->State == HAL_SPI_STATE_READY)
   \   00000008   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD164             BNE.N    ??HAL_SPI_Transmit_DMA_0
   1086            {
   1087              if((pData == NULL) || (Size == 0))
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD002             BEQ.N    ??HAL_SPI_Transmit_DMA_1
   \   00000014   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xD101             BNE.N    ??HAL_SPI_Transmit_DMA_2
   1088              {
   1089                return  HAL_ERROR;
   \                     ??HAL_SPI_Transmit_DMA_1: (+1)
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xE05E             B.N      ??HAL_SPI_Transmit_DMA_3
   1090              }
   1091          
   1092              /* Check the parameters */
   1093              assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
   1094          
   1095              /* Process Locked */
   1096              __HAL_LOCK(hspi);
   \                     ??HAL_SPI_Transmit_DMA_2: (+1)
   \   0000001E   0xF894 0x0050      LDRB     R0,[R4, #+80]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD101             BNE.N    ??HAL_SPI_Transmit_DMA_4
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0xE058             B.N      ??HAL_SPI_Transmit_DMA_3
   \                     ??HAL_SPI_Transmit_DMA_4: (+1)
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xF884 0x0050      STRB     R0,[R4, #+80]
   1097          
   1098              /* Configure communication */
   1099              hspi->State       = HAL_SPI_STATE_BUSY_TX;
   \   00000030   0x2012             MOVS     R0,#+18
   \   00000032   0xF884 0x0051      STRB     R0,[R4, #+81]
   1100              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x6560             STR      R0,[R4, #+84]
   1101          
   1102              hspi->pTxBuffPtr  = pData;
   \   0000003A   0x6325             STR      R5,[R4, #+48]
   1103              hspi->TxXferSize  = Size;
   \   0000003C   0x86A6             STRH     R6,[R4, #+52]
   1104              hspi->TxXferCount = Size;
   \   0000003E   0x86E6             STRH     R6,[R4, #+54]
   1105          
   1106              /*Init field not used in handle to zero */
   1107              hspi->TxISR = 0;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x64E0             STR      R0,[R4, #+76]
   1108              hspi->RxISR = 0;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x64A0             STR      R0,[R4, #+72]
   1109              hspi->pRxBuffPtr  = NULL;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x63A0             STR      R0,[R4, #+56]
   1110              hspi->RxXferSize  = 0;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x87A0             STRH     R0,[R4, #+60]
   1111              hspi->RxXferCount = 0;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x87E0             STRH     R0,[R4, #+62]
   1112          
   1113              /* Configure communication direction : 1Line */
   1114              if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \   00000054   0x68A0             LDR      R0,[R4, #+8]
   \   00000056   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000005A   0xD105             BNE.N    ??HAL_SPI_Transmit_DMA_5
   1115              {
   1116                SPI_1LINE_TX(hspi);
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x6008             STR      R0,[R1, #+0]
   1117              }
   1118          
   1119              /* Reset CRC Calculation */
   1120              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Transmit_DMA_5: (+1)
   \   00000068   0x6AA0             LDR      R0,[R4, #+40]
   \   0000006A   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000006E   0xD10B             BNE.N    ??HAL_SPI_Transmit_DMA_6
   1121              {
   1122                SPI_RESET_CRC(hspi);
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   00000078   0x6821             LDR      R1,[R4, #+0]
   \   0000007A   0x6008             STR      R0,[R1, #+0]
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   00000084   0x6821             LDR      R1,[R4, #+0]
   \   00000086   0x6008             STR      R0,[R1, #+0]
   1123              }
   1124          
   1125              /* Set the SPI TxDMA Half transfer complete callback */
   1126              hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
   \                     ??HAL_SPI_Transmit_DMA_6: (+1)
   \   00000088   0x.... 0x....      ADR.W    R0,SPI_DMAHalfTransmitCplt
   \   0000008C   0x6C21             LDR      R1,[R4, #+64]
   \   0000008E   0x62C8             STR      R0,[R1, #+44]
   1127              
   1128              /* Set the SPI TxDMA transfer complete callback */
   1129              hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;
   \   00000090   0x.... 0x....      ADR.W    R0,SPI_DMATransmitCplt
   \   00000094   0x6C21             LDR      R1,[R4, #+64]
   \   00000096   0x6288             STR      R0,[R1, #+40]
   1130          
   1131              /* Set the DMA error callback */
   1132              hspi->hdmatx->XferErrorCallback = SPI_DMAError;
   \   00000098   0x.... 0x....      ADR.W    R0,SPI_DMAError
   \   0000009C   0x6C21             LDR      R1,[R4, #+64]
   \   0000009E   0x6308             STR      R0,[R1, #+48]
   1133          
   1134              /* Enable the Tx DMA Channel */
   1135              HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
   \   000000A0   0x8EE3             LDRH     R3,[R4, #+54]
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0xF110 0x020C      ADDS     R2,R0,#+12
   \   000000A8   0x6B21             LDR      R1,[R4, #+48]
   \   000000AA   0x6C20             LDR      R0,[R4, #+64]
   \   000000AC   0x.... 0x....      BL       HAL_DMA_Start_IT
   1136          
   1137              /* Enable Tx DMA Request */
   1138              SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \   000000B0   0x6820             LDR      R0,[R4, #+0]
   \   000000B2   0x6840             LDR      R0,[R0, #+4]
   \   000000B4   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000000B8   0x6821             LDR      R1,[R4, #+0]
   \   000000BA   0x6048             STR      R0,[R1, #+4]
   1139          
   1140              /* Process Unlocked */
   1141              __HAL_UNLOCK(hspi);
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0xF884 0x0050      STRB     R0,[R4, #+80]
   1142          
   1143              /* Check if the SPI is already enabled */ 
   1144              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \   000000C2   0x6820             LDR      R0,[R4, #+0]
   \   000000C4   0x6800             LDR      R0,[R0, #+0]
   \   000000C6   0x0640             LSLS     R0,R0,#+25
   \   000000C8   0xD405             BMI.N    ??HAL_SPI_Transmit_DMA_7
   1145              {
   1146                /* Enable SPI peripheral */
   1147                __HAL_SPI_ENABLE(hspi);
   \   000000CA   0x6820             LDR      R0,[R4, #+0]
   \   000000CC   0x6800             LDR      R0,[R0, #+0]
   \   000000CE   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   000000D2   0x6821             LDR      R1,[R4, #+0]
   \   000000D4   0x6008             STR      R0,[R1, #+0]
   1148              }
   1149          
   1150              return HAL_OK;
   \                     ??HAL_SPI_Transmit_DMA_7: (+1)
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0xE000             B.N      ??HAL_SPI_Transmit_DMA_3
   1151            }
   1152            else
   1153            {
   1154              return HAL_BUSY;
   \                     ??HAL_SPI_Transmit_DMA_0: (+1)
   \   000000DA   0x2002             MOVS     R0,#+2
   \                     ??HAL_SPI_Transmit_DMA_3: (+1)
   \   000000DC   0xBD70             POP      {R4-R6,PC}       ;; return
   1155            }
   1156          }
   1157          
   1158          /**
   1159            * @brief  Receive an amount of data in no-blocking mode with DMA 
   1160            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1161            *                the configuration information for SPI module.
   1162            * @param  pData: pointer to data buffer
   1163            * @note  When the CRC feature is enabled the pData Length must be Size + 1. 
   1164            * @param  Size: amount of data to be sent
   1165            * @retval HAL status
   1166            */

   \                                 In section .text, align 2, keep-with-next
   1167          HAL_StatusTypeDef HAL_SPI_Receive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1168          {
   \                     HAL_SPI_Receive_DMA: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1169            if(hspi->State == HAL_SPI_STATE_READY)
   \   00000008   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD177             BNE.N    ??HAL_SPI_Receive_DMA_0
   1170            {
   1171              if((pData == NULL) || (Size == 0))
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD002             BEQ.N    ??HAL_SPI_Receive_DMA_1
   \   00000014   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xD101             BNE.N    ??HAL_SPI_Receive_DMA_2
   1172              {
   1173                return  HAL_ERROR;
   \                     ??HAL_SPI_Receive_DMA_1: (+1)
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xE071             B.N      ??HAL_SPI_Receive_DMA_3
   1174              }
   1175          
   1176              /* Process Locked */
   1177              __HAL_LOCK(hspi);
   \                     ??HAL_SPI_Receive_DMA_2: (+1)
   \   0000001E   0xF894 0x0050      LDRB     R0,[R4, #+80]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD101             BNE.N    ??HAL_SPI_Receive_DMA_4
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0xE06B             B.N      ??HAL_SPI_Receive_DMA_3
   \                     ??HAL_SPI_Receive_DMA_4: (+1)
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xF884 0x0050      STRB     R0,[R4, #+80]
   1178          
   1179              /* Configure communication */
   1180              hspi->State       = HAL_SPI_STATE_BUSY_RX;
   \   00000030   0x2022             MOVS     R0,#+34
   \   00000032   0xF884 0x0051      STRB     R0,[R4, #+81]
   1181              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x6560             STR      R0,[R4, #+84]
   1182          
   1183              hspi->pRxBuffPtr  = pData;
   \   0000003A   0x63A5             STR      R5,[R4, #+56]
   1184              hspi->RxXferSize  = Size;
   \   0000003C   0x87A6             STRH     R6,[R4, #+60]
   1185              hspi->RxXferCount = Size;
   \   0000003E   0x87E6             STRH     R6,[R4, #+62]
   1186          
   1187              /*Init field not used in handle to zero */
   1188              hspi->RxISR = 0;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x64A0             STR      R0,[R4, #+72]
   1189              hspi->TxISR = 0;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x64E0             STR      R0,[R4, #+76]
   1190              hspi->pTxBuffPtr  = NULL;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x6320             STR      R0,[R4, #+48]
   1191              hspi->TxXferSize  = 0;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x86A0             STRH     R0,[R4, #+52]
   1192              hspi->TxXferCount = 0;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x86E0             STRH     R0,[R4, #+54]
   1193          
   1194              /* Configure communication direction : 1Line */
   1195              if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \   00000054   0x68A0             LDR      R0,[R4, #+8]
   \   00000056   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000005A   0xD106             BNE.N    ??HAL_SPI_Receive_DMA_5
   1196              {
   1197                 SPI_1LINE_RX(hspi);
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xF430 0x4080      BICS     R0,R0,#0x4000
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x6008             STR      R0,[R1, #+0]
   \   00000068   0xE011             B.N      ??HAL_SPI_Receive_DMA_6
   1198              }
   1199              else if((hspi->Init.Direction == SPI_DIRECTION_2LINES)&&(hspi->Init.Mode == SPI_MODE_MASTER))
   \                     ??HAL_SPI_Receive_DMA_5: (+1)
   \   0000006A   0x68A0             LDR      R0,[R4, #+8]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD10E             BNE.N    ??HAL_SPI_Receive_DMA_6
   \   00000070   0x6860             LDR      R0,[R4, #+4]
   \   00000072   0xF5B0 0x7F82      CMP      R0,#+260
   \   00000076   0xD10A             BNE.N    ??HAL_SPI_Receive_DMA_6
   1200              {
   1201                 /* Process Unlocked */
   1202                 __HAL_UNLOCK(hspi);
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xF884 0x0050      STRB     R0,[R4, #+80]
   1203          
   1204                 /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
   1205                 return HAL_SPI_TransmitReceive_DMA(hspi, pData, pData, Size);
   \   0000007E   0x0033             MOVS     R3,R6
   \   00000080   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000082   0x002A             MOVS     R2,R5
   \   00000084   0x0029             MOVS     R1,R5
   \   00000086   0x0020             MOVS     R0,R4
   \   00000088   0x.... 0x....      BL       HAL_SPI_TransmitReceive_DMA
   \   0000008C   0xE039             B.N      ??HAL_SPI_Receive_DMA_3
   1206              }
   1207          
   1208              /* Reset CRC Calculation */
   1209              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Receive_DMA_6: (+1)
   \   0000008E   0x6AA0             LDR      R0,[R4, #+40]
   \   00000090   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000094   0xD10B             BNE.N    ??HAL_SPI_Receive_DMA_7
   1210              {
   1211                SPI_RESET_CRC(hspi);
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0x6800             LDR      R0,[R0, #+0]
   \   0000009A   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   0000009E   0x6821             LDR      R1,[R4, #+0]
   \   000000A0   0x6008             STR      R0,[R1, #+0]
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x6800             LDR      R0,[R0, #+0]
   \   000000A6   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   000000AA   0x6821             LDR      R1,[R4, #+0]
   \   000000AC   0x6008             STR      R0,[R1, #+0]
   1212              }
   1213          
   1214              /* Set the SPI RxDMA Half transfer complete callback */
   1215              hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
   \                     ??HAL_SPI_Receive_DMA_7: (+1)
   \   000000AE   0x.... 0x....      ADR.W    R0,SPI_DMAHalfReceiveCplt
   \   000000B2   0x6C61             LDR      R1,[R4, #+68]
   \   000000B4   0x62C8             STR      R0,[R1, #+44]
   1216              
   1217              /* Set the SPI Rx DMA transfer complete callback */
   1218              hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
   \   000000B6   0x.... 0x....      ADR.W    R0,SPI_DMAReceiveCplt
   \   000000BA   0x6C61             LDR      R1,[R4, #+68]
   \   000000BC   0x6288             STR      R0,[R1, #+40]
   1219          
   1220              /* Set the DMA error callback */
   1221              hspi->hdmarx->XferErrorCallback = SPI_DMAError;
   \   000000BE   0x.... 0x....      ADR.W    R0,SPI_DMAError
   \   000000C2   0x6C61             LDR      R1,[R4, #+68]
   \   000000C4   0x6308             STR      R0,[R1, #+48]
   1222          
   1223              /* Enable the Rx DMA Channel */
   1224              HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
   \   000000C6   0x8FE3             LDRH     R3,[R4, #+62]
   \   000000C8   0x6BA2             LDR      R2,[R4, #+56]
   \   000000CA   0x6820             LDR      R0,[R4, #+0]
   \   000000CC   0xF110 0x010C      ADDS     R1,R0,#+12
   \   000000D0   0x6C60             LDR      R0,[R4, #+68]
   \   000000D2   0x.... 0x....      BL       HAL_DMA_Start_IT
   1225          
   1226              /* Enable Rx DMA Request */  
   1227              SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
   \   000000D6   0x6820             LDR      R0,[R4, #+0]
   \   000000D8   0x6840             LDR      R0,[R0, #+4]
   \   000000DA   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000DE   0x6821             LDR      R1,[R4, #+0]
   \   000000E0   0x6048             STR      R0,[R1, #+4]
   1228          
   1229              /* Process Unlocked */
   1230              __HAL_UNLOCK(hspi);
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0xF884 0x0050      STRB     R0,[R4, #+80]
   1231          
   1232              /* Check if the SPI is already enabled */ 
   1233              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \   000000E8   0x6820             LDR      R0,[R4, #+0]
   \   000000EA   0x6800             LDR      R0,[R0, #+0]
   \   000000EC   0x0640             LSLS     R0,R0,#+25
   \   000000EE   0xD405             BMI.N    ??HAL_SPI_Receive_DMA_8
   1234              {
   1235                /* Enable SPI peripheral */
   1236                __HAL_SPI_ENABLE(hspi);
   \   000000F0   0x6820             LDR      R0,[R4, #+0]
   \   000000F2   0x6800             LDR      R0,[R0, #+0]
   \   000000F4   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   000000F8   0x6821             LDR      R1,[R4, #+0]
   \   000000FA   0x6008             STR      R0,[R1, #+0]
   1237              }
   1238          
   1239              return HAL_OK;
   \                     ??HAL_SPI_Receive_DMA_8: (+1)
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0xE000             B.N      ??HAL_SPI_Receive_DMA_3
   1240            }
   1241            else
   1242            {
   1243              return HAL_BUSY;
   \                     ??HAL_SPI_Receive_DMA_0: (+1)
   \   00000100   0x2002             MOVS     R0,#+2
   \                     ??HAL_SPI_Receive_DMA_3: (+1)
   \   00000102   0xBD70             POP      {R4-R6,PC}       ;; return
   1244            }
   1245          }
   1246          
   1247          /**
   1248            * @brief  Transmit and Receive an amount of data in no-blocking mode with DMA 
   1249            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1250            *                the configuration information for SPI module.
   1251            * @param  pTxData: pointer to transmission data buffer
   1252            * @param  pRxData: pointer to reception data buffer
   1253            * @note  When the CRC feature is enabled the pRxData Length must be Size + 1 
   1254            * @param  Size: amount of data to be sent
   1255            * @retval HAL status
   1256            */

   \                                 In section .text, align 2, keep-with-next
   1257          HAL_StatusTypeDef HAL_SPI_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
   1258          {
   \                     HAL_SPI_TransmitReceive_DMA: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
   1259            if((hspi->State == HAL_SPI_STATE_READY) || \
   1260               ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->State == HAL_SPI_STATE_BUSY_RX)))
   \   0000000A   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD00D             BEQ.N    ??HAL_SPI_TransmitReceive_DMA_0
   \   00000012   0x6860             LDR      R0,[R4, #+4]
   \   00000014   0xF5B0 0x7F82      CMP      R0,#+260
   \   00000018   0xF040 0x808E      BNE.W    ??HAL_SPI_TransmitReceive_DMA_1
   \   0000001C   0x68A0             LDR      R0,[R4, #+8]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xF040 0x808A      BNE.W    ??HAL_SPI_TransmitReceive_DMA_1
   \   00000024   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \   00000028   0x2822             CMP      R0,#+34
   \   0000002A   0xF040 0x8085      BNE.W    ??HAL_SPI_TransmitReceive_DMA_1
   1261            {
   1262              if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0))
   \                     ??HAL_SPI_TransmitReceive_DMA_0: (+1)
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD004             BEQ.N    ??HAL_SPI_TransmitReceive_DMA_2
   \   00000032   0x2E00             CMP      R6,#+0
   \   00000034   0xD002             BEQ.N    ??HAL_SPI_TransmitReceive_DMA_2
   \   00000036   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000038   0x2F00             CMP      R7,#+0
   \   0000003A   0xD101             BNE.N    ??HAL_SPI_TransmitReceive_DMA_3
   1263              {
   1264                return  HAL_ERROR;
   \                     ??HAL_SPI_TransmitReceive_DMA_2: (+1)
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xE07C             B.N      ??HAL_SPI_TransmitReceive_DMA_4
   1265              }
   1266          
   1267              /* Check the parameters */
   1268              assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
   1269              
   1270              /* Process locked */
   1271              __HAL_LOCK(hspi);
   \                     ??HAL_SPI_TransmitReceive_DMA_3: (+1)
   \   00000040   0xF894 0x0050      LDRB     R0,[R4, #+80]
   \   00000044   0x2801             CMP      R0,#+1
   \   00000046   0xD101             BNE.N    ??HAL_SPI_TransmitReceive_DMA_5
   \   00000048   0x2002             MOVS     R0,#+2
   \   0000004A   0xE076             B.N      ??HAL_SPI_TransmitReceive_DMA_4
   \                     ??HAL_SPI_TransmitReceive_DMA_5: (+1)
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0xF884 0x0050      STRB     R0,[R4, #+80]
   1272          
   1273              /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
   1274              if(hspi->State != HAL_SPI_STATE_BUSY_RX)
   \   00000052   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \   00000056   0x2822             CMP      R0,#+34
   \   00000058   0xD002             BEQ.N    ??HAL_SPI_TransmitReceive_DMA_6
   1275              {
   1276                hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
   \   0000005A   0x2032             MOVS     R0,#+50
   \   0000005C   0xF884 0x0051      STRB     R0,[R4, #+81]
   1277              }
   1278          
   1279              /* Configure communication */
   1280              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \                     ??HAL_SPI_TransmitReceive_DMA_6: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x6560             STR      R0,[R4, #+84]
   1281          
   1282              hspi->pTxBuffPtr  = (uint8_t*)pTxData;
   \   00000064   0x6325             STR      R5,[R4, #+48]
   1283              hspi->TxXferSize  = Size;
   \   00000066   0x86A7             STRH     R7,[R4, #+52]
   1284              hspi->TxXferCount = Size;
   \   00000068   0x86E7             STRH     R7,[R4, #+54]
   1285          
   1286              hspi->pRxBuffPtr  = (uint8_t*)pRxData;
   \   0000006A   0x63A6             STR      R6,[R4, #+56]
   1287              hspi->RxXferSize  = Size;
   \   0000006C   0x87A7             STRH     R7,[R4, #+60]
   1288              hspi->RxXferCount = Size;
   \   0000006E   0x87E7             STRH     R7,[R4, #+62]
   1289          
   1290              /*Init field not used in handle to zero */
   1291              hspi->RxISR = 0;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x64A0             STR      R0,[R4, #+72]
   1292              hspi->TxISR = 0;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x64E0             STR      R0,[R4, #+76]
   1293          
   1294              /* Reset CRC Calculation */
   1295              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000078   0x6AA0             LDR      R0,[R4, #+40]
   \   0000007A   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000007E   0xD10B             BNE.N    ??HAL_SPI_TransmitReceive_DMA_7
   1296              {
   1297                SPI_RESET_CRC(hspi);
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   00000088   0x6821             LDR      R1,[R4, #+0]
   \   0000008A   0x6008             STR      R0,[R1, #+0]
   \   0000008C   0x6820             LDR      R0,[R4, #+0]
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   00000094   0x6821             LDR      R1,[R4, #+0]
   \   00000096   0x6008             STR      R0,[R1, #+0]
   1298              }
   1299          
   1300              /* Check if we are in Rx only or in Rx/Tx Mode and configure the DMA transfer complete callback */
   1301              if(hspi->State == HAL_SPI_STATE_BUSY_RX)
   \                     ??HAL_SPI_TransmitReceive_DMA_7: (+1)
   \   00000098   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \   0000009C   0x2822             CMP      R0,#+34
   \   0000009E   0xD108             BNE.N    ??HAL_SPI_TransmitReceive_DMA_8
   1302              {
   1303                /* Set the SPI Rx DMA Half transfer complete callback */
   1304                hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
   \   000000A0   0x.... 0x....      ADR.W    R0,SPI_DMAHalfReceiveCplt
   \   000000A4   0x6C61             LDR      R1,[R4, #+68]
   \   000000A6   0x62C8             STR      R0,[R1, #+44]
   1305                
   1306                hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
   \   000000A8   0x.... 0x....      ADR.W    R0,SPI_DMAReceiveCplt
   \   000000AC   0x6C61             LDR      R1,[R4, #+68]
   \   000000AE   0x6288             STR      R0,[R1, #+40]
   \   000000B0   0xE007             B.N      ??HAL_SPI_TransmitReceive_DMA_9
   1307              }
   1308              else
   1309              {
   1310                /* Set the SPI Tx/Rx DMA Half transfer complete callback */
   1311                hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfTransmitReceiveCplt;
   \                     ??HAL_SPI_TransmitReceive_DMA_8: (+1)
   \   000000B2   0x.... 0x....      ADR.W    R0,SPI_DMAHalfTransmitReceiveCplt
   \   000000B6   0x6C61             LDR      R1,[R4, #+68]
   \   000000B8   0x62C8             STR      R0,[R1, #+44]
   1312            
   1313                hspi->hdmarx->XferCpltCallback = SPI_DMATransmitReceiveCplt;
   \   000000BA   0x.... 0x....      ADR.W    R0,SPI_DMATransmitReceiveCplt
   \   000000BE   0x6C61             LDR      R1,[R4, #+68]
   \   000000C0   0x6288             STR      R0,[R1, #+40]
   1314              }
   1315          
   1316              /* Set the DMA error callback */
   1317              hspi->hdmarx->XferErrorCallback = SPI_DMAError;
   \                     ??HAL_SPI_TransmitReceive_DMA_9: (+1)
   \   000000C2   0x.... 0x....      ADR.W    R0,SPI_DMAError
   \   000000C6   0x6C61             LDR      R1,[R4, #+68]
   \   000000C8   0x6308             STR      R0,[R1, #+48]
   1318          
   1319              /* Enable the Rx DMA Channel */
   1320              HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
   \   000000CA   0x8FE3             LDRH     R3,[R4, #+62]
   \   000000CC   0x6BA2             LDR      R2,[R4, #+56]
   \   000000CE   0x6820             LDR      R0,[R4, #+0]
   \   000000D0   0xF110 0x010C      ADDS     R1,R0,#+12
   \   000000D4   0x6C60             LDR      R0,[R4, #+68]
   \   000000D6   0x.... 0x....      BL       HAL_DMA_Start_IT
   1321          
   1322              /* Enable Rx DMA Request */  
   1323              SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
   \   000000DA   0x6820             LDR      R0,[R4, #+0]
   \   000000DC   0x6840             LDR      R0,[R0, #+4]
   \   000000DE   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000E2   0x6821             LDR      R1,[R4, #+0]
   \   000000E4   0x6048             STR      R0,[R1, #+4]
   1324          
   1325              /* Set the SPI Tx DMA transfer complete callback as NULL because the communication closing
   1326              is performed in DMA reception complete callback  */
   1327              if(hspi->State == HAL_SPI_STATE_BUSY_TX_RX)
   \   000000E6   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \   000000EA   0x2832             CMP      R0,#+50
   \   000000EC   0xD104             BNE.N    ??HAL_SPI_TransmitReceive_DMA_10
   1328              {
   1329                /* Set the DMA error callback */
   1330                hspi->hdmatx->XferErrorCallback = SPI_DMAError;
   \   000000EE   0x.... 0x....      ADR.W    R0,SPI_DMAError
   \   000000F2   0x6C21             LDR      R1,[R4, #+64]
   \   000000F4   0x6308             STR      R0,[R1, #+48]
   \   000000F6   0xE002             B.N      ??HAL_SPI_TransmitReceive_DMA_11
   1331              }
   1332              else
   1333              {
   1334                hspi->hdmatx->XferErrorCallback = NULL;
   \                     ??HAL_SPI_TransmitReceive_DMA_10: (+1)
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0x6C21             LDR      R1,[R4, #+64]
   \   000000FC   0x6308             STR      R0,[R1, #+48]
   1335              }
   1336              
   1337              /* Enable the Tx DMA Channel */
   1338              HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
   \                     ??HAL_SPI_TransmitReceive_DMA_11: (+1)
   \   000000FE   0x8EE3             LDRH     R3,[R4, #+54]
   \   00000100   0x6820             LDR      R0,[R4, #+0]
   \   00000102   0xF110 0x020C      ADDS     R2,R0,#+12
   \   00000106   0x6B21             LDR      R1,[R4, #+48]
   \   00000108   0x6C20             LDR      R0,[R4, #+64]
   \   0000010A   0x.... 0x....      BL       HAL_DMA_Start_IT
   1339          
   1340              /* Check if the SPI is already enabled */ 
   1341              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \   0000010E   0x6820             LDR      R0,[R4, #+0]
   \   00000110   0x6800             LDR      R0,[R0, #+0]
   \   00000112   0x0640             LSLS     R0,R0,#+25
   \   00000114   0xD405             BMI.N    ??HAL_SPI_TransmitReceive_DMA_12
   1342              {
   1343                /* Enable SPI peripheral */
   1344                __HAL_SPI_ENABLE(hspi);
   \   00000116   0x6820             LDR      R0,[R4, #+0]
   \   00000118   0x6800             LDR      R0,[R0, #+0]
   \   0000011A   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000011E   0x6821             LDR      R1,[R4, #+0]
   \   00000120   0x6008             STR      R0,[R1, #+0]
   1345              }
   1346          
   1347              /* Enable Tx DMA Request */  
   1348              SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \                     ??HAL_SPI_TransmitReceive_DMA_12: (+1)
   \   00000122   0x6820             LDR      R0,[R4, #+0]
   \   00000124   0x6840             LDR      R0,[R0, #+4]
   \   00000126   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000012A   0x6821             LDR      R1,[R4, #+0]
   \   0000012C   0x6048             STR      R0,[R1, #+4]
   1349          
   1350              /* Process Unlocked */
   1351              __HAL_UNLOCK(hspi);
   \   0000012E   0x2000             MOVS     R0,#+0
   \   00000130   0xF884 0x0050      STRB     R0,[R4, #+80]
   1352          
   1353              return HAL_OK;
   \   00000134   0x2000             MOVS     R0,#+0
   \   00000136   0xE000             B.N      ??HAL_SPI_TransmitReceive_DMA_4
   1354            }
   1355            else
   1356            {
   1357              return HAL_BUSY;
   \                     ??HAL_SPI_TransmitReceive_DMA_1: (+1)
   \   00000138   0x2002             MOVS     R0,#+2
   \                     ??HAL_SPI_TransmitReceive_DMA_4: (+1)
   \   0000013A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1358            }
   1359          }
   1360          
   1361          
   1362          /**
   1363            * @brief Pauses the DMA Transfer.
   1364            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1365            *                the configuration information for the specified SPI module.
   1366            * @retval HAL status
   1367            */

   \                                 In section .text, align 2, keep-with-next
   1368          HAL_StatusTypeDef HAL_SPI_DMAPause(SPI_HandleTypeDef *hspi)
   1369          {
   \                     HAL_SPI_DMAPause: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1370            /* Process Locked */
   1371            __HAL_LOCK(hspi);
   \   00000002   0xF891 0x0050      LDRB     R0,[R1, #+80]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_SPI_DMAPause_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE012             B.N      ??HAL_SPI_DMAPause_1
   \                     ??HAL_SPI_DMAPause_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x0050      STRB     R0,[R1, #+80]
   1372            
   1373            /* Disable the SPI DMA Tx & Rx requests */
   1374            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \   00000014   0x6808             LDR      R0,[R1, #+0]
   \   00000016   0x6840             LDR      R0,[R0, #+4]
   \   00000018   0xF030 0x0002      BICS     R0,R0,#0x2
   \   0000001C   0x680A             LDR      R2,[R1, #+0]
   \   0000001E   0x6050             STR      R0,[R2, #+4]
   1375            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
   \   00000020   0x6808             LDR      R0,[R1, #+0]
   \   00000022   0x6840             LDR      R0,[R0, #+4]
   \   00000024   0x0840             LSRS     R0,R0,#+1
   \   00000026   0x0040             LSLS     R0,R0,#+1
   \   00000028   0x680A             LDR      R2,[R1, #+0]
   \   0000002A   0x6050             STR      R0,[R2, #+4]
   1376            
   1377            /* Process Unlocked */
   1378            __HAL_UNLOCK(hspi);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xF881 0x0050      STRB     R0,[R1, #+80]
   1379            
   1380            return HAL_OK; 
   \   00000032   0x2000             MOVS     R0,#+0
   \                     ??HAL_SPI_DMAPause_1: (+1)
   \   00000034   0x4770             BX       LR               ;; return
   1381          }
   1382          
   1383          /**
   1384            * @brief Resumes the DMA Transfer.
   1385            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1386            *                the configuration information for the specified SPI module.
   1387            * @retval HAL status
   1388            */

   \                                 In section .text, align 2, keep-with-next
   1389          HAL_StatusTypeDef HAL_SPI_DMAResume(SPI_HandleTypeDef *hspi)
   1390          {
   \                     HAL_SPI_DMAResume: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1391            /* Process Locked */
   1392            __HAL_LOCK(hspi);
   \   00000002   0xF891 0x0050      LDRB     R0,[R1, #+80]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_SPI_DMAResume_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE012             B.N      ??HAL_SPI_DMAResume_1
   \                     ??HAL_SPI_DMAResume_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x0050      STRB     R0,[R1, #+80]
   1393            
   1394            /* Enable the SPI DMA Tx & Rx requests */
   1395            SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \   00000014   0x6808             LDR      R0,[R1, #+0]
   \   00000016   0x6840             LDR      R0,[R0, #+4]
   \   00000018   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000001C   0x680A             LDR      R2,[R1, #+0]
   \   0000001E   0x6050             STR      R0,[R2, #+4]
   1396            SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
   \   00000020   0x6808             LDR      R0,[R1, #+0]
   \   00000022   0x6840             LDR      R0,[R0, #+4]
   \   00000024   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000028   0x680A             LDR      R2,[R1, #+0]
   \   0000002A   0x6050             STR      R0,[R2, #+4]
   1397            
   1398            /* Process Unlocked */
   1399            __HAL_UNLOCK(hspi);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xF881 0x0050      STRB     R0,[R1, #+80]
   1400            
   1401            return HAL_OK;
   \   00000032   0x2000             MOVS     R0,#+0
   \                     ??HAL_SPI_DMAResume_1: (+1)
   \   00000034   0x4770             BX       LR               ;; return
   1402          }
   1403          
   1404          /**
   1405            * @brief Stops the DMA Transfer.
   1406            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1407            *                the configuration information for the specified UART module.
   1408            * @retval HAL status
   1409            */

   \                                 In section .text, align 2, keep-with-next
   1410          HAL_StatusTypeDef HAL_SPI_DMAStop(SPI_HandleTypeDef *hspi)
   1411          {
   \                     HAL_SPI_DMAStop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1412            /* The Lock is not implemented on this API to allow the user application
   1413               to call the HAL SPI API under callbacks HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback():
   1414               when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
   1415               and the correspond call back is executed HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback()
   1416               */
   1417            
   1418            /* Abort the SPI DMA tx Channel */
   1419            if(hspi->hdmatx != NULL)
   \   00000004   0x6C20             LDR      R0,[R4, #+64]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD002             BEQ.N    ??HAL_SPI_DMAStop_0
   1420            {
   1421              HAL_DMA_Abort(hspi->hdmatx);
   \   0000000A   0x6C20             LDR      R0,[R4, #+64]
   \   0000000C   0x.... 0x....      BL       HAL_DMA_Abort
   1422            }
   1423            /* Abort the SPI DMA rx Channel */
   1424            if(hspi->hdmarx != NULL)
   \                     ??HAL_SPI_DMAStop_0: (+1)
   \   00000010   0x6C60             LDR      R0,[R4, #+68]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD002             BEQ.N    ??HAL_SPI_DMAStop_1
   1425            {
   1426              HAL_DMA_Abort(hspi->hdmarx);
   \   00000016   0x6C60             LDR      R0,[R4, #+68]
   \   00000018   0x.... 0x....      BL       HAL_DMA_Abort
   1427            }
   1428            
   1429            /* Disable the SPI DMA Tx & Rx requests */
   1430            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \                     ??HAL_SPI_DMAStop_1: (+1)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6840             LDR      R0,[R0, #+4]
   \   00000020   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000024   0x6821             LDR      R1,[R4, #+0]
   \   00000026   0x6048             STR      R0,[R1, #+4]
   1431            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x6840             LDR      R0,[R0, #+4]
   \   0000002C   0x0840             LSRS     R0,R0,#+1
   \   0000002E   0x0040             LSLS     R0,R0,#+1
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x6048             STR      R0,[R1, #+4]
   1432            
   1433            hspi->State = HAL_SPI_STATE_READY;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xF884 0x0051      STRB     R0,[R4, #+81]
   1434            
   1435            return HAL_OK;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
   1436          }
   1437          
   1438          /**
   1439            * @brief  This function handles SPI interrupt request.
   1440            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1441            *                the configuration information for SPI module.
   1442            * @retval HAL status
   1443            */

   \                                 In section .text, align 2, keep-with-next
   1444          void HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi)
   1445          {
   \                     HAL_SPI_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   1446            /* SPI in mode Receiver and Overrun not occurred ---------------------------*/
   1447            if((__HAL_SPI_GET_IT_SOURCE(hspi, SPI_IT_RXNE) != RESET) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE) != RESET) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_OVR) == RESET))
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x6840             LDR      R0,[R0, #+4]
   \   0000000A   0x0640             LSLS     R0,R0,#+25
   \   0000000C   0xD50B             BPL.N    ??HAL_SPI_IRQHandler_0
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6880             LDR      R0,[R0, #+8]
   \   00000012   0x07C0             LSLS     R0,R0,#+31
   \   00000014   0xD507             BPL.N    ??HAL_SPI_IRQHandler_0
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6880             LDR      R0,[R0, #+8]
   \   0000001A   0x0640             LSLS     R0,R0,#+25
   \   0000001C   0xD403             BMI.N    ??HAL_SPI_IRQHandler_0
   1448            {
   1449              hspi->RxISR(hspi);
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x6CA1             LDR      R1,[R4, #+72]
   \   00000022   0x4788             BLX      R1
   1450              return;
   \   00000024   0xE05B             B.N      ??HAL_SPI_IRQHandler_1
   1451            }
   1452          
   1453            /* SPI in mode Tramitter ---------------------------------------------------*/
   1454            if((__HAL_SPI_GET_IT_SOURCE(hspi, SPI_IT_TXE) != RESET) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE) != RESET))
   \                     ??HAL_SPI_IRQHandler_0: (+1)
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6840             LDR      R0,[R0, #+4]
   \   0000002A   0x0600             LSLS     R0,R0,#+24
   \   0000002C   0xD507             BPL.N    ??HAL_SPI_IRQHandler_2
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x6880             LDR      R0,[R0, #+8]
   \   00000032   0x0780             LSLS     R0,R0,#+30
   \   00000034   0xD503             BPL.N    ??HAL_SPI_IRQHandler_2
   1455            {
   1456              hspi->TxISR(hspi);
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x6CE1             LDR      R1,[R4, #+76]
   \   0000003A   0x4788             BLX      R1
   1457              return;
   \   0000003C   0xE04F             B.N      ??HAL_SPI_IRQHandler_1
   1458            }
   1459          
   1460            if(__HAL_SPI_GET_IT_SOURCE(hspi, SPI_IT_ERR) != RESET)
   \                     ??HAL_SPI_IRQHandler_2: (+1)
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6840             LDR      R0,[R0, #+4]
   \   00000042   0x0680             LSLS     R0,R0,#+26
   \   00000044   0xD54B             BPL.N    ??HAL_SPI_IRQHandler_3
   1461            {
   1462              /* SPI CRC error interrupt occurred ---------------------------------------*/
   1463              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6880             LDR      R0,[R0, #+8]
   \   0000004A   0x06C0             LSLS     R0,R0,#+27
   \   0000004C   0xD507             BPL.N    ??HAL_SPI_IRQHandler_4
   1464              {
   1465                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   \   0000004E   0x6D60             LDR      R0,[R4, #+84]
   \   00000050   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000054   0x6560             STR      R0,[R4, #+84]
   1466                __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   \   00000056   0xF07F 0x0010      MVNS     R0,#+16
   \   0000005A   0x6821             LDR      R1,[R4, #+0]
   \   0000005C   0x6088             STR      R0,[R1, #+8]
   1467              }
   1468              /* SPI Mode Fault error interrupt occurred --------------------------------*/
   1469              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_MODF) != RESET)
   \                     ??HAL_SPI_IRQHandler_4: (+1)
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x6880             LDR      R0,[R0, #+8]
   \   00000062   0x0680             LSLS     R0,R0,#+26
   \   00000064   0xD50D             BPL.N    ??HAL_SPI_IRQHandler_5
   1470              {
   1471                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
   \   00000066   0x6D60             LDR      R0,[R4, #+84]
   \   00000068   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000006C   0x6560             STR      R0,[R4, #+84]
   1472                __HAL_SPI_CLEAR_MODFFLAG(hspi);
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x6880             LDR      R0,[R0, #+8]
   \   00000072   0x9000             STR      R0,[SP, #+0]
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0xF030 0x0040      BICS     R0,R0,#0x40
   \   0000007C   0x6821             LDR      R1,[R4, #+0]
   \   0000007E   0x6008             STR      R0,[R1, #+0]
   \   00000080   0x9800             LDR      R0,[SP, #+0]
   1473              }
   1474              
   1475              /* SPI Overrun error interrupt occurred -----------------------------------*/
   1476              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_OVR) != RESET)
   \                     ??HAL_SPI_IRQHandler_5: (+1)
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0x6880             LDR      R0,[R0, #+8]
   \   00000086   0x0640             LSLS     R0,R0,#+25
   \   00000088   0xD50E             BPL.N    ??HAL_SPI_IRQHandler_6
   1477              {
   1478                if(hspi->State != HAL_SPI_STATE_BUSY_TX)
   \   0000008A   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \   0000008E   0x2812             CMP      R0,#+18
   \   00000090   0xD00A             BEQ.N    ??HAL_SPI_IRQHandler_6
   1479                {
   1480                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
   \   00000092   0x6D60             LDR      R0,[R4, #+84]
   \   00000094   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000098   0x6560             STR      R0,[R4, #+84]
   1481                  __HAL_SPI_CLEAR_OVRFLAG(hspi);      
   \   0000009A   0x6820             LDR      R0,[R4, #+0]
   \   0000009C   0x68C0             LDR      R0,[R0, #+12]
   \   0000009E   0x9000             STR      R0,[SP, #+0]
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x6880             LDR      R0,[R0, #+8]
   \   000000A4   0x9000             STR      R0,[SP, #+0]
   \   000000A6   0x9800             LDR      R0,[SP, #+0]
   1482                }
   1483              }
   1484          
   1485              /* SPI Frame error interrupt occurred -------------------------------------*/
   1486              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_FRE) != RESET)
   \                     ??HAL_SPI_IRQHandler_6: (+1)
   \   000000A8   0x6820             LDR      R0,[R4, #+0]
   \   000000AA   0x6880             LDR      R0,[R0, #+8]
   \   000000AC   0x05C0             LSLS     R0,R0,#+23
   \   000000AE   0xD507             BPL.N    ??HAL_SPI_IRQHandler_7
   1487              {
   1488                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FRE);
   \   000000B0   0x6D60             LDR      R0,[R4, #+84]
   \   000000B2   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   000000B6   0x6560             STR      R0,[R4, #+84]
   1489                __HAL_SPI_CLEAR_FREFLAG(hspi);
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0x6880             LDR      R0,[R0, #+8]
   \   000000BC   0x9000             STR      R0,[SP, #+0]
   \   000000BE   0x9800             LDR      R0,[SP, #+0]
   1490              }
   1491          
   1492              /* Call the Error call Back in case of Errors */
   1493              if(hspi->ErrorCode!=HAL_SPI_ERROR_NONE)
   \                     ??HAL_SPI_IRQHandler_7: (+1)
   \   000000C0   0x6D60             LDR      R0,[R4, #+84]
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD00B             BEQ.N    ??HAL_SPI_IRQHandler_3
   1494              {
   1495                __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
   \   000000C6   0x6820             LDR      R0,[R4, #+0]
   \   000000C8   0x6840             LDR      R0,[R0, #+4]
   \   000000CA   0xF030 0x00E0      BICS     R0,R0,#0xE0
   \   000000CE   0x6821             LDR      R1,[R4, #+0]
   \   000000D0   0x6048             STR      R0,[R1, #+4]
   1496                hspi->State = HAL_SPI_STATE_READY;
   \   000000D2   0x2001             MOVS     R0,#+1
   \   000000D4   0xF884 0x0051      STRB     R0,[R4, #+81]
   1497                HAL_SPI_ErrorCallback(hspi);
   \   000000D8   0x0020             MOVS     R0,R4
   \   000000DA   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   1498              }
   1499            }
   1500          }
   \                     ??HAL_SPI_IRQHandler_3: (+1)
   \                     ??HAL_SPI_IRQHandler_1: (+1)
   \   000000DE   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   1501          
   1502          /**
   1503            * @brief Tx Transfer completed callbacks
   1504            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1505            *                the configuration information for SPI module.
   1506            * @retval None
   1507            */

   \                                 In section .text, align 2
   1508          __weak void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi)
   1509          {
   1510            /* NOTE : This function Should not be modified, when the callback is needed,
   1511                      the HAL_SPI_TxCpltCallback could be implenetd in the user file
   1512             */
   1513          }
   \                     HAL_SPI_TxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1514          
   1515          /**
   1516            * @brief Rx Transfer completed callbacks
   1517            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1518            *                the configuration information for SPI module.
   1519            * @retval None
   1520            */

   \                                 In section .text, align 2
   1521          __weak void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)
   1522          {
   1523            /* NOTE : This function Should not be modified, when the callback is needed,
   1524                      the HAL_SPI_RxCpltCallback() could be implenetd in the user file
   1525             */
   1526          }
   \                     HAL_SPI_RxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1527          
   1528          /**
   1529            * @brief Tx and Rx Transfer completed callbacks
   1530            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1531            *                the configuration information for SPI module.
   1532            * @retval None
   1533            */

   \                                 In section .text, align 2
   1534          __weak void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)
   1535          {
   1536            /* NOTE : This function Should not be modified, when the callback is needed,
   1537                      the HAL_SPI_TxRxCpltCallback() could be implenetd in the user file
   1538             */
   1539          }
   \                     HAL_SPI_TxRxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1540          
   1541          /**
   1542            * @brief Tx Half Transfer completed callbacks
   1543            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1544            *                the configuration information for SPI module.
   1545            * @retval None
   1546            */

   \                                 In section .text, align 2
   1547          __weak void HAL_SPI_TxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   1548          {
   1549            /* NOTE : This function Should not be modified, when the callback is needed,
   1550                      the HAL_SPI_TxHalfCpltCallback could be implenetd in the user file
   1551             */
   1552          }
   \                     HAL_SPI_TxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1553          
   1554          /**
   1555            * @brief Rx Half Transfer completed callbacks
   1556            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1557            *                the configuration information for SPI module.
   1558            * @retval None
   1559            */

   \                                 In section .text, align 2
   1560          __weak void HAL_SPI_RxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   1561          {
   1562            /* NOTE : This function Should not be modified, when the callback is needed,
   1563                      the HAL_SPI_RxHalfCpltCallback() could be implenetd in the user file
   1564             */
   1565          }
   \                     HAL_SPI_RxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1566          
   1567          /**
   1568            * @brief Tx and Rx Transfer completed callbacks
   1569            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1570            *                the configuration information for SPI module.
   1571            * @retval None
   1572            */

   \                                 In section .text, align 2
   1573          __weak void HAL_SPI_TxRxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   1574          {
   1575            /* NOTE : This function Should not be modified, when the callback is needed,
   1576                      the HAL_SPI_TxRxHalfCpltCallback() could be implenetd in the user file
   1577             */
   1578          }
   \                     HAL_SPI_TxRxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1579          
   1580          /**
   1581            * @brief SPI error callbacks
   1582            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1583            *                the configuration information for SPI module.
   1584            * @retval None
   1585            */

   \                                 In section .text, align 2
   1586           __weak void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
   1587          {
   1588            /* NOTE : - This function Should not be modified, when the callback is needed,
   1589                      the HAL_SPI_ErrorCallback() could be implenetd in the user file.
   1590                      - The ErrorCode parameter in the hspi handle is updated by the SPI processes
   1591                      and user can use HAL_SPI_GetError() API to check the latest error occurred.
   1592             */
   1593          }
   \                     HAL_SPI_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1594          
   1595          /**
   1596            * @}
   1597            */
   1598          
   1599          /** @defgroup SPI_Exported_Functions_Group3 Peripheral State and Errors functions 
   1600            *  @brief   SPI control functions 
   1601            *
   1602          @verbatim
   1603           ===============================================================================
   1604                                ##### Peripheral State and Errors functions #####
   1605           ===============================================================================  
   1606              [..]
   1607              This subsection provides a set of functions allowing to control the SPI.
   1608               (+) HAL_SPI_GetState() API can be helpful to check in run-time the state of the SPI peripheral
   1609               (+) HAL_SPI_GetError() check in run-time Errors occurring during communication
   1610          @endverbatim
   1611            * @{
   1612            */
   1613          
   1614          /**
   1615            * @brief  Return the SPI state
   1616            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1617            *                the configuration information for SPI module.
   1618            * @retval HAL state
   1619            */

   \                                 In section .text, align 2, keep-with-next
   1620          HAL_SPI_StateTypeDef HAL_SPI_GetState(SPI_HandleTypeDef *hspi)
   1621          {
   1622            return hspi->State;
   \                     HAL_SPI_GetState: (+1)
   \   00000000   0xF890 0x0051      LDRB     R0,[R0, #+81]
   \   00000004   0x4770             BX       LR               ;; return
   1623          }
   1624          
   1625          /**
   1626            * @brief  Return the SPI error code
   1627            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1628            *                the configuration information for SPI module.
   1629            * @retval SPI Error Code
   1630            */

   \                                 In section .text, align 2, keep-with-next
   1631          uint32_t HAL_SPI_GetError(SPI_HandleTypeDef *hspi)
   1632          {
   1633            return hspi->ErrorCode;
   \                     HAL_SPI_GetError: (+1)
   \   00000000   0x6D40             LDR      R0,[R0, #+84]
   \   00000002   0x4770             BX       LR               ;; return
   1634          }
   1635          
   1636          /**
   1637            * @}
   1638            */
   1639            
   1640          /**
   1641              * @}
   1642              */
   1643          
   1644          
   1645          
   1646          /** @addtogroup SPI_Private_Functions
   1647              * @{
   1648              */
   1649          
   1650          
   1651            /**
   1652            * @brief  Interrupt Handler to close Tx transfer 
   1653            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1654            *                the configuration information for SPI module.
   1655            * @retval void
   1656            */

   \                                 In section .text, align 2, keep-with-next
   1657          static void SPI_TxCloseIRQHandler(struct __SPI_HandleTypeDef *hspi)
   1658          {
   \                     SPI_TxCloseIRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   1659            /* Wait until TXE flag is set to send data */
   1660            if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, SPI_TIMEOUT_VALUE) != HAL_OK)
   \   00000006   0x230A             MOVS     R3,#+10
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x2102             MOVS     R1,#+2
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD003             BEQ.N    ??SPI_TxCloseIRQHandler_0
   1661            {
   1662              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   00000016   0x6D60             LDR      R0,[R4, #+84]
   \   00000018   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000001C   0x6560             STR      R0,[R4, #+84]
   1663            }
   1664          
   1665            /* Disable TXE interrupt */
   1666            __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE ));
   \                     ??SPI_TxCloseIRQHandler_0: (+1)
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x6840             LDR      R0,[R0, #+4]
   \   00000022   0xF030 0x0080      BICS     R0,R0,#0x80
   \   00000026   0x6821             LDR      R1,[R4, #+0]
   \   00000028   0x6048             STR      R0,[R1, #+4]
   1667          
   1668            /* Disable ERR interrupt if Receive process is finished */
   1669            if(__HAL_SPI_GET_IT_SOURCE(hspi, SPI_IT_RXNE) == RESET)
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x6840             LDR      R0,[R0, #+4]
   \   0000002E   0x0640             LSLS     R0,R0,#+25
   \   00000030   0xD436             BMI.N    ??SPI_TxCloseIRQHandler_1
   1670            {
   1671              __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_ERR));
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x6840             LDR      R0,[R0, #+4]
   \   00000036   0xF030 0x0020      BICS     R0,R0,#0x20
   \   0000003A   0x6821             LDR      R1,[R4, #+0]
   \   0000003C   0x6048             STR      R0,[R1, #+4]
   1672          
   1673              /* Wait until Busy flag is reset before disabling SPI */
   1674              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_BSY, SET, SPI_TIMEOUT_VALUE) != HAL_OK)
   \   0000003E   0x230A             MOVS     R3,#+10
   \   00000040   0x2201             MOVS     R2,#+1
   \   00000042   0x2180             MOVS     R1,#+128
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD003             BEQ.N    ??SPI_TxCloseIRQHandler_2
   1675              {
   1676                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   0000004E   0x6D60             LDR      R0,[R4, #+84]
   \   00000050   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000054   0x6560             STR      R0,[R4, #+84]
   1677              }
   1678          
   1679              /* Clear OVERUN flag in 2 Lines communication mode because received is not read */
   1680              if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \                     ??SPI_TxCloseIRQHandler_2: (+1)
   \   00000056   0x68A0             LDR      R0,[R4, #+8]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD106             BNE.N    ??SPI_TxCloseIRQHandler_3
   1681              {
   1682                __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x68C0             LDR      R0,[R0, #+12]
   \   00000060   0x9000             STR      R0,[SP, #+0]
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x6880             LDR      R0,[R0, #+8]
   \   00000066   0x9000             STR      R0,[SP, #+0]
   \   00000068   0x9800             LDR      R0,[SP, #+0]
   1683              }
   1684              
   1685              /* Check if Errors has been detected during transfer */
   1686              if(hspi->ErrorCode ==  HAL_SPI_ERROR_NONE)
   \                     ??SPI_TxCloseIRQHandler_3: (+1)
   \   0000006A   0x6D60             LDR      R0,[R4, #+84]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD111             BNE.N    ??SPI_TxCloseIRQHandler_4
   1687              {
   1688                /* Check if we are in Tx or in Rx/Tx Mode */
   1689                if(hspi->State == HAL_SPI_STATE_BUSY_TX_RX)
   \   00000070   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \   00000074   0x2832             CMP      R0,#+50
   \   00000076   0xD106             BNE.N    ??SPI_TxCloseIRQHandler_5
   1690                {
   1691                  /* Set state to READY before run the Callback Complete */
   1692                  hspi->State = HAL_SPI_STATE_READY;
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0xF884 0x0051      STRB     R0,[R4, #+81]
   1693                  HAL_SPI_TxRxCpltCallback(hspi);
   \   0000007E   0x0020             MOVS     R0,R4
   \   00000080   0x.... 0x....      BL       HAL_SPI_TxRxCpltCallback
   \   00000084   0xE00C             B.N      ??SPI_TxCloseIRQHandler_1
   1694                }
   1695                else
   1696                {
   1697                  /* Set state to READY before run the Callback Complete */
   1698                  hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_TxCloseIRQHandler_5: (+1)
   \   00000086   0x2001             MOVS     R0,#+1
   \   00000088   0xF884 0x0051      STRB     R0,[R4, #+81]
   1699                  HAL_SPI_TxCpltCallback(hspi);
   \   0000008C   0x0020             MOVS     R0,R4
   \   0000008E   0x.... 0x....      BL       HAL_SPI_TxCpltCallback
   \   00000092   0xE005             B.N      ??SPI_TxCloseIRQHandler_1
   1700                }
   1701              }
   1702              else
   1703              {
   1704                /* Set state to READY before run the Callback Complete */
   1705                hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_TxCloseIRQHandler_4: (+1)
   \   00000094   0x2001             MOVS     R0,#+1
   \   00000096   0xF884 0x0051      STRB     R0,[R4, #+81]
   1706                /* Call Error call back in case of Error */
   1707                HAL_SPI_ErrorCallback(hspi);
   \   0000009A   0x0020             MOVS     R0,R4
   \   0000009C   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   1708              }
   1709            }
   1710          }
   \                     ??SPI_TxCloseIRQHandler_1: (+1)
   \   000000A0   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   1711          
   1712          /**
   1713            * @brief  Interrupt Handler to transmit amount of data in no-blocking mode 
   1714            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1715            *                the configuration information for SPI module.
   1716            * @retval void
   1717            */

   \                                 In section .text, align 4, keep-with-next
   1718          static void SPI_TxISR(struct __SPI_HandleTypeDef *hspi)
   1719          {
   \                     SPI_TxISR: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1720            /* Transmit data in 8 Bit mode */
   1721            if(hspi->Init.DataSize == SPI_DATASIZE_8BIT)
   \   00000004   0x68E0             LDR      R0,[R4, #+12]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD106             BNE.N    ??SPI_TxISR_0
   1722            {
   1723              hspi->Instance->DR = (*hspi->pTxBuffPtr++);
   \   0000000A   0x6B20             LDR      R0,[R4, #+48]
   \   0000000C   0x1C41             ADDS     R1,R0,#+1
   \   0000000E   0x6321             STR      R1,[R4, #+48]
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x6821             LDR      R1,[R4, #+0]
   \   00000014   0x60C8             STR      R0,[R1, #+12]
   \   00000016   0xE006             B.N      ??SPI_TxISR_1
   1724            }
   1725            /* Transmit data in 16 Bit mode */
   1726            else
   1727            {
   1728              hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
   \                     ??SPI_TxISR_0: (+1)
   \   00000018   0x6B20             LDR      R0,[R4, #+48]
   \   0000001A   0x8800             LDRH     R0,[R0, #+0]
   \   0000001C   0x6821             LDR      R1,[R4, #+0]
   \   0000001E   0x60C8             STR      R0,[R1, #+12]
   1729              hspi->pTxBuffPtr+=2;
   \   00000020   0x6B20             LDR      R0,[R4, #+48]
   \   00000022   0x1C80             ADDS     R0,R0,#+2
   \   00000024   0x6320             STR      R0,[R4, #+48]
   1730            }
   1731            hspi->TxXferCount--;
   \                     ??SPI_TxISR_1: (+1)
   \   00000026   0x8EE0             LDRH     R0,[R4, #+54]
   \   00000028   0x1E40             SUBS     R0,R0,#+1
   \   0000002A   0x86E0             STRH     R0,[R4, #+54]
   1732          
   1733            if(hspi->TxXferCount == 0)
   \   0000002C   0x8EE0             LDRH     R0,[R4, #+54]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD10C             BNE.N    ??SPI_TxISR_2
   1734            {
   1735              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000032   0x6AA0             LDR      R0,[R4, #+40]
   \   00000034   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000038   0xD105             BNE.N    ??SPI_TxISR_3
   1736              {
   1737                /* calculate and transfer CRC on Tx line */
   1738                SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   00000042   0x6821             LDR      R1,[R4, #+0]
   \   00000044   0x6008             STR      R0,[R1, #+0]
   1739              }
   1740              SPI_TxCloseIRQHandler(hspi);
   \                     ??SPI_TxISR_3: (+1)
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x.... 0x....      BL       SPI_TxCloseIRQHandler
   1741            }
   1742          }
   \                     ??SPI_TxISR_2: (+1)
   \   0000004C   0xBD10             POP      {R4,PC}          ;; return
   1743          
   1744          /**
   1745            * @brief  Interrupt Handler to close Rx transfer 
   1746            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1747            *                the configuration information for SPI module.
   1748            * @retval void
   1749            */

   \                                 In section .text, align 2, keep-with-next
   1750          static void SPI_RxCloseIRQHandler(struct __SPI_HandleTypeDef *hspi)
   1751          {
   \                     SPI_RxCloseIRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   1752            __IO uint16_t tmpreg = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1753          
   1754            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   0000000C   0x6AA0             LDR      R0,[R4, #+40]
   \   0000000E   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000012   0xD131             BNE.N    ??SPI_RxCloseIRQHandler_0
   1755            {
   1756              /* Wait until RXNE flag is set to send data */
   1757              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, SPI_TIMEOUT_VALUE) != HAL_OK)
   \   00000014   0x230A             MOVS     R3,#+10
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD003             BEQ.N    ??SPI_RxCloseIRQHandler_1
   1758              {
   1759                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   00000024   0x6D60             LDR      R0,[R4, #+84]
   \   00000026   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000002A   0x6560             STR      R0,[R4, #+84]
   1760              }
   1761          
   1762              /* Read CRC to reset RXNE flag */
   1763              tmpreg = hspi->Instance->DR;
   \                     ??SPI_RxCloseIRQHandler_1: (+1)
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x68C0             LDR      R0,[R0, #+12]
   \   00000030   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1764              UNUSED(tmpreg);
   \   00000034   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   1765          
   1766              /* Wait until RXNE flag is set to send data */
   1767              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, SET, SPI_TIMEOUT_VALUE) != HAL_OK)
   \   00000038   0x230A             MOVS     R3,#+10
   \   0000003A   0x2201             MOVS     R2,#+1
   \   0000003C   0x2101             MOVS     R1,#+1
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD003             BEQ.N    ??SPI_RxCloseIRQHandler_2
   1768              {
   1769                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   00000048   0x6D60             LDR      R0,[R4, #+84]
   \   0000004A   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000004E   0x6560             STR      R0,[R4, #+84]
   1770              }
   1771          
   1772              /* Check if CRC error occurred */
   1773              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   \                     ??SPI_RxCloseIRQHandler_2: (+1)
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x6880             LDR      R0,[R0, #+8]
   \   00000054   0x06C0             LSLS     R0,R0,#+27
   \   00000056   0xD50F             BPL.N    ??SPI_RxCloseIRQHandler_0
   1774              {
   1775                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   \   00000058   0x6D60             LDR      R0,[R4, #+84]
   \   0000005A   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000005E   0x6560             STR      R0,[R4, #+84]
   1776          
   1777                /* Reset CRC Calculation */
   1778                SPI_RESET_CRC(hspi);
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   00000068   0x6821             LDR      R1,[R4, #+0]
   \   0000006A   0x6008             STR      R0,[R1, #+0]
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   00000074   0x6821             LDR      R1,[R4, #+0]
   \   00000076   0x6008             STR      R0,[R1, #+0]
   1779              }
   1780            }
   1781          
   1782            /* Disable RXNE interrupt */
   1783            __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE));
   \                     ??SPI_RxCloseIRQHandler_0: (+1)
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0x6840             LDR      R0,[R0, #+4]
   \   0000007C   0xF030 0x0040      BICS     R0,R0,#0x40
   \   00000080   0x6821             LDR      R1,[R4, #+0]
   \   00000082   0x6048             STR      R0,[R1, #+4]
   1784          
   1785            /* if Transmit process is finished */
   1786            if(__HAL_SPI_GET_IT_SOURCE(hspi, SPI_IT_TXE) == RESET)
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6840             LDR      R0,[R0, #+4]
   \   00000088   0x0600             LSLS     R0,R0,#+24
   \   0000008A   0xD432             BMI.N    ??SPI_RxCloseIRQHandler_3
   1787            {
   1788              /* Disable ERR interrupt */
   1789              __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_ERR));
   \   0000008C   0x6820             LDR      R0,[R4, #+0]
   \   0000008E   0x6840             LDR      R0,[R0, #+4]
   \   00000090   0xF030 0x0020      BICS     R0,R0,#0x20
   \   00000094   0x6821             LDR      R1,[R4, #+0]
   \   00000096   0x6048             STR      R0,[R1, #+4]
   1790          
   1791              if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
   \   00000098   0x6860             LDR      R0,[R4, #+4]
   \   0000009A   0xF5B0 0x7F82      CMP      R0,#+260
   \   0000009E   0xD10D             BNE.N    ??SPI_RxCloseIRQHandler_4
   \   000000A0   0x68A0             LDR      R0,[R4, #+8]
   \   000000A2   0xF5B0 0x4F00      CMP      R0,#+32768
   \   000000A6   0xD003             BEQ.N    ??SPI_RxCloseIRQHandler_5
   \   000000A8   0x68A0             LDR      R0,[R4, #+8]
   \   000000AA   0xF5B0 0x6F80      CMP      R0,#+1024
   \   000000AE   0xD105             BNE.N    ??SPI_RxCloseIRQHandler_4
   1792              {
   1793                /* Disable SPI peripheral */
   1794                __HAL_SPI_DISABLE(hspi);
   \                     ??SPI_RxCloseIRQHandler_5: (+1)
   \   000000B0   0x6820             LDR      R0,[R4, #+0]
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0xF030 0x0040      BICS     R0,R0,#0x40
   \   000000B8   0x6821             LDR      R1,[R4, #+0]
   \   000000BA   0x6008             STR      R0,[R1, #+0]
   1795              }
   1796              
   1797              /* Check if Errors has been detected during transfer */
   1798              if(hspi->ErrorCode ==  HAL_SPI_ERROR_NONE)
   \                     ??SPI_RxCloseIRQHandler_4: (+1)
   \   000000BC   0x6D60             LDR      R0,[R4, #+84]
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xD111             BNE.N    ??SPI_RxCloseIRQHandler_6
   1799              {
   1800                /* Check if we are in Rx or in Rx/Tx Mode */
   1801                if(hspi->State == HAL_SPI_STATE_BUSY_TX_RX)
   \   000000C2   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \   000000C6   0x2832             CMP      R0,#+50
   \   000000C8   0xD106             BNE.N    ??SPI_RxCloseIRQHandler_7
   1802                {
   1803                  /* Set state to READY before run the Callback Complete */
   1804                  hspi->State = HAL_SPI_STATE_READY;
   \   000000CA   0x2001             MOVS     R0,#+1
   \   000000CC   0xF884 0x0051      STRB     R0,[R4, #+81]
   1805                  HAL_SPI_TxRxCpltCallback(hspi);
   \   000000D0   0x0020             MOVS     R0,R4
   \   000000D2   0x.... 0x....      BL       HAL_SPI_TxRxCpltCallback
   \   000000D6   0xE00C             B.N      ??SPI_RxCloseIRQHandler_3
   1806                }
   1807                else
   1808                {
   1809                  /* Set state to READY before run the Callback Complete */
   1810                  hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_RxCloseIRQHandler_7: (+1)
   \   000000D8   0x2001             MOVS     R0,#+1
   \   000000DA   0xF884 0x0051      STRB     R0,[R4, #+81]
   1811                  HAL_SPI_RxCpltCallback(hspi);
   \   000000DE   0x0020             MOVS     R0,R4
   \   000000E0   0x.... 0x....      BL       HAL_SPI_RxCpltCallback
   \   000000E4   0xE005             B.N      ??SPI_RxCloseIRQHandler_3
   1812                }
   1813              }
   1814              else
   1815              {
   1816                /* Set state to READY before run the Callback Complete */
   1817                hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_RxCloseIRQHandler_6: (+1)
   \   000000E6   0x2001             MOVS     R0,#+1
   \   000000E8   0xF884 0x0051      STRB     R0,[R4, #+81]
   1818                /* Call Error call back in case of Error */
   1819                HAL_SPI_ErrorCallback(hspi);
   \   000000EC   0x0020             MOVS     R0,R4
   \   000000EE   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   1820              }
   1821            }
   1822          }
   \                     ??SPI_RxCloseIRQHandler_3: (+1)
   \   000000F2   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   1823          
   1824          /**
   1825            * @brief  Interrupt Handler to receive amount of data in 2Lines mode 
   1826            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1827            *                the configuration information for SPI module.
   1828            * @retval void
   1829            */

   \                                 In section .text, align 4, keep-with-next
   1830          static void SPI_2LinesRxISR(struct __SPI_HandleTypeDef *hspi)
   1831          {
   \                     SPI_2LinesRxISR: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1832            /* Receive data in 8 Bit mode */
   1833            if(hspi->Init.DataSize == SPI_DATASIZE_8BIT)
   \   00000004   0x68E0             LDR      R0,[R4, #+12]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD106             BNE.N    ??SPI_2LinesRxISR_0
   1834            {
   1835              (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
   \   0000000A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000000C   0x1C41             ADDS     R1,R0,#+1
   \   0000000E   0x63A1             STR      R1,[R4, #+56]
   \   00000010   0x6821             LDR      R1,[R4, #+0]
   \   00000012   0x68C9             LDR      R1,[R1, #+12]
   \   00000014   0x7001             STRB     R1,[R0, #+0]
   \   00000016   0xE006             B.N      ??SPI_2LinesRxISR_1
   1836            }
   1837            /* Receive data in 16 Bit mode */
   1838            else
   1839            {
   1840              *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \                     ??SPI_2LinesRxISR_0: (+1)
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x68C0             LDR      R0,[R0, #+12]
   \   0000001C   0x6BA1             LDR      R1,[R4, #+56]
   \   0000001E   0x8008             STRH     R0,[R1, #+0]
   1841              hspi->pRxBuffPtr+=2;
   \   00000020   0x6BA0             LDR      R0,[R4, #+56]
   \   00000022   0x1C80             ADDS     R0,R0,#+2
   \   00000024   0x63A0             STR      R0,[R4, #+56]
   1842            }
   1843            hspi->RxXferCount--;
   \                     ??SPI_2LinesRxISR_1: (+1)
   \   00000026   0x8FE0             LDRH     R0,[R4, #+62]
   \   00000028   0x1E40             SUBS     R0,R0,#+1
   \   0000002A   0x87E0             STRH     R0,[R4, #+62]
   1844          
   1845            if(hspi->RxXferCount==0)
   \   0000002C   0x8FE0             LDRH     R0,[R4, #+62]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD102             BNE.N    ??SPI_2LinesRxISR_2
   1846            {
   1847              SPI_RxCloseIRQHandler(hspi);
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       SPI_RxCloseIRQHandler
   1848            }
   1849          }
   \                     ??SPI_2LinesRxISR_2: (+1)
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
   1850          
   1851          /**
   1852            * @brief  Interrupt Handler to receive amount of data in no-blocking mode 
   1853            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1854            *                the configuration information for SPI module.
   1855            * @retval void
   1856            */

   \                                 In section .text, align 4, keep-with-next
   1857          static void SPI_RxISR(struct __SPI_HandleTypeDef *hspi)
   1858          {
   \                     SPI_RxISR: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1859            /* Receive data in 8 Bit mode */
   1860            if(hspi->Init.DataSize == SPI_DATASIZE_8BIT)
   \   00000004   0x68E0             LDR      R0,[R4, #+12]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD106             BNE.N    ??SPI_RxISR_0
   1861            {
   1862              (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
   \   0000000A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000000C   0x1C41             ADDS     R1,R0,#+1
   \   0000000E   0x63A1             STR      R1,[R4, #+56]
   \   00000010   0x6821             LDR      R1,[R4, #+0]
   \   00000012   0x68C9             LDR      R1,[R1, #+12]
   \   00000014   0x7001             STRB     R1,[R0, #+0]
   \   00000016   0xE006             B.N      ??SPI_RxISR_1
   1863            }
   1864            /* Receive data in 16 Bit mode */
   1865            else
   1866            {
   1867              *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \                     ??SPI_RxISR_0: (+1)
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x68C0             LDR      R0,[R0, #+12]
   \   0000001C   0x6BA1             LDR      R1,[R4, #+56]
   \   0000001E   0x8008             STRH     R0,[R1, #+0]
   1868              hspi->pRxBuffPtr+=2;
   \   00000020   0x6BA0             LDR      R0,[R4, #+56]
   \   00000022   0x1C80             ADDS     R0,R0,#+2
   \   00000024   0x63A0             STR      R0,[R4, #+56]
   1869            }
   1870              hspi->RxXferCount--;
   \                     ??SPI_RxISR_1: (+1)
   \   00000026   0x8FE0             LDRH     R0,[R4, #+62]
   \   00000028   0x1E40             SUBS     R0,R0,#+1
   \   0000002A   0x87E0             STRH     R0,[R4, #+62]
   1871          
   1872            /* Enable CRC Transmission */
   1873            if((hspi->RxXferCount == 1) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
   \   0000002C   0x8FE0             LDRH     R0,[R4, #+62]
   \   0000002E   0x2801             CMP      R0,#+1
   \   00000030   0xD109             BNE.N    ??SPI_RxISR_2
   \   00000032   0x6AA0             LDR      R0,[R4, #+40]
   \   00000034   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000038   0xD105             BNE.N    ??SPI_RxISR_2
   1874            {
   1875              /* Set CRC Next to calculate CRC on Rx side */
   1876              SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   00000042   0x6821             LDR      R1,[R4, #+0]
   \   00000044   0x6008             STR      R0,[R1, #+0]
   1877            }
   1878          
   1879            if(hspi->RxXferCount == 0)
   \                     ??SPI_RxISR_2: (+1)
   \   00000046   0x8FE0             LDRH     R0,[R4, #+62]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD102             BNE.N    ??SPI_RxISR_3
   1880            {
   1881              SPI_RxCloseIRQHandler(hspi);
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x.... 0x....      BL       SPI_RxCloseIRQHandler
   1882            }
   1883          }
   \                     ??SPI_RxISR_3: (+1)
   \   00000052   0xBD10             POP      {R4,PC}          ;; return
   1884          
   1885          /**
   1886            * @brief DMA SPI transmit process complete callback 
   1887            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1888            *                the configuration information for the specified DMA module.
   1889            * @retval None
   1890            */

   \                                 In section .text, align 4, keep-with-next
   1891          static void SPI_DMATransmitCplt(struct __DMA_HandleTypeDef *hdma)
   1892          {
   \                     SPI_DMATransmitCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1893            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   1894          
   1895            /* DMA Normal Mode */
   1896            if((hdma->Instance->CCR & DMA_CIRCULAR) == 0)
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0680             LSLS     R0,R0,#+26
   \   0000000C   0xD422             BMI.N    ??SPI_DMATransmitCplt_0
   1897            {
   1898              /* Wait until TXE flag is set to send data */
   1899              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, SPI_TIMEOUT_VALUE) != HAL_OK)
   \   0000000E   0x230A             MOVS     R3,#+10
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x2102             MOVS     R1,#+2
   \   00000014   0x0028             MOVS     R0,R5
   \   00000016   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD003             BEQ.N    ??SPI_DMATransmitCplt_1
   1900              {
   1901                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   0000001E   0x6D68             LDR      R0,[R5, #+84]
   \   00000020   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000024   0x6568             STR      R0,[R5, #+84]
   1902              }
   1903          
   1904              /* Disable Tx DMA Request */
   1905              CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \                     ??SPI_DMATransmitCplt_1: (+1)
   \   00000026   0x6828             LDR      R0,[R5, #+0]
   \   00000028   0x6840             LDR      R0,[R0, #+4]
   \   0000002A   0xF030 0x0002      BICS     R0,R0,#0x2
   \   0000002E   0x6829             LDR      R1,[R5, #+0]
   \   00000030   0x6048             STR      R0,[R1, #+4]
   1906          
   1907              /* Wait until Busy flag is reset before disabling SPI */
   1908              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_BSY, SET, SPI_TIMEOUT_VALUE) != HAL_OK)
   \   00000032   0x230A             MOVS     R3,#+10
   \   00000034   0x2201             MOVS     R2,#+1
   \   00000036   0x2180             MOVS     R1,#+128
   \   00000038   0x0028             MOVS     R0,R5
   \   0000003A   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD003             BEQ.N    ??SPI_DMATransmitCplt_2
   1909              {
   1910                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   00000042   0x6D68             LDR      R0,[R5, #+84]
   \   00000044   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000048   0x6568             STR      R0,[R5, #+84]
   1911              }
   1912          
   1913              hspi->TxXferCount = 0;
   \                     ??SPI_DMATransmitCplt_2: (+1)
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x86E8             STRH     R0,[R5, #+54]
   1914              hspi->State = HAL_SPI_STATE_READY;
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xF885 0x0051      STRB     R0,[R5, #+81]
   1915            }
   1916          
   1917            /* Clear OVERUN flag in 2 Lines communication mode because received is not read */
   1918            if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \                     ??SPI_DMATransmitCplt_0: (+1)
   \   00000054   0x68A8             LDR      R0,[R5, #+8]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD106             BNE.N    ??SPI_DMATransmitCplt_3
   1919            {
   1920              __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \   0000005A   0x6828             LDR      R0,[R5, #+0]
   \   0000005C   0x68C0             LDR      R0,[R0, #+12]
   \   0000005E   0x9000             STR      R0,[SP, #+0]
   \   00000060   0x6828             LDR      R0,[R5, #+0]
   \   00000062   0x6880             LDR      R0,[R0, #+8]
   \   00000064   0x9000             STR      R0,[SP, #+0]
   \   00000066   0x9800             LDR      R0,[SP, #+0]
   1921            }
   1922          
   1923            /* Check if Errors has been detected during transfer */
   1924            if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \                     ??SPI_DMATransmitCplt_3: (+1)
   \   00000068   0x6D68             LDR      R0,[R5, #+84]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD003             BEQ.N    ??SPI_DMATransmitCplt_4
   1925            {
   1926              HAL_SPI_ErrorCallback(hspi);
   \   0000006E   0x0028             MOVS     R0,R5
   \   00000070   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   \   00000074   0xE002             B.N      ??SPI_DMATransmitCplt_5
   1927            }
   1928            else
   1929            {
   1930              HAL_SPI_TxCpltCallback(hspi);
   \                     ??SPI_DMATransmitCplt_4: (+1)
   \   00000076   0x0028             MOVS     R0,R5
   \   00000078   0x.... 0x....      BL       HAL_SPI_TxCpltCallback
   1931            }
   1932          }
   \                     ??SPI_DMATransmitCplt_5: (+1)
   \   0000007C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1933          
   1934          /**
   1935            * @brief DMA SPI receive process complete callback 
   1936            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1937            *                the configuration information for the specified DMA module.
   1938            * @retval None
   1939            */

   \                                 In section .text, align 4, keep-with-next
   1940          static void SPI_DMAReceiveCplt(struct __DMA_HandleTypeDef *hdma)
   1941          {
   \                     SPI_DMAReceiveCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1942            __IO uint16_t tmpreg = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1943          
   1944            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   0000000A   0x6A65             LDR      R5,[R4, #+36]
   1945          
   1946            /* DMA Normal mode */
   1947            if((hdma->Instance->CCR & DMA_CIRCULAR) == 0)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x0680             LSLS     R0,R0,#+26
   \   00000012   0xD45B             BMI.N    ??SPI_DMAReceiveCplt_0
   1948            {
   1949              if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
   \   00000014   0x6868             LDR      R0,[R5, #+4]
   \   00000016   0xF5B0 0x7F82      CMP      R0,#+260
   \   0000001A   0xD10D             BNE.N    ??SPI_DMAReceiveCplt_1
   \   0000001C   0x68A8             LDR      R0,[R5, #+8]
   \   0000001E   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000022   0xD003             BEQ.N    ??SPI_DMAReceiveCplt_2
   \   00000024   0x68A8             LDR      R0,[R5, #+8]
   \   00000026   0xF5B0 0x6F80      CMP      R0,#+1024
   \   0000002A   0xD105             BNE.N    ??SPI_DMAReceiveCplt_1
   1950              {
   1951                /* Disable SPI peripheral */
   1952                __HAL_SPI_DISABLE(hspi);
   \                     ??SPI_DMAReceiveCplt_2: (+1)
   \   0000002C   0x6828             LDR      R0,[R5, #+0]
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF030 0x0040      BICS     R0,R0,#0x40
   \   00000034   0x6829             LDR      R1,[R5, #+0]
   \   00000036   0x6008             STR      R0,[R1, #+0]
   1953              }
   1954          
   1955              /* Disable Rx DMA Request */
   1956              CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
   \                     ??SPI_DMAReceiveCplt_1: (+1)
   \   00000038   0x6828             LDR      R0,[R5, #+0]
   \   0000003A   0x6840             LDR      R0,[R0, #+4]
   \   0000003C   0x0840             LSRS     R0,R0,#+1
   \   0000003E   0x0040             LSLS     R0,R0,#+1
   \   00000040   0x6829             LDR      R1,[R5, #+0]
   \   00000042   0x6048             STR      R0,[R1, #+4]
   1957          
   1958              /* Disable Tx DMA Request (done by default to handle the case Master RX direction 2 lines) */
   1959              CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \   00000044   0x6828             LDR      R0,[R5, #+0]
   \   00000046   0x6840             LDR      R0,[R0, #+4]
   \   00000048   0xF030 0x0002      BICS     R0,R0,#0x2
   \   0000004C   0x6829             LDR      R1,[R5, #+0]
   \   0000004E   0x6048             STR      R0,[R1, #+4]
   1960          
   1961              /* Reset CRC Calculation */
   1962              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000050   0x6AA8             LDR      R0,[R5, #+40]
   \   00000052   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000056   0xD129             BNE.N    ??SPI_DMAReceiveCplt_3
   1963              {
   1964                /* Wait until RXNE flag is set to send data */
   1965                if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, SPI_TIMEOUT_VALUE) != HAL_OK)
   \   00000058   0x230A             MOVS     R3,#+10
   \   0000005A   0x2200             MOVS     R2,#+0
   \   0000005C   0x2101             MOVS     R1,#+1
   \   0000005E   0x0028             MOVS     R0,R5
   \   00000060   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD003             BEQ.N    ??SPI_DMAReceiveCplt_4
   1966                {
   1967                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   00000068   0x6D68             LDR      R0,[R5, #+84]
   \   0000006A   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000006E   0x6568             STR      R0,[R5, #+84]
   1968                }
   1969          
   1970                /* Read CRC */
   1971                tmpreg = hspi->Instance->DR;
   \                     ??SPI_DMAReceiveCplt_4: (+1)
   \   00000070   0x6828             LDR      R0,[R5, #+0]
   \   00000072   0x68C0             LDR      R0,[R0, #+12]
   \   00000074   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1972                UNUSED(tmpreg);
   \   00000078   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   1973          
   1974                /* Wait until RXNE flag is set */
   1975                if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, SET, SPI_TIMEOUT_VALUE) != HAL_OK)
   \   0000007C   0x230A             MOVS     R3,#+10
   \   0000007E   0x2201             MOVS     R2,#+1
   \   00000080   0x2101             MOVS     R1,#+1
   \   00000082   0x0028             MOVS     R0,R5
   \   00000084   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD003             BEQ.N    ??SPI_DMAReceiveCplt_5
   1976                {
   1977                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   0000008C   0x6D68             LDR      R0,[R5, #+84]
   \   0000008E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000092   0x6568             STR      R0,[R5, #+84]
   1978                }
   1979          
   1980                /* Check if CRC error occurred */
   1981                if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   \                     ??SPI_DMAReceiveCplt_5: (+1)
   \   00000094   0x6828             LDR      R0,[R5, #+0]
   \   00000096   0x6880             LDR      R0,[R0, #+8]
   \   00000098   0x06C0             LSLS     R0,R0,#+27
   \   0000009A   0xD507             BPL.N    ??SPI_DMAReceiveCplt_3
   1982                {
   1983                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   \   0000009C   0x6D68             LDR      R0,[R5, #+84]
   \   0000009E   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000000A2   0x6568             STR      R0,[R5, #+84]
   1984                  __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   \   000000A4   0xF07F 0x0010      MVNS     R0,#+16
   \   000000A8   0x6829             LDR      R1,[R5, #+0]
   \   000000AA   0x6088             STR      R0,[R1, #+8]
   1985                }
   1986              }
   1987          
   1988              hspi->RxXferCount = 0;
   \                     ??SPI_DMAReceiveCplt_3: (+1)
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x87E8             STRH     R0,[R5, #+62]
   1989              hspi->State = HAL_SPI_STATE_READY;
   \   000000B0   0x2001             MOVS     R0,#+1
   \   000000B2   0xF885 0x0051      STRB     R0,[R5, #+81]
   1990          
   1991              /* Check if Errors has been detected during transfer */
   1992              if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \   000000B6   0x6D68             LDR      R0,[R5, #+84]
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD003             BEQ.N    ??SPI_DMAReceiveCplt_6
   1993              {
   1994                HAL_SPI_ErrorCallback(hspi);
   \   000000BC   0x0028             MOVS     R0,R5
   \   000000BE   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   \   000000C2   0xE006             B.N      ??SPI_DMAReceiveCplt_7
   1995              }
   1996              else
   1997              {
   1998                HAL_SPI_RxCpltCallback(hspi);
   \                     ??SPI_DMAReceiveCplt_6: (+1)
   \   000000C4   0x0028             MOVS     R0,R5
   \   000000C6   0x.... 0x....      BL       HAL_SPI_RxCpltCallback
   \   000000CA   0xE002             B.N      ??SPI_DMAReceiveCplt_7
   1999              }
   2000            }
   2001            else
   2002            {
   2003              HAL_SPI_RxCpltCallback(hspi);
   \                     ??SPI_DMAReceiveCplt_0: (+1)
   \   000000CC   0x0028             MOVS     R0,R5
   \   000000CE   0x.... 0x....      BL       HAL_SPI_RxCpltCallback
   2004            }
   2005          }
   \                     ??SPI_DMAReceiveCplt_7: (+1)
   \   000000D2   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2006          
   2007          /**
   2008            * @brief DMA SPI transmit receive process complete callback 
   2009            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   2010            *                the configuration information for the specified DMA module.
   2011            * @retval None
   2012            */

   \                                 In section .text, align 4, keep-with-next
   2013          static void SPI_DMATransmitReceiveCplt(struct __DMA_HandleTypeDef *hdma)   
   2014          {
   \                     SPI_DMATransmitReceiveCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2015            __IO uint16_t tmpreg = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2016          
   2017            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   0000000A   0x6A65             LDR      R5,[R4, #+36]
   2018          
   2019            if((hdma->Instance->CCR & DMA_CIRCULAR) == 0)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x0680             LSLS     R0,R0,#+26
   \   00000012   0xD45F             BMI.N    ??SPI_DMATransmitReceiveCplt_0
   2020            {
   2021              /* Reset CRC Calculation */
   2022              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000014   0x6AA8             LDR      R0,[R5, #+40]
   \   00000016   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000001A   0xD125             BNE.N    ??SPI_DMATransmitReceiveCplt_1
   2023              {
   2024                /* Check if CRC is done on going (RXNE flag set) */
   2025                if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, SET, SPI_TIMEOUT_VALUE) == HAL_OK)
   \   0000001C   0x230A             MOVS     R3,#+10
   \   0000001E   0x2201             MOVS     R2,#+1
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD10B             BNE.N    ??SPI_DMATransmitReceiveCplt_2
   2026                {
   2027                  /* Wait until RXNE flag is set to send data */
   2028                  if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, SPI_TIMEOUT_VALUE) != HAL_OK)
   \   0000002C   0x230A             MOVS     R3,#+10
   \   0000002E   0x2200             MOVS     R2,#+0
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD003             BEQ.N    ??SPI_DMATransmitReceiveCplt_2
   2029                  {
   2030                    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   0000003C   0x6D68             LDR      R0,[R5, #+84]
   \   0000003E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000042   0x6568             STR      R0,[R5, #+84]
   2031                  }
   2032                }
   2033                /* Read CRC */
   2034                tmpreg = hspi->Instance->DR;
   \                     ??SPI_DMATransmitReceiveCplt_2: (+1)
   \   00000044   0x6828             LDR      R0,[R5, #+0]
   \   00000046   0x68C0             LDR      R0,[R0, #+12]
   \   00000048   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2035                UNUSED(tmpreg);
   \   0000004C   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   2036          
   2037                /* Check if CRC error occurred */
   2038                if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   \   00000050   0x6828             LDR      R0,[R5, #+0]
   \   00000052   0x6880             LDR      R0,[R0, #+8]
   \   00000054   0x06C0             LSLS     R0,R0,#+27
   \   00000056   0xD507             BPL.N    ??SPI_DMATransmitReceiveCplt_1
   2039                {
   2040                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   \   00000058   0x6D68             LDR      R0,[R5, #+84]
   \   0000005A   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000005E   0x6568             STR      R0,[R5, #+84]
   2041                  __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   \   00000060   0xF07F 0x0010      MVNS     R0,#+16
   \   00000064   0x6829             LDR      R1,[R5, #+0]
   \   00000066   0x6088             STR      R0,[R1, #+8]
   2042                }
   2043              }
   2044          
   2045              /* Wait until TXE flag is set to send data */
   2046              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, SPI_TIMEOUT_VALUE) != HAL_OK)
   \                     ??SPI_DMATransmitReceiveCplt_1: (+1)
   \   00000068   0x230A             MOVS     R3,#+10
   \   0000006A   0x2200             MOVS     R2,#+0
   \   0000006C   0x2102             MOVS     R1,#+2
   \   0000006E   0x0028             MOVS     R0,R5
   \   00000070   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD003             BEQ.N    ??SPI_DMATransmitReceiveCplt_3
   2047              {
   2048                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   00000078   0x6D68             LDR      R0,[R5, #+84]
   \   0000007A   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000007E   0x6568             STR      R0,[R5, #+84]
   2049              }
   2050            
   2051              /* Disable Tx DMA Request */
   2052              CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \                     ??SPI_DMATransmitReceiveCplt_3: (+1)
   \   00000080   0x6828             LDR      R0,[R5, #+0]
   \   00000082   0x6840             LDR      R0,[R0, #+4]
   \   00000084   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000088   0x6829             LDR      R1,[R5, #+0]
   \   0000008A   0x6048             STR      R0,[R1, #+4]
   2053          
   2054              /* Wait until Busy flag is reset before disabling SPI */
   2055              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_BSY, SET, SPI_TIMEOUT_VALUE) != HAL_OK)
   \   0000008C   0x230A             MOVS     R3,#+10
   \   0000008E   0x2201             MOVS     R2,#+1
   \   00000090   0x2180             MOVS     R1,#+128
   \   00000092   0x0028             MOVS     R0,R5
   \   00000094   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD003             BEQ.N    ??SPI_DMATransmitReceiveCplt_4
   2056              {
   2057                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   0000009C   0x6D68             LDR      R0,[R5, #+84]
   \   0000009E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000000A2   0x6568             STR      R0,[R5, #+84]
   2058              }
   2059          
   2060              /* Disable Rx DMA Request */
   2061              CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
   \                     ??SPI_DMATransmitReceiveCplt_4: (+1)
   \   000000A4   0x6828             LDR      R0,[R5, #+0]
   \   000000A6   0x6840             LDR      R0,[R0, #+4]
   \   000000A8   0x0840             LSRS     R0,R0,#+1
   \   000000AA   0x0040             LSLS     R0,R0,#+1
   \   000000AC   0x6829             LDR      R1,[R5, #+0]
   \   000000AE   0x6048             STR      R0,[R1, #+4]
   2062          
   2063              hspi->TxXferCount = 0;
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0x86E8             STRH     R0,[R5, #+54]
   2064              hspi->RxXferCount = 0;
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0x87E8             STRH     R0,[R5, #+62]
   2065          
   2066              hspi->State = HAL_SPI_STATE_READY;
   \   000000B8   0x2001             MOVS     R0,#+1
   \   000000BA   0xF885 0x0051      STRB     R0,[R5, #+81]
   2067          
   2068              /* Check if Errors has been detected during transfer */
   2069              if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \   000000BE   0x6D68             LDR      R0,[R5, #+84]
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD003             BEQ.N    ??SPI_DMATransmitReceiveCplt_5
   2070              {
   2071                HAL_SPI_ErrorCallback(hspi);
   \   000000C4   0x0028             MOVS     R0,R5
   \   000000C6   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   \   000000CA   0xE006             B.N      ??SPI_DMATransmitReceiveCplt_6
   2072              }
   2073              else
   2074              {
   2075                HAL_SPI_TxRxCpltCallback(hspi);
   \                     ??SPI_DMATransmitReceiveCplt_5: (+1)
   \   000000CC   0x0028             MOVS     R0,R5
   \   000000CE   0x.... 0x....      BL       HAL_SPI_TxRxCpltCallback
   \   000000D2   0xE002             B.N      ??SPI_DMATransmitReceiveCplt_6
   2076              }
   2077            }
   2078            else
   2079            {
   2080              HAL_SPI_TxRxCpltCallback(hspi);
   \                     ??SPI_DMATransmitReceiveCplt_0: (+1)
   \   000000D4   0x0028             MOVS     R0,R5
   \   000000D6   0x.... 0x....      BL       HAL_SPI_TxRxCpltCallback
   2081            }
   2082          }
   \                     ??SPI_DMATransmitReceiveCplt_6: (+1)
   \   000000DA   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2083          
   2084          /**
   2085            * @brief DMA SPI half transmit process complete callback 
   2086            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   2087            *                the configuration information for the specified DMA module.
   2088            * @retval None
   2089            */

   \                                 In section .text, align 4, keep-with-next
   2090          static void SPI_DMAHalfTransmitCplt(struct __DMA_HandleTypeDef *hdma)
   2091          {
   \                     SPI_DMAHalfTransmitCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2092            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   2093          
   2094            HAL_SPI_TxHalfCpltCallback(hspi);
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x.... 0x....      BL       HAL_SPI_TxHalfCpltCallback
   2095          }
   \   0000000C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2096          
   2097          /**
   2098            * @brief DMA SPI half receive process complete callback 
   2099            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   2100            *                the configuration information for the specified DMA module.
   2101            * @retval None
   2102            */

   \                                 In section .text, align 4, keep-with-next
   2103          static void SPI_DMAHalfReceiveCplt(struct __DMA_HandleTypeDef *hdma)
   2104          {
   \                     SPI_DMAHalfReceiveCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2105            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   2106          
   2107            HAL_SPI_RxHalfCpltCallback(hspi);
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x.... 0x....      BL       HAL_SPI_RxHalfCpltCallback
   2108          }
   \   0000000C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2109          
   2110          /**
   2111            * @brief DMA SPI Half transmit receive process complete callback 
   2112            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   2113            *                the configuration information for the specified DMA module.
   2114            * @retval None
   2115            */

   \                                 In section .text, align 4, keep-with-next
   2116          static void SPI_DMAHalfTransmitReceiveCplt(struct __DMA_HandleTypeDef *hdma)   
   2117          {
   \                     SPI_DMAHalfTransmitReceiveCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2118            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   2119          
   2120            HAL_SPI_TxRxHalfCpltCallback(hspi);
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x.... 0x....      BL       HAL_SPI_TxRxHalfCpltCallback
   2121          }
   \   0000000C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2122          
   2123          /**
   2124            * @brief DMA SPI communication error callback 
   2125            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   2126            *                the configuration information for the specified DMA module.
   2127            * @retval None
   2128            */

   \                                 In section .text, align 4, keep-with-next
   2129          static void SPI_DMAError(DMA_HandleTypeDef *hdma)
   2130          {
   \                     SPI_DMAError: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2131            SPI_HandleTypeDef* hspi = (SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   2132            hspi->TxXferCount = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x86E8             STRH     R0,[R5, #+54]
   2133            hspi->RxXferCount = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x87E8             STRH     R0,[R5, #+62]
   2134            hspi->State= HAL_SPI_STATE_READY;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF885 0x0051      STRB     R0,[R5, #+81]
   2135            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
   \   00000014   0x6D68             LDR      R0,[R5, #+84]
   \   00000016   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000001A   0x6568             STR      R0,[R5, #+84]
   2136            HAL_SPI_ErrorCallback(hspi);
   \   0000001C   0x0028             MOVS     R0,R5
   \   0000001E   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   2137          }
   \   00000022   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2138          
   2139          /**
   2140            * @brief  This function handles SPI Communication Timeout.
   2141            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2142            *                the configuration information for SPI module.
   2143            * @param  Flag: SPI flag to check
   2144            * @param  Status: Flag status to check: RESET or set
   2145            * @param  Timeout: Timeout duration
   2146            * @retval HAL status
   2147            */

   \                                 In section .text, align 2, keep-with-next
   2148          static HAL_StatusTypeDef SPI_WaitOnFlagUntilTimeout(struct __SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus Status, uint32_t Timeout)  
   2149          {
   \                     SPI_WaitOnFlagUntilTimeout: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   2150            uint32_t tickstart = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   2151          
   2152            /* Get tick */ 
   2153            tickstart = HAL_GetTick();
   \   00000010   0x.... 0x....      BL       HAL_GetTick
   \   00000014   0x4680             MOV      R8,R0
   2154          
   2155            /* Wait until flag is set */
   2156            if(Status == RESET)
   \   00000016   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000018   0x2E00             CMP      R6,#+0
   \   0000001A   0xD133             BNE.N    ??SPI_WaitOnFlagUntilTimeout_0
   2157            {
   2158              while(__HAL_SPI_GET_FLAG(hspi, Flag) == RESET)
   \                     ??SPI_WaitOnFlagUntilTimeout_1: (+1)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6880             LDR      R0,[R0, #+8]
   \   00000020   0x4028             ANDS     R0,R5,R0
   \   00000022   0x42A8             CMP      R0,R5
   \   00000024   0xD062             BEQ.N    ??SPI_WaitOnFlagUntilTimeout_2
   2159              {
   2160                if(Timeout != HAL_MAX_DELAY)
   \   00000026   0xF117 0x0F01      CMN      R7,#+1
   \   0000002A   0xD0F7             BEQ.N    ??SPI_WaitOnFlagUntilTimeout_1
   2161                {
   2162                  if((Timeout == 0) || ((HAL_GetTick() - tickstart ) > Timeout))
   \   0000002C   0x2F00             CMP      R7,#+0
   \   0000002E   0xD005             BEQ.N    ??SPI_WaitOnFlagUntilTimeout_3
   \   00000030   0x.... 0x....      BL       HAL_GetTick
   \   00000034   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   00000038   0x4287             CMP      R7,R0
   \   0000003A   0xD2EF             BCS.N    ??SPI_WaitOnFlagUntilTimeout_1
   2163                  {
   2164                    /* Disable the SPI and reset the CRC: the CRC value should be cleared
   2165                       on both master and slave sides in order to resynchronize the master
   2166                       and slave for their respective CRC calculation */
   2167          
   2168                    /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
   2169                    __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
   \                     ??SPI_WaitOnFlagUntilTimeout_3: (+1)
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6840             LDR      R0,[R0, #+4]
   \   00000040   0xF030 0x00E0      BICS     R0,R0,#0xE0
   \   00000044   0x6821             LDR      R1,[R4, #+0]
   \   00000046   0x6048             STR      R0,[R1, #+4]
   2170          
   2171                    /* Disable SPI peripheral */
   2172                    __HAL_SPI_DISABLE(hspi);
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0xF030 0x0040      BICS     R0,R0,#0x40
   \   00000050   0x6821             LDR      R1,[R4, #+0]
   \   00000052   0x6008             STR      R0,[R1, #+0]
   2173          
   2174                    /* Reset CRC Calculation */
   2175                    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000054   0x6AA0             LDR      R0,[R4, #+40]
   \   00000056   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000005A   0xD10B             BNE.N    ??SPI_WaitOnFlagUntilTimeout_4
   2176                    {
   2177                      SPI_RESET_CRC(hspi);
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x6008             STR      R0,[R1, #+0]
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   00000070   0x6821             LDR      R1,[R4, #+0]
   \   00000072   0x6008             STR      R0,[R1, #+0]
   2178                    }
   2179          
   2180                    hspi->State= HAL_SPI_STATE_READY;
   \                     ??SPI_WaitOnFlagUntilTimeout_4: (+1)
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xF884 0x0051      STRB     R0,[R4, #+81]
   2181          
   2182                    /* Process Unlocked */
   2183                    __HAL_UNLOCK(hspi);
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xF884 0x0050      STRB     R0,[R4, #+80]
   2184          
   2185                    return HAL_TIMEOUT;
   \   00000080   0x2003             MOVS     R0,#+3
   \   00000082   0xE034             B.N      ??SPI_WaitOnFlagUntilTimeout_5
   2186                  }
   2187                }
   2188              }
   2189            }
   2190            else
   2191            {
   2192              while(__HAL_SPI_GET_FLAG(hspi, Flag) != RESET)
   \                     ??SPI_WaitOnFlagUntilTimeout_0: (+1)
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6880             LDR      R0,[R0, #+8]
   \   00000088   0x4028             ANDS     R0,R5,R0
   \   0000008A   0x42A8             CMP      R0,R5
   \   0000008C   0xD12E             BNE.N    ??SPI_WaitOnFlagUntilTimeout_2
   2193              {
   2194                if(Timeout != HAL_MAX_DELAY)
   \   0000008E   0xF117 0x0F01      CMN      R7,#+1
   \   00000092   0xD0F7             BEQ.N    ??SPI_WaitOnFlagUntilTimeout_0
   2195                {
   2196                  if((Timeout == 0) || ((HAL_GetTick() - tickstart ) > Timeout))
   \   00000094   0x2F00             CMP      R7,#+0
   \   00000096   0xD005             BEQ.N    ??SPI_WaitOnFlagUntilTimeout_6
   \   00000098   0x.... 0x....      BL       HAL_GetTick
   \   0000009C   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   000000A0   0x4287             CMP      R7,R0
   \   000000A2   0xD2EF             BCS.N    ??SPI_WaitOnFlagUntilTimeout_0
   2197                  {
   2198                    /* Disable the SPI and reset the CRC: the CRC value should be cleared
   2199                       on both master and slave sides in order to resynchronize the master
   2200                       and slave for their respective CRC calculation */
   2201          
   2202                    /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
   2203                    __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
   \                     ??SPI_WaitOnFlagUntilTimeout_6: (+1)
   \   000000A4   0x6820             LDR      R0,[R4, #+0]
   \   000000A6   0x6840             LDR      R0,[R0, #+4]
   \   000000A8   0xF030 0x00E0      BICS     R0,R0,#0xE0
   \   000000AC   0x6821             LDR      R1,[R4, #+0]
   \   000000AE   0x6048             STR      R0,[R1, #+4]
   2204          
   2205                    /* Disable SPI peripheral */
   2206                    __HAL_SPI_DISABLE(hspi);
   \   000000B0   0x6820             LDR      R0,[R4, #+0]
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0xF030 0x0040      BICS     R0,R0,#0x40
   \   000000B8   0x6821             LDR      R1,[R4, #+0]
   \   000000BA   0x6008             STR      R0,[R1, #+0]
   2207          
   2208                    /* Reset CRC Calculation */
   2209                    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   000000BC   0x6AA0             LDR      R0,[R4, #+40]
   \   000000BE   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000000C2   0xD10B             BNE.N    ??SPI_WaitOnFlagUntilTimeout_7
   2210                    {
   2211                      SPI_RESET_CRC(hspi);
   \   000000C4   0x6820             LDR      R0,[R4, #+0]
   \   000000C6   0x6800             LDR      R0,[R0, #+0]
   \   000000C8   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   000000CC   0x6821             LDR      R1,[R4, #+0]
   \   000000CE   0x6008             STR      R0,[R1, #+0]
   \   000000D0   0x6820             LDR      R0,[R4, #+0]
   \   000000D2   0x6800             LDR      R0,[R0, #+0]
   \   000000D4   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   000000D8   0x6821             LDR      R1,[R4, #+0]
   \   000000DA   0x6008             STR      R0,[R1, #+0]
   2212                    }
   2213          
   2214                    hspi->State= HAL_SPI_STATE_READY;
   \                     ??SPI_WaitOnFlagUntilTimeout_7: (+1)
   \   000000DC   0x2001             MOVS     R0,#+1
   \   000000DE   0xF884 0x0051      STRB     R0,[R4, #+81]
   2215          
   2216                    /* Process Unlocked */
   2217                    __HAL_UNLOCK(hspi);
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0xF884 0x0050      STRB     R0,[R4, #+80]
   2218          
   2219                    return HAL_TIMEOUT;
   \   000000E8   0x2003             MOVS     R0,#+3
   \   000000EA   0xE000             B.N      ??SPI_WaitOnFlagUntilTimeout_5
   2220                  }
   2221                }
   2222              }
   2223            }
   2224            return HAL_OK;
   \                     ??SPI_WaitOnFlagUntilTimeout_2: (+1)
   \   000000EC   0x2000             MOVS     R0,#+0
   \                     ??SPI_WaitOnFlagUntilTimeout_5: (+1)
   \   000000EE   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2225          }
   2226          /**
   2227            * @}
   2228            */
   2229          
   2230          #endif /* HAL_SPI_MODULE_ENABLED */
   2231          /**
   2232            * @}
   2233            */
   2234          
   2235          /**
   2236            * @}
   2237            */
   2238          
   2239          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_SPI_DMAPause
       0   HAL_SPI_DMAResume
       8   HAL_SPI_DMAStop
         8   -> HAL_DMA_Abort
       8   HAL_SPI_DeInit
         8   -> HAL_SPI_MspDeInit
       0   HAL_SPI_ErrorCallback
       0   HAL_SPI_GetError
       0   HAL_SPI_GetState
      16   HAL_SPI_IRQHandler
        16   -- Indirect call
        16   -> HAL_SPI_ErrorCallback
       0   HAL_SPI_Init
       0   HAL_SPI_MspDeInit
       0   HAL_SPI_MspInit
      32   HAL_SPI_Receive
        32   -> HAL_SPI_TransmitReceive
        32   -> SPI_WaitOnFlagUntilTimeout
      16   HAL_SPI_Receive_DMA
        16   -> HAL_DMA_Start_IT
        16   -> HAL_SPI_TransmitReceive_DMA
      16   HAL_SPI_Receive_IT
        16   -> HAL_SPI_TransmitReceive_IT
       0   HAL_SPI_RxCpltCallback
       0   HAL_SPI_RxHalfCpltCallback
      24   HAL_SPI_Transmit
        24   -> SPI_WaitOnFlagUntilTimeout
      32   HAL_SPI_TransmitReceive
        32   -> SPI_WaitOnFlagUntilTimeout
      24   HAL_SPI_TransmitReceive_DMA
        24   -> HAL_DMA_Start_IT
       8   HAL_SPI_TransmitReceive_IT
      16   HAL_SPI_Transmit_DMA
        16   -> HAL_DMA_Start_IT
       4   HAL_SPI_Transmit_IT
       0   HAL_SPI_TxCpltCallback
       0   HAL_SPI_TxHalfCpltCallback
       0   HAL_SPI_TxRxCpltCallback
       0   HAL_SPI_TxRxHalfCpltCallback
       8   SPI_2LinesRxISR
         8   -> SPI_RxCloseIRQHandler
      16   SPI_DMAError
        16   -> HAL_SPI_ErrorCallback
      16   SPI_DMAHalfReceiveCplt
        16   -> HAL_SPI_RxHalfCpltCallback
      16   SPI_DMAHalfTransmitCplt
        16   -> HAL_SPI_TxHalfCpltCallback
      16   SPI_DMAHalfTransmitReceiveCplt
        16   -> HAL_SPI_TxRxHalfCpltCallback
      16   SPI_DMAReceiveCplt
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_RxCpltCallback
        16   -> SPI_WaitOnFlagUntilTimeout
      16   SPI_DMATransmitCplt
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_TxCpltCallback
        16   -> SPI_WaitOnFlagUntilTimeout
      16   SPI_DMATransmitReceiveCplt
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_TxRxCpltCallback
        16   -> SPI_WaitOnFlagUntilTimeout
      16   SPI_RxCloseIRQHandler
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_RxCpltCallback
        16   -> HAL_SPI_TxRxCpltCallback
        16   -> SPI_WaitOnFlagUntilTimeout
       8   SPI_RxISR
         8   -> SPI_RxCloseIRQHandler
      16   SPI_TxCloseIRQHandler
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_TxCpltCallback
        16   -> HAL_SPI_TxRxCpltCallback
        16   -> SPI_WaitOnFlagUntilTimeout
       8   SPI_TxISR
         8   -> SPI_TxCloseIRQHandler
      24   SPI_WaitOnFlagUntilTimeout
        24   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      54  HAL_SPI_DMAPause
      54  HAL_SPI_DMAResume
      62  HAL_SPI_DMAStop
      50  HAL_SPI_DeInit
       2  HAL_SPI_ErrorCallback
       4  HAL_SPI_GetError
       6  HAL_SPI_GetState
     224  HAL_SPI_IRQHandler
       6  HAL_SPI_Init
       2  HAL_SPI_MspDeInit
       2  HAL_SPI_MspInit
     570  HAL_SPI_Receive
     260  HAL_SPI_Receive_DMA
     222  HAL_SPI_Receive_IT
       2  HAL_SPI_RxCpltCallback
       2  HAL_SPI_RxHalfCpltCallback
     460  HAL_SPI_Transmit
     868  HAL_SPI_TransmitReceive
     316  HAL_SPI_TransmitReceive_DMA
     192  HAL_SPI_TransmitReceive_IT
     222  HAL_SPI_Transmit_DMA
     202  HAL_SPI_Transmit_IT
       2  HAL_SPI_TxCpltCallback
       2  HAL_SPI_TxHalfCpltCallback
       2  HAL_SPI_TxRxCpltCallback
       2  HAL_SPI_TxRxHalfCpltCallback
      58  SPI_2LinesRxISR
      36  SPI_DMAError
      14  SPI_DMAHalfReceiveCplt
      14  SPI_DMAHalfTransmitCplt
      14  SPI_DMAHalfTransmitReceiveCplt
     212  SPI_DMAReceiveCplt
     126  SPI_DMATransmitCplt
     220  SPI_DMATransmitReceiveCplt
     244  SPI_RxCloseIRQHandler
      84  SPI_RxISR
     162  SPI_TxCloseIRQHandler
      78  SPI_TxISR
     242  SPI_WaitOnFlagUntilTimeout

 
 5 294 bytes in section .text
 
 5 270 bytes of CODE memory (+ 24 bytes shared)

Errors: none
Warnings: none
