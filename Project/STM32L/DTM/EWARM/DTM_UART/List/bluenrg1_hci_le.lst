###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       29/Jan/2018  14:45:20
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\SimpleBlueNRG1_HCI\hci\bluenrg1_hci_le.c
#    Command line =  
#        "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\SimpleBlueNRG1_HCI\hci\bluenrg1_hci_le.c"
#        -D STM32L151xB -D STM32L1XX_XL -D USE_STM32L1XX_STEVAL_IDB00xV1 -D
#        USE_HAL_DRIVER -D HCLK_32MHZ=1 -D SYSCLK_MSI=1 -D ENABLE_USART -D
#        USER_DEFINED_PLATFORM=USER_EVAL_PLATFORM -D IRQ_RESET_PIN -D DTM_UART
#        -lC "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\List"
#        -o "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        D:\Software\IAR_BlueNRG\arm\INC\c\DLib_Config_Normal.h -I
#        "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\HAL\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\BSP\STM32L1xx_BlueNRG1\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\BSP\STM32L1xx_Nucleo\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\CMSIS\Device\ST\STM32L1xx\Include\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\STM32L1xx_HAL_BlueNRG1_Drivers\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\SimpleBlueNRG1_HCI\includes\"
#        -On --use_c++_inline -I D:\Software\IAR_BlueNRG\arm\CMSIS\Include\
#    Locale       =  Chinese (Simplified)_China.936
#    List file    =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\List\bluenrg1_hci_le.lst
#    Object file  =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\Obj\bluenrg1_hci_le.o
#
###############################################################################

C:\Users\Administrator\Desktop\Temporary Files\eeworld_project\Project_Test\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\SimpleBlueNRG1_HCI\hci\bluenrg1_hci_le.c
      1          
      2          
      3          /**
      4            ******************************************************************************
      5            * @file    bluenrg1_hci_le.c
      6            * @author  AMG - RF Application team
      7            * @version V1.0.0
      8            * @date    22 June 2017
      9            * @brief   Source file for external uC - BlueNRG-x in network coprocessor mode (hci_le)
     10            *          Autogenerated files, do not edit!!
     11            ******************************************************************************
     12            * @attention
     13            *
     14            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     15            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     16            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     17            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     18            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     19            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     20            *
     21            * <h2><center>&copy; COPYRIGHT STMicroelectronics</center></h2>
     22            ******************************************************************************
     23            */
     24          #include "bluenrg1_hci_le.h"
     25          #include "osal.h"

   \                                 In section .text, align 2, keep-with-next
     26          tBleStatus hci_disconnect(uint16_t Connection_Handle,
     27                                    uint8_t Reason)
     28          {
   \                     hci_disconnect: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB0C9             SUB      SP,SP,#+292
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
     29            struct hci_request rq;
     30            uint8_t cmd_buffer[258];
     31            hci_disconnect_cp0 *cp0 = (hci_disconnect_cp0*)(cmd_buffer);
   \   00000008   0xAE07             ADD      R6,SP,#+28
     32            tBleStatus status = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
     33            uint8_t index_input = 0;
   \   00000010   0x2700             MOVS     R7,#+0
     34            cp0->Connection_Handle = htob(Connection_Handle, 2);
   \   00000012   0x8034             STRH     R4,[R6, #+0]
     35            index_input += 2;
   \   00000014   0x1CBF             ADDS     R7,R7,#+2
     36            cp0->Reason = htob(Reason, 1);
   \   00000016   0x70B5             STRB     R5,[R6, #+2]
     37            index_input += 1;
   \   00000018   0x1C7F             ADDS     R7,R7,#+1
     38            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000001A   0x2218             MOVS     R2,#+24
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0xA801             ADD      R0,SP,#+4
   \   00000020   0x.... 0x....      BL       Osal_MemSet
     39            rq.ogf = 0x01;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xF8AD 0x0004      STRH     R0,[SP, #+4]
     40            rq.ocf = 0x006;
   \   0000002A   0x2006             MOVS     R0,#+6
   \   0000002C   0xF8AD 0x0006      STRH     R0,[SP, #+6]
     41            rq.event = 0x0F;
   \   00000030   0x200F             MOVS     R0,#+15
   \   00000032   0x9002             STR      R0,[SP, #+8]
     42            rq.cparam = cmd_buffer;
   \   00000034   0xA807             ADD      R0,SP,#+28
   \   00000036   0x9003             STR      R0,[SP, #+12]
     43            rq.clen = index_input;
   \   00000038   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003A   0x9704             STR      R7,[SP, #+16]
     44            rq.rparam = &status;
   \   0000003C   0x4668             MOV      R0,SP
   \   0000003E   0x9005             STR      R0,[SP, #+20]
     45            rq.rlen = 1;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x9006             STR      R0,[SP, #+24]
     46            if (hci_send_req(&rq, FALSE) < 0)
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0xA801             ADD      R0,SP,#+4
   \   00000048   0x.... 0x....      BL       hci_send_req
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD501             BPL.N    ??hci_disconnect_0
     47              return BLE_STATUS_TIMEOUT;
   \   00000050   0x20FF             MOVS     R0,#+255
   \   00000052   0xE007             B.N      ??hci_disconnect_1
     48            if (status) {
   \                     ??hci_disconnect_0: (+1)
   \   00000054   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD002             BEQ.N    ??hci_disconnect_2
     49              return status;
   \   0000005C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000060   0xE000             B.N      ??hci_disconnect_1
     50            }
     51            return BLE_STATUS_SUCCESS;
   \                     ??hci_disconnect_2: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
   \                     ??hci_disconnect_1: (+1)
   \   00000064   0xB049             ADD      SP,SP,#+292
   \   00000066   0xBDF0             POP      {R4-R7,PC}       ;; return
     52          }

   \                                 In section .text, align 2, keep-with-next
     53          tBleStatus hci_read_remote_version_information(uint16_t Connection_Handle)
     54          {
   \                     hci_read_remote_version_information: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB0C8             SUB      SP,SP,#+288
   \   00000004   0x0004             MOVS     R4,R0
     55            struct hci_request rq;
     56            uint8_t cmd_buffer[258];
     57            hci_read_remote_version_information_cp0 *cp0 = (hci_read_remote_version_information_cp0*)(cmd_buffer);
   \   00000006   0xAD07             ADD      R5,SP,#+28
     58            tBleStatus status = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF88D 0x0000      STRB     R0,[SP, #+0]
     59            uint8_t index_input = 0;
   \   0000000E   0x2600             MOVS     R6,#+0
     60            cp0->Connection_Handle = htob(Connection_Handle, 2);
   \   00000010   0x802C             STRH     R4,[R5, #+0]
     61            index_input += 2;
   \   00000012   0x1CB6             ADDS     R6,R6,#+2
     62            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000014   0x2218             MOVS     R2,#+24
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0xA801             ADD      R0,SP,#+4
   \   0000001A   0x.... 0x....      BL       Osal_MemSet
     63            rq.ogf = 0x01;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xF8AD 0x0004      STRH     R0,[SP, #+4]
     64            rq.ocf = 0x01d;
   \   00000024   0x201D             MOVS     R0,#+29
   \   00000026   0xF8AD 0x0006      STRH     R0,[SP, #+6]
     65            rq.event = 0x0F;
   \   0000002A   0x200F             MOVS     R0,#+15
   \   0000002C   0x9002             STR      R0,[SP, #+8]
     66            rq.cparam = cmd_buffer;
   \   0000002E   0xA807             ADD      R0,SP,#+28
   \   00000030   0x9003             STR      R0,[SP, #+12]
     67            rq.clen = index_input;
   \   00000032   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000034   0x9604             STR      R6,[SP, #+16]
     68            rq.rparam = &status;
   \   00000036   0x4668             MOV      R0,SP
   \   00000038   0x9005             STR      R0,[SP, #+20]
     69            rq.rlen = 1;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x9006             STR      R0,[SP, #+24]
     70            if (hci_send_req(&rq, FALSE) < 0)
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0xA801             ADD      R0,SP,#+4
   \   00000042   0x.... 0x....      BL       hci_send_req
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD501             BPL.N    ??hci_read_remote_version_information_0
     71              return BLE_STATUS_TIMEOUT;
   \   0000004A   0x20FF             MOVS     R0,#+255
   \   0000004C   0xE007             B.N      ??hci_read_remote_version_information_1
     72            if (status) {
   \                     ??hci_read_remote_version_information_0: (+1)
   \   0000004E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD002             BEQ.N    ??hci_read_remote_version_information_2
     73              return status;
   \   00000056   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005A   0xE000             B.N      ??hci_read_remote_version_information_1
     74            }
     75            return BLE_STATUS_SUCCESS;
   \                     ??hci_read_remote_version_information_2: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \                     ??hci_read_remote_version_information_1: (+1)
   \   0000005E   0xB048             ADD      SP,SP,#+288
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return
     76          }

   \                                 In section .text, align 2, keep-with-next
     77          tBleStatus hci_set_event_mask(uint8_t Event_Mask[8])
     78          {
   \                     hci_set_event_mask: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB0C8             SUB      SP,SP,#+288
   \   00000004   0x0004             MOVS     R4,R0
     79            struct hci_request rq;
     80            uint8_t cmd_buffer[258];
     81            hci_set_event_mask_cp0 *cp0 = (hci_set_event_mask_cp0*)(cmd_buffer);
   \   00000006   0xAD07             ADD      R5,SP,#+28
     82            tBleStatus status = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF88D 0x0000      STRB     R0,[SP, #+0]
     83            uint8_t index_input = 0;
   \   0000000E   0x2600             MOVS     R6,#+0
     84            Osal_MemCpy((void *) &cp0->Event_Mask, (const void *) Event_Mask, 8);
   \   00000010   0x2208             MOVS     R2,#+8
   \   00000012   0x0021             MOVS     R1,R4
   \   00000014   0x0028             MOVS     R0,R5
   \   00000016   0x.... 0x....      BL       Osal_MemCpy
     85            index_input += 8;
   \   0000001A   0x3608             ADDS     R6,R6,#+8
     86            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000001C   0x2218             MOVS     R2,#+24
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0xA801             ADD      R0,SP,#+4
   \   00000022   0x.... 0x....      BL       Osal_MemSet
     87            rq.ogf = 0x03;
   \   00000026   0x2003             MOVS     R0,#+3
   \   00000028   0xF8AD 0x0004      STRH     R0,[SP, #+4]
     88            rq.ocf = 0x001;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF8AD 0x0006      STRH     R0,[SP, #+6]
     89            rq.cparam = cmd_buffer;
   \   00000032   0xA807             ADD      R0,SP,#+28
   \   00000034   0x9003             STR      R0,[SP, #+12]
     90            rq.clen = index_input;
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0x9604             STR      R6,[SP, #+16]
     91            rq.rparam = &status;
   \   0000003A   0x4668             MOV      R0,SP
   \   0000003C   0x9005             STR      R0,[SP, #+20]
     92            rq.rlen = 1;
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x9006             STR      R0,[SP, #+24]
     93            if (hci_send_req(&rq, FALSE) < 0)
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0xA801             ADD      R0,SP,#+4
   \   00000046   0x.... 0x....      BL       hci_send_req
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD501             BPL.N    ??hci_set_event_mask_0
     94              return BLE_STATUS_TIMEOUT;
   \   0000004E   0x20FF             MOVS     R0,#+255
   \   00000050   0xE007             B.N      ??hci_set_event_mask_1
     95            if (status) {
   \                     ??hci_set_event_mask_0: (+1)
   \   00000052   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD002             BEQ.N    ??hci_set_event_mask_2
     96              return status;
   \   0000005A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005E   0xE000             B.N      ??hci_set_event_mask_1
     97            }
     98            return BLE_STATUS_SUCCESS;
   \                     ??hci_set_event_mask_2: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \                     ??hci_set_event_mask_1: (+1)
   \   00000062   0xB048             ADD      SP,SP,#+288
   \   00000064   0xBD70             POP      {R4-R6,PC}       ;; return
     99          }

   \                                 In section .text, align 2, keep-with-next
    100          tBleStatus hci_reset(void)
    101          {
   \                     hci_reset: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    102            struct hci_request rq;
    103            tBleStatus status = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
    104            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000000A   0x2218             MOVS     R2,#+24
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0xA801             ADD      R0,SP,#+4
   \   00000010   0x.... 0x....      BL       Osal_MemSet
    105            rq.ogf = 0x03;
   \   00000014   0x2003             MOVS     R0,#+3
   \   00000016   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    106            rq.ocf = 0x003;
   \   0000001A   0x2003             MOVS     R0,#+3
   \   0000001C   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    107            rq.rparam = &status;
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x9005             STR      R0,[SP, #+20]
    108            rq.rlen = 1;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x9006             STR      R0,[SP, #+24]
    109            if (hci_send_req(&rq, FALSE) < 0)
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0xA801             ADD      R0,SP,#+4
   \   0000002C   0x.... 0x....      BL       hci_send_req
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD501             BPL.N    ??hci_reset_0
    110              return BLE_STATUS_TIMEOUT;
   \   00000034   0x20FF             MOVS     R0,#+255
   \   00000036   0xE007             B.N      ??hci_reset_1
    111            if (status) {
   \                     ??hci_reset_0: (+1)
   \   00000038   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD002             BEQ.N    ??hci_reset_2
    112              return status;
   \   00000040   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000044   0xE000             B.N      ??hci_reset_1
    113            }
    114            return BLE_STATUS_SUCCESS;
   \                     ??hci_reset_2: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \                     ??hci_reset_1: (+1)
   \   00000048   0xB007             ADD      SP,SP,#+28
   \   0000004A   0xBD00             POP      {PC}             ;; return
    115          }

   \                                 In section .text, align 2, keep-with-next
    116          tBleStatus hci_read_transmit_power_level(uint16_t Connection_Handle,
    117                                                   uint8_t Type,
    118                                                   uint8_t *Transmit_Power_Level)
    119          {
   \                     hci_read_transmit_power_level: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB0C8             SUB      SP,SP,#+288
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    120            struct hci_request rq;
    121            uint8_t cmd_buffer[258];
    122            hci_read_transmit_power_level_cp0 *cp0 = (hci_read_transmit_power_level_cp0*)(cmd_buffer);
   \   0000000C   0xAF07             ADD      R7,SP,#+28
    123            hci_read_transmit_power_level_rp0 resp;
    124            Osal_MemSet(&resp, 0, sizeof(resp));
   \   0000000E   0x2204             MOVS     R2,#+4
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x4668             MOV      R0,SP
   \   00000014   0x.... 0x....      BL       Osal_MemSet
    125            uint8_t index_input = 0;
   \   00000018   0xF05F 0x0800      MOVS     R8,#+0
    126            cp0->Connection_Handle = htob(Connection_Handle, 2);
   \   0000001C   0x803C             STRH     R4,[R7, #+0]
    127            index_input += 2;
   \   0000001E   0xF118 0x0802      ADDS     R8,R8,#+2
    128            cp0->Type = htob(Type, 1);
   \   00000022   0x70BD             STRB     R5,[R7, #+2]
    129            index_input += 1;
   \   00000024   0xF118 0x0801      ADDS     R8,R8,#+1
    130            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000028   0x2218             MOVS     R2,#+24
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0xA801             ADD      R0,SP,#+4
   \   0000002E   0x.... 0x....      BL       Osal_MemSet
    131            rq.ogf = 0x03;
   \   00000032   0x2003             MOVS     R0,#+3
   \   00000034   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    132            rq.ocf = 0x02d;
   \   00000038   0x202D             MOVS     R0,#+45
   \   0000003A   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    133            rq.cparam = cmd_buffer;
   \   0000003E   0xA807             ADD      R0,SP,#+28
   \   00000040   0x9003             STR      R0,[SP, #+12]
    134            rq.clen = index_input;
   \   00000042   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000046   0xF8CD 0x8010      STR      R8,[SP, #+16]
    135            rq.rparam = &resp;
   \   0000004A   0x4668             MOV      R0,SP
   \   0000004C   0x9005             STR      R0,[SP, #+20]
    136            rq.rlen = sizeof(resp);
   \   0000004E   0x2004             MOVS     R0,#+4
   \   00000050   0x9006             STR      R0,[SP, #+24]
    137            if (hci_send_req(&rq, FALSE) < 0)
   \   00000052   0x2100             MOVS     R1,#+0
   \   00000054   0xA801             ADD      R0,SP,#+4
   \   00000056   0x.... 0x....      BL       hci_send_req
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD501             BPL.N    ??hci_read_transmit_power_level_0
    138              return BLE_STATUS_TIMEOUT;
   \   0000005E   0x20FF             MOVS     R0,#+255
   \   00000060   0xE00A             B.N      ??hci_read_transmit_power_level_1
    139            if (resp.Status) {
   \                     ??hci_read_transmit_power_level_0: (+1)
   \   00000062   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD002             BEQ.N    ??hci_read_transmit_power_level_2
    140              return resp.Status;
   \   0000006A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000006E   0xE003             B.N      ??hci_read_transmit_power_level_1
    141            }
    142            *Transmit_Power_Level = btoh(resp.Transmit_Power_Level, 1);
   \                     ??hci_read_transmit_power_level_2: (+1)
   \   00000070   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   00000074   0x7030             STRB     R0,[R6, #+0]
    143            return BLE_STATUS_SUCCESS;
   \   00000076   0x2000             MOVS     R0,#+0
   \                     ??hci_read_transmit_power_level_1: (+1)
   \   00000078   0xB048             ADD      SP,SP,#+288
   \   0000007A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    144          }

   \                                 In section .text, align 2, keep-with-next
    145          tBleStatus hci_read_local_version_information(uint8_t *HCI_Version,
    146                                                        uint16_t *HCI_Revision,
    147                                                        uint8_t *LMP_PAL_Version,
    148                                                        uint16_t *Manufacturer_Name,
    149                                                        uint16_t *LMP_PAL_Subversion)
    150          {
   \                     hci_read_local_version_information: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB08A             SUB      SP,SP,#+40
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8040      LDR      R8,[SP, #+64]
    151            struct hci_request rq;
    152            hci_read_local_version_information_rp0 resp;
    153            Osal_MemSet(&resp, 0, sizeof(resp));
   \   00000012   0x2209             MOVS     R2,#+9
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x4668             MOV      R0,SP
   \   00000018   0x.... 0x....      BL       Osal_MemSet
    154            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000001C   0x2218             MOVS     R2,#+24
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0xA803             ADD      R0,SP,#+12
   \   00000022   0x.... 0x....      BL       Osal_MemSet
    155            rq.ogf = 0x04;
   \   00000026   0x2004             MOVS     R0,#+4
   \   00000028   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    156            rq.ocf = 0x001;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF8AD 0x000E      STRH     R0,[SP, #+14]
    157            rq.rparam = &resp;
   \   00000032   0x4668             MOV      R0,SP
   \   00000034   0x9007             STR      R0,[SP, #+28]
    158            rq.rlen = sizeof(resp);
   \   00000036   0x2009             MOVS     R0,#+9
   \   00000038   0x9008             STR      R0,[SP, #+32]
    159            if (hci_send_req(&rq, FALSE) < 0)
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0xA803             ADD      R0,SP,#+12
   \   0000003E   0x.... 0x....      BL       hci_send_req
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD501             BPL.N    ??hci_read_local_version_information_0
    160              return BLE_STATUS_TIMEOUT;
   \   00000046   0x20FF             MOVS     R0,#+255
   \   00000048   0xE017             B.N      ??hci_read_local_version_information_1
    161            if (resp.Status) {
   \                     ??hci_read_local_version_information_0: (+1)
   \   0000004A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD002             BEQ.N    ??hci_read_local_version_information_2
    162              return resp.Status;
   \   00000052   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000056   0xE010             B.N      ??hci_read_local_version_information_1
    163            }
    164            *HCI_Version = btoh(resp.HCI_Version, 1);
   \                     ??hci_read_local_version_information_2: (+1)
   \   00000058   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000005C   0x7020             STRB     R0,[R4, #+0]
    165            *HCI_Revision = btoh(resp.HCI_Revision, 2);
   \   0000005E   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   00000062   0x8028             STRH     R0,[R5, #+0]
    166            *LMP_PAL_Version = btoh(resp.LMP_PAL_Version, 1);
   \   00000064   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000068   0x7030             STRB     R0,[R6, #+0]
    167            *Manufacturer_Name = btoh(resp.Manufacturer_Name, 2);
   \   0000006A   0xF8BD 0x0005      LDRH     R0,[SP, #+5]
   \   0000006E   0x8038             STRH     R0,[R7, #+0]
    168            *LMP_PAL_Subversion = btoh(resp.LMP_PAL_Subversion, 2);
   \   00000070   0xF8BD 0x0007      LDRH     R0,[SP, #+7]
   \   00000074   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    169            return BLE_STATUS_SUCCESS;
   \   00000078   0x2000             MOVS     R0,#+0
   \                     ??hci_read_local_version_information_1: (+1)
   \   0000007A   0xB00A             ADD      SP,SP,#+40
   \   0000007C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    170          }

   \                                 In section .text, align 2, keep-with-next
    171          tBleStatus hci_read_local_supported_commands(uint8_t Supported_Commands[64])
    172          {
   \                     hci_read_local_supported_commands: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB098             SUB      SP,SP,#+96
   \   00000004   0x0004             MOVS     R4,R0
    173            struct hci_request rq;
    174            hci_read_local_supported_commands_rp0 resp;
    175            Osal_MemSet(&resp, 0, sizeof(resp));
   \   00000006   0x2241             MOVS     R2,#+65
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0xA806             ADD      R0,SP,#+24
   \   0000000C   0x.... 0x....      BL       Osal_MemSet
    176            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000010   0x2218             MOVS     R2,#+24
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x4668             MOV      R0,SP
   \   00000016   0x.... 0x....      BL       Osal_MemSet
    177            rq.ogf = 0x04;
   \   0000001A   0x2004             MOVS     R0,#+4
   \   0000001C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    178            rq.ocf = 0x002;
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    179            rq.rparam = &resp;
   \   00000026   0xA806             ADD      R0,SP,#+24
   \   00000028   0x9004             STR      R0,[SP, #+16]
    180            rq.rlen = sizeof(resp);
   \   0000002A   0x2041             MOVS     R0,#+65
   \   0000002C   0x9005             STR      R0,[SP, #+20]
    181            if (hci_send_req(&rq, FALSE) < 0)
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x4668             MOV      R0,SP
   \   00000032   0x.... 0x....      BL       hci_send_req
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD501             BPL.N    ??hci_read_local_supported_commands_0
    182              return BLE_STATUS_TIMEOUT;
   \   0000003A   0x20FF             MOVS     R0,#+255
   \   0000003C   0xE00D             B.N      ??hci_read_local_supported_commands_1
    183            if (resp.Status) {
   \                     ??hci_read_local_supported_commands_0: (+1)
   \   0000003E   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD002             BEQ.N    ??hci_read_local_supported_commands_2
    184              return resp.Status;
   \   00000046   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \   0000004A   0xE006             B.N      ??hci_read_local_supported_commands_1
    185            }
    186            Osal_MemCpy((void *) Supported_Commands, (const void *) resp.Supported_Commands, 64);
   \                     ??hci_read_local_supported_commands_2: (+1)
   \   0000004C   0x2240             MOVS     R2,#+64
   \   0000004E   0xF10D 0x0119      ADD      R1,SP,#+25
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       Osal_MemCpy
    187            return BLE_STATUS_SUCCESS;
   \   00000058   0x2000             MOVS     R0,#+0
   \                     ??hci_read_local_supported_commands_1: (+1)
   \   0000005A   0xB018             ADD      SP,SP,#+96
   \   0000005C   0xBD10             POP      {R4,PC}          ;; return
    188          }

   \                                 In section .text, align 2, keep-with-next
    189          tBleStatus hci_read_local_supported_features(uint8_t LMP_Features[8])
    190          {
   \                     hci_read_local_supported_features: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
   \   00000004   0x0004             MOVS     R4,R0
    191            struct hci_request rq;
    192            hci_read_local_supported_features_rp0 resp;
    193            Osal_MemSet(&resp, 0, sizeof(resp));
   \   00000006   0x2209             MOVS     R2,#+9
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       Osal_MemSet
    194            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000010   0x2218             MOVS     R2,#+24
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0xA803             ADD      R0,SP,#+12
   \   00000016   0x.... 0x....      BL       Osal_MemSet
    195            rq.ogf = 0x04;
   \   0000001A   0x2004             MOVS     R0,#+4
   \   0000001C   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    196            rq.ocf = 0x003;
   \   00000020   0x2003             MOVS     R0,#+3
   \   00000022   0xF8AD 0x000E      STRH     R0,[SP, #+14]
    197            rq.rparam = &resp;
   \   00000026   0x4668             MOV      R0,SP
   \   00000028   0x9007             STR      R0,[SP, #+28]
    198            rq.rlen = sizeof(resp);
   \   0000002A   0x2009             MOVS     R0,#+9
   \   0000002C   0x9008             STR      R0,[SP, #+32]
    199            if (hci_send_req(&rq, FALSE) < 0)
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0xA803             ADD      R0,SP,#+12
   \   00000032   0x.... 0x....      BL       hci_send_req
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD501             BPL.N    ??hci_read_local_supported_features_0
    200              return BLE_STATUS_TIMEOUT;
   \   0000003A   0x20FF             MOVS     R0,#+255
   \   0000003C   0xE00D             B.N      ??hci_read_local_supported_features_1
    201            if (resp.Status) {
   \                     ??hci_read_local_supported_features_0: (+1)
   \   0000003E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD002             BEQ.N    ??hci_read_local_supported_features_2
    202              return resp.Status;
   \   00000046   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004A   0xE006             B.N      ??hci_read_local_supported_features_1
    203            }
    204            Osal_MemCpy((void *) LMP_Features, (const void *) resp.LMP_Features, 8);
   \                     ??hci_read_local_supported_features_2: (+1)
   \   0000004C   0x2208             MOVS     R2,#+8
   \   0000004E   0xF10D 0x0101      ADD      R1,SP,#+1
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       Osal_MemCpy
    205            return BLE_STATUS_SUCCESS;
   \   00000058   0x2000             MOVS     R0,#+0
   \                     ??hci_read_local_supported_features_1: (+1)
   \   0000005A   0xB00A             ADD      SP,SP,#+40
   \   0000005C   0xBD10             POP      {R4,PC}          ;; return
    206          }

   \                                 In section .text, align 2, keep-with-next
    207          tBleStatus hci_read_bd_addr(uint8_t BD_ADDR[6])
    208          {
   \                     hci_read_bd_addr: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x0004             MOVS     R4,R0
    209            struct hci_request rq;
    210            hci_read_bd_addr_rp0 resp;
    211            Osal_MemSet(&resp, 0, sizeof(resp));
   \   00000006   0x2207             MOVS     R2,#+7
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       Osal_MemSet
    212            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000010   0x2218             MOVS     R2,#+24
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0xA802             ADD      R0,SP,#+8
   \   00000016   0x.... 0x....      BL       Osal_MemSet
    213            rq.ogf = 0x04;
   \   0000001A   0x2004             MOVS     R0,#+4
   \   0000001C   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    214            rq.ocf = 0x009;
   \   00000020   0x2009             MOVS     R0,#+9
   \   00000022   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    215            rq.rparam = &resp;
   \   00000026   0x4668             MOV      R0,SP
   \   00000028   0x9006             STR      R0,[SP, #+24]
    216            rq.rlen = sizeof(resp);
   \   0000002A   0x2007             MOVS     R0,#+7
   \   0000002C   0x9007             STR      R0,[SP, #+28]
    217            if (hci_send_req(&rq, FALSE) < 0)
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0xA802             ADD      R0,SP,#+8
   \   00000032   0x.... 0x....      BL       hci_send_req
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD501             BPL.N    ??hci_read_bd_addr_0
    218              return BLE_STATUS_TIMEOUT;
   \   0000003A   0x20FF             MOVS     R0,#+255
   \   0000003C   0xE00D             B.N      ??hci_read_bd_addr_1
    219            if (resp.Status) {
   \                     ??hci_read_bd_addr_0: (+1)
   \   0000003E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD002             BEQ.N    ??hci_read_bd_addr_2
    220              return resp.Status;
   \   00000046   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004A   0xE006             B.N      ??hci_read_bd_addr_1
    221            }
    222            Osal_MemCpy((void *) BD_ADDR, (const void *) resp.BD_ADDR, 6);
   \                     ??hci_read_bd_addr_2: (+1)
   \   0000004C   0x2206             MOVS     R2,#+6
   \   0000004E   0xF10D 0x0101      ADD      R1,SP,#+1
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       Osal_MemCpy
    223            return BLE_STATUS_SUCCESS;
   \   00000058   0x2000             MOVS     R0,#+0
   \                     ??hci_read_bd_addr_1: (+1)
   \   0000005A   0xB008             ADD      SP,SP,#+32
   \   0000005C   0xBD10             POP      {R4,PC}          ;; return
    224          }

   \                                 In section .text, align 2, keep-with-next
    225          tBleStatus hci_read_rssi(uint16_t Connection_Handle,
    226                                   uint8_t *RSSI)
    227          {
   \                     hci_read_rssi: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB0C9             SUB      SP,SP,#+292
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    228            struct hci_request rq;
    229            uint8_t cmd_buffer[258];
    230            hci_read_rssi_cp0 *cp0 = (hci_read_rssi_cp0*)(cmd_buffer);
   \   00000008   0xAE07             ADD      R6,SP,#+28
    231            hci_read_rssi_rp0 resp;
    232            Osal_MemSet(&resp, 0, sizeof(resp));
   \   0000000A   0x2204             MOVS     R2,#+4
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x4668             MOV      R0,SP
   \   00000010   0x.... 0x....      BL       Osal_MemSet
    233            uint8_t index_input = 0;
   \   00000014   0x2700             MOVS     R7,#+0
    234            cp0->Connection_Handle = htob(Connection_Handle, 2);
   \   00000016   0x8034             STRH     R4,[R6, #+0]
    235            index_input += 2;
   \   00000018   0x1CBF             ADDS     R7,R7,#+2
    236            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000001A   0x2218             MOVS     R2,#+24
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0xA801             ADD      R0,SP,#+4
   \   00000020   0x.... 0x....      BL       Osal_MemSet
    237            rq.ogf = 0x05;
   \   00000024   0x2005             MOVS     R0,#+5
   \   00000026   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    238            rq.ocf = 0x005;
   \   0000002A   0x2005             MOVS     R0,#+5
   \   0000002C   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    239            rq.cparam = cmd_buffer;
   \   00000030   0xA807             ADD      R0,SP,#+28
   \   00000032   0x9003             STR      R0,[SP, #+12]
    240            rq.clen = index_input;
   \   00000034   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000036   0x9704             STR      R7,[SP, #+16]
    241            rq.rparam = &resp;
   \   00000038   0x4668             MOV      R0,SP
   \   0000003A   0x9005             STR      R0,[SP, #+20]
    242            rq.rlen = sizeof(resp);
   \   0000003C   0x2004             MOVS     R0,#+4
   \   0000003E   0x9006             STR      R0,[SP, #+24]
    243            if (hci_send_req(&rq, FALSE) < 0)
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0xA801             ADD      R0,SP,#+4
   \   00000044   0x.... 0x....      BL       hci_send_req
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD501             BPL.N    ??hci_read_rssi_0
    244              return BLE_STATUS_TIMEOUT;
   \   0000004C   0x20FF             MOVS     R0,#+255
   \   0000004E   0xE00A             B.N      ??hci_read_rssi_1
    245            if (resp.Status) {
   \                     ??hci_read_rssi_0: (+1)
   \   00000050   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD002             BEQ.N    ??hci_read_rssi_2
    246              return resp.Status;
   \   00000058   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005C   0xE003             B.N      ??hci_read_rssi_1
    247            }
    248            *RSSI = btoh(resp.RSSI, 1);
   \                     ??hci_read_rssi_2: (+1)
   \   0000005E   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   00000062   0x7028             STRB     R0,[R5, #+0]
    249            return BLE_STATUS_SUCCESS;
   \   00000064   0x2000             MOVS     R0,#+0
   \                     ??hci_read_rssi_1: (+1)
   \   00000066   0xB049             ADD      SP,SP,#+292
   \   00000068   0xBDF0             POP      {R4-R7,PC}       ;; return
    250          }

   \                                 In section .text, align 2, keep-with-next
    251          tBleStatus hci_le_set_event_mask(uint8_t LE_Event_Mask[8])
    252          {
   \                     hci_le_set_event_mask: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB0C8             SUB      SP,SP,#+288
   \   00000004   0x0004             MOVS     R4,R0
    253            struct hci_request rq;
    254            uint8_t cmd_buffer[258];
    255            hci_le_set_event_mask_cp0 *cp0 = (hci_le_set_event_mask_cp0*)(cmd_buffer);
   \   00000006   0xAD07             ADD      R5,SP,#+28
    256            tBleStatus status = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    257            uint8_t index_input = 0;
   \   0000000E   0x2600             MOVS     R6,#+0
    258            Osal_MemCpy((void *) &cp0->LE_Event_Mask, (const void *) LE_Event_Mask, 8);
   \   00000010   0x2208             MOVS     R2,#+8
   \   00000012   0x0021             MOVS     R1,R4
   \   00000014   0x0028             MOVS     R0,R5
   \   00000016   0x.... 0x....      BL       Osal_MemCpy
    259            index_input += 8;
   \   0000001A   0x3608             ADDS     R6,R6,#+8
    260            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000001C   0x2218             MOVS     R2,#+24
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0xA801             ADD      R0,SP,#+4
   \   00000022   0x.... 0x....      BL       Osal_MemSet
    261            rq.ogf = 0x08;
   \   00000026   0x2008             MOVS     R0,#+8
   \   00000028   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    262            rq.ocf = 0x001;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    263            rq.cparam = cmd_buffer;
   \   00000032   0xA807             ADD      R0,SP,#+28
   \   00000034   0x9003             STR      R0,[SP, #+12]
    264            rq.clen = index_input;
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0x9604             STR      R6,[SP, #+16]
    265            rq.rparam = &status;
   \   0000003A   0x4668             MOV      R0,SP
   \   0000003C   0x9005             STR      R0,[SP, #+20]
    266            rq.rlen = 1;
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x9006             STR      R0,[SP, #+24]
    267            if (hci_send_req(&rq, FALSE) < 0)
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0xA801             ADD      R0,SP,#+4
   \   00000046   0x.... 0x....      BL       hci_send_req
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD501             BPL.N    ??hci_le_set_event_mask_0
    268              return BLE_STATUS_TIMEOUT;
   \   0000004E   0x20FF             MOVS     R0,#+255
   \   00000050   0xE007             B.N      ??hci_le_set_event_mask_1
    269            if (status) {
   \                     ??hci_le_set_event_mask_0: (+1)
   \   00000052   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD002             BEQ.N    ??hci_le_set_event_mask_2
    270              return status;
   \   0000005A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005E   0xE000             B.N      ??hci_le_set_event_mask_1
    271            }
    272            return BLE_STATUS_SUCCESS;
   \                     ??hci_le_set_event_mask_2: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \                     ??hci_le_set_event_mask_1: (+1)
   \   00000062   0xB048             ADD      SP,SP,#+288
   \   00000064   0xBD70             POP      {R4-R6,PC}       ;; return
    273          }

   \                                 In section .text, align 2, keep-with-next
    274          tBleStatus hci_le_read_buffer_size(uint16_t *HC_LE_ACL_Data_Packet_Length,
    275                                             uint8_t *HC_Total_Num_LE_ACL_Data_Packets)
    276          {
   \                     hci_le_read_buffer_size: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    277            struct hci_request rq;
    278            hci_le_read_buffer_size_rp0 resp;
    279            Osal_MemSet(&resp, 0, sizeof(resp));
   \   00000008   0x2204             MOVS     R2,#+4
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x4668             MOV      R0,SP
   \   0000000E   0x.... 0x....      BL       Osal_MemSet
    280            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000012   0x2218             MOVS     R2,#+24
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0xA801             ADD      R0,SP,#+4
   \   00000018   0x.... 0x....      BL       Osal_MemSet
    281            rq.ogf = 0x08;
   \   0000001C   0x2008             MOVS     R0,#+8
   \   0000001E   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    282            rq.ocf = 0x002;
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    283            rq.rparam = &resp;
   \   00000028   0x4668             MOV      R0,SP
   \   0000002A   0x9005             STR      R0,[SP, #+20]
    284            rq.rlen = sizeof(resp);
   \   0000002C   0x2004             MOVS     R0,#+4
   \   0000002E   0x9006             STR      R0,[SP, #+24]
    285            if (hci_send_req(&rq, FALSE) < 0)
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0xA801             ADD      R0,SP,#+4
   \   00000034   0x.... 0x....      BL       hci_send_req
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD501             BPL.N    ??hci_le_read_buffer_size_0
    286              return BLE_STATUS_TIMEOUT;
   \   0000003C   0x20FF             MOVS     R0,#+255
   \   0000003E   0xE00D             B.N      ??hci_le_read_buffer_size_1
    287            if (resp.Status) {
   \                     ??hci_le_read_buffer_size_0: (+1)
   \   00000040   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD002             BEQ.N    ??hci_le_read_buffer_size_2
    288              return resp.Status;
   \   00000048   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004C   0xE006             B.N      ??hci_le_read_buffer_size_1
    289            }
    290            *HC_LE_ACL_Data_Packet_Length = btoh(resp.HC_LE_ACL_Data_Packet_Length, 2);
   \                     ??hci_le_read_buffer_size_2: (+1)
   \   0000004E   0xF8BD 0x0001      LDRH     R0,[SP, #+1]
   \   00000052   0x8020             STRH     R0,[R4, #+0]
    291            *HC_Total_Num_LE_ACL_Data_Packets = btoh(resp.HC_Total_Num_LE_ACL_Data_Packets, 1);
   \   00000054   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   00000058   0x7028             STRB     R0,[R5, #+0]
    292            return BLE_STATUS_SUCCESS;
   \   0000005A   0x2000             MOVS     R0,#+0
   \                     ??hci_le_read_buffer_size_1: (+1)
   \   0000005C   0xB007             ADD      SP,SP,#+28
   \   0000005E   0xBD30             POP      {R4,R5,PC}       ;; return
    293          }

   \                                 In section .text, align 2, keep-with-next
    294          tBleStatus hci_le_read_local_supported_features(uint8_t LE_Features[8])
    295          {
   \                     hci_le_read_local_supported_features: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
   \   00000004   0x0004             MOVS     R4,R0
    296            struct hci_request rq;
    297            hci_le_read_local_supported_features_rp0 resp;
    298            Osal_MemSet(&resp, 0, sizeof(resp));
   \   00000006   0x2209             MOVS     R2,#+9
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       Osal_MemSet
    299            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000010   0x2218             MOVS     R2,#+24
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0xA803             ADD      R0,SP,#+12
   \   00000016   0x.... 0x....      BL       Osal_MemSet
    300            rq.ogf = 0x08;
   \   0000001A   0x2008             MOVS     R0,#+8
   \   0000001C   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    301            rq.ocf = 0x003;
   \   00000020   0x2003             MOVS     R0,#+3
   \   00000022   0xF8AD 0x000E      STRH     R0,[SP, #+14]
    302            rq.rparam = &resp;
   \   00000026   0x4668             MOV      R0,SP
   \   00000028   0x9007             STR      R0,[SP, #+28]
    303            rq.rlen = sizeof(resp);
   \   0000002A   0x2009             MOVS     R0,#+9
   \   0000002C   0x9008             STR      R0,[SP, #+32]
    304            if (hci_send_req(&rq, FALSE) < 0)
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0xA803             ADD      R0,SP,#+12
   \   00000032   0x.... 0x....      BL       hci_send_req
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD501             BPL.N    ??hci_le_read_local_supported_features_0
    305              return BLE_STATUS_TIMEOUT;
   \   0000003A   0x20FF             MOVS     R0,#+255
   \   0000003C   0xE00D             B.N      ??hci_le_read_local_supported_features_1
    306            if (resp.Status) {
   \                     ??hci_le_read_local_supported_features_0: (+1)
   \   0000003E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD002             BEQ.N    ??hci_le_read_local_supported_features_2
    307              return resp.Status;
   \   00000046   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004A   0xE006             B.N      ??hci_le_read_local_supported_features_1
    308            }
    309            Osal_MemCpy((void *) LE_Features, (const void *) resp.LE_Features, 8);
   \                     ??hci_le_read_local_supported_features_2: (+1)
   \   0000004C   0x2208             MOVS     R2,#+8
   \   0000004E   0xF10D 0x0101      ADD      R1,SP,#+1
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       Osal_MemCpy
    310            return BLE_STATUS_SUCCESS;
   \   00000058   0x2000             MOVS     R0,#+0
   \                     ??hci_le_read_local_supported_features_1: (+1)
   \   0000005A   0xB00A             ADD      SP,SP,#+40
   \   0000005C   0xBD10             POP      {R4,PC}          ;; return
    311          }

   \                                 In section .text, align 2, keep-with-next
    312          tBleStatus hci_le_set_random_address(uint8_t Random_Address[6])
    313          {
   \                     hci_le_set_random_address: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB0C8             SUB      SP,SP,#+288
   \   00000004   0x0004             MOVS     R4,R0
    314            struct hci_request rq;
    315            uint8_t cmd_buffer[258];
    316            hci_le_set_random_address_cp0 *cp0 = (hci_le_set_random_address_cp0*)(cmd_buffer);
   \   00000006   0xAD07             ADD      R5,SP,#+28
    317            tBleStatus status = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    318            uint8_t index_input = 0;
   \   0000000E   0x2600             MOVS     R6,#+0
    319            Osal_MemCpy((void *) &cp0->Random_Address, (const void *) Random_Address, 6);
   \   00000010   0x2206             MOVS     R2,#+6
   \   00000012   0x0021             MOVS     R1,R4
   \   00000014   0x0028             MOVS     R0,R5
   \   00000016   0x.... 0x....      BL       Osal_MemCpy
    320            index_input += 6;
   \   0000001A   0x1DB6             ADDS     R6,R6,#+6
    321            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000001C   0x2218             MOVS     R2,#+24
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0xA801             ADD      R0,SP,#+4
   \   00000022   0x.... 0x....      BL       Osal_MemSet
    322            rq.ogf = 0x08;
   \   00000026   0x2008             MOVS     R0,#+8
   \   00000028   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    323            rq.ocf = 0x005;
   \   0000002C   0x2005             MOVS     R0,#+5
   \   0000002E   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    324            rq.cparam = cmd_buffer;
   \   00000032   0xA807             ADD      R0,SP,#+28
   \   00000034   0x9003             STR      R0,[SP, #+12]
    325            rq.clen = index_input;
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0x9604             STR      R6,[SP, #+16]
    326            rq.rparam = &status;
   \   0000003A   0x4668             MOV      R0,SP
   \   0000003C   0x9005             STR      R0,[SP, #+20]
    327            rq.rlen = 1;
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x9006             STR      R0,[SP, #+24]
    328            if (hci_send_req(&rq, FALSE) < 0)
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0xA801             ADD      R0,SP,#+4
   \   00000046   0x.... 0x....      BL       hci_send_req
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD501             BPL.N    ??hci_le_set_random_address_0
    329              return BLE_STATUS_TIMEOUT;
   \   0000004E   0x20FF             MOVS     R0,#+255
   \   00000050   0xE007             B.N      ??hci_le_set_random_address_1
    330            if (status) {
   \                     ??hci_le_set_random_address_0: (+1)
   \   00000052   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD002             BEQ.N    ??hci_le_set_random_address_2
    331              return status;
   \   0000005A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005E   0xE000             B.N      ??hci_le_set_random_address_1
    332            }
    333            return BLE_STATUS_SUCCESS;
   \                     ??hci_le_set_random_address_2: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \                     ??hci_le_set_random_address_1: (+1)
   \   00000062   0xB048             ADD      SP,SP,#+288
   \   00000064   0xBD70             POP      {R4-R6,PC}       ;; return
    334          }

   \                                 In section .text, align 2, keep-with-next
    335          tBleStatus hci_le_set_advertising_parameters(uint16_t Advertising_Interval_Min,
    336                                                       uint16_t Advertising_Interval_Max,
    337                                                       uint8_t Advertising_Type,
    338                                                       uint8_t Own_Address_Type,
    339                                                       uint8_t Peer_Address_Type,
    340                                                       uint8_t Peer_Address[6],
    341                                                       uint8_t Advertising_Channel_Map,
    342                                                       uint8_t Advertising_Filter_Policy)
    343          {
   \                     hci_le_set_advertising_parameters: (+1)
   \   00000000   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \   00000004   0xB0C9             SUB      SP,SP,#+292
   \   00000006   0x0017             MOVS     R7,R2
   \   00000008   0x4698             MOV      R8,R3
   \   0000000A   0x9C54             LDR      R4,[SP, #+336]
   \   0000000C   0xF8DD 0x9154      LDR      R9,[SP, #+340]
   \   00000010   0x9D56             LDR      R5,[SP, #+344]
   \   00000012   0x9E57             LDR      R6,[SP, #+348]
    344            struct hci_request rq;
    345            uint8_t cmd_buffer[258];
    346            hci_le_set_advertising_parameters_cp0 *cp0 = (hci_le_set_advertising_parameters_cp0*)(cmd_buffer);
   \   00000014   0xF10D 0x0A1C      ADD      R10,SP,#+28
    347            tBleStatus status = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    348            uint8_t index_input = 0;
   \   0000001E   0xF05F 0x0B00      MOVS     R11,#+0
    349            cp0->Advertising_Interval_Min = htob(Advertising_Interval_Min, 2);
   \   00000022   0xF8BD 0x0124      LDRH     R0,[SP, #+292]
   \   00000026   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    350            index_input += 2;
   \   0000002A   0xF11B 0x0B02      ADDS     R11,R11,#+2
    351            cp0->Advertising_Interval_Max = htob(Advertising_Interval_Max, 2);
   \   0000002E   0xF8BD 0x0128      LDRH     R0,[SP, #+296]
   \   00000032   0xF8AA 0x0002      STRH     R0,[R10, #+2]
    352            index_input += 2;
   \   00000036   0xF11B 0x0B02      ADDS     R11,R11,#+2
    353            cp0->Advertising_Type = htob(Advertising_Type, 1);
   \   0000003A   0xF88A 0x7004      STRB     R7,[R10, #+4]
    354            index_input += 1;
   \   0000003E   0xF11B 0x0B01      ADDS     R11,R11,#+1
    355            cp0->Own_Address_Type = htob(Own_Address_Type, 1);
   \   00000042   0xF88A 0x8005      STRB     R8,[R10, #+5]
    356            index_input += 1;
   \   00000046   0xF11B 0x0B01      ADDS     R11,R11,#+1
    357            cp0->Peer_Address_Type = htob(Peer_Address_Type, 1);
   \   0000004A   0xF88A 0x4006      STRB     R4,[R10, #+6]
    358            index_input += 1;
   \   0000004E   0xF11B 0x0B01      ADDS     R11,R11,#+1
    359            Osal_MemCpy((void *) &cp0->Peer_Address, (const void *) Peer_Address, 6);
   \   00000052   0x2206             MOVS     R2,#+6
   \   00000054   0x4649             MOV      R1,R9
   \   00000056   0xF11A 0x0007      ADDS     R0,R10,#+7
   \   0000005A   0x.... 0x....      BL       Osal_MemCpy
    360            index_input += 6;
   \   0000005E   0xF11B 0x0B06      ADDS     R11,R11,#+6
    361            cp0->Advertising_Channel_Map = htob(Advertising_Channel_Map, 1);
   \   00000062   0xF88A 0x500D      STRB     R5,[R10, #+13]
    362            index_input += 1;
   \   00000066   0xF11B 0x0B01      ADDS     R11,R11,#+1
    363            cp0->Advertising_Filter_Policy = htob(Advertising_Filter_Policy, 1);
   \   0000006A   0xF88A 0x600E      STRB     R6,[R10, #+14]
    364            index_input += 1;
   \   0000006E   0xF11B 0x0B01      ADDS     R11,R11,#+1
    365            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000072   0x2218             MOVS     R2,#+24
   \   00000074   0x2100             MOVS     R1,#+0
   \   00000076   0xA801             ADD      R0,SP,#+4
   \   00000078   0x.... 0x....      BL       Osal_MemSet
    366            rq.ogf = 0x08;
   \   0000007C   0x2008             MOVS     R0,#+8
   \   0000007E   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    367            rq.ocf = 0x006;
   \   00000082   0x2006             MOVS     R0,#+6
   \   00000084   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    368            rq.cparam = cmd_buffer;
   \   00000088   0xA807             ADD      R0,SP,#+28
   \   0000008A   0x9003             STR      R0,[SP, #+12]
    369            rq.clen = index_input;
   \   0000008C   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000090   0xF8CD 0xB010      STR      R11,[SP, #+16]
    370            rq.rparam = &status;
   \   00000094   0x4668             MOV      R0,SP
   \   00000096   0x9005             STR      R0,[SP, #+20]
    371            rq.rlen = 1;
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0x9006             STR      R0,[SP, #+24]
    372            if (hci_send_req(&rq, FALSE) < 0)
   \   0000009C   0x2100             MOVS     R1,#+0
   \   0000009E   0xA801             ADD      R0,SP,#+4
   \   000000A0   0x.... 0x....      BL       hci_send_req
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD501             BPL.N    ??hci_le_set_advertising_parameters_0
    373              return BLE_STATUS_TIMEOUT;
   \   000000A8   0x20FF             MOVS     R0,#+255
   \   000000AA   0xE007             B.N      ??hci_le_set_advertising_parameters_1
    374            if (status) {
   \                     ??hci_le_set_advertising_parameters_0: (+1)
   \   000000AC   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD002             BEQ.N    ??hci_le_set_advertising_parameters_2
    375              return status;
   \   000000B4   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000B8   0xE000             B.N      ??hci_le_set_advertising_parameters_1
    376            }
    377            return BLE_STATUS_SUCCESS;
   \                     ??hci_le_set_advertising_parameters_2: (+1)
   \   000000BA   0x2000             MOVS     R0,#+0
   \                     ??hci_le_set_advertising_parameters_1: (+1)
   \   000000BC   0xB04B             ADD      SP,SP,#+300
   \   000000BE   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    378          }

   \                                 In section .text, align 2, keep-with-next
    379          tBleStatus hci_le_read_advertising_channel_tx_power(uint8_t *Transmit_Power_Level)
    380          {
   \                     hci_le_read_advertising_channel_tx_power: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x0004             MOVS     R4,R0
    381            struct hci_request rq;
    382            hci_le_read_advertising_channel_tx_power_rp0 resp;
    383            Osal_MemSet(&resp, 0, sizeof(resp));
   \   00000006   0x2202             MOVS     R2,#+2
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       Osal_MemSet
    384            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000010   0x2218             MOVS     R2,#+24
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0xA801             ADD      R0,SP,#+4
   \   00000016   0x.... 0x....      BL       Osal_MemSet
    385            rq.ogf = 0x08;
   \   0000001A   0x2008             MOVS     R0,#+8
   \   0000001C   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    386            rq.ocf = 0x007;
   \   00000020   0x2007             MOVS     R0,#+7
   \   00000022   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    387            rq.rparam = &resp;
   \   00000026   0x4668             MOV      R0,SP
   \   00000028   0x9005             STR      R0,[SP, #+20]
    388            rq.rlen = sizeof(resp);
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0x9006             STR      R0,[SP, #+24]
    389            if (hci_send_req(&rq, FALSE) < 0)
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0xA801             ADD      R0,SP,#+4
   \   00000032   0x.... 0x....      BL       hci_send_req
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD501             BPL.N    ??hci_le_read_advertising_channel_tx_power_0
    390              return BLE_STATUS_TIMEOUT;
   \   0000003A   0x20FF             MOVS     R0,#+255
   \   0000003C   0xE00A             B.N      ??hci_le_read_advertising_channel_tx_power_1
    391            if (resp.Status) {
   \                     ??hci_le_read_advertising_channel_tx_power_0: (+1)
   \   0000003E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD002             BEQ.N    ??hci_le_read_advertising_channel_tx_power_2
    392              return resp.Status;
   \   00000046   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004A   0xE003             B.N      ??hci_le_read_advertising_channel_tx_power_1
    393            }
    394            *Transmit_Power_Level = btoh(resp.Transmit_Power_Level, 1);
   \                     ??hci_le_read_advertising_channel_tx_power_2: (+1)
   \   0000004C   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000050   0x7020             STRB     R0,[R4, #+0]
    395            return BLE_STATUS_SUCCESS;
   \   00000052   0x2000             MOVS     R0,#+0
   \                     ??hci_le_read_advertising_channel_tx_power_1: (+1)
   \   00000054   0xB008             ADD      SP,SP,#+32
   \   00000056   0xBD10             POP      {R4,PC}          ;; return
    396          }

   \                                 In section .text, align 2, keep-with-next
    397          tBleStatus hci_le_set_advertising_data(uint8_t Advertising_Data_Length,
    398                                                 uint8_t Advertising_Data[31])
    399          {
   \                     hci_le_set_advertising_data: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB0C9             SUB      SP,SP,#+292
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    400            struct hci_request rq;
    401            uint8_t cmd_buffer[258];
    402            hci_le_set_advertising_data_cp0 *cp0 = (hci_le_set_advertising_data_cp0*)(cmd_buffer);
   \   00000008   0xAE07             ADD      R6,SP,#+28
    403            tBleStatus status = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    404            uint8_t index_input = 0;
   \   00000010   0x2700             MOVS     R7,#+0
    405            cp0->Advertising_Data_Length = htob(Advertising_Data_Length, 1);
   \   00000012   0x7034             STRB     R4,[R6, #+0]
    406            index_input += 1;
   \   00000014   0x1C7F             ADDS     R7,R7,#+1
    407            Osal_MemCpy((void *) &cp0->Advertising_Data, (const void *) Advertising_Data, 31);
   \   00000016   0x221F             MOVS     R2,#+31
   \   00000018   0x0029             MOVS     R1,R5
   \   0000001A   0x1C70             ADDS     R0,R6,#+1
   \   0000001C   0x.... 0x....      BL       Osal_MemCpy
    408            index_input += 31;
   \   00000020   0x371F             ADDS     R7,R7,#+31
    409            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000022   0x2218             MOVS     R2,#+24
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0xA801             ADD      R0,SP,#+4
   \   00000028   0x.... 0x....      BL       Osal_MemSet
    410            rq.ogf = 0x08;
   \   0000002C   0x2008             MOVS     R0,#+8
   \   0000002E   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    411            rq.ocf = 0x008;
   \   00000032   0x2008             MOVS     R0,#+8
   \   00000034   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    412            rq.cparam = cmd_buffer;
   \   00000038   0xA807             ADD      R0,SP,#+28
   \   0000003A   0x9003             STR      R0,[SP, #+12]
    413            rq.clen = index_input;
   \   0000003C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003E   0x9704             STR      R7,[SP, #+16]
    414            rq.rparam = &status;
   \   00000040   0x4668             MOV      R0,SP
   \   00000042   0x9005             STR      R0,[SP, #+20]
    415            rq.rlen = 1;
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x9006             STR      R0,[SP, #+24]
    416            if (hci_send_req(&rq, FALSE) < 0)
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0xA801             ADD      R0,SP,#+4
   \   0000004C   0x.... 0x....      BL       hci_send_req
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD501             BPL.N    ??hci_le_set_advertising_data_0
    417              return BLE_STATUS_TIMEOUT;
   \   00000054   0x20FF             MOVS     R0,#+255
   \   00000056   0xE007             B.N      ??hci_le_set_advertising_data_1
    418            if (status) {
   \                     ??hci_le_set_advertising_data_0: (+1)
   \   00000058   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD002             BEQ.N    ??hci_le_set_advertising_data_2
    419              return status;
   \   00000060   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000064   0xE000             B.N      ??hci_le_set_advertising_data_1
    420            }
    421            return BLE_STATUS_SUCCESS;
   \                     ??hci_le_set_advertising_data_2: (+1)
   \   00000066   0x2000             MOVS     R0,#+0
   \                     ??hci_le_set_advertising_data_1: (+1)
   \   00000068   0xB049             ADD      SP,SP,#+292
   \   0000006A   0xBDF0             POP      {R4-R7,PC}       ;; return
    422          }

   \                                 In section .text, align 2, keep-with-next
    423          tBleStatus hci_le_set_scan_response_data(uint8_t Scan_Response_Data_Length,
    424                                                   uint8_t Scan_Response_Data[31])
    425          {
   \                     hci_le_set_scan_response_data: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB0C9             SUB      SP,SP,#+292
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    426            struct hci_request rq;
    427            uint8_t cmd_buffer[258];
    428            hci_le_set_scan_response_data_cp0 *cp0 = (hci_le_set_scan_response_data_cp0*)(cmd_buffer);
   \   00000008   0xAE07             ADD      R6,SP,#+28
    429            tBleStatus status = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    430            uint8_t index_input = 0;
   \   00000010   0x2700             MOVS     R7,#+0
    431            cp0->Scan_Response_Data_Length = htob(Scan_Response_Data_Length, 1);
   \   00000012   0x7034             STRB     R4,[R6, #+0]
    432            index_input += 1;
   \   00000014   0x1C7F             ADDS     R7,R7,#+1
    433            Osal_MemCpy((void *) &cp0->Scan_Response_Data, (const void *) Scan_Response_Data, 31);
   \   00000016   0x221F             MOVS     R2,#+31
   \   00000018   0x0029             MOVS     R1,R5
   \   0000001A   0x1C70             ADDS     R0,R6,#+1
   \   0000001C   0x.... 0x....      BL       Osal_MemCpy
    434            index_input += 31;
   \   00000020   0x371F             ADDS     R7,R7,#+31
    435            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000022   0x2218             MOVS     R2,#+24
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0xA801             ADD      R0,SP,#+4
   \   00000028   0x.... 0x....      BL       Osal_MemSet
    436            rq.ogf = 0x08;
   \   0000002C   0x2008             MOVS     R0,#+8
   \   0000002E   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    437            rq.ocf = 0x009;
   \   00000032   0x2009             MOVS     R0,#+9
   \   00000034   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    438            rq.cparam = cmd_buffer;
   \   00000038   0xA807             ADD      R0,SP,#+28
   \   0000003A   0x9003             STR      R0,[SP, #+12]
    439            rq.clen = index_input;
   \   0000003C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003E   0x9704             STR      R7,[SP, #+16]
    440            rq.rparam = &status;
   \   00000040   0x4668             MOV      R0,SP
   \   00000042   0x9005             STR      R0,[SP, #+20]
    441            rq.rlen = 1;
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x9006             STR      R0,[SP, #+24]
    442            if (hci_send_req(&rq, FALSE) < 0)
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0xA801             ADD      R0,SP,#+4
   \   0000004C   0x.... 0x....      BL       hci_send_req
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD501             BPL.N    ??hci_le_set_scan_response_data_0
    443              return BLE_STATUS_TIMEOUT;
   \   00000054   0x20FF             MOVS     R0,#+255
   \   00000056   0xE007             B.N      ??hci_le_set_scan_response_data_1
    444            if (status) {
   \                     ??hci_le_set_scan_response_data_0: (+1)
   \   00000058   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD002             BEQ.N    ??hci_le_set_scan_response_data_2
    445              return status;
   \   00000060   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000064   0xE000             B.N      ??hci_le_set_scan_response_data_1
    446            }
    447            return BLE_STATUS_SUCCESS;
   \                     ??hci_le_set_scan_response_data_2: (+1)
   \   00000066   0x2000             MOVS     R0,#+0
   \                     ??hci_le_set_scan_response_data_1: (+1)
   \   00000068   0xB049             ADD      SP,SP,#+292
   \   0000006A   0xBDF0             POP      {R4-R7,PC}       ;; return
    448          }

   \                                 In section .text, align 2, keep-with-next
    449          tBleStatus hci_le_set_advertise_enable(uint8_t Advertising_Enable)
    450          {
   \                     hci_le_set_advertise_enable: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB0C8             SUB      SP,SP,#+288
   \   00000004   0x0004             MOVS     R4,R0
    451            struct hci_request rq;
    452            uint8_t cmd_buffer[258];
    453            hci_le_set_advertise_enable_cp0 *cp0 = (hci_le_set_advertise_enable_cp0*)(cmd_buffer);
   \   00000006   0xAD07             ADD      R5,SP,#+28
    454            tBleStatus status = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    455            uint8_t index_input = 0;
   \   0000000E   0x2600             MOVS     R6,#+0
    456            cp0->Advertising_Enable = htob(Advertising_Enable, 1);
   \   00000010   0x702C             STRB     R4,[R5, #+0]
    457            index_input += 1;
   \   00000012   0x1C76             ADDS     R6,R6,#+1
    458            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000014   0x2218             MOVS     R2,#+24
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0xA801             ADD      R0,SP,#+4
   \   0000001A   0x.... 0x....      BL       Osal_MemSet
    459            rq.ogf = 0x08;
   \   0000001E   0x2008             MOVS     R0,#+8
   \   00000020   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    460            rq.ocf = 0x00a;
   \   00000024   0x200A             MOVS     R0,#+10
   \   00000026   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    461            rq.cparam = cmd_buffer;
   \   0000002A   0xA807             ADD      R0,SP,#+28
   \   0000002C   0x9003             STR      R0,[SP, #+12]
    462            rq.clen = index_input;
   \   0000002E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000030   0x9604             STR      R6,[SP, #+16]
    463            rq.rparam = &status;
   \   00000032   0x4668             MOV      R0,SP
   \   00000034   0x9005             STR      R0,[SP, #+20]
    464            rq.rlen = 1;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x9006             STR      R0,[SP, #+24]
    465            if (hci_send_req(&rq, FALSE) < 0)
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0xA801             ADD      R0,SP,#+4
   \   0000003E   0x.... 0x....      BL       hci_send_req
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD501             BPL.N    ??hci_le_set_advertise_enable_0
    466              return BLE_STATUS_TIMEOUT;
   \   00000046   0x20FF             MOVS     R0,#+255
   \   00000048   0xE007             B.N      ??hci_le_set_advertise_enable_1
    467            if (status) {
   \                     ??hci_le_set_advertise_enable_0: (+1)
   \   0000004A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD002             BEQ.N    ??hci_le_set_advertise_enable_2
    468              return status;
   \   00000052   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000056   0xE000             B.N      ??hci_le_set_advertise_enable_1
    469            }
    470            return BLE_STATUS_SUCCESS;
   \                     ??hci_le_set_advertise_enable_2: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \                     ??hci_le_set_advertise_enable_1: (+1)
   \   0000005A   0xB048             ADD      SP,SP,#+288
   \   0000005C   0xBD70             POP      {R4-R6,PC}       ;; return
    471          }

   \                                 In section .text, align 2, keep-with-next
    472          tBleStatus hci_le_set_scan_parameters(uint8_t LE_Scan_Type,
    473                                                uint16_t LE_Scan_Interval,
    474                                                uint16_t LE_Scan_Window,
    475                                                uint8_t Own_Address_Type,
    476                                                uint8_t Scanning_Filter_Policy)
    477          {
   \                     hci_le_set_scan_parameters: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB0C8             SUB      SP,SP,#+288
   \   00000006   0x0005             MOVS     R5,R0
   \   00000008   0x000E             MOVS     R6,R1
   \   0000000A   0x0017             MOVS     R7,R2
   \   0000000C   0x4698             MOV      R8,R3
   \   0000000E   0x9C50             LDR      R4,[SP, #+320]
    478            struct hci_request rq;
    479            uint8_t cmd_buffer[258];
    480            hci_le_set_scan_parameters_cp0 *cp0 = (hci_le_set_scan_parameters_cp0*)(cmd_buffer);
   \   00000010   0xF10D 0x091C      ADD      R9,SP,#+28
    481            tBleStatus status = 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF88D 0x0000      STRB     R0,[SP, #+0]
    482            uint8_t index_input = 0;
   \   0000001A   0xF05F 0x0A00      MOVS     R10,#+0
    483            cp0->LE_Scan_Type = htob(LE_Scan_Type, 1);
   \   0000001E   0xF889 0x5000      STRB     R5,[R9, #+0]
    484            index_input += 1;
   \   00000022   0xF11A 0x0A01      ADDS     R10,R10,#+1
    485            cp0->LE_Scan_Interval = htob(LE_Scan_Interval, 2);
   \   00000026   0xF8A9 0x6001      STRH     R6,[R9, #+1]
    486            index_input += 2;
   \   0000002A   0xF11A 0x0A02      ADDS     R10,R10,#+2
    487            cp0->LE_Scan_Window = htob(LE_Scan_Window, 2);
   \   0000002E   0xF8A9 0x7003      STRH     R7,[R9, #+3]
    488            index_input += 2;
   \   00000032   0xF11A 0x0A02      ADDS     R10,R10,#+2
    489            cp0->Own_Address_Type = htob(Own_Address_Type, 1);
   \   00000036   0xF889 0x8005      STRB     R8,[R9, #+5]
    490            index_input += 1;
   \   0000003A   0xF11A 0x0A01      ADDS     R10,R10,#+1
    491            cp0->Scanning_Filter_Policy = htob(Scanning_Filter_Policy, 1);
   \   0000003E   0xF889 0x4006      STRB     R4,[R9, #+6]
    492            index_input += 1;
   \   00000042   0xF11A 0x0A01      ADDS     R10,R10,#+1
    493            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000046   0x2218             MOVS     R2,#+24
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0xA801             ADD      R0,SP,#+4
   \   0000004C   0x.... 0x....      BL       Osal_MemSet
    494            rq.ogf = 0x08;
   \   00000050   0x2008             MOVS     R0,#+8
   \   00000052   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    495            rq.ocf = 0x00b;
   \   00000056   0x200B             MOVS     R0,#+11
   \   00000058   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    496            rq.cparam = cmd_buffer;
   \   0000005C   0xA807             ADD      R0,SP,#+28
   \   0000005E   0x9003             STR      R0,[SP, #+12]
    497            rq.clen = index_input;
   \   00000060   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000064   0xF8CD 0xA010      STR      R10,[SP, #+16]
    498            rq.rparam = &status;
   \   00000068   0x4668             MOV      R0,SP
   \   0000006A   0x9005             STR      R0,[SP, #+20]
    499            rq.rlen = 1;
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0x9006             STR      R0,[SP, #+24]
    500            if (hci_send_req(&rq, FALSE) < 0)
   \   00000070   0x2100             MOVS     R1,#+0
   \   00000072   0xA801             ADD      R0,SP,#+4
   \   00000074   0x.... 0x....      BL       hci_send_req
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD501             BPL.N    ??hci_le_set_scan_parameters_0
    501              return BLE_STATUS_TIMEOUT;
   \   0000007C   0x20FF             MOVS     R0,#+255
   \   0000007E   0xE007             B.N      ??hci_le_set_scan_parameters_1
    502            if (status) {
   \                     ??hci_le_set_scan_parameters_0: (+1)
   \   00000080   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD002             BEQ.N    ??hci_le_set_scan_parameters_2
    503              return status;
   \   00000088   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000008C   0xE000             B.N      ??hci_le_set_scan_parameters_1
    504            }
    505            return BLE_STATUS_SUCCESS;
   \                     ??hci_le_set_scan_parameters_2: (+1)
   \   0000008E   0x2000             MOVS     R0,#+0
   \                     ??hci_le_set_scan_parameters_1: (+1)
   \   00000090   0xB048             ADD      SP,SP,#+288
   \   00000092   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    506          }

   \                                 In section .text, align 2, keep-with-next
    507          tBleStatus hci_le_set_scan_enable(uint8_t LE_Scan_Enable,
    508                                            uint8_t Filter_Duplicates)
    509          {
   \                     hci_le_set_scan_enable: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB0C9             SUB      SP,SP,#+292
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    510            struct hci_request rq;
    511            uint8_t cmd_buffer[258];
    512            hci_le_set_scan_enable_cp0 *cp0 = (hci_le_set_scan_enable_cp0*)(cmd_buffer);
   \   00000008   0xAE07             ADD      R6,SP,#+28
    513            tBleStatus status = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    514            uint8_t index_input = 0;
   \   00000010   0x2700             MOVS     R7,#+0
    515            cp0->LE_Scan_Enable = htob(LE_Scan_Enable, 1);
   \   00000012   0x7034             STRB     R4,[R6, #+0]
    516            index_input += 1;
   \   00000014   0x1C7F             ADDS     R7,R7,#+1
    517            cp0->Filter_Duplicates = htob(Filter_Duplicates, 1);
   \   00000016   0x7075             STRB     R5,[R6, #+1]
    518            index_input += 1;
   \   00000018   0x1C7F             ADDS     R7,R7,#+1
    519            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000001A   0x2218             MOVS     R2,#+24
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0xA801             ADD      R0,SP,#+4
   \   00000020   0x.... 0x....      BL       Osal_MemSet
    520            rq.ogf = 0x08;
   \   00000024   0x2008             MOVS     R0,#+8
   \   00000026   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    521            rq.ocf = 0x00c;
   \   0000002A   0x200C             MOVS     R0,#+12
   \   0000002C   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    522            rq.cparam = cmd_buffer;
   \   00000030   0xA807             ADD      R0,SP,#+28
   \   00000032   0x9003             STR      R0,[SP, #+12]
    523            rq.clen = index_input;
   \   00000034   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000036   0x9704             STR      R7,[SP, #+16]
    524            rq.rparam = &status;
   \   00000038   0x4668             MOV      R0,SP
   \   0000003A   0x9005             STR      R0,[SP, #+20]
    525            rq.rlen = 1;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x9006             STR      R0,[SP, #+24]
    526            if (hci_send_req(&rq, FALSE) < 0)
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0xA801             ADD      R0,SP,#+4
   \   00000044   0x.... 0x....      BL       hci_send_req
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD501             BPL.N    ??hci_le_set_scan_enable_0
    527              return BLE_STATUS_TIMEOUT;
   \   0000004C   0x20FF             MOVS     R0,#+255
   \   0000004E   0xE007             B.N      ??hci_le_set_scan_enable_1
    528            if (status) {
   \                     ??hci_le_set_scan_enable_0: (+1)
   \   00000050   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD002             BEQ.N    ??hci_le_set_scan_enable_2
    529              return status;
   \   00000058   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005C   0xE000             B.N      ??hci_le_set_scan_enable_1
    530            }
    531            return BLE_STATUS_SUCCESS;
   \                     ??hci_le_set_scan_enable_2: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \                     ??hci_le_set_scan_enable_1: (+1)
   \   00000060   0xB049             ADD      SP,SP,#+292
   \   00000062   0xBDF0             POP      {R4-R7,PC}       ;; return
    532          }

   \                                 In section .text, align 2, keep-with-next
    533          tBleStatus hci_le_create_connection(uint16_t LE_Scan_Interval,
    534                                              uint16_t LE_Scan_Window,
    535                                              uint8_t Initiator_Filter_Policy,
    536                                              uint8_t Peer_Address_Type,
    537                                              uint8_t Peer_Address[6],
    538                                              uint8_t Own_Address_Type,
    539                                              uint16_t Conn_Interval_Min,
    540                                              uint16_t Conn_Interval_Max,
    541                                              uint16_t Conn_Latency,
    542                                              uint16_t Supervision_Timeout,
    543                                              uint16_t Minimum_CE_Length,
    544                                              uint16_t Maximum_CE_Length)
    545          {
   \                     hci_le_create_connection: (+1)
   \   00000000   0xE92D 0x4FFF      PUSH     {R0-R11,LR}
   \   00000004   0xB0C9             SUB      SP,SP,#+292
   \   00000006   0x9C58             LDR      R4,[SP, #+352]
   \   00000008   0x9D59             LDR      R5,[SP, #+356]
   \   0000000A   0x9E5A             LDR      R6,[SP, #+360]
   \   0000000C   0x9F5B             LDR      R7,[SP, #+364]
   \   0000000E   0xF8DD 0x8170      LDR      R8,[SP, #+368]
   \   00000012   0xF8DD 0x9174      LDR      R9,[SP, #+372]
    546            struct hci_request rq;
    547            uint8_t cmd_buffer[258];
    548            hci_le_create_connection_cp0 *cp0 = (hci_le_create_connection_cp0*)(cmd_buffer);
   \   00000016   0xF10D 0x0A1C      ADD      R10,SP,#+28
    549            tBleStatus status = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    550            uint8_t index_input = 0;
   \   00000020   0xF05F 0x0B00      MOVS     R11,#+0
    551            cp0->LE_Scan_Interval = htob(LE_Scan_Interval, 2);
   \   00000024   0xF8BD 0x0124      LDRH     R0,[SP, #+292]
   \   00000028   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    552            index_input += 2;
   \   0000002C   0xF11B 0x0B02      ADDS     R11,R11,#+2
    553            cp0->LE_Scan_Window = htob(LE_Scan_Window, 2);
   \   00000030   0xF8BD 0x0128      LDRH     R0,[SP, #+296]
   \   00000034   0xF8AA 0x0002      STRH     R0,[R10, #+2]
    554            index_input += 2;
   \   00000038   0xF11B 0x0B02      ADDS     R11,R11,#+2
    555            cp0->Initiator_Filter_Policy = htob(Initiator_Filter_Policy, 1);
   \   0000003C   0xF89D 0x012C      LDRB     R0,[SP, #+300]
   \   00000040   0xF88A 0x0004      STRB     R0,[R10, #+4]
    556            index_input += 1;
   \   00000044   0xF11B 0x0B01      ADDS     R11,R11,#+1
    557            cp0->Peer_Address_Type = htob(Peer_Address_Type, 1);
   \   00000048   0xF89D 0x0130      LDRB     R0,[SP, #+304]
   \   0000004C   0xF88A 0x0005      STRB     R0,[R10, #+5]
    558            index_input += 1;
   \   00000050   0xF11B 0x0B01      ADDS     R11,R11,#+1
    559            Osal_MemCpy((void *) &cp0->Peer_Address, (const void *) Peer_Address, 6);
   \   00000054   0x2206             MOVS     R2,#+6
   \   00000056   0x9956             LDR      R1,[SP, #+344]
   \   00000058   0xF11A 0x0006      ADDS     R0,R10,#+6
   \   0000005C   0x.... 0x....      BL       Osal_MemCpy
    560            index_input += 6;
   \   00000060   0xF11B 0x0B06      ADDS     R11,R11,#+6
    561            cp0->Own_Address_Type = htob(Own_Address_Type, 1);
   \   00000064   0xF89D 0x015C      LDRB     R0,[SP, #+348]
   \   00000068   0xF88A 0x000C      STRB     R0,[R10, #+12]
    562            index_input += 1;
   \   0000006C   0xF11B 0x0B01      ADDS     R11,R11,#+1
    563            cp0->Conn_Interval_Min = htob(Conn_Interval_Min, 2);
   \   00000070   0xF8AA 0x400D      STRH     R4,[R10, #+13]
    564            index_input += 2;
   \   00000074   0xF11B 0x0B02      ADDS     R11,R11,#+2
    565            cp0->Conn_Interval_Max = htob(Conn_Interval_Max, 2);
   \   00000078   0xF8AA 0x500F      STRH     R5,[R10, #+15]
    566            index_input += 2;
   \   0000007C   0xF11B 0x0B02      ADDS     R11,R11,#+2
    567            cp0->Conn_Latency = htob(Conn_Latency, 2);
   \   00000080   0xF8AA 0x6011      STRH     R6,[R10, #+17]
    568            index_input += 2;
   \   00000084   0xF11B 0x0B02      ADDS     R11,R11,#+2
    569            cp0->Supervision_Timeout = htob(Supervision_Timeout, 2);
   \   00000088   0xF8AA 0x7013      STRH     R7,[R10, #+19]
    570            index_input += 2;
   \   0000008C   0xF11B 0x0B02      ADDS     R11,R11,#+2
    571            cp0->Minimum_CE_Length = htob(Minimum_CE_Length, 2);
   \   00000090   0xF8AA 0x8015      STRH     R8,[R10, #+21]
    572            index_input += 2;
   \   00000094   0xF11B 0x0B02      ADDS     R11,R11,#+2
    573            cp0->Maximum_CE_Length = htob(Maximum_CE_Length, 2);
   \   00000098   0xF8AA 0x9017      STRH     R9,[R10, #+23]
    574            index_input += 2;
   \   0000009C   0xF11B 0x0B02      ADDS     R11,R11,#+2
    575            Osal_MemSet(&rq, 0, sizeof(rq));
   \   000000A0   0x2218             MOVS     R2,#+24
   \   000000A2   0x2100             MOVS     R1,#+0
   \   000000A4   0xA801             ADD      R0,SP,#+4
   \   000000A6   0x.... 0x....      BL       Osal_MemSet
    576            rq.ogf = 0x08;
   \   000000AA   0x2008             MOVS     R0,#+8
   \   000000AC   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    577            rq.ocf = 0x00d;
   \   000000B0   0x200D             MOVS     R0,#+13
   \   000000B2   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    578            rq.event = 0x0F;
   \   000000B6   0x200F             MOVS     R0,#+15
   \   000000B8   0x9002             STR      R0,[SP, #+8]
    579            rq.cparam = cmd_buffer;
   \   000000BA   0xA807             ADD      R0,SP,#+28
   \   000000BC   0x9003             STR      R0,[SP, #+12]
    580            rq.clen = index_input;
   \   000000BE   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000C2   0xF8CD 0xB010      STR      R11,[SP, #+16]
    581            rq.rparam = &status;
   \   000000C6   0x4668             MOV      R0,SP
   \   000000C8   0x9005             STR      R0,[SP, #+20]
    582            rq.rlen = 1;
   \   000000CA   0x2001             MOVS     R0,#+1
   \   000000CC   0x9006             STR      R0,[SP, #+24]
    583            if (hci_send_req(&rq, FALSE) < 0)
   \   000000CE   0x2100             MOVS     R1,#+0
   \   000000D0   0xA801             ADD      R0,SP,#+4
   \   000000D2   0x.... 0x....      BL       hci_send_req
   \   000000D6   0x2800             CMP      R0,#+0
   \   000000D8   0xD501             BPL.N    ??hci_le_create_connection_0
    584              return BLE_STATUS_TIMEOUT;
   \   000000DA   0x20FF             MOVS     R0,#+255
   \   000000DC   0xE007             B.N      ??hci_le_create_connection_1
    585            if (status) {
   \                     ??hci_le_create_connection_0: (+1)
   \   000000DE   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD002             BEQ.N    ??hci_le_create_connection_2
    586              return status;
   \   000000E6   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000EA   0xE000             B.N      ??hci_le_create_connection_1
    587            }
    588            return BLE_STATUS_SUCCESS;
   \                     ??hci_le_create_connection_2: (+1)
   \   000000EC   0x2000             MOVS     R0,#+0
   \                     ??hci_le_create_connection_1: (+1)
   \   000000EE   0xB04D             ADD      SP,SP,#+308
   \   000000F0   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    589          }

   \                                 In section .text, align 2, keep-with-next
    590          tBleStatus hci_le_create_connection_cancel(void)
    591          {
   \                     hci_le_create_connection_cancel: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    592            struct hci_request rq;
    593            tBleStatus status = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
    594            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000000A   0x2218             MOVS     R2,#+24
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0xA801             ADD      R0,SP,#+4
   \   00000010   0x.... 0x....      BL       Osal_MemSet
    595            rq.ogf = 0x08;
   \   00000014   0x2008             MOVS     R0,#+8
   \   00000016   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    596            rq.ocf = 0x00e;
   \   0000001A   0x200E             MOVS     R0,#+14
   \   0000001C   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    597            rq.rparam = &status;
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x9005             STR      R0,[SP, #+20]
    598            rq.rlen = 1;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x9006             STR      R0,[SP, #+24]
    599            if (hci_send_req(&rq, FALSE) < 0)
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0xA801             ADD      R0,SP,#+4
   \   0000002C   0x.... 0x....      BL       hci_send_req
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD501             BPL.N    ??hci_le_create_connection_cancel_0
    600              return BLE_STATUS_TIMEOUT;
   \   00000034   0x20FF             MOVS     R0,#+255
   \   00000036   0xE007             B.N      ??hci_le_create_connection_cancel_1
    601            if (status) {
   \                     ??hci_le_create_connection_cancel_0: (+1)
   \   00000038   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD002             BEQ.N    ??hci_le_create_connection_cancel_2
    602              return status;
   \   00000040   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000044   0xE000             B.N      ??hci_le_create_connection_cancel_1
    603            }
    604            return BLE_STATUS_SUCCESS;
   \                     ??hci_le_create_connection_cancel_2: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \                     ??hci_le_create_connection_cancel_1: (+1)
   \   00000048   0xB007             ADD      SP,SP,#+28
   \   0000004A   0xBD00             POP      {PC}             ;; return
    605          }

   \                                 In section .text, align 2, keep-with-next
    606          tBleStatus hci_le_read_white_list_size(uint8_t *White_List_Size)
    607          {
   \                     hci_le_read_white_list_size: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x0004             MOVS     R4,R0
    608            struct hci_request rq;
    609            hci_le_read_white_list_size_rp0 resp;
    610            Osal_MemSet(&resp, 0, sizeof(resp));
   \   00000006   0x2202             MOVS     R2,#+2
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       Osal_MemSet
    611            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000010   0x2218             MOVS     R2,#+24
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0xA801             ADD      R0,SP,#+4
   \   00000016   0x.... 0x....      BL       Osal_MemSet
    612            rq.ogf = 0x08;
   \   0000001A   0x2008             MOVS     R0,#+8
   \   0000001C   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    613            rq.ocf = 0x00f;
   \   00000020   0x200F             MOVS     R0,#+15
   \   00000022   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    614            rq.rparam = &resp;
   \   00000026   0x4668             MOV      R0,SP
   \   00000028   0x9005             STR      R0,[SP, #+20]
    615            rq.rlen = sizeof(resp);
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0x9006             STR      R0,[SP, #+24]
    616            if (hci_send_req(&rq, FALSE) < 0)
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0xA801             ADD      R0,SP,#+4
   \   00000032   0x.... 0x....      BL       hci_send_req
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD501             BPL.N    ??hci_le_read_white_list_size_0
    617              return BLE_STATUS_TIMEOUT;
   \   0000003A   0x20FF             MOVS     R0,#+255
   \   0000003C   0xE00A             B.N      ??hci_le_read_white_list_size_1
    618            if (resp.Status) {
   \                     ??hci_le_read_white_list_size_0: (+1)
   \   0000003E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD002             BEQ.N    ??hci_le_read_white_list_size_2
    619              return resp.Status;
   \   00000046   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004A   0xE003             B.N      ??hci_le_read_white_list_size_1
    620            }
    621            *White_List_Size = btoh(resp.White_List_Size, 1);
   \                     ??hci_le_read_white_list_size_2: (+1)
   \   0000004C   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000050   0x7020             STRB     R0,[R4, #+0]
    622            return BLE_STATUS_SUCCESS;
   \   00000052   0x2000             MOVS     R0,#+0
   \                     ??hci_le_read_white_list_size_1: (+1)
   \   00000054   0xB008             ADD      SP,SP,#+32
   \   00000056   0xBD10             POP      {R4,PC}          ;; return
    623          }

   \                                 In section .text, align 2, keep-with-next
    624          tBleStatus hci_le_clear_white_list(void)
    625          {
   \                     hci_le_clear_white_list: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    626            struct hci_request rq;
    627            tBleStatus status = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
    628            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000000A   0x2218             MOVS     R2,#+24
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0xA801             ADD      R0,SP,#+4
   \   00000010   0x.... 0x....      BL       Osal_MemSet
    629            rq.ogf = 0x08;
   \   00000014   0x2008             MOVS     R0,#+8
   \   00000016   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    630            rq.ocf = 0x010;
   \   0000001A   0x2010             MOVS     R0,#+16
   \   0000001C   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    631            rq.rparam = &status;
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x9005             STR      R0,[SP, #+20]
    632            rq.rlen = 1;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x9006             STR      R0,[SP, #+24]
    633            if (hci_send_req(&rq, FALSE) < 0)
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0xA801             ADD      R0,SP,#+4
   \   0000002C   0x.... 0x....      BL       hci_send_req
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD501             BPL.N    ??hci_le_clear_white_list_0
    634              return BLE_STATUS_TIMEOUT;
   \   00000034   0x20FF             MOVS     R0,#+255
   \   00000036   0xE007             B.N      ??hci_le_clear_white_list_1
    635            if (status) {
   \                     ??hci_le_clear_white_list_0: (+1)
   \   00000038   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD002             BEQ.N    ??hci_le_clear_white_list_2
    636              return status;
   \   00000040   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000044   0xE000             B.N      ??hci_le_clear_white_list_1
    637            }
    638            return BLE_STATUS_SUCCESS;
   \                     ??hci_le_clear_white_list_2: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \                     ??hci_le_clear_white_list_1: (+1)
   \   00000048   0xB007             ADD      SP,SP,#+28
   \   0000004A   0xBD00             POP      {PC}             ;; return
    639          }

   \                                 In section .text, align 2, keep-with-next
    640          tBleStatus hci_le_add_device_to_white_list(uint8_t Address_Type,
    641                                                     uint8_t Address[6])
    642          {
   \                     hci_le_add_device_to_white_list: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB0C9             SUB      SP,SP,#+292
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    643            struct hci_request rq;
    644            uint8_t cmd_buffer[258];
    645            hci_le_add_device_to_white_list_cp0 *cp0 = (hci_le_add_device_to_white_list_cp0*)(cmd_buffer);
   \   00000008   0xAE07             ADD      R6,SP,#+28
    646            tBleStatus status = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    647            uint8_t index_input = 0;
   \   00000010   0x2700             MOVS     R7,#+0
    648            cp0->Address_Type = htob(Address_Type, 1);
   \   00000012   0x7034             STRB     R4,[R6, #+0]
    649            index_input += 1;
   \   00000014   0x1C7F             ADDS     R7,R7,#+1
    650            Osal_MemCpy((void *) &cp0->Address, (const void *) Address, 6);
   \   00000016   0x2206             MOVS     R2,#+6
   \   00000018   0x0029             MOVS     R1,R5
   \   0000001A   0x1C70             ADDS     R0,R6,#+1
   \   0000001C   0x.... 0x....      BL       Osal_MemCpy
    651            index_input += 6;
   \   00000020   0x1DBF             ADDS     R7,R7,#+6
    652            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000022   0x2218             MOVS     R2,#+24
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0xA801             ADD      R0,SP,#+4
   \   00000028   0x.... 0x....      BL       Osal_MemSet
    653            rq.ogf = 0x08;
   \   0000002C   0x2008             MOVS     R0,#+8
   \   0000002E   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    654            rq.ocf = 0x011;
   \   00000032   0x2011             MOVS     R0,#+17
   \   00000034   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    655            rq.cparam = cmd_buffer;
   \   00000038   0xA807             ADD      R0,SP,#+28
   \   0000003A   0x9003             STR      R0,[SP, #+12]
    656            rq.clen = index_input;
   \   0000003C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003E   0x9704             STR      R7,[SP, #+16]
    657            rq.rparam = &status;
   \   00000040   0x4668             MOV      R0,SP
   \   00000042   0x9005             STR      R0,[SP, #+20]
    658            rq.rlen = 1;
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x9006             STR      R0,[SP, #+24]
    659            if (hci_send_req(&rq, FALSE) < 0)
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0xA801             ADD      R0,SP,#+4
   \   0000004C   0x.... 0x....      BL       hci_send_req
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD501             BPL.N    ??hci_le_add_device_to_white_list_0
    660              return BLE_STATUS_TIMEOUT;
   \   00000054   0x20FF             MOVS     R0,#+255
   \   00000056   0xE007             B.N      ??hci_le_add_device_to_white_list_1
    661            if (status) {
   \                     ??hci_le_add_device_to_white_list_0: (+1)
   \   00000058   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD002             BEQ.N    ??hci_le_add_device_to_white_list_2
    662              return status;
   \   00000060   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000064   0xE000             B.N      ??hci_le_add_device_to_white_list_1
    663            }
    664            return BLE_STATUS_SUCCESS;
   \                     ??hci_le_add_device_to_white_list_2: (+1)
   \   00000066   0x2000             MOVS     R0,#+0
   \                     ??hci_le_add_device_to_white_list_1: (+1)
   \   00000068   0xB049             ADD      SP,SP,#+292
   \   0000006A   0xBDF0             POP      {R4-R7,PC}       ;; return
    665          }

   \                                 In section .text, align 2, keep-with-next
    666          tBleStatus hci_le_remove_device_from_white_list(uint8_t Address_Type,
    667                                                          uint8_t Address[6])
    668          {
   \                     hci_le_remove_device_from_white_list: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB0C9             SUB      SP,SP,#+292
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    669            struct hci_request rq;
    670            uint8_t cmd_buffer[258];
    671            hci_le_remove_device_from_white_list_cp0 *cp0 = (hci_le_remove_device_from_white_list_cp0*)(cmd_buffer);
   \   00000008   0xAE07             ADD      R6,SP,#+28
    672            tBleStatus status = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    673            uint8_t index_input = 0;
   \   00000010   0x2700             MOVS     R7,#+0
    674            cp0->Address_Type = htob(Address_Type, 1);
   \   00000012   0x7034             STRB     R4,[R6, #+0]
    675            index_input += 1;
   \   00000014   0x1C7F             ADDS     R7,R7,#+1
    676            Osal_MemCpy((void *) &cp0->Address, (const void *) Address, 6);
   \   00000016   0x2206             MOVS     R2,#+6
   \   00000018   0x0029             MOVS     R1,R5
   \   0000001A   0x1C70             ADDS     R0,R6,#+1
   \   0000001C   0x.... 0x....      BL       Osal_MemCpy
    677            index_input += 6;
   \   00000020   0x1DBF             ADDS     R7,R7,#+6
    678            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000022   0x2218             MOVS     R2,#+24
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0xA801             ADD      R0,SP,#+4
   \   00000028   0x.... 0x....      BL       Osal_MemSet
    679            rq.ogf = 0x08;
   \   0000002C   0x2008             MOVS     R0,#+8
   \   0000002E   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    680            rq.ocf = 0x012;
   \   00000032   0x2012             MOVS     R0,#+18
   \   00000034   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    681            rq.cparam = cmd_buffer;
   \   00000038   0xA807             ADD      R0,SP,#+28
   \   0000003A   0x9003             STR      R0,[SP, #+12]
    682            rq.clen = index_input;
   \   0000003C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003E   0x9704             STR      R7,[SP, #+16]
    683            rq.rparam = &status;
   \   00000040   0x4668             MOV      R0,SP
   \   00000042   0x9005             STR      R0,[SP, #+20]
    684            rq.rlen = 1;
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x9006             STR      R0,[SP, #+24]
    685            if (hci_send_req(&rq, FALSE) < 0)
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0xA801             ADD      R0,SP,#+4
   \   0000004C   0x.... 0x....      BL       hci_send_req
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD501             BPL.N    ??hci_le_remove_device_from_white_list_0
    686              return BLE_STATUS_TIMEOUT;
   \   00000054   0x20FF             MOVS     R0,#+255
   \   00000056   0xE007             B.N      ??hci_le_remove_device_from_white_list_1
    687            if (status) {
   \                     ??hci_le_remove_device_from_white_list_0: (+1)
   \   00000058   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD002             BEQ.N    ??hci_le_remove_device_from_white_list_2
    688              return status;
   \   00000060   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000064   0xE000             B.N      ??hci_le_remove_device_from_white_list_1
    689            }
    690            return BLE_STATUS_SUCCESS;
   \                     ??hci_le_remove_device_from_white_list_2: (+1)
   \   00000066   0x2000             MOVS     R0,#+0
   \                     ??hci_le_remove_device_from_white_list_1: (+1)
   \   00000068   0xB049             ADD      SP,SP,#+292
   \   0000006A   0xBDF0             POP      {R4-R7,PC}       ;; return
    691          }

   \                                 In section .text, align 2, keep-with-next
    692          tBleStatus hci_le_connection_update(uint16_t Connection_Handle,
    693                                              uint16_t Conn_Interval_Min,
    694                                              uint16_t Conn_Interval_Max,
    695                                              uint16_t Conn_Latency,
    696                                              uint16_t Supervision_Timeout,
    697                                              uint16_t Minimum_CE_Length,
    698                                              uint16_t Maximum_CE_Length)
    699          {
   \                     hci_le_connection_update: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB0C8             SUB      SP,SP,#+288
   \   00000006   0x000F             MOVS     R7,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x4699             MOV      R9,R3
   \   0000000C   0x9C52             LDR      R4,[SP, #+328]
   \   0000000E   0x9D53             LDR      R5,[SP, #+332]
   \   00000010   0x9E54             LDR      R6,[SP, #+336]
    700            struct hci_request rq;
    701            uint8_t cmd_buffer[258];
    702            hci_le_connection_update_cp0 *cp0 = (hci_le_connection_update_cp0*)(cmd_buffer);
   \   00000012   0xF10D 0x0A1C      ADD      R10,SP,#+28
    703            tBleStatus status = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF88D 0x0000      STRB     R0,[SP, #+0]
    704            uint8_t index_input = 0;
   \   0000001C   0xF05F 0x0B00      MOVS     R11,#+0
    705            cp0->Connection_Handle = htob(Connection_Handle, 2);
   \   00000020   0xF8BD 0x0120      LDRH     R0,[SP, #+288]
   \   00000024   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    706            index_input += 2;
   \   00000028   0xF11B 0x0B02      ADDS     R11,R11,#+2
    707            cp0->Conn_Interval_Min = htob(Conn_Interval_Min, 2);
   \   0000002C   0xF8AA 0x7002      STRH     R7,[R10, #+2]
    708            index_input += 2;
   \   00000030   0xF11B 0x0B02      ADDS     R11,R11,#+2
    709            cp0->Conn_Interval_Max = htob(Conn_Interval_Max, 2);
   \   00000034   0xF8AA 0x8004      STRH     R8,[R10, #+4]
    710            index_input += 2;
   \   00000038   0xF11B 0x0B02      ADDS     R11,R11,#+2
    711            cp0->Conn_Latency = htob(Conn_Latency, 2);
   \   0000003C   0xF8AA 0x9006      STRH     R9,[R10, #+6]
    712            index_input += 2;
   \   00000040   0xF11B 0x0B02      ADDS     R11,R11,#+2
    713            cp0->Supervision_Timeout = htob(Supervision_Timeout, 2);
   \   00000044   0xF8AA 0x4008      STRH     R4,[R10, #+8]
    714            index_input += 2;
   \   00000048   0xF11B 0x0B02      ADDS     R11,R11,#+2
    715            cp0->Minimum_CE_Length = htob(Minimum_CE_Length, 2);
   \   0000004C   0xF8AA 0x500A      STRH     R5,[R10, #+10]
    716            index_input += 2;
   \   00000050   0xF11B 0x0B02      ADDS     R11,R11,#+2
    717            cp0->Maximum_CE_Length = htob(Maximum_CE_Length, 2);
   \   00000054   0xF8AA 0x600C      STRH     R6,[R10, #+12]
    718            index_input += 2;
   \   00000058   0xF11B 0x0B02      ADDS     R11,R11,#+2
    719            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000005C   0x2218             MOVS     R2,#+24
   \   0000005E   0x2100             MOVS     R1,#+0
   \   00000060   0xA801             ADD      R0,SP,#+4
   \   00000062   0x.... 0x....      BL       Osal_MemSet
    720            rq.ogf = 0x08;
   \   00000066   0x2008             MOVS     R0,#+8
   \   00000068   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    721            rq.ocf = 0x013;
   \   0000006C   0x2013             MOVS     R0,#+19
   \   0000006E   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    722            rq.event = 0x0F;
   \   00000072   0x200F             MOVS     R0,#+15
   \   00000074   0x9002             STR      R0,[SP, #+8]
    723            rq.cparam = cmd_buffer;
   \   00000076   0xA807             ADD      R0,SP,#+28
   \   00000078   0x9003             STR      R0,[SP, #+12]
    724            rq.clen = index_input;
   \   0000007A   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   0000007E   0xF8CD 0xB010      STR      R11,[SP, #+16]
    725            rq.rparam = &status;
   \   00000082   0x4668             MOV      R0,SP
   \   00000084   0x9005             STR      R0,[SP, #+20]
    726            rq.rlen = 1;
   \   00000086   0x2001             MOVS     R0,#+1
   \   00000088   0x9006             STR      R0,[SP, #+24]
    727            if (hci_send_req(&rq, FALSE) < 0)
   \   0000008A   0x2100             MOVS     R1,#+0
   \   0000008C   0xA801             ADD      R0,SP,#+4
   \   0000008E   0x.... 0x....      BL       hci_send_req
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD501             BPL.N    ??hci_le_connection_update_0
    728              return BLE_STATUS_TIMEOUT;
   \   00000096   0x20FF             MOVS     R0,#+255
   \   00000098   0xE007             B.N      ??hci_le_connection_update_1
    729            if (status) {
   \                     ??hci_le_connection_update_0: (+1)
   \   0000009A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD002             BEQ.N    ??hci_le_connection_update_2
    730              return status;
   \   000000A2   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000A6   0xE000             B.N      ??hci_le_connection_update_1
    731            }
    732            return BLE_STATUS_SUCCESS;
   \                     ??hci_le_connection_update_2: (+1)
   \   000000A8   0x2000             MOVS     R0,#+0
   \                     ??hci_le_connection_update_1: (+1)
   \   000000AA   0xB049             ADD      SP,SP,#+292
   \   000000AC   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    733          }

   \                                 In section .text, align 2, keep-with-next
    734          tBleStatus hci_le_set_host_channel_classification(uint8_t LE_Channel_Map[5])
    735          {
   \                     hci_le_set_host_channel_classification: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB0C8             SUB      SP,SP,#+288
   \   00000004   0x0004             MOVS     R4,R0
    736            struct hci_request rq;
    737            uint8_t cmd_buffer[258];
    738            hci_le_set_host_channel_classification_cp0 *cp0 = (hci_le_set_host_channel_classification_cp0*)(cmd_buffer);
   \   00000006   0xAD07             ADD      R5,SP,#+28
    739            tBleStatus status = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    740            uint8_t index_input = 0;
   \   0000000E   0x2600             MOVS     R6,#+0
    741            Osal_MemCpy((void *) &cp0->LE_Channel_Map, (const void *) LE_Channel_Map, 5);
   \   00000010   0x2205             MOVS     R2,#+5
   \   00000012   0x0021             MOVS     R1,R4
   \   00000014   0x0028             MOVS     R0,R5
   \   00000016   0x.... 0x....      BL       Osal_MemCpy
    742            index_input += 5;
   \   0000001A   0x1D76             ADDS     R6,R6,#+5
    743            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000001C   0x2218             MOVS     R2,#+24
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0xA801             ADD      R0,SP,#+4
   \   00000022   0x.... 0x....      BL       Osal_MemSet
    744            rq.ogf = 0x08;
   \   00000026   0x2008             MOVS     R0,#+8
   \   00000028   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    745            rq.ocf = 0x014;
   \   0000002C   0x2014             MOVS     R0,#+20
   \   0000002E   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    746            rq.cparam = cmd_buffer;
   \   00000032   0xA807             ADD      R0,SP,#+28
   \   00000034   0x9003             STR      R0,[SP, #+12]
    747            rq.clen = index_input;
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0x9604             STR      R6,[SP, #+16]
    748            rq.rparam = &status;
   \   0000003A   0x4668             MOV      R0,SP
   \   0000003C   0x9005             STR      R0,[SP, #+20]
    749            rq.rlen = 1;
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x9006             STR      R0,[SP, #+24]
    750            if (hci_send_req(&rq, FALSE) < 0)
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0xA801             ADD      R0,SP,#+4
   \   00000046   0x.... 0x....      BL       hci_send_req
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD501             BPL.N    ??hci_le_set_host_channel_classification_0
    751              return BLE_STATUS_TIMEOUT;
   \   0000004E   0x20FF             MOVS     R0,#+255
   \   00000050   0xE007             B.N      ??hci_le_set_host_channel_classification_1
    752            if (status) {
   \                     ??hci_le_set_host_channel_classification_0: (+1)
   \   00000052   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD002             BEQ.N    ??hci_le_set_host_channel_classification_2
    753              return status;
   \   0000005A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005E   0xE000             B.N      ??hci_le_set_host_channel_classification_1
    754            }
    755            return BLE_STATUS_SUCCESS;
   \                     ??hci_le_set_host_channel_classification_2: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \                     ??hci_le_set_host_channel_classification_1: (+1)
   \   00000062   0xB048             ADD      SP,SP,#+288
   \   00000064   0xBD70             POP      {R4-R6,PC}       ;; return
    756          }

   \                                 In section .text, align 2, keep-with-next
    757          tBleStatus hci_le_read_channel_map(uint16_t Connection_Handle,
    758                                             uint8_t LE_Channel_Map[5])
    759          {
   \                     hci_le_read_channel_map: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB0C9             SUB      SP,SP,#+292
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    760            struct hci_request rq;
    761            uint8_t cmd_buffer[258];
    762            hci_le_read_channel_map_cp0 *cp0 = (hci_le_read_channel_map_cp0*)(cmd_buffer);
   \   00000008   0xAE08             ADD      R6,SP,#+32
    763            hci_le_read_channel_map_rp0 resp;
    764            Osal_MemSet(&resp, 0, sizeof(resp));
   \   0000000A   0x2208             MOVS     R2,#+8
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x4668             MOV      R0,SP
   \   00000010   0x.... 0x....      BL       Osal_MemSet
    765            uint8_t index_input = 0;
   \   00000014   0x2700             MOVS     R7,#+0
    766            cp0->Connection_Handle = htob(Connection_Handle, 2);
   \   00000016   0x8034             STRH     R4,[R6, #+0]
    767            index_input += 2;
   \   00000018   0x1CBF             ADDS     R7,R7,#+2
    768            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000001A   0x2218             MOVS     R2,#+24
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0xA802             ADD      R0,SP,#+8
   \   00000020   0x.... 0x....      BL       Osal_MemSet
    769            rq.ogf = 0x08;
   \   00000024   0x2008             MOVS     R0,#+8
   \   00000026   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    770            rq.ocf = 0x015;
   \   0000002A   0x2015             MOVS     R0,#+21
   \   0000002C   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    771            rq.cparam = cmd_buffer;
   \   00000030   0xA808             ADD      R0,SP,#+32
   \   00000032   0x9004             STR      R0,[SP, #+16]
    772            rq.clen = index_input;
   \   00000034   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000036   0x9705             STR      R7,[SP, #+20]
    773            rq.rparam = &resp;
   \   00000038   0x4668             MOV      R0,SP
   \   0000003A   0x9006             STR      R0,[SP, #+24]
    774            rq.rlen = sizeof(resp);
   \   0000003C   0x2008             MOVS     R0,#+8
   \   0000003E   0x9007             STR      R0,[SP, #+28]
    775            if (hci_send_req(&rq, FALSE) < 0)
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0xA802             ADD      R0,SP,#+8
   \   00000044   0x.... 0x....      BL       hci_send_req
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD501             BPL.N    ??hci_le_read_channel_map_0
    776              return BLE_STATUS_TIMEOUT;
   \   0000004C   0x20FF             MOVS     R0,#+255
   \   0000004E   0xE00D             B.N      ??hci_le_read_channel_map_1
    777            if (resp.Status) {
   \                     ??hci_le_read_channel_map_0: (+1)
   \   00000050   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD002             BEQ.N    ??hci_le_read_channel_map_2
    778              return resp.Status;
   \   00000058   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005C   0xE006             B.N      ??hci_le_read_channel_map_1
    779            }
    780            Osal_MemCpy((void *) LE_Channel_Map, (const void *) resp.LE_Channel_Map, 5);
   \                     ??hci_le_read_channel_map_2: (+1)
   \   0000005E   0x2205             MOVS     R2,#+5
   \   00000060   0xF10D 0x0103      ADD      R1,SP,#+3
   \   00000064   0x0028             MOVS     R0,R5
   \   00000066   0x.... 0x....      BL       Osal_MemCpy
    781            return BLE_STATUS_SUCCESS;
   \   0000006A   0x2000             MOVS     R0,#+0
   \                     ??hci_le_read_channel_map_1: (+1)
   \   0000006C   0xB049             ADD      SP,SP,#+292
   \   0000006E   0xBDF0             POP      {R4-R7,PC}       ;; return
    782          }

   \                                 In section .text, align 2, keep-with-next
    783          tBleStatus hci_le_read_remote_used_features(uint16_t Connection_Handle)
    784          {
   \                     hci_le_read_remote_used_features: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB0C8             SUB      SP,SP,#+288
   \   00000004   0x0004             MOVS     R4,R0
    785            struct hci_request rq;
    786            uint8_t cmd_buffer[258];
    787            hci_le_read_remote_used_features_cp0 *cp0 = (hci_le_read_remote_used_features_cp0*)(cmd_buffer);
   \   00000006   0xAD07             ADD      R5,SP,#+28
    788            tBleStatus status = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    789            uint8_t index_input = 0;
   \   0000000E   0x2600             MOVS     R6,#+0
    790            cp0->Connection_Handle = htob(Connection_Handle, 2);
   \   00000010   0x802C             STRH     R4,[R5, #+0]
    791            index_input += 2;
   \   00000012   0x1CB6             ADDS     R6,R6,#+2
    792            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000014   0x2218             MOVS     R2,#+24
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0xA801             ADD      R0,SP,#+4
   \   0000001A   0x.... 0x....      BL       Osal_MemSet
    793            rq.ogf = 0x08;
   \   0000001E   0x2008             MOVS     R0,#+8
   \   00000020   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    794            rq.ocf = 0x016;
   \   00000024   0x2016             MOVS     R0,#+22
   \   00000026   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    795            rq.event = 0x0F;
   \   0000002A   0x200F             MOVS     R0,#+15
   \   0000002C   0x9002             STR      R0,[SP, #+8]
    796            rq.cparam = cmd_buffer;
   \   0000002E   0xA807             ADD      R0,SP,#+28
   \   00000030   0x9003             STR      R0,[SP, #+12]
    797            rq.clen = index_input;
   \   00000032   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000034   0x9604             STR      R6,[SP, #+16]
    798            rq.rparam = &status;
   \   00000036   0x4668             MOV      R0,SP
   \   00000038   0x9005             STR      R0,[SP, #+20]
    799            rq.rlen = 1;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x9006             STR      R0,[SP, #+24]
    800            if (hci_send_req(&rq, FALSE) < 0)
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0xA801             ADD      R0,SP,#+4
   \   00000042   0x.... 0x....      BL       hci_send_req
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD501             BPL.N    ??hci_le_read_remote_used_features_0
    801              return BLE_STATUS_TIMEOUT;
   \   0000004A   0x20FF             MOVS     R0,#+255
   \   0000004C   0xE007             B.N      ??hci_le_read_remote_used_features_1
    802            if (status) {
   \                     ??hci_le_read_remote_used_features_0: (+1)
   \   0000004E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD002             BEQ.N    ??hci_le_read_remote_used_features_2
    803              return status;
   \   00000056   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005A   0xE000             B.N      ??hci_le_read_remote_used_features_1
    804            }
    805            return BLE_STATUS_SUCCESS;
   \                     ??hci_le_read_remote_used_features_2: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \                     ??hci_le_read_remote_used_features_1: (+1)
   \   0000005E   0xB048             ADD      SP,SP,#+288
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return
    806          }

   \                                 In section .text, align 2, keep-with-next
    807          tBleStatus hci_le_encrypt(uint8_t Key[16],
    808                                    uint8_t Plaintext_Data[16],
    809                                    uint8_t Encrypted_Data[16])
    810          {
   \                     hci_le_encrypt: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB0CC             SUB      SP,SP,#+304
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    811            struct hci_request rq;
    812            uint8_t cmd_buffer[258];
    813            hci_le_encrypt_cp0 *cp0 = (hci_le_encrypt_cp0*)(cmd_buffer);
   \   0000000C   0xAF0B             ADD      R7,SP,#+44
    814            hci_le_encrypt_rp0 resp;
    815            Osal_MemSet(&resp, 0, sizeof(resp));
   \   0000000E   0x2211             MOVS     R2,#+17
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0xA806             ADD      R0,SP,#+24
   \   00000014   0x.... 0x....      BL       Osal_MemSet
    816            uint8_t index_input = 0;
   \   00000018   0xF05F 0x0800      MOVS     R8,#+0
    817            Osal_MemCpy((void *) &cp0->Key, (const void *) Key, 16);
   \   0000001C   0x2210             MOVS     R2,#+16
   \   0000001E   0x0021             MOVS     R1,R4
   \   00000020   0x0038             MOVS     R0,R7
   \   00000022   0x.... 0x....      BL       Osal_MemCpy
    818            index_input += 16;
   \   00000026   0xF118 0x0810      ADDS     R8,R8,#+16
    819            Osal_MemCpy((void *) &cp0->Plaintext_Data, (const void *) Plaintext_Data, 16);
   \   0000002A   0x2210             MOVS     R2,#+16
   \   0000002C   0x0029             MOVS     R1,R5
   \   0000002E   0xF117 0x0010      ADDS     R0,R7,#+16
   \   00000032   0x.... 0x....      BL       Osal_MemCpy
    820            index_input += 16;
   \   00000036   0xF118 0x0810      ADDS     R8,R8,#+16
    821            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000003A   0x2218             MOVS     R2,#+24
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x4668             MOV      R0,SP
   \   00000040   0x.... 0x....      BL       Osal_MemSet
    822            rq.ogf = 0x08;
   \   00000044   0x2008             MOVS     R0,#+8
   \   00000046   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    823            rq.ocf = 0x017;
   \   0000004A   0x2017             MOVS     R0,#+23
   \   0000004C   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    824            rq.cparam = cmd_buffer;
   \   00000050   0xA80B             ADD      R0,SP,#+44
   \   00000052   0x9002             STR      R0,[SP, #+8]
    825            rq.clen = index_input;
   \   00000054   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000058   0xF8CD 0x800C      STR      R8,[SP, #+12]
    826            rq.rparam = &resp;
   \   0000005C   0xA806             ADD      R0,SP,#+24
   \   0000005E   0x9004             STR      R0,[SP, #+16]
    827            rq.rlen = sizeof(resp);
   \   00000060   0x2011             MOVS     R0,#+17
   \   00000062   0x9005             STR      R0,[SP, #+20]
    828            if (hci_send_req(&rq, FALSE) < 0)
   \   00000064   0x2100             MOVS     R1,#+0
   \   00000066   0x4668             MOV      R0,SP
   \   00000068   0x.... 0x....      BL       hci_send_req
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD501             BPL.N    ??hci_le_encrypt_0
    829              return BLE_STATUS_TIMEOUT;
   \   00000070   0x20FF             MOVS     R0,#+255
   \   00000072   0xE00D             B.N      ??hci_le_encrypt_1
    830            if (resp.Status) {
   \                     ??hci_le_encrypt_0: (+1)
   \   00000074   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD002             BEQ.N    ??hci_le_encrypt_2
    831              return resp.Status;
   \   0000007C   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \   00000080   0xE006             B.N      ??hci_le_encrypt_1
    832            }
    833            Osal_MemCpy((void *) Encrypted_Data, (const void *) resp.Encrypted_Data, 16);
   \                     ??hci_le_encrypt_2: (+1)
   \   00000082   0x2210             MOVS     R2,#+16
   \   00000084   0xF10D 0x0119      ADD      R1,SP,#+25
   \   00000088   0x0030             MOVS     R0,R6
   \   0000008A   0x.... 0x....      BL       Osal_MemCpy
    834            return BLE_STATUS_SUCCESS;
   \   0000008E   0x2000             MOVS     R0,#+0
   \                     ??hci_le_encrypt_1: (+1)
   \   00000090   0xB04C             ADD      SP,SP,#+304
   \   00000092   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    835          }

   \                                 In section .text, align 2, keep-with-next
    836          tBleStatus hci_le_rand(uint8_t Random_Number[8])
    837          {
   \                     hci_le_rand: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
   \   00000004   0x0004             MOVS     R4,R0
    838            struct hci_request rq;
    839            hci_le_rand_rp0 resp;
    840            Osal_MemSet(&resp, 0, sizeof(resp));
   \   00000006   0x2209             MOVS     R2,#+9
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       Osal_MemSet
    841            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000010   0x2218             MOVS     R2,#+24
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0xA803             ADD      R0,SP,#+12
   \   00000016   0x.... 0x....      BL       Osal_MemSet
    842            rq.ogf = 0x08;
   \   0000001A   0x2008             MOVS     R0,#+8
   \   0000001C   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    843            rq.ocf = 0x018;
   \   00000020   0x2018             MOVS     R0,#+24
   \   00000022   0xF8AD 0x000E      STRH     R0,[SP, #+14]
    844            rq.rparam = &resp;
   \   00000026   0x4668             MOV      R0,SP
   \   00000028   0x9007             STR      R0,[SP, #+28]
    845            rq.rlen = sizeof(resp);
   \   0000002A   0x2009             MOVS     R0,#+9
   \   0000002C   0x9008             STR      R0,[SP, #+32]
    846            if (hci_send_req(&rq, FALSE) < 0)
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0xA803             ADD      R0,SP,#+12
   \   00000032   0x.... 0x....      BL       hci_send_req
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD501             BPL.N    ??hci_le_rand_0
    847              return BLE_STATUS_TIMEOUT;
   \   0000003A   0x20FF             MOVS     R0,#+255
   \   0000003C   0xE00D             B.N      ??hci_le_rand_1
    848            if (resp.Status) {
   \                     ??hci_le_rand_0: (+1)
   \   0000003E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD002             BEQ.N    ??hci_le_rand_2
    849              return resp.Status;
   \   00000046   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004A   0xE006             B.N      ??hci_le_rand_1
    850            }
    851            Osal_MemCpy((void *) Random_Number, (const void *) resp.Random_Number, 8);
   \                     ??hci_le_rand_2: (+1)
   \   0000004C   0x2208             MOVS     R2,#+8
   \   0000004E   0xF10D 0x0101      ADD      R1,SP,#+1
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       Osal_MemCpy
    852            return BLE_STATUS_SUCCESS;
   \   00000058   0x2000             MOVS     R0,#+0
   \                     ??hci_le_rand_1: (+1)
   \   0000005A   0xB00A             ADD      SP,SP,#+40
   \   0000005C   0xBD10             POP      {R4,PC}          ;; return
    853          }

   \                                 In section .text, align 2, keep-with-next
    854          tBleStatus hci_le_start_encryption(uint16_t Connection_Handle,
    855                                             uint8_t Random_Number[8],
    856                                             uint16_t Encrypted_Diversifier,
    857                                             uint8_t Long_Term_Key[16])
    858          {
   \                     hci_le_start_encryption: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB0C9             SUB      SP,SP,#+292
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
    859            struct hci_request rq;
    860            uint8_t cmd_buffer[258];
    861            hci_le_start_encryption_cp0 *cp0 = (hci_le_start_encryption_cp0*)(cmd_buffer);
   \   0000000E   0xF10D 0x081C      ADD      R8,SP,#+28
    862            tBleStatus status = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF88D 0x0000      STRB     R0,[SP, #+0]
    863            uint8_t index_input = 0;
   \   00000018   0xF05F 0x0900      MOVS     R9,#+0
    864            cp0->Connection_Handle = htob(Connection_Handle, 2);
   \   0000001C   0xF8A8 0x4000      STRH     R4,[R8, #+0]
    865            index_input += 2;
   \   00000020   0xF119 0x0902      ADDS     R9,R9,#+2
    866            Osal_MemCpy((void *) &cp0->Random_Number, (const void *) Random_Number, 8);
   \   00000024   0x2208             MOVS     R2,#+8
   \   00000026   0x0029             MOVS     R1,R5
   \   00000028   0xF118 0x0002      ADDS     R0,R8,#+2
   \   0000002C   0x.... 0x....      BL       Osal_MemCpy
    867            index_input += 8;
   \   00000030   0xF119 0x0908      ADDS     R9,R9,#+8
    868            cp0->Encrypted_Diversifier = htob(Encrypted_Diversifier, 2);
   \   00000034   0xF8A8 0x600A      STRH     R6,[R8, #+10]
    869            index_input += 2;
   \   00000038   0xF119 0x0902      ADDS     R9,R9,#+2
    870            Osal_MemCpy((void *) &cp0->Long_Term_Key, (const void *) Long_Term_Key, 16);
   \   0000003C   0x2210             MOVS     R2,#+16
   \   0000003E   0x0039             MOVS     R1,R7
   \   00000040   0xF118 0x000C      ADDS     R0,R8,#+12
   \   00000044   0x.... 0x....      BL       Osal_MemCpy
    871            index_input += 16;
   \   00000048   0xF119 0x0910      ADDS     R9,R9,#+16
    872            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000004C   0x2218             MOVS     R2,#+24
   \   0000004E   0x2100             MOVS     R1,#+0
   \   00000050   0xA801             ADD      R0,SP,#+4
   \   00000052   0x.... 0x....      BL       Osal_MemSet
    873            rq.ogf = 0x08;
   \   00000056   0x2008             MOVS     R0,#+8
   \   00000058   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    874            rq.ocf = 0x019;
   \   0000005C   0x2019             MOVS     R0,#+25
   \   0000005E   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    875            rq.event = 0x0F;
   \   00000062   0x200F             MOVS     R0,#+15
   \   00000064   0x9002             STR      R0,[SP, #+8]
    876            rq.cparam = cmd_buffer;
   \   00000066   0xA807             ADD      R0,SP,#+28
   \   00000068   0x9003             STR      R0,[SP, #+12]
    877            rq.clen = index_input;
   \   0000006A   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000006E   0xF8CD 0x9010      STR      R9,[SP, #+16]
    878            rq.rparam = &status;
   \   00000072   0x4668             MOV      R0,SP
   \   00000074   0x9005             STR      R0,[SP, #+20]
    879            rq.rlen = 1;
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0x9006             STR      R0,[SP, #+24]
    880            if (hci_send_req(&rq, FALSE) < 0)
   \   0000007A   0x2100             MOVS     R1,#+0
   \   0000007C   0xA801             ADD      R0,SP,#+4
   \   0000007E   0x.... 0x....      BL       hci_send_req
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD501             BPL.N    ??hci_le_start_encryption_0
    881              return BLE_STATUS_TIMEOUT;
   \   00000086   0x20FF             MOVS     R0,#+255
   \   00000088   0xE007             B.N      ??hci_le_start_encryption_1
    882            if (status) {
   \                     ??hci_le_start_encryption_0: (+1)
   \   0000008A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD002             BEQ.N    ??hci_le_start_encryption_2
    883              return status;
   \   00000092   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000096   0xE000             B.N      ??hci_le_start_encryption_1
    884            }
    885            return BLE_STATUS_SUCCESS;
   \                     ??hci_le_start_encryption_2: (+1)
   \   00000098   0x2000             MOVS     R0,#+0
   \                     ??hci_le_start_encryption_1: (+1)
   \   0000009A   0xB049             ADD      SP,SP,#+292
   \   0000009C   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    886          }

   \                                 In section .text, align 2, keep-with-next
    887          tBleStatus hci_le_long_term_key_request_reply(uint16_t Connection_Handle,
    888                                                        uint8_t Long_Term_Key[16])
    889          {
   \                     hci_le_long_term_key_request_reply: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB0C9             SUB      SP,SP,#+292
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    890            struct hci_request rq;
    891            uint8_t cmd_buffer[258];
    892            hci_le_long_term_key_request_reply_cp0 *cp0 = (hci_le_long_term_key_request_reply_cp0*)(cmd_buffer);
   \   00000008   0xAE07             ADD      R6,SP,#+28
    893            hci_le_long_term_key_request_reply_rp0 resp;
    894            Osal_MemSet(&resp, 0, sizeof(resp));
   \   0000000A   0x2203             MOVS     R2,#+3
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x4668             MOV      R0,SP
   \   00000010   0x.... 0x....      BL       Osal_MemSet
    895            uint8_t index_input = 0;
   \   00000014   0x2700             MOVS     R7,#+0
    896            cp0->Connection_Handle = htob(Connection_Handle, 2);
   \   00000016   0x8034             STRH     R4,[R6, #+0]
    897            index_input += 2;
   \   00000018   0x1CBF             ADDS     R7,R7,#+2
    898            Osal_MemCpy((void *) &cp0->Long_Term_Key, (const void *) Long_Term_Key, 16);
   \   0000001A   0x2210             MOVS     R2,#+16
   \   0000001C   0x0029             MOVS     R1,R5
   \   0000001E   0x1CB0             ADDS     R0,R6,#+2
   \   00000020   0x.... 0x....      BL       Osal_MemCpy
    899            index_input += 16;
   \   00000024   0x3710             ADDS     R7,R7,#+16
    900            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000026   0x2218             MOVS     R2,#+24
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0xA801             ADD      R0,SP,#+4
   \   0000002C   0x.... 0x....      BL       Osal_MemSet
    901            rq.ogf = 0x08;
   \   00000030   0x2008             MOVS     R0,#+8
   \   00000032   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    902            rq.ocf = 0x01a;
   \   00000036   0x201A             MOVS     R0,#+26
   \   00000038   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    903            rq.cparam = cmd_buffer;
   \   0000003C   0xA807             ADD      R0,SP,#+28
   \   0000003E   0x9003             STR      R0,[SP, #+12]
    904            rq.clen = index_input;
   \   00000040   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000042   0x9704             STR      R7,[SP, #+16]
    905            rq.rparam = &resp;
   \   00000044   0x4668             MOV      R0,SP
   \   00000046   0x9005             STR      R0,[SP, #+20]
    906            rq.rlen = sizeof(resp);
   \   00000048   0x2003             MOVS     R0,#+3
   \   0000004A   0x9006             STR      R0,[SP, #+24]
    907            if (hci_send_req(&rq, FALSE) < 0)
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0xA801             ADD      R0,SP,#+4
   \   00000050   0x.... 0x....      BL       hci_send_req
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD501             BPL.N    ??hci_le_long_term_key_request_reply_0
    908              return BLE_STATUS_TIMEOUT;
   \   00000058   0x20FF             MOVS     R0,#+255
   \   0000005A   0xE007             B.N      ??hci_le_long_term_key_request_reply_1
    909            if (resp.Status) {
   \                     ??hci_le_long_term_key_request_reply_0: (+1)
   \   0000005C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD002             BEQ.N    ??hci_le_long_term_key_request_reply_2
    910              return resp.Status;
   \   00000064   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000068   0xE000             B.N      ??hci_le_long_term_key_request_reply_1
    911            }
    912            return BLE_STATUS_SUCCESS;
   \                     ??hci_le_long_term_key_request_reply_2: (+1)
   \   0000006A   0x2000             MOVS     R0,#+0
   \                     ??hci_le_long_term_key_request_reply_1: (+1)
   \   0000006C   0xB049             ADD      SP,SP,#+292
   \   0000006E   0xBDF0             POP      {R4-R7,PC}       ;; return
    913          }

   \                                 In section .text, align 2, keep-with-next
    914          tBleStatus hci_le_long_term_key_requested_negative_reply(uint16_t Connection_Handle)
    915          {
   \                     hci_le_long_term_key_requested_negative_reply: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB0C8             SUB      SP,SP,#+288
   \   00000004   0x0004             MOVS     R4,R0
    916            struct hci_request rq;
    917            uint8_t cmd_buffer[258];
    918            hci_le_long_term_key_requested_negative_reply_cp0 *cp0 = (hci_le_long_term_key_requested_negative_reply_cp0*)(cmd_buffer);
   \   00000006   0xAD07             ADD      R5,SP,#+28
    919            hci_le_long_term_key_requested_negative_reply_rp0 resp;
    920            Osal_MemSet(&resp, 0, sizeof(resp));
   \   00000008   0x2203             MOVS     R2,#+3
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x4668             MOV      R0,SP
   \   0000000E   0x.... 0x....      BL       Osal_MemSet
    921            uint8_t index_input = 0;
   \   00000012   0x2600             MOVS     R6,#+0
    922            cp0->Connection_Handle = htob(Connection_Handle, 2);
   \   00000014   0x802C             STRH     R4,[R5, #+0]
    923            index_input += 2;
   \   00000016   0x1CB6             ADDS     R6,R6,#+2
    924            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000018   0x2218             MOVS     R2,#+24
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0xA801             ADD      R0,SP,#+4
   \   0000001E   0x.... 0x....      BL       Osal_MemSet
    925            rq.ogf = 0x08;
   \   00000022   0x2008             MOVS     R0,#+8
   \   00000024   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    926            rq.ocf = 0x01b;
   \   00000028   0x201B             MOVS     R0,#+27
   \   0000002A   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    927            rq.cparam = cmd_buffer;
   \   0000002E   0xA807             ADD      R0,SP,#+28
   \   00000030   0x9003             STR      R0,[SP, #+12]
    928            rq.clen = index_input;
   \   00000032   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000034   0x9604             STR      R6,[SP, #+16]
    929            rq.rparam = &resp;
   \   00000036   0x4668             MOV      R0,SP
   \   00000038   0x9005             STR      R0,[SP, #+20]
    930            rq.rlen = sizeof(resp);
   \   0000003A   0x2003             MOVS     R0,#+3
   \   0000003C   0x9006             STR      R0,[SP, #+24]
    931            if (hci_send_req(&rq, FALSE) < 0)
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0xA801             ADD      R0,SP,#+4
   \   00000042   0x.... 0x....      BL       hci_send_req
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD501             BPL.N    ??hci_le_long_term_key_requested_negative_reply_0
    932              return BLE_STATUS_TIMEOUT;
   \   0000004A   0x20FF             MOVS     R0,#+255
   \   0000004C   0xE007             B.N      ??hci_le_long_term_key_requested_negative_reply_1
    933            if (resp.Status) {
   \                     ??hci_le_long_term_key_requested_negative_reply_0: (+1)
   \   0000004E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD002             BEQ.N    ??hci_le_long_term_key_requested_negative_reply_2
    934              return resp.Status;
   \   00000056   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005A   0xE000             B.N      ??hci_le_long_term_key_requested_negative_reply_1
    935            }
    936            return BLE_STATUS_SUCCESS;
   \                     ??hci_le_long_term_key_requested_negative_reply_2: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \                     ??hci_le_long_term_key_requested_negative_reply_1: (+1)
   \   0000005E   0xB048             ADD      SP,SP,#+288
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return
    937          }

   \                                 In section .text, align 2, keep-with-next
    938          tBleStatus hci_le_read_supported_states(uint8_t LE_States[8])
    939          {
   \                     hci_le_read_supported_states: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
   \   00000004   0x0004             MOVS     R4,R0
    940            struct hci_request rq;
    941            hci_le_read_supported_states_rp0 resp;
    942            Osal_MemSet(&resp, 0, sizeof(resp));
   \   00000006   0x2209             MOVS     R2,#+9
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       Osal_MemSet
    943            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000010   0x2218             MOVS     R2,#+24
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0xA803             ADD      R0,SP,#+12
   \   00000016   0x.... 0x....      BL       Osal_MemSet
    944            rq.ogf = 0x08;
   \   0000001A   0x2008             MOVS     R0,#+8
   \   0000001C   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    945            rq.ocf = 0x01c;
   \   00000020   0x201C             MOVS     R0,#+28
   \   00000022   0xF8AD 0x000E      STRH     R0,[SP, #+14]
    946            rq.rparam = &resp;
   \   00000026   0x4668             MOV      R0,SP
   \   00000028   0x9007             STR      R0,[SP, #+28]
    947            rq.rlen = sizeof(resp);
   \   0000002A   0x2009             MOVS     R0,#+9
   \   0000002C   0x9008             STR      R0,[SP, #+32]
    948            if (hci_send_req(&rq, FALSE) < 0)
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0xA803             ADD      R0,SP,#+12
   \   00000032   0x.... 0x....      BL       hci_send_req
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD501             BPL.N    ??hci_le_read_supported_states_0
    949              return BLE_STATUS_TIMEOUT;
   \   0000003A   0x20FF             MOVS     R0,#+255
   \   0000003C   0xE00D             B.N      ??hci_le_read_supported_states_1
    950            if (resp.Status) {
   \                     ??hci_le_read_supported_states_0: (+1)
   \   0000003E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD002             BEQ.N    ??hci_le_read_supported_states_2
    951              return resp.Status;
   \   00000046   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004A   0xE006             B.N      ??hci_le_read_supported_states_1
    952            }
    953            Osal_MemCpy((void *) LE_States, (const void *) resp.LE_States, 8);
   \                     ??hci_le_read_supported_states_2: (+1)
   \   0000004C   0x2208             MOVS     R2,#+8
   \   0000004E   0xF10D 0x0101      ADD      R1,SP,#+1
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       Osal_MemCpy
    954            return BLE_STATUS_SUCCESS;
   \   00000058   0x2000             MOVS     R0,#+0
   \                     ??hci_le_read_supported_states_1: (+1)
   \   0000005A   0xB00A             ADD      SP,SP,#+40
   \   0000005C   0xBD10             POP      {R4,PC}          ;; return
    955          }

   \                                 In section .text, align 2, keep-with-next
    956          tBleStatus hci_le_receiver_test(uint8_t RX_Frequency)
    957          {
   \                     hci_le_receiver_test: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB0C8             SUB      SP,SP,#+288
   \   00000004   0x0004             MOVS     R4,R0
    958            struct hci_request rq;
    959            uint8_t cmd_buffer[258];
    960            hci_le_receiver_test_cp0 *cp0 = (hci_le_receiver_test_cp0*)(cmd_buffer);
   \   00000006   0xAD07             ADD      R5,SP,#+28
    961            tBleStatus status = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    962            uint8_t index_input = 0;
   \   0000000E   0x2600             MOVS     R6,#+0
    963            cp0->RX_Frequency = htob(RX_Frequency, 1);
   \   00000010   0x702C             STRB     R4,[R5, #+0]
    964            index_input += 1;
   \   00000012   0x1C76             ADDS     R6,R6,#+1
    965            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000014   0x2218             MOVS     R2,#+24
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0xA801             ADD      R0,SP,#+4
   \   0000001A   0x.... 0x....      BL       Osal_MemSet
    966            rq.ogf = 0x08;
   \   0000001E   0x2008             MOVS     R0,#+8
   \   00000020   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    967            rq.ocf = 0x01d;
   \   00000024   0x201D             MOVS     R0,#+29
   \   00000026   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    968            rq.cparam = cmd_buffer;
   \   0000002A   0xA807             ADD      R0,SP,#+28
   \   0000002C   0x9003             STR      R0,[SP, #+12]
    969            rq.clen = index_input;
   \   0000002E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000030   0x9604             STR      R6,[SP, #+16]
    970            rq.rparam = &status;
   \   00000032   0x4668             MOV      R0,SP
   \   00000034   0x9005             STR      R0,[SP, #+20]
    971            rq.rlen = 1;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x9006             STR      R0,[SP, #+24]
    972            if (hci_send_req(&rq, FALSE) < 0)
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0xA801             ADD      R0,SP,#+4
   \   0000003E   0x.... 0x....      BL       hci_send_req
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD501             BPL.N    ??hci_le_receiver_test_0
    973              return BLE_STATUS_TIMEOUT;
   \   00000046   0x20FF             MOVS     R0,#+255
   \   00000048   0xE007             B.N      ??hci_le_receiver_test_1
    974            if (status) {
   \                     ??hci_le_receiver_test_0: (+1)
   \   0000004A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD002             BEQ.N    ??hci_le_receiver_test_2
    975              return status;
   \   00000052   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000056   0xE000             B.N      ??hci_le_receiver_test_1
    976            }
    977            return BLE_STATUS_SUCCESS;
   \                     ??hci_le_receiver_test_2: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \                     ??hci_le_receiver_test_1: (+1)
   \   0000005A   0xB048             ADD      SP,SP,#+288
   \   0000005C   0xBD70             POP      {R4-R6,PC}       ;; return
    978          }

   \                                 In section .text, align 2, keep-with-next
    979          tBleStatus hci_le_transmitter_test(uint8_t TX_Frequency,
    980                                             uint8_t Length_Of_Test_Data,
    981                                             uint8_t Packet_Payload)
    982          {
   \                     hci_le_transmitter_test: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB0C8             SUB      SP,SP,#+288
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    983            struct hci_request rq;
    984            uint8_t cmd_buffer[258];
    985            hci_le_transmitter_test_cp0 *cp0 = (hci_le_transmitter_test_cp0*)(cmd_buffer);
   \   0000000C   0xAF07             ADD      R7,SP,#+28
    986            tBleStatus status = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF88D 0x0000      STRB     R0,[SP, #+0]
    987            uint8_t index_input = 0;
   \   00000014   0xF05F 0x0800      MOVS     R8,#+0
    988            cp0->TX_Frequency = htob(TX_Frequency, 1);
   \   00000018   0x703C             STRB     R4,[R7, #+0]
    989            index_input += 1;
   \   0000001A   0xF118 0x0801      ADDS     R8,R8,#+1
    990            cp0->Length_Of_Test_Data = htob(Length_Of_Test_Data, 1);
   \   0000001E   0x707D             STRB     R5,[R7, #+1]
    991            index_input += 1;
   \   00000020   0xF118 0x0801      ADDS     R8,R8,#+1
    992            cp0->Packet_Payload = htob(Packet_Payload, 1);
   \   00000024   0x70BE             STRB     R6,[R7, #+2]
    993            index_input += 1;
   \   00000026   0xF118 0x0801      ADDS     R8,R8,#+1
    994            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000002A   0x2218             MOVS     R2,#+24
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0xA801             ADD      R0,SP,#+4
   \   00000030   0x.... 0x....      BL       Osal_MemSet
    995            rq.ogf = 0x08;
   \   00000034   0x2008             MOVS     R0,#+8
   \   00000036   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    996            rq.ocf = 0x01e;
   \   0000003A   0x201E             MOVS     R0,#+30
   \   0000003C   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    997            rq.cparam = cmd_buffer;
   \   00000040   0xA807             ADD      R0,SP,#+28
   \   00000042   0x9003             STR      R0,[SP, #+12]
    998            rq.clen = index_input;
   \   00000044   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000048   0xF8CD 0x8010      STR      R8,[SP, #+16]
    999            rq.rparam = &status;
   \   0000004C   0x4668             MOV      R0,SP
   \   0000004E   0x9005             STR      R0,[SP, #+20]
   1000            rq.rlen = 1;
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0x9006             STR      R0,[SP, #+24]
   1001            if (hci_send_req(&rq, FALSE) < 0)
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0xA801             ADD      R0,SP,#+4
   \   00000058   0x.... 0x....      BL       hci_send_req
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD501             BPL.N    ??hci_le_transmitter_test_0
   1002              return BLE_STATUS_TIMEOUT;
   \   00000060   0x20FF             MOVS     R0,#+255
   \   00000062   0xE007             B.N      ??hci_le_transmitter_test_1
   1003            if (status) {
   \                     ??hci_le_transmitter_test_0: (+1)
   \   00000064   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD002             BEQ.N    ??hci_le_transmitter_test_2
   1004              return status;
   \   0000006C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000070   0xE000             B.N      ??hci_le_transmitter_test_1
   1005            }
   1006            return BLE_STATUS_SUCCESS;
   \                     ??hci_le_transmitter_test_2: (+1)
   \   00000072   0x2000             MOVS     R0,#+0
   \                     ??hci_le_transmitter_test_1: (+1)
   \   00000074   0xB048             ADD      SP,SP,#+288
   \   00000076   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1007          }

   \                                 In section .text, align 2, keep-with-next
   1008          tBleStatus hci_le_test_end(uint16_t *Number_Of_Packets)
   1009          {
   \                     hci_le_test_end: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x0004             MOVS     R4,R0
   1010            struct hci_request rq;
   1011            hci_le_test_end_rp0 resp;
   1012            Osal_MemSet(&resp, 0, sizeof(resp));
   \   00000006   0x2203             MOVS     R2,#+3
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       Osal_MemSet
   1013            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000010   0x2218             MOVS     R2,#+24
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0xA801             ADD      R0,SP,#+4
   \   00000016   0x.... 0x....      BL       Osal_MemSet
   1014            rq.ogf = 0x08;
   \   0000001A   0x2008             MOVS     R0,#+8
   \   0000001C   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1015            rq.ocf = 0x01f;
   \   00000020   0x201F             MOVS     R0,#+31
   \   00000022   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1016            rq.rparam = &resp;
   \   00000026   0x4668             MOV      R0,SP
   \   00000028   0x9005             STR      R0,[SP, #+20]
   1017            rq.rlen = sizeof(resp);
   \   0000002A   0x2003             MOVS     R0,#+3
   \   0000002C   0x9006             STR      R0,[SP, #+24]
   1018            if (hci_send_req(&rq, FALSE) < 0)
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0xA801             ADD      R0,SP,#+4
   \   00000032   0x.... 0x....      BL       hci_send_req
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD501             BPL.N    ??hci_le_test_end_0
   1019              return BLE_STATUS_TIMEOUT;
   \   0000003A   0x20FF             MOVS     R0,#+255
   \   0000003C   0xE00A             B.N      ??hci_le_test_end_1
   1020            if (resp.Status) {
   \                     ??hci_le_test_end_0: (+1)
   \   0000003E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD002             BEQ.N    ??hci_le_test_end_2
   1021              return resp.Status;
   \   00000046   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004A   0xE003             B.N      ??hci_le_test_end_1
   1022            }
   1023            *Number_Of_Packets = btoh(resp.Number_Of_Packets, 2);
   \                     ??hci_le_test_end_2: (+1)
   \   0000004C   0xF8BD 0x0001      LDRH     R0,[SP, #+1]
   \   00000050   0x8020             STRH     R0,[R4, #+0]
   1024            return BLE_STATUS_SUCCESS;
   \   00000052   0x2000             MOVS     R0,#+0
   \                     ??hci_le_test_end_1: (+1)
   \   00000054   0xB008             ADD      SP,SP,#+32
   \   00000056   0xBD10             POP      {R4,PC}          ;; return
   1025          }

   \                                 In section .text, align 2, keep-with-next
   1026          tBleStatus hci_le_read_local_p256_public_key(void)
   1027          {
   \                     hci_le_read_local_p256_public_key: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   1028            struct hci_request rq;
   1029            tBleStatus status = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1030            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000000A   0x2218             MOVS     R2,#+24
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0xA801             ADD      R0,SP,#+4
   \   00000010   0x.... 0x....      BL       Osal_MemSet
   1031            rq.ogf = 0x08;
   \   00000014   0x2008             MOVS     R0,#+8
   \   00000016   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1032            rq.ocf = 0x025;
   \   0000001A   0x2025             MOVS     R0,#+37
   \   0000001C   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1033            rq.event = 0x0F;
   \   00000020   0x200F             MOVS     R0,#+15
   \   00000022   0x9002             STR      R0,[SP, #+8]
   1034            rq.rparam = &status;
   \   00000024   0x4668             MOV      R0,SP
   \   00000026   0x9005             STR      R0,[SP, #+20]
   1035            rq.rlen = 1;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x9006             STR      R0,[SP, #+24]
   1036            if (hci_send_req(&rq, FALSE) < 0)
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0xA801             ADD      R0,SP,#+4
   \   00000030   0x.... 0x....      BL       hci_send_req
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD501             BPL.N    ??hci_le_read_local_p256_public_key_0
   1037              return BLE_STATUS_TIMEOUT;
   \   00000038   0x20FF             MOVS     R0,#+255
   \   0000003A   0xE007             B.N      ??hci_le_read_local_p256_public_key_1
   1038            if (status) {
   \                     ??hci_le_read_local_p256_public_key_0: (+1)
   \   0000003C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD002             BEQ.N    ??hci_le_read_local_p256_public_key_2
   1039              return status;
   \   00000044   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000048   0xE000             B.N      ??hci_le_read_local_p256_public_key_1
   1040            }
   1041            return BLE_STATUS_SUCCESS;
   \                     ??hci_le_read_local_p256_public_key_2: (+1)
   \   0000004A   0x2000             MOVS     R0,#+0
   \                     ??hci_le_read_local_p256_public_key_1: (+1)
   \   0000004C   0xB007             ADD      SP,SP,#+28
   \   0000004E   0xBD00             POP      {PC}             ;; return
   1042          }

   \                                 In section .text, align 2, keep-with-next
   1043          tBleStatus hci_le_generate_dhkey(uint8_t Remote_P256_Public_Key[64])
   1044          {
   \                     hci_le_generate_dhkey: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB0C8             SUB      SP,SP,#+288
   \   00000004   0x0004             MOVS     R4,R0
   1045            struct hci_request rq;
   1046            uint8_t cmd_buffer[258];
   1047            hci_le_generate_dhkey_cp0 *cp0 = (hci_le_generate_dhkey_cp0*)(cmd_buffer);
   \   00000006   0xAD07             ADD      R5,SP,#+28
   1048            tBleStatus status = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1049            uint8_t index_input = 0;
   \   0000000E   0x2600             MOVS     R6,#+0
   1050            Osal_MemCpy((void *) &cp0->Remote_P256_Public_Key, (const void *) Remote_P256_Public_Key, 64);
   \   00000010   0x2240             MOVS     R2,#+64
   \   00000012   0x0021             MOVS     R1,R4
   \   00000014   0x0028             MOVS     R0,R5
   \   00000016   0x.... 0x....      BL       Osal_MemCpy
   1051            index_input += 64;
   \   0000001A   0x3640             ADDS     R6,R6,#+64
   1052            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000001C   0x2218             MOVS     R2,#+24
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0xA801             ADD      R0,SP,#+4
   \   00000022   0x.... 0x....      BL       Osal_MemSet
   1053            rq.ogf = 0x08;
   \   00000026   0x2008             MOVS     R0,#+8
   \   00000028   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1054            rq.ocf = 0x026;
   \   0000002C   0x2026             MOVS     R0,#+38
   \   0000002E   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1055            rq.event = 0x0F;
   \   00000032   0x200F             MOVS     R0,#+15
   \   00000034   0x9002             STR      R0,[SP, #+8]
   1056            rq.cparam = cmd_buffer;
   \   00000036   0xA807             ADD      R0,SP,#+28
   \   00000038   0x9003             STR      R0,[SP, #+12]
   1057            rq.clen = index_input;
   \   0000003A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003C   0x9604             STR      R6,[SP, #+16]
   1058            rq.rparam = &status;
   \   0000003E   0x4668             MOV      R0,SP
   \   00000040   0x9005             STR      R0,[SP, #+20]
   1059            rq.rlen = 1;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x9006             STR      R0,[SP, #+24]
   1060            if (hci_send_req(&rq, FALSE) < 0)
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0xA801             ADD      R0,SP,#+4
   \   0000004A   0x.... 0x....      BL       hci_send_req
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD501             BPL.N    ??hci_le_generate_dhkey_0
   1061              return BLE_STATUS_TIMEOUT;
   \   00000052   0x20FF             MOVS     R0,#+255
   \   00000054   0xE007             B.N      ??hci_le_generate_dhkey_1
   1062            if (status) {
   \                     ??hci_le_generate_dhkey_0: (+1)
   \   00000056   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD002             BEQ.N    ??hci_le_generate_dhkey_2
   1063              return status;
   \   0000005E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000062   0xE000             B.N      ??hci_le_generate_dhkey_1
   1064            }
   1065            return BLE_STATUS_SUCCESS;
   \                     ??hci_le_generate_dhkey_2: (+1)
   \   00000064   0x2000             MOVS     R0,#+0
   \                     ??hci_le_generate_dhkey_1: (+1)
   \   00000066   0xB048             ADD      SP,SP,#+288
   \   00000068   0xBD70             POP      {R4-R6,PC}       ;; return
   1066          }

   \                                 In section .text, align 2, keep-with-next
   1067          tBleStatus hci_le_add_device_to_resolving_list(uint8_t Peer_Identity_Address_Type,
   1068                                                         uint8_t Peer_Identity_Address[6],
   1069                                                         uint8_t Peer_IRK[16],
   1070                                                         uint8_t Local_IRK[16])
   1071          {
   \                     hci_le_add_device_to_resolving_list: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB0C9             SUB      SP,SP,#+292
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   1072            struct hci_request rq;
   1073            uint8_t cmd_buffer[258];
   1074            hci_le_add_device_to_resolving_list_cp0 *cp0 = (hci_le_add_device_to_resolving_list_cp0*)(cmd_buffer);
   \   0000000E   0xF10D 0x081C      ADD      R8,SP,#+28
   1075            tBleStatus status = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1076            uint8_t index_input = 0;
   \   00000018   0xF05F 0x0900      MOVS     R9,#+0
   1077            cp0->Peer_Identity_Address_Type = htob(Peer_Identity_Address_Type, 1);
   \   0000001C   0xF888 0x4000      STRB     R4,[R8, #+0]
   1078            index_input += 1;
   \   00000020   0xF119 0x0901      ADDS     R9,R9,#+1
   1079            Osal_MemCpy((void *) &cp0->Peer_Identity_Address, (const void *) Peer_Identity_Address, 6);
   \   00000024   0x2206             MOVS     R2,#+6
   \   00000026   0x0029             MOVS     R1,R5
   \   00000028   0xF118 0x0001      ADDS     R0,R8,#+1
   \   0000002C   0x.... 0x....      BL       Osal_MemCpy
   1080            index_input += 6;
   \   00000030   0xF119 0x0906      ADDS     R9,R9,#+6
   1081            Osal_MemCpy((void *) &cp0->Peer_IRK, (const void *) Peer_IRK, 16);
   \   00000034   0x2210             MOVS     R2,#+16
   \   00000036   0x0031             MOVS     R1,R6
   \   00000038   0xF118 0x0007      ADDS     R0,R8,#+7
   \   0000003C   0x.... 0x....      BL       Osal_MemCpy
   1082            index_input += 16;
   \   00000040   0xF119 0x0910      ADDS     R9,R9,#+16
   1083            Osal_MemCpy((void *) &cp0->Local_IRK, (const void *) Local_IRK, 16);
   \   00000044   0x2210             MOVS     R2,#+16
   \   00000046   0x0039             MOVS     R1,R7
   \   00000048   0xF118 0x0017      ADDS     R0,R8,#+23
   \   0000004C   0x.... 0x....      BL       Osal_MemCpy
   1084            index_input += 16;
   \   00000050   0xF119 0x0910      ADDS     R9,R9,#+16
   1085            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000054   0x2218             MOVS     R2,#+24
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0xA801             ADD      R0,SP,#+4
   \   0000005A   0x.... 0x....      BL       Osal_MemSet
   1086            rq.ogf = 0x08;
   \   0000005E   0x2008             MOVS     R0,#+8
   \   00000060   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1087            rq.ocf = 0x027;
   \   00000064   0x2027             MOVS     R0,#+39
   \   00000066   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1088            rq.cparam = cmd_buffer;
   \   0000006A   0xA807             ADD      R0,SP,#+28
   \   0000006C   0x9003             STR      R0,[SP, #+12]
   1089            rq.clen = index_input;
   \   0000006E   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000072   0xF8CD 0x9010      STR      R9,[SP, #+16]
   1090            rq.rparam = &status;
   \   00000076   0x4668             MOV      R0,SP
   \   00000078   0x9005             STR      R0,[SP, #+20]
   1091            rq.rlen = 1;
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0x9006             STR      R0,[SP, #+24]
   1092            if (hci_send_req(&rq, FALSE) < 0)
   \   0000007E   0x2100             MOVS     R1,#+0
   \   00000080   0xA801             ADD      R0,SP,#+4
   \   00000082   0x.... 0x....      BL       hci_send_req
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD501             BPL.N    ??hci_le_add_device_to_resolving_list_0
   1093              return BLE_STATUS_TIMEOUT;
   \   0000008A   0x20FF             MOVS     R0,#+255
   \   0000008C   0xE007             B.N      ??hci_le_add_device_to_resolving_list_1
   1094            if (status) {
   \                     ??hci_le_add_device_to_resolving_list_0: (+1)
   \   0000008E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD002             BEQ.N    ??hci_le_add_device_to_resolving_list_2
   1095              return status;
   \   00000096   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000009A   0xE000             B.N      ??hci_le_add_device_to_resolving_list_1
   1096            }
   1097            return BLE_STATUS_SUCCESS;
   \                     ??hci_le_add_device_to_resolving_list_2: (+1)
   \   0000009C   0x2000             MOVS     R0,#+0
   \                     ??hci_le_add_device_to_resolving_list_1: (+1)
   \   0000009E   0xB049             ADD      SP,SP,#+292
   \   000000A0   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   1098          }

   \                                 In section .text, align 2, keep-with-next
   1099          tBleStatus hci_le_remove_device_from_resolving_list(uint8_t Peer_Identity_Address_Type,
   1100                                                              uint8_t Peer_Identity_Address[6])
   1101          {
   \                     hci_le_remove_device_from_resolving_list: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB0C9             SUB      SP,SP,#+292
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1102            struct hci_request rq;
   1103            uint8_t cmd_buffer[258];
   1104            hci_le_remove_device_from_resolving_list_cp0 *cp0 = (hci_le_remove_device_from_resolving_list_cp0*)(cmd_buffer);
   \   00000008   0xAE07             ADD      R6,SP,#+28
   1105            tBleStatus status = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1106            uint8_t index_input = 0;
   \   00000010   0x2700             MOVS     R7,#+0
   1107            cp0->Peer_Identity_Address_Type = htob(Peer_Identity_Address_Type, 1);
   \   00000012   0x7034             STRB     R4,[R6, #+0]
   1108            index_input += 1;
   \   00000014   0x1C7F             ADDS     R7,R7,#+1
   1109            Osal_MemCpy((void *) &cp0->Peer_Identity_Address, (const void *) Peer_Identity_Address, 6);
   \   00000016   0x2206             MOVS     R2,#+6
   \   00000018   0x0029             MOVS     R1,R5
   \   0000001A   0x1C70             ADDS     R0,R6,#+1
   \   0000001C   0x.... 0x....      BL       Osal_MemCpy
   1110            index_input += 6;
   \   00000020   0x1DBF             ADDS     R7,R7,#+6
   1111            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000022   0x2218             MOVS     R2,#+24
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0xA801             ADD      R0,SP,#+4
   \   00000028   0x.... 0x....      BL       Osal_MemSet
   1112            rq.ogf = 0x08;
   \   0000002C   0x2008             MOVS     R0,#+8
   \   0000002E   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1113            rq.ocf = 0x028;
   \   00000032   0x2028             MOVS     R0,#+40
   \   00000034   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1114            rq.cparam = cmd_buffer;
   \   00000038   0xA807             ADD      R0,SP,#+28
   \   0000003A   0x9003             STR      R0,[SP, #+12]
   1115            rq.clen = index_input;
   \   0000003C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003E   0x9704             STR      R7,[SP, #+16]
   1116            rq.rparam = &status;
   \   00000040   0x4668             MOV      R0,SP
   \   00000042   0x9005             STR      R0,[SP, #+20]
   1117            rq.rlen = 1;
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x9006             STR      R0,[SP, #+24]
   1118            if (hci_send_req(&rq, FALSE) < 0)
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0xA801             ADD      R0,SP,#+4
   \   0000004C   0x.... 0x....      BL       hci_send_req
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD501             BPL.N    ??hci_le_remove_device_from_resolving_list_0
   1119              return BLE_STATUS_TIMEOUT;
   \   00000054   0x20FF             MOVS     R0,#+255
   \   00000056   0xE007             B.N      ??hci_le_remove_device_from_resolving_list_1
   1120            if (status) {
   \                     ??hci_le_remove_device_from_resolving_list_0: (+1)
   \   00000058   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD002             BEQ.N    ??hci_le_remove_device_from_resolving_list_2
   1121              return status;
   \   00000060   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000064   0xE000             B.N      ??hci_le_remove_device_from_resolving_list_1
   1122            }
   1123            return BLE_STATUS_SUCCESS;
   \                     ??hci_le_remove_device_from_resolving_list_2: (+1)
   \   00000066   0x2000             MOVS     R0,#+0
   \                     ??hci_le_remove_device_from_resolving_list_1: (+1)
   \   00000068   0xB049             ADD      SP,SP,#+292
   \   0000006A   0xBDF0             POP      {R4-R7,PC}       ;; return
   1124          }

   \                                 In section .text, align 2, keep-with-next
   1125          tBleStatus hci_le_clear_resolving_list(void)
   1126          {
   \                     hci_le_clear_resolving_list: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   1127            struct hci_request rq;
   1128            tBleStatus status = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1129            Osal_MemSet(&rq, 0, sizeof(rq));
   \   0000000A   0x2218             MOVS     R2,#+24
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0xA801             ADD      R0,SP,#+4
   \   00000010   0x.... 0x....      BL       Osal_MemSet
   1130            rq.ogf = 0x08;
   \   00000014   0x2008             MOVS     R0,#+8
   \   00000016   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1131            rq.ocf = 0x029;
   \   0000001A   0x2029             MOVS     R0,#+41
   \   0000001C   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1132            rq.rparam = &status;
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x9005             STR      R0,[SP, #+20]
   1133            rq.rlen = 1;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x9006             STR      R0,[SP, #+24]
   1134            if (hci_send_req(&rq, FALSE) < 0)
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0xA801             ADD      R0,SP,#+4
   \   0000002C   0x.... 0x....      BL       hci_send_req
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD501             BPL.N    ??hci_le_clear_resolving_list_0
   1135              return BLE_STATUS_TIMEOUT;
   \   00000034   0x20FF             MOVS     R0,#+255
   \   00000036   0xE007             B.N      ??hci_le_clear_resolving_list_1
   1136            if (status) {
   \                     ??hci_le_clear_resolving_list_0: (+1)
   \   00000038   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD002             BEQ.N    ??hci_le_clear_resolving_list_2
   1137              return status;
   \   00000040   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000044   0xE000             B.N      ??hci_le_clear_resolving_list_1
   1138            }
   1139            return BLE_STATUS_SUCCESS;
   \                     ??hci_le_clear_resolving_list_2: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \                     ??hci_le_clear_resolving_list_1: (+1)
   \   00000048   0xB007             ADD      SP,SP,#+28
   \   0000004A   0xBD00             POP      {PC}             ;; return
   1140          }

   \                                 In section .text, align 2, keep-with-next
   1141          tBleStatus hci_le_read_resolving_list_size(uint8_t *Resolving_List_Size)
   1142          {
   \                     hci_le_read_resolving_list_size: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x0004             MOVS     R4,R0
   1143            struct hci_request rq;
   1144            hci_le_read_resolving_list_size_rp0 resp;
   1145            Osal_MemSet(&resp, 0, sizeof(resp));
   \   00000006   0x2202             MOVS     R2,#+2
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       Osal_MemSet
   1146            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000010   0x2218             MOVS     R2,#+24
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0xA801             ADD      R0,SP,#+4
   \   00000016   0x.... 0x....      BL       Osal_MemSet
   1147            rq.ogf = 0x08;
   \   0000001A   0x2008             MOVS     R0,#+8
   \   0000001C   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1148            rq.ocf = 0x02a;
   \   00000020   0x202A             MOVS     R0,#+42
   \   00000022   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1149            rq.rparam = &resp;
   \   00000026   0x4668             MOV      R0,SP
   \   00000028   0x9005             STR      R0,[SP, #+20]
   1150            rq.rlen = sizeof(resp);
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0x9006             STR      R0,[SP, #+24]
   1151            if (hci_send_req(&rq, FALSE) < 0)
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0xA801             ADD      R0,SP,#+4
   \   00000032   0x.... 0x....      BL       hci_send_req
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD501             BPL.N    ??hci_le_read_resolving_list_size_0
   1152              return BLE_STATUS_TIMEOUT;
   \   0000003A   0x20FF             MOVS     R0,#+255
   \   0000003C   0xE00A             B.N      ??hci_le_read_resolving_list_size_1
   1153            if (resp.Status) {
   \                     ??hci_le_read_resolving_list_size_0: (+1)
   \   0000003E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD002             BEQ.N    ??hci_le_read_resolving_list_size_2
   1154              return resp.Status;
   \   00000046   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004A   0xE003             B.N      ??hci_le_read_resolving_list_size_1
   1155            }
   1156            *Resolving_List_Size = btoh(resp.Resolving_List_Size, 1);
   \                     ??hci_le_read_resolving_list_size_2: (+1)
   \   0000004C   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000050   0x7020             STRB     R0,[R4, #+0]
   1157            return BLE_STATUS_SUCCESS;
   \   00000052   0x2000             MOVS     R0,#+0
   \                     ??hci_le_read_resolving_list_size_1: (+1)
   \   00000054   0xB008             ADD      SP,SP,#+32
   \   00000056   0xBD10             POP      {R4,PC}          ;; return
   1158          }

   \                                 In section .text, align 2, keep-with-next
   1159          tBleStatus hci_le_read_peer_resolvable_address(uint8_t Peer_Identity_Address_Type,
   1160                                                         uint8_t Peer_Identity_Address[6],
   1161                                                         uint8_t Peer_Resolvable_Address[6])
   1162          {
   \                     hci_le_read_peer_resolvable_address: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB0CA             SUB      SP,SP,#+296
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   1163            struct hci_request rq;
   1164            uint8_t cmd_buffer[258];
   1165            hci_le_read_peer_resolvable_address_cp0 *cp0 = (hci_le_read_peer_resolvable_address_cp0*)(cmd_buffer);
   \   0000000C   0xAF08             ADD      R7,SP,#+32
   1166            hci_le_read_peer_resolvable_address_rp0 resp;
   1167            Osal_MemSet(&resp, 0, sizeof(resp));
   \   0000000E   0x2207             MOVS     R2,#+7
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x4668             MOV      R0,SP
   \   00000014   0x.... 0x....      BL       Osal_MemSet
   1168            uint8_t index_input = 0;
   \   00000018   0xF05F 0x0800      MOVS     R8,#+0
   1169            cp0->Peer_Identity_Address_Type = htob(Peer_Identity_Address_Type, 1);
   \   0000001C   0x703C             STRB     R4,[R7, #+0]
   1170            index_input += 1;
   \   0000001E   0xF118 0x0801      ADDS     R8,R8,#+1
   1171            Osal_MemCpy((void *) &cp0->Peer_Identity_Address, (const void *) Peer_Identity_Address, 6);
   \   00000022   0x2206             MOVS     R2,#+6
   \   00000024   0x0029             MOVS     R1,R5
   \   00000026   0x1C78             ADDS     R0,R7,#+1
   \   00000028   0x.... 0x....      BL       Osal_MemCpy
   1172            index_input += 6;
   \   0000002C   0xF118 0x0806      ADDS     R8,R8,#+6
   1173            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000030   0x2218             MOVS     R2,#+24
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0xA802             ADD      R0,SP,#+8
   \   00000036   0x.... 0x....      BL       Osal_MemSet
   1174            rq.ogf = 0x08;
   \   0000003A   0x2008             MOVS     R0,#+8
   \   0000003C   0xF8AD 0x0008      STRH     R0,[SP, #+8]
   1175            rq.ocf = 0x02b;
   \   00000040   0x202B             MOVS     R0,#+43
   \   00000042   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   1176            rq.cparam = cmd_buffer;
   \   00000046   0xA808             ADD      R0,SP,#+32
   \   00000048   0x9004             STR      R0,[SP, #+16]
   1177            rq.clen = index_input;
   \   0000004A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000004E   0xF8CD 0x8014      STR      R8,[SP, #+20]
   1178            rq.rparam = &resp;
   \   00000052   0x4668             MOV      R0,SP
   \   00000054   0x9006             STR      R0,[SP, #+24]
   1179            rq.rlen = sizeof(resp);
   \   00000056   0x2007             MOVS     R0,#+7
   \   00000058   0x9007             STR      R0,[SP, #+28]
   1180            if (hci_send_req(&rq, FALSE) < 0)
   \   0000005A   0x2100             MOVS     R1,#+0
   \   0000005C   0xA802             ADD      R0,SP,#+8
   \   0000005E   0x.... 0x....      BL       hci_send_req
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD501             BPL.N    ??hci_le_read_peer_resolvable_address_0
   1181              return BLE_STATUS_TIMEOUT;
   \   00000066   0x20FF             MOVS     R0,#+255
   \   00000068   0xE00D             B.N      ??hci_le_read_peer_resolvable_address_1
   1182            if (resp.Status) {
   \                     ??hci_le_read_peer_resolvable_address_0: (+1)
   \   0000006A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD002             BEQ.N    ??hci_le_read_peer_resolvable_address_2
   1183              return resp.Status;
   \   00000072   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000076   0xE006             B.N      ??hci_le_read_peer_resolvable_address_1
   1184            }
   1185            Osal_MemCpy((void *) Peer_Resolvable_Address, (const void *) resp.Peer_Resolvable_Address, 6);
   \                     ??hci_le_read_peer_resolvable_address_2: (+1)
   \   00000078   0x2206             MOVS     R2,#+6
   \   0000007A   0xF10D 0x0101      ADD      R1,SP,#+1
   \   0000007E   0x0030             MOVS     R0,R6
   \   00000080   0x.... 0x....      BL       Osal_MemCpy
   1186            return BLE_STATUS_SUCCESS;
   \   00000084   0x2000             MOVS     R0,#+0
   \                     ??hci_le_read_peer_resolvable_address_1: (+1)
   \   00000086   0xB04A             ADD      SP,SP,#+296
   \   00000088   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1187          }

   \                                 In section .text, align 2, keep-with-next
   1188          tBleStatus hci_le_read_local_resolvable_address(uint8_t Peer_Identity_Address_Type,
   1189                                                          uint8_t Peer_Identity_Address[6],
   1190                                                          uint8_t Local_Resolvable_Address[6])
   1191          {
   \                     hci_le_read_local_resolvable_address: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB0CA             SUB      SP,SP,#+296
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   1192            struct hci_request rq;
   1193            uint8_t cmd_buffer[258];
   1194            hci_le_read_local_resolvable_address_cp0 *cp0 = (hci_le_read_local_resolvable_address_cp0*)(cmd_buffer);
   \   0000000C   0xAF08             ADD      R7,SP,#+32
   1195            hci_le_read_local_resolvable_address_rp0 resp;
   1196            Osal_MemSet(&resp, 0, sizeof(resp));
   \   0000000E   0x2207             MOVS     R2,#+7
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x4668             MOV      R0,SP
   \   00000014   0x.... 0x....      BL       Osal_MemSet
   1197            uint8_t index_input = 0;
   \   00000018   0xF05F 0x0800      MOVS     R8,#+0
   1198            cp0->Peer_Identity_Address_Type = htob(Peer_Identity_Address_Type, 1);
   \   0000001C   0x703C             STRB     R4,[R7, #+0]
   1199            index_input += 1;
   \   0000001E   0xF118 0x0801      ADDS     R8,R8,#+1
   1200            Osal_MemCpy((void *) &cp0->Peer_Identity_Address, (const void *) Peer_Identity_Address, 6);
   \   00000022   0x2206             MOVS     R2,#+6
   \   00000024   0x0029             MOVS     R1,R5
   \   00000026   0x1C78             ADDS     R0,R7,#+1
   \   00000028   0x.... 0x....      BL       Osal_MemCpy
   1201            index_input += 6;
   \   0000002C   0xF118 0x0806      ADDS     R8,R8,#+6
   1202            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000030   0x2218             MOVS     R2,#+24
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0xA802             ADD      R0,SP,#+8
   \   00000036   0x.... 0x....      BL       Osal_MemSet
   1203            rq.ogf = 0x08;
   \   0000003A   0x2008             MOVS     R0,#+8
   \   0000003C   0xF8AD 0x0008      STRH     R0,[SP, #+8]
   1204            rq.ocf = 0x02c;
   \   00000040   0x202C             MOVS     R0,#+44
   \   00000042   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   1205            rq.cparam = cmd_buffer;
   \   00000046   0xA808             ADD      R0,SP,#+32
   \   00000048   0x9004             STR      R0,[SP, #+16]
   1206            rq.clen = index_input;
   \   0000004A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000004E   0xF8CD 0x8014      STR      R8,[SP, #+20]
   1207            rq.rparam = &resp;
   \   00000052   0x4668             MOV      R0,SP
   \   00000054   0x9006             STR      R0,[SP, #+24]
   1208            rq.rlen = sizeof(resp);
   \   00000056   0x2007             MOVS     R0,#+7
   \   00000058   0x9007             STR      R0,[SP, #+28]
   1209            if (hci_send_req(&rq, FALSE) < 0)
   \   0000005A   0x2100             MOVS     R1,#+0
   \   0000005C   0xA802             ADD      R0,SP,#+8
   \   0000005E   0x.... 0x....      BL       hci_send_req
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD501             BPL.N    ??hci_le_read_local_resolvable_address_0
   1210              return BLE_STATUS_TIMEOUT;
   \   00000066   0x20FF             MOVS     R0,#+255
   \   00000068   0xE00D             B.N      ??hci_le_read_local_resolvable_address_1
   1211            if (resp.Status) {
   \                     ??hci_le_read_local_resolvable_address_0: (+1)
   \   0000006A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD002             BEQ.N    ??hci_le_read_local_resolvable_address_2
   1212              return resp.Status;
   \   00000072   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000076   0xE006             B.N      ??hci_le_read_local_resolvable_address_1
   1213            }
   1214            Osal_MemCpy((void *) Local_Resolvable_Address, (const void *) resp.Local_Resolvable_Address, 6);
   \                     ??hci_le_read_local_resolvable_address_2: (+1)
   \   00000078   0x2206             MOVS     R2,#+6
   \   0000007A   0xF10D 0x0101      ADD      R1,SP,#+1
   \   0000007E   0x0030             MOVS     R0,R6
   \   00000080   0x.... 0x....      BL       Osal_MemCpy
   1215            return BLE_STATUS_SUCCESS;
   \   00000084   0x2000             MOVS     R0,#+0
   \                     ??hci_le_read_local_resolvable_address_1: (+1)
   \   00000086   0xB04A             ADD      SP,SP,#+296
   \   00000088   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1216          }

   \                                 In section .text, align 2, keep-with-next
   1217          tBleStatus hci_le_set_address_resolution_enable(uint8_t Address_Resolution_Enable)
   1218          {
   \                     hci_le_set_address_resolution_enable: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB0C8             SUB      SP,SP,#+288
   \   00000004   0x0004             MOVS     R4,R0
   1219            struct hci_request rq;
   1220            uint8_t cmd_buffer[258];
   1221            hci_le_set_address_resolution_enable_cp0 *cp0 = (hci_le_set_address_resolution_enable_cp0*)(cmd_buffer);
   \   00000006   0xAD07             ADD      R5,SP,#+28
   1222            tBleStatus status = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1223            uint8_t index_input = 0;
   \   0000000E   0x2600             MOVS     R6,#+0
   1224            cp0->Address_Resolution_Enable = htob(Address_Resolution_Enable, 1);
   \   00000010   0x702C             STRB     R4,[R5, #+0]
   1225            index_input += 1;
   \   00000012   0x1C76             ADDS     R6,R6,#+1
   1226            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000014   0x2218             MOVS     R2,#+24
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0xA801             ADD      R0,SP,#+4
   \   0000001A   0x.... 0x....      BL       Osal_MemSet
   1227            rq.ogf = 0x08;
   \   0000001E   0x2008             MOVS     R0,#+8
   \   00000020   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1228            rq.ocf = 0x02d;
   \   00000024   0x202D             MOVS     R0,#+45
   \   00000026   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1229            rq.cparam = cmd_buffer;
   \   0000002A   0xA807             ADD      R0,SP,#+28
   \   0000002C   0x9003             STR      R0,[SP, #+12]
   1230            rq.clen = index_input;
   \   0000002E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000030   0x9604             STR      R6,[SP, #+16]
   1231            rq.rparam = &status;
   \   00000032   0x4668             MOV      R0,SP
   \   00000034   0x9005             STR      R0,[SP, #+20]
   1232            rq.rlen = 1;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x9006             STR      R0,[SP, #+24]
   1233            if (hci_send_req(&rq, FALSE) < 0)
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0xA801             ADD      R0,SP,#+4
   \   0000003E   0x.... 0x....      BL       hci_send_req
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD501             BPL.N    ??hci_le_set_address_resolution_enable_0
   1234              return BLE_STATUS_TIMEOUT;
   \   00000046   0x20FF             MOVS     R0,#+255
   \   00000048   0xE007             B.N      ??hci_le_set_address_resolution_enable_1
   1235            if (status) {
   \                     ??hci_le_set_address_resolution_enable_0: (+1)
   \   0000004A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD002             BEQ.N    ??hci_le_set_address_resolution_enable_2
   1236              return status;
   \   00000052   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000056   0xE000             B.N      ??hci_le_set_address_resolution_enable_1
   1237            }
   1238            return BLE_STATUS_SUCCESS;
   \                     ??hci_le_set_address_resolution_enable_2: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \                     ??hci_le_set_address_resolution_enable_1: (+1)
   \   0000005A   0xB048             ADD      SP,SP,#+288
   \   0000005C   0xBD70             POP      {R4-R6,PC}       ;; return
   1239          }

   \                                 In section .text, align 2, keep-with-next
   1240          tBleStatus hci_le_set_resolvable_private_address_timeout(uint16_t RPA_Timeout)
   1241          {
   \                     hci_le_set_resolvable_private_address_timeout: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB0C8             SUB      SP,SP,#+288
   \   00000004   0x0004             MOVS     R4,R0
   1242            struct hci_request rq;
   1243            uint8_t cmd_buffer[258];
   1244            hci_le_set_resolvable_private_address_timeout_cp0 *cp0 = (hci_le_set_resolvable_private_address_timeout_cp0*)(cmd_buffer);
   \   00000006   0xAD07             ADD      R5,SP,#+28
   1245            tBleStatus status = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1246            uint8_t index_input = 0;
   \   0000000E   0x2600             MOVS     R6,#+0
   1247            cp0->RPA_Timeout = htob(RPA_Timeout, 2);
   \   00000010   0x802C             STRH     R4,[R5, #+0]
   1248            index_input += 2;
   \   00000012   0x1CB6             ADDS     R6,R6,#+2
   1249            Osal_MemSet(&rq, 0, sizeof(rq));
   \   00000014   0x2218             MOVS     R2,#+24
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0xA801             ADD      R0,SP,#+4
   \   0000001A   0x.... 0x....      BL       Osal_MemSet
   1250            rq.ogf = 0x08;
   \   0000001E   0x2008             MOVS     R0,#+8
   \   00000020   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1251            rq.ocf = 0x02e;
   \   00000024   0x202E             MOVS     R0,#+46
   \   00000026   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1252            rq.cparam = cmd_buffer;
   \   0000002A   0xA807             ADD      R0,SP,#+28
   \   0000002C   0x9003             STR      R0,[SP, #+12]
   1253            rq.clen = index_input;
   \   0000002E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000030   0x9604             STR      R6,[SP, #+16]
   1254            rq.rparam = &status;
   \   00000032   0x4668             MOV      R0,SP
   \   00000034   0x9005             STR      R0,[SP, #+20]
   1255            rq.rlen = 1;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x9006             STR      R0,[SP, #+24]
   1256            if (hci_send_req(&rq, FALSE) < 0)
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0xA801             ADD      R0,SP,#+4
   \   0000003E   0x.... 0x....      BL       hci_send_req
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD501             BPL.N    ??hci_le_set_resolvable_private_address_timeout_0
   1257              return BLE_STATUS_TIMEOUT;
   \   00000046   0x20FF             MOVS     R0,#+255
   \   00000048   0xE007             B.N      ??hci_le_set_resolvable_private_address_timeout_1
   1258            if (status) {
   \                     ??hci_le_set_resolvable_private_address_timeout_0: (+1)
   \   0000004A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD002             BEQ.N    ??hci_le_set_resolvable_private_address_timeout_2
   1259              return status;
   \   00000052   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000056   0xE000             B.N      ??hci_le_set_resolvable_private_address_timeout_1
   1260            }
   1261            return BLE_STATUS_SUCCESS;
   \                     ??hci_le_set_resolvable_private_address_timeout_2: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \                     ??hci_le_set_resolvable_private_address_timeout_1: (+1)
   \   0000005A   0xB048             ADD      SP,SP,#+288
   \   0000005C   0xBD70             POP      {R4-R6,PC}       ;; return
   1262          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     312   hci_disconnect
       312   -> Osal_MemSet
       312   -> hci_send_req
     320   hci_le_add_device_to_resolving_list
       320   -> Osal_MemCpy
       320   -> Osal_MemSet
       320   -> hci_send_req
     312   hci_le_add_device_to_white_list
       312   -> Osal_MemCpy
       312   -> Osal_MemSet
       312   -> hci_send_req
      32   hci_le_clear_resolving_list
        32   -> Osal_MemSet
        32   -> hci_send_req
      32   hci_le_clear_white_list
        32   -> Osal_MemSet
        32   -> hci_send_req
     328   hci_le_connection_update
       328   -> Osal_MemSet
       328   -> hci_send_req
     344   hci_le_create_connection
       344   -> Osal_MemCpy
       344   -> Osal_MemSet
       344   -> hci_send_req
      32   hci_le_create_connection_cancel
        32   -> Osal_MemSet
        32   -> hci_send_req
     328   hci_le_encrypt
       328   -> Osal_MemCpy
       328   -> Osal_MemSet
       328   -> hci_send_req
     304   hci_le_generate_dhkey
       304   -> Osal_MemCpy
       304   -> Osal_MemSet
       304   -> hci_send_req
     312   hci_le_long_term_key_request_reply
       312   -> Osal_MemCpy
       312   -> Osal_MemSet
       312   -> hci_send_req
     304   hci_le_long_term_key_requested_negative_reply
       304   -> Osal_MemSet
       304   -> hci_send_req
      48   hci_le_rand
        48   -> Osal_MemCpy
        48   -> Osal_MemSet
        48   -> hci_send_req
      40   hci_le_read_advertising_channel_tx_power
        40   -> Osal_MemSet
        40   -> hci_send_req
      40   hci_le_read_buffer_size
        40   -> Osal_MemSet
        40   -> hci_send_req
     312   hci_le_read_channel_map
       312   -> Osal_MemCpy
       312   -> Osal_MemSet
       312   -> hci_send_req
      32   hci_le_read_local_p256_public_key
        32   -> Osal_MemSet
        32   -> hci_send_req
     320   hci_le_read_local_resolvable_address
       320   -> Osal_MemCpy
       320   -> Osal_MemSet
       320   -> hci_send_req
      48   hci_le_read_local_supported_features
        48   -> Osal_MemCpy
        48   -> Osal_MemSet
        48   -> hci_send_req
     320   hci_le_read_peer_resolvable_address
       320   -> Osal_MemCpy
       320   -> Osal_MemSet
       320   -> hci_send_req
     304   hci_le_read_remote_used_features
       304   -> Osal_MemSet
       304   -> hci_send_req
      40   hci_le_read_resolving_list_size
        40   -> Osal_MemSet
        40   -> hci_send_req
      48   hci_le_read_supported_states
        48   -> Osal_MemCpy
        48   -> Osal_MemSet
        48   -> hci_send_req
      40   hci_le_read_white_list_size
        40   -> Osal_MemSet
        40   -> hci_send_req
     304   hci_le_receiver_test
       304   -> Osal_MemSet
       304   -> hci_send_req
     312   hci_le_remove_device_from_resolving_list
       312   -> Osal_MemCpy
       312   -> Osal_MemSet
       312   -> hci_send_req
     312   hci_le_remove_device_from_white_list
       312   -> Osal_MemCpy
       312   -> Osal_MemSet
       312   -> hci_send_req
     304   hci_le_set_address_resolution_enable
       304   -> Osal_MemSet
       304   -> hci_send_req
     304   hci_le_set_advertise_enable
       304   -> Osal_MemSet
       304   -> hci_send_req
     312   hci_le_set_advertising_data
       312   -> Osal_MemCpy
       312   -> Osal_MemSet
       312   -> hci_send_req
     336   hci_le_set_advertising_parameters
       336   -> Osal_MemCpy
       336   -> Osal_MemSet
       336   -> hci_send_req
     304   hci_le_set_event_mask
       304   -> Osal_MemCpy
       304   -> Osal_MemSet
       304   -> hci_send_req
     304   hci_le_set_host_channel_classification
       304   -> Osal_MemCpy
       304   -> Osal_MemSet
       304   -> hci_send_req
     304   hci_le_set_random_address
       304   -> Osal_MemCpy
       304   -> Osal_MemSet
       304   -> hci_send_req
     304   hci_le_set_resolvable_private_address_timeout
       304   -> Osal_MemSet
       304   -> hci_send_req
     312   hci_le_set_scan_enable
       312   -> Osal_MemSet
       312   -> hci_send_req
     320   hci_le_set_scan_parameters
       320   -> Osal_MemSet
       320   -> hci_send_req
     312   hci_le_set_scan_response_data
       312   -> Osal_MemCpy
       312   -> Osal_MemSet
       312   -> hci_send_req
     320   hci_le_start_encryption
       320   -> Osal_MemCpy
       320   -> Osal_MemSet
       320   -> hci_send_req
      40   hci_le_test_end
        40   -> Osal_MemSet
        40   -> hci_send_req
     312   hci_le_transmitter_test
       312   -> Osal_MemSet
       312   -> hci_send_req
      40   hci_read_bd_addr
        40   -> Osal_MemCpy
        40   -> Osal_MemSet
        40   -> hci_send_req
     104   hci_read_local_supported_commands
       104   -> Osal_MemCpy
       104   -> Osal_MemSet
       104   -> hci_send_req
      48   hci_read_local_supported_features
        48   -> Osal_MemCpy
        48   -> Osal_MemSet
        48   -> hci_send_req
      64   hci_read_local_version_information
        64   -> Osal_MemSet
        64   -> hci_send_req
     304   hci_read_remote_version_information
       304   -> Osal_MemSet
       304   -> hci_send_req
     312   hci_read_rssi
       312   -> Osal_MemSet
       312   -> hci_send_req
     312   hci_read_transmit_power_level
       312   -> Osal_MemSet
       312   -> hci_send_req
      32   hci_reset
        32   -> Osal_MemSet
        32   -> hci_send_req
     304   hci_set_event_mask
       304   -> Osal_MemCpy
       304   -> Osal_MemSet
       304   -> hci_send_req


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     104  hci_disconnect
     164  hci_le_add_device_to_resolving_list
     108  hci_le_add_device_to_white_list
      76  hci_le_clear_resolving_list
      76  hci_le_clear_white_list
     176  hci_le_connection_update
     244  hci_le_create_connection
      76  hci_le_create_connection_cancel
     150  hci_le_encrypt
     106  hci_le_generate_dhkey
     112  hci_le_long_term_key_request_reply
      98  hci_le_long_term_key_requested_negative_reply
      94  hci_le_rand
      88  hci_le_read_advertising_channel_tx_power
      96  hci_le_read_buffer_size
     112  hci_le_read_channel_map
      80  hci_le_read_local_p256_public_key
     140  hci_le_read_local_resolvable_address
      94  hci_le_read_local_supported_features
     140  hci_le_read_peer_resolvable_address
      98  hci_le_read_remote_used_features
      88  hci_le_read_resolving_list_size
      94  hci_le_read_supported_states
      88  hci_le_read_white_list_size
      94  hci_le_receiver_test
     108  hci_le_remove_device_from_resolving_list
     108  hci_le_remove_device_from_white_list
      94  hci_le_set_address_resolution_enable
      94  hci_le_set_advertise_enable
     108  hci_le_set_advertising_data
     194  hci_le_set_advertising_parameters
     102  hci_le_set_event_mask
     102  hci_le_set_host_channel_classification
     102  hci_le_set_random_address
      94  hci_le_set_resolvable_private_address_timeout
     100  hci_le_set_scan_enable
     150  hci_le_set_scan_parameters
     108  hci_le_set_scan_response_data
     160  hci_le_start_encryption
      88  hci_le_test_end
     122  hci_le_transmitter_test
      94  hci_read_bd_addr
      94  hci_read_local_supported_commands
      94  hci_read_local_supported_features
     128  hci_read_local_version_information
      98  hci_read_remote_version_information
     106  hci_read_rssi
     126  hci_read_transmit_power_level
      76  hci_reset
     102  hci_set_event_mask

 
 5 548 bytes in section .text
 
 5 548 bytes of CODE memory

Errors: none
Warnings: none
