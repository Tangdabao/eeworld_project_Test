###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       29/Jan/2018  14:45:26
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_rcc.c
#    Command line =  
#        "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_rcc.c"
#        -D STM32L151xB -D STM32L1XX_XL -D USE_STM32L1XX_STEVAL_IDB00xV1 -D
#        USE_HAL_DRIVER -D HCLK_32MHZ=1 -D SYSCLK_MSI=1 -D ENABLE_USART -D
#        USER_DEFINED_PLATFORM=USER_EVAL_PLATFORM -D IRQ_RESET_PIN -D DTM_UART
#        -lC "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\List"
#        -o "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        D:\Software\IAR_BlueNRG\arm\INC\c\DLib_Config_Normal.h -I
#        "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\HAL\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\BSP\STM32L1xx_BlueNRG1\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\BSP\STM32L1xx_Nucleo\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\CMSIS\Device\ST\STM32L1xx\Include\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\STM32L1xx_HAL_BlueNRG1_Drivers\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\SimpleBlueNRG1_HCI\includes\"
#        -On --use_c++_inline -I D:\Software\IAR_BlueNRG\arm\CMSIS\Include\
#    Locale       =  Chinese (Simplified)_China.936
#    List file    =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\List\stm32l1xx_hal_rcc.lst
#    Object file  =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\Obj\stm32l1xx_hal_rcc.o
#
###############################################################################

C:\Users\Administrator\Desktop\Temporary Files\eeworld_project\Project_Test\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_rcc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_hal_rcc.c
      4            * @author  MCD Application Team
      5            * @version V1.1.1
      6            * @date    31-March-2015
      7            * @brief   RCC HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Reset and Clock Control (RCC) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + Peripheral Control functions
     12            *       
     13            @verbatim                
     14            ==============================================================================
     15                                ##### RCC specific features #####
     16            ==============================================================================
     17              [..]  
     18                After reset the device is running from multispeed internal oscillator clock 
     19                (MSI 2.097MHz) with Flash 0 wait state and Flash prefetch buffer is disabled, 
     20                and all peripherals are off except internal SRAM, Flash and JTAG.
     21                (+) There is no prescaler on High speed (AHB) and Low speed (APB) busses;
     22                    all peripherals mapped on these busses are running at MSI speed.
     23                (+) The clock for all peripherals is switched off, except the SRAM and FLASH.
     24                (+) All GPIOs are in input floating state, except the JTAG pins which
     25                    are assigned to be used for debug purpose.
     26              [..] Once the device started from reset, the user application has to:
     27                (+) Configure the clock source to be used to drive the System clock
     28                    (if the application needs higher frequency/performance)
     29                (+) Configure the System clock frequency and Flash settings  
     30                (+) Configure the AHB and APB busses prescalers
     31                (+) Enable the clock for the peripheral(s) to be used
     32                (+) Configure the clock source(s) for peripherals whose clocks are not
     33                    derived from the System clock (I2S, RTC, ADC, USB OTG FS/SDIO/RNG) 
     34                    (*) SDIO only for STM32L1xxxD devices
     35          
     36                                ##### RCC Limitations #####
     37            ==============================================================================
     38              [..]  
     39                A delay between an RCC peripheral clock enable and the effective peripheral 
     40                enabling should be taken into account in order to manage the peripheral read/write 
     41                from/to registers.
     42                (+) This delay depends on the peripheral mapping.
     43                  (++) AHB & APB peripherals, 1 dummy read is necessary
     44          
     45              [..]  
     46                Workarounds:
     47                (#) For AHB & APB peripherals, a dummy read to the peripheral register has been
     48                    inserted in each __HAL_RCC_PPP_CLK_ENABLE() macro.
     49          
     50            @endverbatim
     51            ******************************************************************************
     52            * @attention
     53            *
     54            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     55            *
     56            * Redistribution and use in source and binary forms, with or without modification,
     57            * are permitted provided that the following conditions are met:
     58            *   1. Redistributions of source code must retain the above copyright notice,
     59            *      this list of conditions and the following disclaimer.
     60            *   2. Redistributions in binary form must reproduce the above copyright notice,
     61            *      this list of conditions and the following disclaimer in the documentation
     62            *      and/or other materials provided with the distribution.
     63            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     64            *      may be used to endorse or promote products derived from this software
     65            *      without specific prior written permission.
     66            *
     67            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     68            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     69            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     70            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     71            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     72            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     73            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     74            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     75            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     76            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     77            *
     78            ******************************************************************************  
     79          */ 
     80          
     81          /* Includes ------------------------------------------------------------------*/
     82          #include "stm32l1xx_hal.h"
     83          
     84          /** @addtogroup STM32L1xx_HAL_Driver
     85            * @{
     86            */
     87          
     88          /** @defgroup RCC RCC
     89          * @brief RCC HAL module driver
     90            * @{
     91            */
     92          
     93          #ifdef HAL_RCC_MODULE_ENABLED
     94          
     95          /* Private typedef -----------------------------------------------------------*/
     96          /* Private define ------------------------------------------------------------*/
     97          /** @defgroup RCC_Private_Constants RCC Private Constants
     98           * @{
     99           */
    100          /**
    101            * @}
    102            */
    103          /* Private macro -------------------------------------------------------------*/
    104          /** @defgroup RCC_Private_Macros RCC Private Macros
    105            * @{
    106            */
    107          
    108          #define MCO1_CLK_ENABLE()     __HAL_RCC_GPIOA_CLK_ENABLE()
    109          #define MCO1_GPIO_PORT        GPIOA
    110          #define MCO1_PIN              GPIO_PIN_8
    111          
    112          /**
    113            * @}
    114            */
    115          
    116          /* Private variables ---------------------------------------------------------*/
    117          /** @defgroup RCC_Private_Variables RCC Private Variables
    118            * @{
    119            */

   \                                 In section .rodata, align 4
    120          const uint8_t aAPBAHBPrescTable[16]       = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};
   \                     aAPBAHBPrescTable:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9
   \              0x00 0x00    
   \              0x01 0x02    
   \              0x03 0x04    
   \              0x01 0x02    
   \              0x03 0x04    
   \              0x06 0x07    
   \              0x08 0x09    

   \                                 In section .rodata, align 4
    121          const uint8_t aPLLDivisionFactorTable[4]  = {1, 2, 3, 4};
   \                     aPLLDivisionFactorTable:
   \   00000000   0x01 0x02          DC8 1, 2, 3, 4
   \              0x03 0x04    

   \                                 In section .rodata, align 4
    122          const uint8_t aPLLMulFactorTable[9]       = {3, 4, 6, 8, 12, 16, 24, 32, 48};
   \                     aPLLMulFactorTable:
   \   00000000   0x03 0x04          DC8 3, 4, 6, 8, 12, 16, 24, 32, 48, 0, 0, 0
   \              0x06 0x08    
   \              0x0C 0x10    
   \              0x18 0x20    
   \              0x30 0x00    
   \              0x00 0x00    
    123          /**
    124            * @}
    125            */
    126          
    127          /* Private function prototypes -----------------------------------------------*/
    128          /** @defgroup RCC_Private_Functions RCC Private Functions
    129            * @{
    130            */
    131          static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange);
    132          /**
    133            * @}
    134            */
    135          
    136          /* Private functions ---------------------------------------------------------*/
    137          
    138          /** @defgroup RCC_Exported_Functions RCC Exported Functions
    139            * @{
    140            */
    141          
    142          /** @defgroup RCC_Exported_Functions_Group1 Initialization and de-initialization functions 
    143            *  @brief    Initialization and Configuration functions 
    144            *
    145            @verbatim    
    146            ===============================================================================
    147                     ##### Initialization and de-initialization function #####
    148            ===============================================================================
    149              [..]
    150                This section provides functions allowing to configure the internal/external oscillators
    151                (MSI, HSE, HSI, LSE, LSI, PLL, CSS and MCO) and the System busses clocks (SYSCLK, AHB, APB1 
    152                and APB2).
    153          
    154              [..] Internal/external clock and PLL configuration
    155                (#) MSI (Multispeed internal), Seven frequency ranges are available: 65.536 kHz, 
    156                    131.072 kHz, 262.144 kHz, 524.288 kHz, 1.048 MHz, 2.097 MHz (default value) and 4.194 MHz.
    157          
    158                (#) HSI (high-speed internal), 16 MHz factory-trimmed RC used directly or through
    159                    the PLL as System clock source.
    160          
    161                (#) LSI (low-speed internal), ~37 KHz low consumption RC used as IWDG and/or RTC
    162                    clock source.
    163          
    164                (#) HSE (high-speed external), 1 to 24 MHz crystal oscillator used directly or
    165                    through the PLL as System clock source. Can be used also as RTC clock source.
    166          
    167                (#) LSE (low-speed external), 32 KHz oscillator used as RTC clock source.   
    168          
    169                (#) PLL (clocked by HSI or HSE), featuring two different output clocks:
    170                  (++) The first output is used to generate the high speed system clock (up to 32 MHz)
    171                  (++) The second output is used to generate the clock for the USB OTG FS (48 MHz)
    172          
    173                (#) CSS (Clock security system), once enable using the macro __HAL_RCC_CSS_ENABLE()
    174                    and if a HSE clock failure occurs(HSE used directly or through PLL as System 
    175                    clock source), the System clockis automatically switched to MSI and an interrupt
    176                    is generated if enabled. The interrupt is linked to the Cortex-M3 NMI 
    177                    (Non-Maskable Interrupt) exception vector.   
    178          
    179                (#) MCO1 (microcontroller clock output), used to output SYSCLK, HSI, LSI, MSI, LSE, 
    180                    HSE or PLL clock (through a configurable prescaler) on PA8 pin.
    181          
    182              [..] System, AHB and APB busses clocks configuration  
    183                (#) Several clock sources can be used to drive the System clock (SYSCLK): MSI, HSI,
    184                    HSE and PLL.
    185                    The AHB clock (HCLK) is derived from System clock through configurable 
    186                    prescaler and used to clock the CPU, memory and peripherals mapped 
    187                    on AHB bus (DMA, GPIO...). APB1 (PCLK1) and APB2 (PCLK2) clocks are derived 
    188                    from AHB clock through configurable prescalers and used to clock 
    189                    the peripherals mapped on these busses. You can use 
    190                    "HAL_RCC_GetSysClockFreq()" function to retrieve the frequencies of these clocks.  
    191          
    192                -@- All the peripheral clocks are derived from the System clock (SYSCLK) except:
    193                    (+@) RTC: RTC clock can be derived either from the LSI, LSE or HSE clock
    194                        divided by 2 to 16. You have to use __HAL_RCC_RTC_CONFIG() and __HAL_RCC_RTC_ENABLE()
    195                        macros to configure this clock. 
    196                    (+@) LCD: LCD clock can be derived either from the LSI, LSE or HSE clock
    197                        divided by 2 to 16. You have to use __HAL_RCC_LCD_CONFIG()
    198                        macros to configure this clock. 
    199                    (+@) USB OTG FS and RTC: USB OTG FS require a frequency equal to 48 MHz
    200                        to work correctly. This clock is derived of the main PLL through PLL Multiplier.
    201                    (+@) IWDG clock which is always the LSI clock.
    202          
    203                (#) The maximum frequency of the SYSCLK and HCLK is 32 MHz, PCLK2 32 MHz 
    204                    and PCLK1 32 MHz. Depending on the device voltage range, the maximum 
    205                    frequency should be adapted accordingly:
    206            +----------------------------------------------------------------------+     
    207            | Latency       |                HCLK clock frequency (MHz)            |
    208            |               |------------------------------------------------------|     
    209            |               | voltage range 1  | voltage range 2 | voltage range 3 |
    210            |               |      1.8 V       |     1.5 V       |      1.2 V      |
    211            |---------------|------------------|-----------------|-----------------|              
    212            |0WS(1CPU cycle)| 0 < HCLK <= 16   | 0 < HCLK <= 8   | 0 < HCLK <= 2   |
    213            |---------------|------------------|-----------------|-----------------| 
    214            |1WS(2CPU cycle)| 16 < HCLK <= 32  | 8 < HCLK <= 16  | 2 < HCLK <= 4   | 
    215            +----------------------------------------------------------------------+     
    216                (#) The following table gives the different clock source frequencies depending on the product
    217                voltage range:
    218            +------------------------------------------------------------------------------------------+     
    219            | Product voltage |                    Clock frequency                                     |
    220            |                 |------------------|-----------------------------|-----------------------|              
    221            |      range      |   MSI   |   HSI  |              HSE            |          PLL          |
    222            |-----------------|---------|--------|-----------------------------|-----------------------|              
    223            | Range 1 (1.8 V) | 4.2 MHz | 16 MHz | HSE 32 MHz (external clock) |         32 MHz        |
    224            |                 |         |        |      or 24 MHz (crystal)    | (PLLVCO max = 96 MHz) |
    225            |-----------------|---------|--------|-----------------------------|-----------------------|              
    226            | Range 2 (1.5 V) | 4.2 MHz | 16 MHz |         16 MHz              |         16 MHz        |
    227            |                 |         |        |                             | (PLLVCO max = 48 MHz) |
    228            |-----------------|---------|--------|-----------------------------|-----------------------|              
    229            | Range 3 (1.2 V) | 4.2 MHz |   NA   |         8 MHz               |           4 MHz       |
    230            |                 |         |        |                             | (PLLVCO max = 24 MHz) |
    231            +------------------------------------------------------------------------------------------+     
    232            @endverbatim
    233            * @{
    234            */
    235          
    236          /**
    237            * @brief  Resets the RCC clock configuration to the default reset state.
    238            * @note   The default reset state of the clock configuration is given below:
    239            *            - MSI ON and used as system clock source
    240            *            - HSI, HSE and PLL  OFF
    241            *            - AHB, APB1 and APB2 prescaler set to 1.
    242            *            - CSS and MCO1 OFF
    243            *            - All interrupts disabled
    244            * @note   This function doesn't modify the configuration of the
    245            *            - Peripheral clocks  
    246            *            - LSI, LSE and RTC clocks 
    247            * @retval None
    248            */

   \                                 In section .text, align 2, keep-with-next
    249          void HAL_RCC_DeInit(void)
    250          {
    251            /* Set MSION bit */
    252            SET_BIT(RCC->CR, RCC_CR_MSION);
   \                     HAL_RCC_DeInit: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable1  ;; 0x40023800
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable1  ;; 0x40023800
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    253            
    254            /* Switch SYSCLK to MSI*/
    255            CLEAR_BIT(RCC->CFGR, RCC_CFGR_SW);
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable2  ;; 0x40023808
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x0880             LSRS     R0,R0,#+2
   \   00000018   0x0080             LSLS     R0,R0,#+2
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable2  ;; 0x40023808
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    256          
    257            /* Reset HSION, HSEON, CSSON, HSEBYP & PLLON bits */
    258            CLEAR_BIT(RCC->CR, RCC_CR_HSION | RCC_CR_HSEON | RCC_CR_CSSON | RCC_CR_PLLON | RCC_CR_HSEBYP);
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable1  ;; 0x40023800
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable2_1  ;; 0xeefafffe
   \   0000002A   0x4008             ANDS     R0,R1,R0
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable1  ;; 0x40023800
   \   00000030   0x6008             STR      R0,[R1, #+0]
    259            
    260            /* Reset CFGR register */
    261            CLEAR_REG(RCC->CFGR);
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable2  ;; 0x40023808
   \   00000038   0x6008             STR      R0,[R1, #+0]
    262            
    263            /* Set MSIClockRange & MSITRIM[4:0] bits to the reset value */
    264            MODIFY_REG(RCC->ICSCR, (RCC_ICSCR_MSIRANGE | RCC_ICSCR_MSITRIM), (((uint32_t)0 << POSITION_VAL(RCC_ICSCR_MSITRIM)) | RCC_ICSCR_MSIRANGE_5));
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable2_2  ;; 0x40023804
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x21FF             MOVS     R1,#+255
   \   00000042   0xFAB1 0xF181      CLZ      R1,R1
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable2_3  ;; 0xff1fff
   \   0000004A   0x4008             ANDS     R0,R1,R0
   \   0000004C   0xF450 0x4020      ORRS     R0,R0,#0xA000
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable2_2  ;; 0x40023804
   \   00000054   0x6008             STR      R0,[R1, #+0]
    265            
    266            /* Set HSITRIM bits to the reset value */
    267            MODIFY_REG(RCC->ICSCR, RCC_ICSCR_HSITRIM, ((uint32_t)0x10 << POSITION_VAL(RCC_ICSCR_HSITRIM)));
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable2_2  ;; 0x40023804
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0xF430 0x50F8      BICS     R0,R0,#0x1F00
   \   00000060   0x2110             MOVS     R1,#+16
   \   00000062   0xF45F 0x0278      MOVS     R2,#+16252928
   \   00000066   0xFAB2 0xF282      CLZ      R2,R2
   \   0000006A   0x4091             LSLS     R1,R1,R2
   \   0000006C   0x4308             ORRS     R0,R1,R0
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable2_2  ;; 0x40023804
   \   00000072   0x6008             STR      R0,[R1, #+0]
    268            
    269            /* Disable all interrupts */
    270            CLEAR_REG(RCC->CIR);
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable5  ;; 0x4002380c
   \   0000007A   0x6008             STR      R0,[R1, #+0]
    271          }
   \   0000007C   0x4770             BX       LR               ;; return
    272          
    273          /**
    274            * @brief  Initializes the RCC Oscillators according to the specified parameters in the
    275            *         RCC_OscInitTypeDef.
    276            * @param  RCC_OscInitStruct: pointer to an RCC_OscInitTypeDef structure that
    277            *         contains the configuration information for the RCC Oscillators.
    278            * @note   The PLL is not disabled when used as system clock.
    279            * @retval HAL status
    280            */

   \                                 In section .text, align 2, keep-with-next
    281          HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
    282          {
   \                     HAL_RCC_OscConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    283             uint32_t tickstart = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    284            
    285            /* Check the parameters */
    286            assert_param(RCC_OscInitStruct != NULL);
    287            assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
    288            
    289            /*------------------------------- HSE Configuration ------------------------*/ 
    290            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x07C0             LSLS     R0,R0,#+31
   \   0000000A   0xF140 0x80EA      BPL.W    ??HAL_RCC_OscConfig_0
    291            {
    292              /* Check the parameters */
    293              assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    294                  
    295              /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    296              if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
    297                 || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable2  ;; 0x40023808
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   00000018   0x2808             CMP      R0,#+8
   \   0000001A   0xD00B             BEQ.N    ??HAL_RCC_OscConfig_1
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable2  ;; 0x40023808
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   00000026   0x280C             CMP      R0,#+12
   \   00000028   0xD127             BNE.N    ??HAL_RCC_OscConfig_2
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable2  ;; 0x40023808
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x03C0             LSLS     R0,R0,#+15
   \   00000032   0xD522             BPL.N    ??HAL_RCC_OscConfig_2
    298              {
    299                if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
   \                     ??HAL_RCC_OscConfig_1: (+1)
   \   00000034   0xF44F 0x4080      MOV      R0,#+16384
   \   00000038   0xFAB0 0xF080      CLZ      R0,R0
   \   0000003C   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000040   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000042   0x0940             LSRS     R0,R0,#+5
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0x2801             CMP      R0,#+1
   \   00000048   0xD103             BNE.N    ??HAL_RCC_OscConfig_3
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable1  ;; 0x40023800
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0xE002             B.N      ??HAL_RCC_OscConfig_4
   \                     ??HAL_RCC_OscConfig_3: (+1)
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x40023834
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_4: (+1)
   \   00000058   0xF44F 0x4180      MOV      R1,#+16384
   \   0000005C   0xFAB1 0xF181      CLZ      R1,R1
   \   00000060   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000064   0x40C8             LSRS     R0,R0,R1
   \   00000066   0x07C0             LSLS     R0,R0,#+31
   \   00000068   0xF140 0x80BB      BPL.W    ??HAL_RCC_OscConfig_0
   \   0000006C   0x6860             LDR      R0,[R4, #+4]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xF040 0x80B7      BNE.W    ??HAL_RCC_OscConfig_0
    300                {
    301                  return HAL_ERROR;
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xF000 0xBC24      B.W      ??HAL_RCC_OscConfig_5
    302                }
    303              }
    304              else
    305              {
    306                /* Reset HSEON and HSEBYP bits before configuring the HSE --------------*/
    307                __HAL_RCC_HSE_CONFIG(RCC_HSE_OFF);
   \                     ??HAL_RCC_OscConfig_2: (+1)
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable1  ;; 0x40023800
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0xF430 0x3080      BICS     R0,R0,#0x10000
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable1  ;; 0x40023800
   \   00000088   0x6008             STR      R0,[R1, #+0]
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable1  ;; 0x40023800
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0xF430 0x2080      BICS     R0,R0,#0x40000
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable1  ;; 0x40023800
   \   00000098   0x6008             STR      R0,[R1, #+0]
    308                
    309                /* Get Start Tick*/
    310                tickstart = HAL_GetTick();
   \   0000009A   0x.... 0x....      BL       HAL_GetTick
   \   0000009E   0x0005             MOVS     R5,R0
    311                
    312                /* Wait till HSE is disabled */  
    313                while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
   \                     ??HAL_RCC_OscConfig_6: (+1)
   \   000000A0   0xF44F 0x4080      MOV      R0,#+16384
   \   000000A4   0xFAB0 0xF080      CLZ      R0,R0
   \   000000A8   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000000AC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AE   0x0940             LSRS     R0,R0,#+5
   \   000000B0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B2   0x2801             CMP      R0,#+1
   \   000000B4   0xD103             BNE.N    ??HAL_RCC_OscConfig_7
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable1  ;; 0x40023800
   \   000000BA   0x6800             LDR      R0,[R0, #+0]
   \   000000BC   0xE002             B.N      ??HAL_RCC_OscConfig_8
   \                     ??HAL_RCC_OscConfig_7: (+1)
   \   000000BE   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x40023834
   \   000000C2   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_8: (+1)
   \   000000C4   0xF44F 0x4180      MOV      R1,#+16384
   \   000000C8   0xFAB1 0xF181      CLZ      R1,R1
   \   000000CC   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000000D0   0x40C8             LSRS     R0,R0,R1
   \   000000D2   0x07C0             LSLS     R0,R0,#+31
   \   000000D4   0xD508             BPL.N    ??HAL_RCC_OscConfig_9
    314                {
    315                  if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
   \   000000D6   0x.... 0x....      BL       HAL_GetTick
   \   000000DA   0x1B40             SUBS     R0,R0,R5
   \   000000DC   0xF241 0x3189      MOVW     R1,#+5001
   \   000000E0   0x4288             CMP      R0,R1
   \   000000E2   0xD3DD             BCC.N    ??HAL_RCC_OscConfig_6
    316                  {
    317                    return HAL_TIMEOUT;
   \   000000E4   0x2003             MOVS     R0,#+3
   \   000000E6   0xE3EC             B.N      ??HAL_RCC_OscConfig_5
    318                  }
    319                }
    320                
    321                /* Set the new HSE configuration ---------------------------------------*/
    322                __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
   \                     ??HAL_RCC_OscConfig_9: (+1)
   \   000000E8   0x.... 0x....      LDR.W    R0,??DataTable1  ;; 0x40023800
   \   000000EC   0x6800             LDR      R0,[R0, #+0]
   \   000000EE   0xF430 0x3080      BICS     R0,R0,#0x10000
   \   000000F2   0x.... 0x....      LDR.W    R1,??DataTable1  ;; 0x40023800
   \   000000F6   0x6008             STR      R0,[R1, #+0]
   \   000000F8   0x6860             LDR      R0,[R4, #+4]
   \   000000FA   0x2801             CMP      R0,#+1
   \   000000FC   0xD110             BNE.N    ??HAL_RCC_OscConfig_10
   \   000000FE   0x.... 0x....      LDR.W    R0,??DataTable1  ;; 0x40023800
   \   00000102   0x6800             LDR      R0,[R0, #+0]
   \   00000104   0xF430 0x2080      BICS     R0,R0,#0x40000
   \   00000108   0x.... 0x....      LDR.W    R1,??DataTable1  ;; 0x40023800
   \   0000010C   0x6008             STR      R0,[R1, #+0]
   \   0000010E   0x.... 0x....      LDR.W    R0,??DataTable1  ;; 0x40023800
   \   00000112   0x6800             LDR      R0,[R0, #+0]
   \   00000114   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   00000118   0x.... 0x....      LDR.W    R1,??DataTable1  ;; 0x40023800
   \   0000011C   0x6008             STR      R0,[R1, #+0]
   \   0000011E   0xE00F             B.N      ??HAL_RCC_OscConfig_11
   \                     ??HAL_RCC_OscConfig_10: (+1)
   \   00000120   0x6860             LDR      R0,[R4, #+4]
   \   00000122   0x2805             CMP      R0,#+5
   \   00000124   0xD104             BNE.N    ??HAL_RCC_OscConfig_12
   \   00000126   0x6860             LDR      R0,[R4, #+4]
   \   00000128   0x.... 0x....      LDR.W    R1,??DataTable6  ;; 0x40023802
   \   0000012C   0x7008             STRB     R0,[R1, #+0]
   \   0000012E   0xE007             B.N      ??HAL_RCC_OscConfig_11
   \                     ??HAL_RCC_OscConfig_12: (+1)
   \   00000130   0x.... 0x....      LDR.W    R0,??DataTable1  ;; 0x40023800
   \   00000134   0x6800             LDR      R0,[R0, #+0]
   \   00000136   0xF430 0x2080      BICS     R0,R0,#0x40000
   \   0000013A   0x.... 0x....      LDR.W    R1,??DataTable1  ;; 0x40023800
   \   0000013E   0x6008             STR      R0,[R1, #+0]
    323                
    324                /* Check the HSE State */
    325                if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
   \                     ??HAL_RCC_OscConfig_11: (+1)
   \   00000140   0x6860             LDR      R0,[R4, #+4]
   \   00000142   0x2800             CMP      R0,#+0
   \   00000144   0xD026             BEQ.N    ??HAL_RCC_OscConfig_13
    326                {
    327                  /* Get Start Tick*/
    328                  tickstart = HAL_GetTick();
   \   00000146   0x.... 0x....      BL       HAL_GetTick
   \   0000014A   0x0005             MOVS     R5,R0
    329                  
    330                  /* Wait till HSE is ready */  
    331                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
   \                     ??HAL_RCC_OscConfig_14: (+1)
   \   0000014C   0xF44F 0x4080      MOV      R0,#+16384
   \   00000150   0xFAB0 0xF080      CLZ      R0,R0
   \   00000154   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000158   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000015A   0x0940             LSRS     R0,R0,#+5
   \   0000015C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000015E   0x2801             CMP      R0,#+1
   \   00000160   0xD103             BNE.N    ??HAL_RCC_OscConfig_15
   \   00000162   0x.... 0x....      LDR.W    R0,??DataTable1  ;; 0x40023800
   \   00000166   0x6800             LDR      R0,[R0, #+0]
   \   00000168   0xE002             B.N      ??HAL_RCC_OscConfig_16
   \                     ??HAL_RCC_OscConfig_15: (+1)
   \   0000016A   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x40023834
   \   0000016E   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_16: (+1)
   \   00000170   0xF44F 0x4180      MOV      R1,#+16384
   \   00000174   0xFAB1 0xF181      CLZ      R1,R1
   \   00000178   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   0000017C   0x40C8             LSRS     R0,R0,R1
   \   0000017E   0x07C0             LSLS     R0,R0,#+31
   \   00000180   0xD42F             BMI.N    ??HAL_RCC_OscConfig_0
    332                  {
    333                    if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
   \   00000182   0x.... 0x....      BL       HAL_GetTick
   \   00000186   0x1B40             SUBS     R0,R0,R5
   \   00000188   0xF241 0x3189      MOVW     R1,#+5001
   \   0000018C   0x4288             CMP      R0,R1
   \   0000018E   0xD3DD             BCC.N    ??HAL_RCC_OscConfig_14
    334                    {
    335                      return HAL_TIMEOUT;
   \   00000190   0x2003             MOVS     R0,#+3
   \   00000192   0xE396             B.N      ??HAL_RCC_OscConfig_5
    336                    }
    337                  }
    338                }
    339                else
    340                {
    341                  /* Get Start Tick*/
    342                  tickstart = HAL_GetTick();
   \                     ??HAL_RCC_OscConfig_13: (+1)
   \   00000194   0x.... 0x....      BL       HAL_GetTick
   \   00000198   0x0005             MOVS     R5,R0
    343                  
    344                  /* Wait till HSE is bypassed or disabled */
    345                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
   \                     ??HAL_RCC_OscConfig_17: (+1)
   \   0000019A   0xF44F 0x4080      MOV      R0,#+16384
   \   0000019E   0xFAB0 0xF080      CLZ      R0,R0
   \   000001A2   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000001A6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001A8   0x0940             LSRS     R0,R0,#+5
   \   000001AA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001AC   0x2801             CMP      R0,#+1
   \   000001AE   0xD103             BNE.N    ??HAL_RCC_OscConfig_18
   \   000001B0   0x.... 0x....      LDR.W    R0,??DataTable1  ;; 0x40023800
   \   000001B4   0x6800             LDR      R0,[R0, #+0]
   \   000001B6   0xE002             B.N      ??HAL_RCC_OscConfig_19
   \                     ??HAL_RCC_OscConfig_18: (+1)
   \   000001B8   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x40023834
   \   000001BC   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_19: (+1)
   \   000001BE   0xF44F 0x4180      MOV      R1,#+16384
   \   000001C2   0xFAB1 0xF181      CLZ      R1,R1
   \   000001C6   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000001CA   0x40C8             LSRS     R0,R0,R1
   \   000001CC   0x07C0             LSLS     R0,R0,#+31
   \   000001CE   0xD508             BPL.N    ??HAL_RCC_OscConfig_0
    346                  {
    347                     if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
   \   000001D0   0x.... 0x....      BL       HAL_GetTick
   \   000001D4   0x1B40             SUBS     R0,R0,R5
   \   000001D6   0xF241 0x3189      MOVW     R1,#+5001
   \   000001DA   0x4288             CMP      R0,R1
   \   000001DC   0xD3DD             BCC.N    ??HAL_RCC_OscConfig_17
    348                    {
    349                      return HAL_TIMEOUT;
   \   000001DE   0x2003             MOVS     R0,#+3
   \   000001E0   0xE36F             B.N      ??HAL_RCC_OscConfig_5
    350                    }
    351                  }
    352                }
    353              }
    354            }
    355            /*----------------------------- HSI Configuration --------------------------*/ 
    356            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
   \                     ??HAL_RCC_OscConfig_0: (+1)
   \   000001E2   0x7820             LDRB     R0,[R4, #+0]
   \   000001E4   0x0780             LSLS     R0,R0,#+30
   \   000001E6   0xF140 0x80B6      BPL.W    ??HAL_RCC_OscConfig_20
    357            {
    358              /* Check the parameters */
    359              assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    360              assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    361              
    362              /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    363              if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
    364                 || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
   \   000001EA   0x.... 0x....      LDR.W    R0,??DataTable2  ;; 0x40023808
   \   000001EE   0x6800             LDR      R0,[R0, #+0]
   \   000001F0   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   000001F4   0x2804             CMP      R0,#+4
   \   000001F6   0xD00B             BEQ.N    ??HAL_RCC_OscConfig_21
   \   000001F8   0x.... 0x....      LDR.W    R0,??DataTable2  ;; 0x40023808
   \   000001FC   0x6800             LDR      R0,[R0, #+0]
   \   000001FE   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   00000202   0x280C             CMP      R0,#+12
   \   00000204   0xD135             BNE.N    ??HAL_RCC_OscConfig_22
   \   00000206   0x.... 0x....      LDR.W    R0,??DataTable2  ;; 0x40023808
   \   0000020A   0x6800             LDR      R0,[R0, #+0]
   \   0000020C   0x03C0             LSLS     R0,R0,#+15
   \   0000020E   0xD430             BMI.N    ??HAL_RCC_OscConfig_22
    365              {
    366                /* When HSI is used as system clock it will not disabled */
    367                if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
   \                     ??HAL_RCC_OscConfig_21: (+1)
   \   00000210   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   00000214   0xFAB0 0xF080      CLZ      R0,R0
   \   00000218   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000021C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000021E   0x0940             LSRS     R0,R0,#+5
   \   00000220   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000222   0x2801             CMP      R0,#+1
   \   00000224   0xD103             BNE.N    ??HAL_RCC_OscConfig_23
   \   00000226   0x.... 0x....      LDR.W    R0,??DataTable1  ;; 0x40023800
   \   0000022A   0x6800             LDR      R0,[R0, #+0]
   \   0000022C   0xE002             B.N      ??HAL_RCC_OscConfig_24
   \                     ??HAL_RCC_OscConfig_23: (+1)
   \   0000022E   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x40023834
   \   00000232   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_24: (+1)
   \   00000234   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   00000238   0xFAB1 0xF181      CLZ      R1,R1
   \   0000023C   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000240   0x40C8             LSRS     R0,R0,R1
   \   00000242   0x07C0             LSLS     R0,R0,#+31
   \   00000244   0xD504             BPL.N    ??HAL_RCC_OscConfig_25
   \   00000246   0x68E0             LDR      R0,[R4, #+12]
   \   00000248   0x2801             CMP      R0,#+1
   \   0000024A   0xD001             BEQ.N    ??HAL_RCC_OscConfig_25
    368                {
    369                  return HAL_ERROR;
   \   0000024C   0x2001             MOVS     R0,#+1
   \   0000024E   0xE338             B.N      ??HAL_RCC_OscConfig_5
    370                }
    371                /* Otherwise, just the calibration is allowed */
    372                else
    373                {
    374                  /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
    375                  __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
   \                     ??HAL_RCC_OscConfig_25: (+1)
   \   00000250   0x.... 0x....      LDR.W    R0,??DataTable2_2  ;; 0x40023804
   \   00000254   0x6800             LDR      R0,[R0, #+0]
   \   00000256   0xF45F 0x0178      MOVS     R1,#+16252928
   \   0000025A   0xFAB1 0xF181      CLZ      R1,R1
   \   0000025E   0xF430 0x50F8      BICS     R0,R0,#0x1F00
   \   00000262   0x6922             LDR      R2,[R4, #+16]
   \   00000264   0xFA12 0xF101      LSLS     R1,R2,R1
   \   00000268   0x4308             ORRS     R0,R1,R0
   \   0000026A   0x.... 0x....      LDR.W    R1,??DataTable2_2  ;; 0x40023804
   \   0000026E   0x6008             STR      R0,[R1, #+0]
   \   00000270   0xE071             B.N      ??HAL_RCC_OscConfig_20
    376                }
    377              }
    378              else
    379              {
    380                /* Check the HSI State */
    381                if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
   \                     ??HAL_RCC_OscConfig_22: (+1)
   \   00000272   0x68E0             LDR      R0,[R4, #+12]
   \   00000274   0x2800             CMP      R0,#+0
   \   00000276   0xD03F             BEQ.N    ??HAL_RCC_OscConfig_26
    382                {
    383                 /* Enable the Internal High Speed oscillator (HSI). */
    384                  __HAL_RCC_HSI_ENABLE();
   \   00000278   0x2001             MOVS     R0,#+1
   \   0000027A   0xF05F 0x4100      MOVS     R1,#-2147483648
   \   0000027E   0xFAB1 0xF181      CLZ      R1,R1
   \   00000282   0x.... 0x....      LDR.W    R2,??DataTable9  ;; 0x42470000
   \   00000286   0xEB12 0x0181      ADDS     R1,R2,R1, LSL #+2
   \   0000028A   0x6008             STR      R0,[R1, #+0]
    385                  
    386                  /* Get Start Tick*/
    387                  tickstart = HAL_GetTick();
   \   0000028C   0x.... 0x....      BL       HAL_GetTick
   \   00000290   0x0005             MOVS     R5,R0
    388                  
    389                  /* Wait till HSI is ready */  
    390                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
   \                     ??HAL_RCC_OscConfig_27: (+1)
   \   00000292   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   00000296   0xFAB0 0xF080      CLZ      R0,R0
   \   0000029A   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000029E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002A0   0x0940             LSRS     R0,R0,#+5
   \   000002A2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002A4   0x2801             CMP      R0,#+1
   \   000002A6   0xD103             BNE.N    ??HAL_RCC_OscConfig_28
   \   000002A8   0x.... 0x....      LDR.W    R0,??DataTable1  ;; 0x40023800
   \   000002AC   0x6800             LDR      R0,[R0, #+0]
   \   000002AE   0xE002             B.N      ??HAL_RCC_OscConfig_29
   \                     ??HAL_RCC_OscConfig_28: (+1)
   \   000002B0   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x40023834
   \   000002B4   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_29: (+1)
   \   000002B6   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   000002BA   0xFAB1 0xF181      CLZ      R1,R1
   \   000002BE   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000002C2   0x40C8             LSRS     R0,R0,R1
   \   000002C4   0x07C0             LSLS     R0,R0,#+31
   \   000002C6   0xD406             BMI.N    ??HAL_RCC_OscConfig_30
    391                  {
    392                    if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
   \   000002C8   0x.... 0x....      BL       HAL_GetTick
   \   000002CC   0x1B40             SUBS     R0,R0,R5
   \   000002CE   0x2865             CMP      R0,#+101
   \   000002D0   0xD3DF             BCC.N    ??HAL_RCC_OscConfig_27
    393                    {
    394                      return HAL_TIMEOUT;
   \   000002D2   0x2003             MOVS     R0,#+3
   \   000002D4   0xE2F5             B.N      ??HAL_RCC_OscConfig_5
    395                    }
    396                  }
    397                          
    398                  /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
    399                  __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
   \                     ??HAL_RCC_OscConfig_30: (+1)
   \   000002D6   0x.... 0x....      LDR.W    R0,??DataTable2_2  ;; 0x40023804
   \   000002DA   0x6800             LDR      R0,[R0, #+0]
   \   000002DC   0xF45F 0x0178      MOVS     R1,#+16252928
   \   000002E0   0xFAB1 0xF181      CLZ      R1,R1
   \   000002E4   0xF430 0x50F8      BICS     R0,R0,#0x1F00
   \   000002E8   0x6922             LDR      R2,[R4, #+16]
   \   000002EA   0xFA12 0xF101      LSLS     R1,R2,R1
   \   000002EE   0x4308             ORRS     R0,R1,R0
   \   000002F0   0x.... 0x....      LDR.W    R1,??DataTable2_2  ;; 0x40023804
   \   000002F4   0x6008             STR      R0,[R1, #+0]
   \   000002F6   0xE02E             B.N      ??HAL_RCC_OscConfig_20
    400                }
    401                else
    402                {
    403                  /* Disable the Internal High Speed oscillator (HSI). */
    404                  __HAL_RCC_HSI_DISABLE();
   \                     ??HAL_RCC_OscConfig_26: (+1)
   \   000002F8   0x2000             MOVS     R0,#+0
   \   000002FA   0xF05F 0x4100      MOVS     R1,#-2147483648
   \   000002FE   0xFAB1 0xF181      CLZ      R1,R1
   \   00000302   0x.... 0x....      LDR.W    R2,??DataTable9  ;; 0x42470000
   \   00000306   0xEB12 0x0181      ADDS     R1,R2,R1, LSL #+2
   \   0000030A   0x6008             STR      R0,[R1, #+0]
    405                  
    406                  /* Get Start Tick*/
    407                  tickstart = HAL_GetTick();
   \   0000030C   0x.... 0x....      BL       HAL_GetTick
   \   00000310   0x0005             MOVS     R5,R0
    408                  
    409                  /* Wait till HSI is disabled */  
    410                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
   \                     ??HAL_RCC_OscConfig_31: (+1)
   \   00000312   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   00000316   0xFAB0 0xF080      CLZ      R0,R0
   \   0000031A   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000031E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000320   0x0940             LSRS     R0,R0,#+5
   \   00000322   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000324   0x2801             CMP      R0,#+1
   \   00000326   0xD103             BNE.N    ??HAL_RCC_OscConfig_32
   \   00000328   0x.... 0x....      LDR.W    R0,??DataTable1  ;; 0x40023800
   \   0000032C   0x6800             LDR      R0,[R0, #+0]
   \   0000032E   0xE002             B.N      ??HAL_RCC_OscConfig_33
   \                     ??HAL_RCC_OscConfig_32: (+1)
   \   00000330   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x40023834
   \   00000334   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_33: (+1)
   \   00000336   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   0000033A   0xFAB1 0xF181      CLZ      R1,R1
   \   0000033E   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000342   0x40C8             LSRS     R0,R0,R1
   \   00000344   0x07C0             LSLS     R0,R0,#+31
   \   00000346   0xD506             BPL.N    ??HAL_RCC_OscConfig_20
    411                  {
    412                    if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
   \   00000348   0x.... 0x....      BL       HAL_GetTick
   \   0000034C   0x1B40             SUBS     R0,R0,R5
   \   0000034E   0x2865             CMP      R0,#+101
   \   00000350   0xD3DF             BCC.N    ??HAL_RCC_OscConfig_31
    413                    {
    414                      return HAL_TIMEOUT;
   \   00000352   0x2003             MOVS     R0,#+3
   \   00000354   0xE2B5             B.N      ??HAL_RCC_OscConfig_5
    415                    }
    416                  }
    417                }
    418              }
    419            }
    420            /*----------------------------- MSI Configuration --------------------------*/ 
    421            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
   \                     ??HAL_RCC_OscConfig_20: (+1)
   \   00000356   0x7820             LDRB     R0,[R4, #+0]
   \   00000358   0x06C0             LSLS     R0,R0,#+27
   \   0000035A   0xF140 0x80EE      BPL.W    ??HAL_RCC_OscConfig_34
    422            {
    423              /* Check the parameters */
    424              assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));
    425              assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
    426              assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));
    427          
    428              /* When the MSI is used as system clock it will not be disabled */
    429              if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) )
   \   0000035E   0x.... 0x....      LDR.W    R0,??DataTable2  ;; 0x40023808
   \   00000362   0x6800             LDR      R0,[R0, #+0]
   \   00000364   0xF010 0x0F0C      TST      R0,#0xC
   \   00000368   0xD16C             BNE.N    ??HAL_RCC_OscConfig_35
    430              {
    431                if((__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
   \   0000036A   0xF45F 0x0080      MOVS     R0,#+4194304
   \   0000036E   0xFAB0 0xF080      CLZ      R0,R0
   \   00000372   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000376   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000378   0x0940             LSRS     R0,R0,#+5
   \   0000037A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000037C   0x2801             CMP      R0,#+1
   \   0000037E   0xD103             BNE.N    ??HAL_RCC_OscConfig_36
   \   00000380   0x.... 0x....      LDR.W    R0,??DataTable1  ;; 0x40023800
   \   00000384   0x6800             LDR      R0,[R0, #+0]
   \   00000386   0xE002             B.N      ??HAL_RCC_OscConfig_37
   \                     ??HAL_RCC_OscConfig_36: (+1)
   \   00000388   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x40023834
   \   0000038C   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_37: (+1)
   \   0000038E   0xF45F 0x0180      MOVS     R1,#+4194304
   \   00000392   0xFAB1 0xF181      CLZ      R1,R1
   \   00000396   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   0000039A   0x40C8             LSRS     R0,R0,R1
   \   0000039C   0x07C0             LSLS     R0,R0,#+31
   \   0000039E   0xD504             BPL.N    ??HAL_RCC_OscConfig_38
   \   000003A0   0x69A0             LDR      R0,[R4, #+24]
   \   000003A2   0x2800             CMP      R0,#+0
   \   000003A4   0xD101             BNE.N    ??HAL_RCC_OscConfig_38
    432                {
    433                  return HAL_ERROR;
   \   000003A6   0x2001             MOVS     R0,#+1
   \   000003A8   0xE28B             B.N      ??HAL_RCC_OscConfig_5
    434                }
    435          
    436                 /* Otherwise, just the calibration and MSI range change are allowed */
    437                else
    438                {
    439                  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    440                     must be correctly programmed according to the frequency of the CPU clock
    441                     (HCLK) and the supply voltage of the device. */
    442                  if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
   \                     ??HAL_RCC_OscConfig_38: (+1)
   \   000003AA   0x.... 0x....      LDR.W    R0,??DataTable2_2  ;; 0x40023804
   \   000003AE   0x6800             LDR      R0,[R0, #+0]
   \   000003B0   0xF410 0x4060      ANDS     R0,R0,#0xE000
   \   000003B4   0x6A21             LDR      R1,[R4, #+32]
   \   000003B6   0x4288             CMP      R0,R1
   \   000003B8   0xD220             BCS.N    ??HAL_RCC_OscConfig_39
    443                  {
    444                    /* First increase number of wait states update if necessary */
    445                    if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
   \   000003BA   0x6A20             LDR      R0,[R4, #+32]
   \   000003BC   0x.... 0x....      BL       RCC_SetFlashLatencyFromMSIRange
   \   000003C0   0x2800             CMP      R0,#+0
   \   000003C2   0xD001             BEQ.N    ??HAL_RCC_OscConfig_40
    446                    {
    447                      return HAL_ERROR;
   \   000003C4   0x2001             MOVS     R0,#+1
   \   000003C6   0xE27C             B.N      ??HAL_RCC_OscConfig_5
    448                    }
    449          
    450                    /* Selects the Multiple Speed oscillator (MSI) clock range .*/
    451                    __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
   \                     ??HAL_RCC_OscConfig_40: (+1)
   \   000003C8   0x.... 0x....      LDR.W    R0,??DataTable2_2  ;; 0x40023804
   \   000003CC   0x6800             LDR      R0,[R0, #+0]
   \   000003CE   0xF430 0x4060      BICS     R0,R0,#0xE000
   \   000003D2   0x6A21             LDR      R1,[R4, #+32]
   \   000003D4   0x4308             ORRS     R0,R1,R0
   \   000003D6   0x.... 0x....      LDR.W    R1,??DataTable2_2  ;; 0x40023804
   \   000003DA   0x6008             STR      R0,[R1, #+0]
    452                    /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
    453                    __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
   \   000003DC   0x.... 0x....      LDR.W    R0,??DataTable2_2  ;; 0x40023804
   \   000003E0   0x6800             LDR      R0,[R0, #+0]
   \   000003E2   0x21FF             MOVS     R1,#+255
   \   000003E4   0xFAB1 0xF181      CLZ      R1,R1
   \   000003E8   0xF020 0x407F      BIC      R0,R0,#0xFF000000
   \   000003EC   0x69E2             LDR      R2,[R4, #+28]
   \   000003EE   0xFA12 0xF101      LSLS     R1,R2,R1
   \   000003F2   0x4308             ORRS     R0,R1,R0
   \   000003F4   0x.... 0x....      LDR.W    R1,??DataTable2_2  ;; 0x40023804
   \   000003F8   0x6008             STR      R0,[R1, #+0]
   \   000003FA   0xE01F             B.N      ??HAL_RCC_OscConfig_41
    454                  }
    455                  else
    456                  {
    457                    /* Else, keep current flash latency while decreasing applies */
    458                    /* Selects the Multiple Speed oscillator (MSI) clock range .*/
    459                    __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
   \                     ??HAL_RCC_OscConfig_39: (+1)
   \   000003FC   0x.... 0x....      LDR.W    R0,??DataTable2_2  ;; 0x40023804
   \   00000400   0x6800             LDR      R0,[R0, #+0]
   \   00000402   0xF430 0x4060      BICS     R0,R0,#0xE000
   \   00000406   0x6A21             LDR      R1,[R4, #+32]
   \   00000408   0x4308             ORRS     R0,R1,R0
   \   0000040A   0x.... 0x....      LDR.W    R1,??DataTable2_2  ;; 0x40023804
   \   0000040E   0x6008             STR      R0,[R1, #+0]
    460                    /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
    461                    __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
   \   00000410   0x.... 0x....      LDR.W    R0,??DataTable2_2  ;; 0x40023804
   \   00000414   0x6800             LDR      R0,[R0, #+0]
   \   00000416   0x21FF             MOVS     R1,#+255
   \   00000418   0xFAB1 0xF181      CLZ      R1,R1
   \   0000041C   0xF020 0x407F      BIC      R0,R0,#0xFF000000
   \   00000420   0x69E2             LDR      R2,[R4, #+28]
   \   00000422   0xFA12 0xF101      LSLS     R1,R2,R1
   \   00000426   0x4308             ORRS     R0,R1,R0
   \   00000428   0x.... 0x....      LDR.W    R1,??DataTable2_2  ;; 0x40023804
   \   0000042C   0x6008             STR      R0,[R1, #+0]
    462          
    463                    /* Decrease number of wait states update if necessary */
    464                    if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
   \   0000042E   0x6A20             LDR      R0,[R4, #+32]
   \   00000430   0x.... 0x....      BL       RCC_SetFlashLatencyFromMSIRange
   \   00000434   0x2800             CMP      R0,#+0
   \   00000436   0xD001             BEQ.N    ??HAL_RCC_OscConfig_41
    465                    {
    466                      return HAL_ERROR;
   \   00000438   0x2001             MOVS     R0,#+1
   \   0000043A   0xE242             B.N      ??HAL_RCC_OscConfig_5
    467                    }          
    468                  }
    469          
    470                  /* Configure the source of time base considering new system clocks settings*/
    471                  HAL_InitTick (TICK_INT_PRIORITY);
   \                     ??HAL_RCC_OscConfig_41: (+1)
   \   0000043C   0x2000             MOVS     R0,#+0
   \   0000043E   0x.... 0x....      BL       HAL_InitTick
   \   00000442   0xE07A             B.N      ??HAL_RCC_OscConfig_34
    472                }
    473              }
    474              else
    475              {
    476                /* Check the MSI State */
    477                if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
   \                     ??HAL_RCC_OscConfig_35: (+1)
   \   00000444   0x69A0             LDR      R0,[R4, #+24]
   \   00000446   0x2800             CMP      R0,#+0
   \   00000448   0xD048             BEQ.N    ??HAL_RCC_OscConfig_42
    478                {
    479                  /* Enable the Multi Speed oscillator (MSI). */
    480                  __HAL_RCC_MSI_ENABLE();
   \   0000044A   0x2001             MOVS     R0,#+1
   \   0000044C   0xF45F 0x0100      MOVS     R1,#+8388608
   \   00000450   0xFAB1 0xF181      CLZ      R1,R1
   \   00000454   0x.... 0x....      LDR.W    R2,??DataTable9  ;; 0x42470000
   \   00000458   0xEB12 0x0181      ADDS     R1,R2,R1, LSL #+2
   \   0000045C   0x6008             STR      R0,[R1, #+0]
    481          
    482                  /* Get timeout */
    483                  tickstart = HAL_GetTick();
   \   0000045E   0x.... 0x....      BL       HAL_GetTick
   \   00000462   0x0005             MOVS     R5,R0
    484          
    485                  /* Wait till MSI is ready */
    486                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
   \                     ??HAL_RCC_OscConfig_43: (+1)
   \   00000464   0xF45F 0x0080      MOVS     R0,#+4194304
   \   00000468   0xFAB0 0xF080      CLZ      R0,R0
   \   0000046C   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000470   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000472   0x0940             LSRS     R0,R0,#+5
   \   00000474   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000476   0x2801             CMP      R0,#+1
   \   00000478   0xD103             BNE.N    ??HAL_RCC_OscConfig_44
   \   0000047A   0x.... 0x....      LDR.W    R0,??DataTable1  ;; 0x40023800
   \   0000047E   0x6800             LDR      R0,[R0, #+0]
   \   00000480   0xE002             B.N      ??HAL_RCC_OscConfig_45
   \                     ??HAL_RCC_OscConfig_44: (+1)
   \   00000482   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x40023834
   \   00000486   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_45: (+1)
   \   00000488   0xF45F 0x0180      MOVS     R1,#+4194304
   \   0000048C   0xFAB1 0xF181      CLZ      R1,R1
   \   00000490   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000494   0x40C8             LSRS     R0,R0,R1
   \   00000496   0x07C0             LSLS     R0,R0,#+31
   \   00000498   0xD406             BMI.N    ??HAL_RCC_OscConfig_46
    487                  {
    488                    if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
   \   0000049A   0x.... 0x....      BL       HAL_GetTick
   \   0000049E   0x1B40             SUBS     R0,R0,R5
   \   000004A0   0x2865             CMP      R0,#+101
   \   000004A2   0xD3DF             BCC.N    ??HAL_RCC_OscConfig_43
    489                    {
    490                      return HAL_TIMEOUT;
   \   000004A4   0x2003             MOVS     R0,#+3
   \   000004A6   0xE20C             B.N      ??HAL_RCC_OscConfig_5
    491                    }
    492                  }
    493                   /* Selects the Multiple Speed oscillator (MSI) clock range .*/
    494                  __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
   \                     ??HAL_RCC_OscConfig_46: (+1)
   \   000004A8   0x.... 0x....      LDR.W    R0,??DataTable2_2  ;; 0x40023804
   \   000004AC   0x6800             LDR      R0,[R0, #+0]
   \   000004AE   0xF430 0x4060      BICS     R0,R0,#0xE000
   \   000004B2   0x6A21             LDR      R1,[R4, #+32]
   \   000004B4   0x4308             ORRS     R0,R1,R0
   \   000004B6   0x.... 0x....      LDR.W    R1,??DataTable2_2  ;; 0x40023804
   \   000004BA   0x6008             STR      R0,[R1, #+0]
    495                   /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
    496                  __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
   \   000004BC   0x.... 0x....      LDR.W    R0,??DataTable2_2  ;; 0x40023804
   \   000004C0   0x6800             LDR      R0,[R0, #+0]
   \   000004C2   0x21FF             MOVS     R1,#+255
   \   000004C4   0xFAB1 0xF181      CLZ      R1,R1
   \   000004C8   0xF020 0x407F      BIC      R0,R0,#0xFF000000
   \   000004CC   0x69E2             LDR      R2,[R4, #+28]
   \   000004CE   0xFA12 0xF101      LSLS     R1,R2,R1
   \   000004D2   0x4308             ORRS     R0,R1,R0
   \   000004D4   0x.... 0x....      LDR.W    R1,??DataTable2_2  ;; 0x40023804
   \   000004D8   0x6008             STR      R0,[R1, #+0]
   \   000004DA   0xE02E             B.N      ??HAL_RCC_OscConfig_34
    497          
    498                }
    499                else
    500                {
    501                  /* Disable the Multi Speed oscillator (MSI). */
    502                  __HAL_RCC_MSI_DISABLE();
   \                     ??HAL_RCC_OscConfig_42: (+1)
   \   000004DC   0x2000             MOVS     R0,#+0
   \   000004DE   0xF45F 0x0100      MOVS     R1,#+8388608
   \   000004E2   0xFAB1 0xF181      CLZ      R1,R1
   \   000004E6   0x.... 0x....      LDR.W    R2,??DataTable9  ;; 0x42470000
   \   000004EA   0xEB12 0x0181      ADDS     R1,R2,R1, LSL #+2
   \   000004EE   0x6008             STR      R0,[R1, #+0]
    503          
    504                  /* Get timeout */
    505                  tickstart = HAL_GetTick();
   \   000004F0   0x.... 0x....      BL       HAL_GetTick
   \   000004F4   0x0005             MOVS     R5,R0
    506          
    507                  /* Wait till MSI is ready */
    508                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET)
   \                     ??HAL_RCC_OscConfig_47: (+1)
   \   000004F6   0xF45F 0x0080      MOVS     R0,#+4194304
   \   000004FA   0xFAB0 0xF080      CLZ      R0,R0
   \   000004FE   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000502   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000504   0x0940             LSRS     R0,R0,#+5
   \   00000506   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000508   0x2801             CMP      R0,#+1
   \   0000050A   0xD103             BNE.N    ??HAL_RCC_OscConfig_48
   \   0000050C   0x.... 0x....      LDR.W    R0,??DataTable1  ;; 0x40023800
   \   00000510   0x6800             LDR      R0,[R0, #+0]
   \   00000512   0xE002             B.N      ??HAL_RCC_OscConfig_49
   \                     ??HAL_RCC_OscConfig_48: (+1)
   \   00000514   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x40023834
   \   00000518   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_49: (+1)
   \   0000051A   0xF45F 0x0180      MOVS     R1,#+4194304
   \   0000051E   0xFAB1 0xF181      CLZ      R1,R1
   \   00000522   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000526   0x40C8             LSRS     R0,R0,R1
   \   00000528   0x07C0             LSLS     R0,R0,#+31
   \   0000052A   0xD506             BPL.N    ??HAL_RCC_OscConfig_34
    509                  {
    510                    if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
   \   0000052C   0x.... 0x....      BL       HAL_GetTick
   \   00000530   0x1B40             SUBS     R0,R0,R5
   \   00000532   0x2865             CMP      R0,#+101
   \   00000534   0xD3DF             BCC.N    ??HAL_RCC_OscConfig_47
    511                    {
    512                      return HAL_TIMEOUT;
   \   00000536   0x2003             MOVS     R0,#+3
   \   00000538   0xE1C3             B.N      ??HAL_RCC_OscConfig_5
    513                    }
    514                  }
    515                }
    516              }
    517            }  
    518            /*------------------------------ LSI Configuration -------------------------*/ 
    519            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
   \                     ??HAL_RCC_OscConfig_34: (+1)
   \   0000053A   0x7820             LDRB     R0,[R4, #+0]
   \   0000053C   0x0700             LSLS     R0,R0,#+28
   \   0000053E   0xD54A             BPL.N    ??HAL_RCC_OscConfig_50
    520            {
    521              /* Check the parameters */
    522              assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
    523              
    524              /* Check the LSI State */
    525              if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
   \   00000540   0x6960             LDR      R0,[R4, #+20]
   \   00000542   0x2800             CMP      R0,#+0
   \   00000544   0xD023             BEQ.N    ??HAL_RCC_OscConfig_51
    526              {
    527                /* Enable the Internal Low Speed oscillator (LSI). */
    528                __HAL_RCC_LSI_ENABLE();
   \   00000546   0x2001             MOVS     R0,#+1
   \   00000548   0xF05F 0x4100      MOVS     R1,#-2147483648
   \   0000054C   0xFAB1 0xF181      CLZ      R1,R1
   \   00000550   0x.... 0x....      LDR.W    R2,??DataTable13  ;; 0x42470680
   \   00000554   0xEB12 0x0181      ADDS     R1,R2,R1, LSL #+2
   \   00000558   0x6008             STR      R0,[R1, #+0]
    529                
    530                /* Get Start Tick*/
    531                tickstart = HAL_GetTick();
   \   0000055A   0x.... 0x....      BL       HAL_GetTick
   \   0000055E   0x0005             MOVS     R5,R0
    532                
    533                /* Wait till LSI is ready */  
    534                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
   \                     ??HAL_RCC_OscConfig_52: (+1)
   \   00000560   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   00000564   0xFAB0 0xF080      CLZ      R0,R0
   \   00000568   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x40023834
   \   0000056C   0x6800             LDR      R0,[R0, #+0]
   \   0000056E   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   00000572   0xFAB1 0xF181      CLZ      R1,R1
   \   00000576   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   0000057A   0x40C8             LSRS     R0,R0,R1
   \   0000057C   0x07C0             LSLS     R0,R0,#+31
   \   0000057E   0xD42A             BMI.N    ??HAL_RCC_OscConfig_50
    535                {
    536                  if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
   \   00000580   0x.... 0x....      BL       HAL_GetTick
   \   00000584   0x1B40             SUBS     R0,R0,R5
   \   00000586   0x2865             CMP      R0,#+101
   \   00000588   0xD3EA             BCC.N    ??HAL_RCC_OscConfig_52
    537                  {
    538                    return HAL_TIMEOUT;
   \   0000058A   0x2003             MOVS     R0,#+3
   \   0000058C   0xE199             B.N      ??HAL_RCC_OscConfig_5
    539                  }
    540                }
    541              }
    542              else
    543              {
    544                /* Disable the Internal Low Speed oscillator (LSI). */
    545                __HAL_RCC_LSI_DISABLE();
   \                     ??HAL_RCC_OscConfig_51: (+1)
   \   0000058E   0x2000             MOVS     R0,#+0
   \   00000590   0xF05F 0x4100      MOVS     R1,#-2147483648
   \   00000594   0xFAB1 0xF181      CLZ      R1,R1
   \   00000598   0x.... 0x....      LDR.W    R2,??DataTable13  ;; 0x42470680
   \   0000059C   0xEB12 0x0181      ADDS     R1,R2,R1, LSL #+2
   \   000005A0   0x6008             STR      R0,[R1, #+0]
    546                
    547                /* Get Start Tick*/
    548                tickstart = HAL_GetTick();
   \   000005A2   0x.... 0x....      BL       HAL_GetTick
   \   000005A6   0x0005             MOVS     R5,R0
    549                
    550                /* Wait till LSI is disabled */  
    551                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
   \                     ??HAL_RCC_OscConfig_53: (+1)
   \   000005A8   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   000005AC   0xFAB0 0xF080      CLZ      R0,R0
   \   000005B0   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x40023834
   \   000005B4   0x6800             LDR      R0,[R0, #+0]
   \   000005B6   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   000005BA   0xFAB1 0xF181      CLZ      R1,R1
   \   000005BE   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000005C2   0x40C8             LSRS     R0,R0,R1
   \   000005C4   0x07C0             LSLS     R0,R0,#+31
   \   000005C6   0xD506             BPL.N    ??HAL_RCC_OscConfig_50
    552                {
    553                  if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
   \   000005C8   0x.... 0x....      BL       HAL_GetTick
   \   000005CC   0x1B40             SUBS     R0,R0,R5
   \   000005CE   0x2865             CMP      R0,#+101
   \   000005D0   0xD3EA             BCC.N    ??HAL_RCC_OscConfig_53
    554                  {
    555                    return HAL_TIMEOUT;
   \   000005D2   0x2003             MOVS     R0,#+3
   \   000005D4   0xE175             B.N      ??HAL_RCC_OscConfig_5
    556                  }
    557                }
    558              }
    559            }
    560            /*------------------------------ LSE Configuration -------------------------*/ 
    561            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
   \                     ??HAL_RCC_OscConfig_50: (+1)
   \   000005D6   0x7820             LDRB     R0,[R4, #+0]
   \   000005D8   0x0740             LSLS     R0,R0,#+29
   \   000005DA   0xF140 0x80D1      BPL.W    ??HAL_RCC_OscConfig_54
    562            {
    563              /* Check the parameters */
    564              assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    565              
    566              /* Enable Power Clock*/
    567              __HAL_RCC_PWR_CLK_ENABLE();
   \   000005DE   0x.... 0x....      LDR.W    R0,??DataTable13_1  ;; 0x40023824
   \   000005E2   0x6800             LDR      R0,[R0, #+0]
   \   000005E4   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   000005E8   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x40023824
   \   000005EC   0x6008             STR      R0,[R1, #+0]
   \   000005EE   0x.... 0x....      LDR.W    R0,??DataTable13_1  ;; 0x40023824
   \   000005F2   0x6800             LDR      R0,[R0, #+0]
   \   000005F4   0xF010 0x5080      ANDS     R0,R0,#0x10000000
   \   000005F8   0x9000             STR      R0,[SP, #+0]
   \   000005FA   0x9800             LDR      R0,[SP, #+0]
    568              
    569              /* Enable write access to Backup domain */
    570              SET_BIT(PWR->CR, PWR_CR_DBP);
   \   000005FC   0x.... 0x....      LDR.W    R0,??DataTable13_2  ;; 0x40007000
   \   00000600   0x6800             LDR      R0,[R0, #+0]
   \   00000602   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000606   0x.... 0x....      LDR.W    R1,??DataTable13_2  ;; 0x40007000
   \   0000060A   0x6008             STR      R0,[R1, #+0]
    571          
    572              /* Wait for Backup domain Write protection disable */
    573              tickstart = HAL_GetTick();
   \   0000060C   0x.... 0x....      BL       HAL_GetTick
   \   00000610   0x0005             MOVS     R5,R0
    574              
    575              while((PWR->CR & PWR_CR_DBP) == RESET)
   \                     ??HAL_RCC_OscConfig_55: (+1)
   \   00000612   0x.... 0x....      LDR.W    R0,??DataTable13_2  ;; 0x40007000
   \   00000616   0x6800             LDR      R0,[R0, #+0]
   \   00000618   0x05C0             LSLS     R0,R0,#+23
   \   0000061A   0xD406             BMI.N    ??HAL_RCC_OscConfig_56
    576              {
    577                if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
   \   0000061C   0x.... 0x....      BL       HAL_GetTick
   \   00000620   0x1B40             SUBS     R0,R0,R5
   \   00000622   0x2865             CMP      R0,#+101
   \   00000624   0xD3F5             BCC.N    ??HAL_RCC_OscConfig_55
    578                {
    579                  return HAL_TIMEOUT;
   \   00000626   0x2003             MOVS     R0,#+3
   \   00000628   0xE14B             B.N      ??HAL_RCC_OscConfig_5
    580                }      
    581              }
    582              
    583              /* Reset LSEON and LSEBYP bits before configuring the LSE ----------------*/
    584              __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
   \                     ??HAL_RCC_OscConfig_56: (+1)
   \   0000062A   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x40023834
   \   0000062E   0x6800             LDR      R0,[R0, #+0]
   \   00000630   0xF430 0x7080      BICS     R0,R0,#0x100
   \   00000634   0x.... 0x....      LDR.W    R1,??DataTable5_1  ;; 0x40023834
   \   00000638   0x6008             STR      R0,[R1, #+0]
   \   0000063A   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x40023834
   \   0000063E   0x6800             LDR      R0,[R0, #+0]
   \   00000640   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000644   0x.... 0x....      LDR.W    R1,??DataTable5_1  ;; 0x40023834
   \   00000648   0x6008             STR      R0,[R1, #+0]
    585              
    586              /* Get Start Tick*/
    587              tickstart = HAL_GetTick();
   \   0000064A   0x.... 0x....      BL       HAL_GetTick
   \   0000064E   0x0005             MOVS     R5,R0
    588              
    589              /* Wait till LSE is disabled */  
    590              while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
   \                     ??HAL_RCC_OscConfig_57: (+1)
   \   00000650   0xF45F 0x0080      MOVS     R0,#+4194304
   \   00000654   0xFAB0 0xF080      CLZ      R0,R0
   \   00000658   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x40023834
   \   0000065C   0x6800             LDR      R0,[R0, #+0]
   \   0000065E   0xF45F 0x0180      MOVS     R1,#+4194304
   \   00000662   0xFAB1 0xF181      CLZ      R1,R1
   \   00000666   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   0000066A   0x40C8             LSRS     R0,R0,R1
   \   0000066C   0x07C0             LSLS     R0,R0,#+31
   \   0000066E   0xD508             BPL.N    ??HAL_RCC_OscConfig_58
    591              {
    592                if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
   \   00000670   0x.... 0x....      BL       HAL_GetTick
   \   00000674   0x1B40             SUBS     R0,R0,R5
   \   00000676   0xF241 0x3189      MOVW     R1,#+5001
   \   0000067A   0x4288             CMP      R0,R1
   \   0000067C   0xD3E8             BCC.N    ??HAL_RCC_OscConfig_57
    593                {
    594                  return HAL_TIMEOUT;
   \   0000067E   0x2003             MOVS     R0,#+3
   \   00000680   0xE11F             B.N      ??HAL_RCC_OscConfig_5
    595                }
    596              }
    597              
    598              /* Set the new LSE configuration -----------------------------------------*/
    599              __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
   \                     ??HAL_RCC_OscConfig_58: (+1)
   \   00000682   0x68A0             LDR      R0,[R4, #+8]
   \   00000684   0x2801             CMP      R0,#+1
   \   00000686   0xD108             BNE.N    ??HAL_RCC_OscConfig_59
   \   00000688   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x40023834
   \   0000068C   0x6800             LDR      R0,[R0, #+0]
   \   0000068E   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000692   0x.... 0x....      LDR.W    R1,??DataTable5_1  ;; 0x40023834
   \   00000696   0x6008             STR      R0,[R1, #+0]
   \   00000698   0xE037             B.N      ??HAL_RCC_OscConfig_60
   \                     ??HAL_RCC_OscConfig_59: (+1)
   \   0000069A   0x68A0             LDR      R0,[R4, #+8]
   \   0000069C   0x2800             CMP      R0,#+0
   \   0000069E   0xD110             BNE.N    ??HAL_RCC_OscConfig_61
   \   000006A0   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x40023834
   \   000006A4   0x6800             LDR      R0,[R0, #+0]
   \   000006A6   0xF430 0x7080      BICS     R0,R0,#0x100
   \   000006AA   0x.... 0x....      LDR.W    R1,??DataTable5_1  ;; 0x40023834
   \   000006AE   0x6008             STR      R0,[R1, #+0]
   \   000006B0   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x40023834
   \   000006B4   0x6800             LDR      R0,[R0, #+0]
   \   000006B6   0xF430 0x6080      BICS     R0,R0,#0x400
   \   000006BA   0x.... 0x....      LDR.W    R1,??DataTable5_1  ;; 0x40023834
   \   000006BE   0x6008             STR      R0,[R1, #+0]
   \   000006C0   0xE023             B.N      ??HAL_RCC_OscConfig_60
   \                     ??HAL_RCC_OscConfig_61: (+1)
   \   000006C2   0x68A0             LDR      R0,[R4, #+8]
   \   000006C4   0x2805             CMP      R0,#+5
   \   000006C6   0xD110             BNE.N    ??HAL_RCC_OscConfig_62
   \   000006C8   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x40023834
   \   000006CC   0x6800             LDR      R0,[R0, #+0]
   \   000006CE   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   000006D2   0x.... 0x....      LDR.W    R1,??DataTable5_1  ;; 0x40023834
   \   000006D6   0x6008             STR      R0,[R1, #+0]
   \   000006D8   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x40023834
   \   000006DC   0x6800             LDR      R0,[R0, #+0]
   \   000006DE   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   000006E2   0x.... 0x....      LDR.W    R1,??DataTable5_1  ;; 0x40023834
   \   000006E6   0x6008             STR      R0,[R1, #+0]
   \   000006E8   0xE00F             B.N      ??HAL_RCC_OscConfig_60
   \                     ??HAL_RCC_OscConfig_62: (+1)
   \   000006EA   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x40023834
   \   000006EE   0x6800             LDR      R0,[R0, #+0]
   \   000006F0   0xF430 0x7080      BICS     R0,R0,#0x100
   \   000006F4   0x.... 0x....      LDR.W    R1,??DataTable5_1  ;; 0x40023834
   \   000006F8   0x6008             STR      R0,[R1, #+0]
   \   000006FA   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x40023834
   \   000006FE   0x6800             LDR      R0,[R0, #+0]
   \   00000700   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000704   0x.... 0x....      LDR.W    R1,??DataTable5_1  ;; 0x40023834
   \   00000708   0x6008             STR      R0,[R1, #+0]
    600              /* Check the LSE State */
    601              if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
   \                     ??HAL_RCC_OscConfig_60: (+1)
   \   0000070A   0x68A0             LDR      R0,[R4, #+8]
   \   0000070C   0x2800             CMP      R0,#+0
   \   0000070E   0xD01B             BEQ.N    ??HAL_RCC_OscConfig_63
    602              {
    603                /* Get Start Tick*/
    604                tickstart = HAL_GetTick();
   \   00000710   0x.... 0x....      BL       HAL_GetTick
   \   00000714   0x0005             MOVS     R5,R0
    605                
    606                /* Wait till LSE is ready */  
    607                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
   \                     ??HAL_RCC_OscConfig_64: (+1)
   \   00000716   0xF45F 0x0080      MOVS     R0,#+4194304
   \   0000071A   0xFAB0 0xF080      CLZ      R0,R0
   \   0000071E   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x40023834
   \   00000722   0x6800             LDR      R0,[R0, #+0]
   \   00000724   0xF45F 0x0180      MOVS     R1,#+4194304
   \   00000728   0xFAB1 0xF181      CLZ      R1,R1
   \   0000072C   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000730   0x40C8             LSRS     R0,R0,R1
   \   00000732   0x07C0             LSLS     R0,R0,#+31
   \   00000734   0xD424             BMI.N    ??HAL_RCC_OscConfig_54
    608                {
    609                  if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
   \   00000736   0x.... 0x....      BL       HAL_GetTick
   \   0000073A   0x1B40             SUBS     R0,R0,R5
   \   0000073C   0xF241 0x3189      MOVW     R1,#+5001
   \   00000740   0x4288             CMP      R0,R1
   \   00000742   0xD3E8             BCC.N    ??HAL_RCC_OscConfig_64
    610                  {
    611                    return HAL_TIMEOUT;
   \   00000744   0x2003             MOVS     R0,#+3
   \   00000746   0xE0BC             B.N      ??HAL_RCC_OscConfig_5
    612                  }
    613                }
    614              }
    615              else
    616              {
    617                /* Get Start Tick*/
    618                tickstart = HAL_GetTick();
   \                     ??HAL_RCC_OscConfig_63: (+1)
   \   00000748   0x.... 0x....      BL       HAL_GetTick
   \   0000074C   0x0005             MOVS     R5,R0
    619                
    620                /* Wait till LSE is disabled */  
    621                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
   \                     ??HAL_RCC_OscConfig_65: (+1)
   \   0000074E   0xF45F 0x0080      MOVS     R0,#+4194304
   \   00000752   0xFAB0 0xF080      CLZ      R0,R0
   \   00000756   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x40023834
   \   0000075A   0x6800             LDR      R0,[R0, #+0]
   \   0000075C   0xF45F 0x0180      MOVS     R1,#+4194304
   \   00000760   0xFAB1 0xF181      CLZ      R1,R1
   \   00000764   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000768   0x40C8             LSRS     R0,R0,R1
   \   0000076A   0x07C0             LSLS     R0,R0,#+31
   \   0000076C   0xD508             BPL.N    ??HAL_RCC_OscConfig_54
    622                {
    623                  if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
   \   0000076E   0x.... 0x....      BL       HAL_GetTick
   \   00000772   0x1B40             SUBS     R0,R0,R5
   \   00000774   0xF241 0x3189      MOVW     R1,#+5001
   \   00000778   0x4288             CMP      R0,R1
   \   0000077A   0xD3E8             BCC.N    ??HAL_RCC_OscConfig_65
    624                  {
    625                    return HAL_TIMEOUT;
   \   0000077C   0x2003             MOVS     R0,#+3
   \   0000077E   0xE0A0             B.N      ??HAL_RCC_OscConfig_5
    626                  }
    627                }
    628              }
    629            }
    630          
    631            /*-------------------------------- PLL Configuration -----------------------*/
    632            /* Check the parameters */
    633            assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
    634            if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
   \                     ??HAL_RCC_OscConfig_54: (+1)
   \   00000780   0x6A60             LDR      R0,[R4, #+36]
   \   00000782   0x2800             CMP      R0,#+0
   \   00000784   0xF000 0x809C      BEQ.W    ??HAL_RCC_OscConfig_66
    635            {
    636              /* Check if the PLL is used as system clock or not */
    637              if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
   \   00000788   0x.... 0x....      LDR.W    R0,??DataTable2  ;; 0x40023808
   \   0000078C   0x6800             LDR      R0,[R0, #+0]
   \   0000078E   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   00000792   0x280C             CMP      R0,#+12
   \   00000794   0xF000 0x8092      BEQ.W    ??HAL_RCC_OscConfig_67
    638              { 
    639                if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
   \   00000798   0x6A60             LDR      R0,[R4, #+36]
   \   0000079A   0x2802             CMP      R0,#+2
   \   0000079C   0xD163             BNE.N    ??HAL_RCC_OscConfig_68
    640                {
    641                  /* Check the parameters */
    642                  assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
    643                  assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
    644                  assert_param(IS_RCC_PLL_DIV(RCC_OscInitStruct->PLL.PLLDIV));
    645            
    646                  /* Disable the main PLL. */
    647                  __HAL_RCC_PLL_DISABLE();
   \   0000079E   0x2000             MOVS     R0,#+0
   \   000007A0   0x2180             MOVS     R1,#+128
   \   000007A2   0xFAB1 0xF181      CLZ      R1,R1
   \   000007A6   0x.... 0x....      LDR.W    R2,??DataTable9  ;; 0x42470000
   \   000007AA   0xEB12 0x0181      ADDS     R1,R2,R1, LSL #+2
   \   000007AE   0x6008             STR      R0,[R1, #+0]
    648                  
    649                  /* Get Start Tick*/
    650                  tickstart = HAL_GetTick();
   \   000007B0   0x.... 0x....      BL       HAL_GetTick
   \   000007B4   0x0005             MOVS     R5,R0
    651                  
    652                  /* Wait till PLL is disabled */
    653                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
   \                     ??HAL_RCC_OscConfig_69: (+1)
   \   000007B6   0x2040             MOVS     R0,#+64
   \   000007B8   0xFAB0 0xF080      CLZ      R0,R0
   \   000007BC   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000007C0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000007C2   0x0940             LSRS     R0,R0,#+5
   \   000007C4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000007C6   0x2801             CMP      R0,#+1
   \   000007C8   0xD102             BNE.N    ??HAL_RCC_OscConfig_70
   \   000007CA   0x....             LDR.N    R0,??DataTable1  ;; 0x40023800
   \   000007CC   0x6800             LDR      R0,[R0, #+0]
   \   000007CE   0xE002             B.N      ??HAL_RCC_OscConfig_71
   \                     ??HAL_RCC_OscConfig_70: (+1)
   \   000007D0   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x40023834
   \   000007D4   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_71: (+1)
   \   000007D6   0x2140             MOVS     R1,#+64
   \   000007D8   0xFAB1 0xF181      CLZ      R1,R1
   \   000007DC   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000007E0   0x40C8             LSRS     R0,R0,R1
   \   000007E2   0x07C0             LSLS     R0,R0,#+31
   \   000007E4   0xD506             BPL.N    ??HAL_RCC_OscConfig_72
    654                  {
    655                    if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
   \   000007E6   0x.... 0x....      BL       HAL_GetTick
   \   000007EA   0x1B40             SUBS     R0,R0,R5
   \   000007EC   0x2865             CMP      R0,#+101
   \   000007EE   0xD3E2             BCC.N    ??HAL_RCC_OscConfig_69
    656                    {
    657                      return HAL_TIMEOUT;
   \   000007F0   0x2003             MOVS     R0,#+3
   \   000007F2   0xE066             B.N      ??HAL_RCC_OscConfig_5
    658                    }
    659                  }
    660                  
    661                  /* Configure the main PLL clock source, multiplication and division factors. */
    662                  __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
    663                                       RCC_OscInitStruct->PLL.PLLMUL,
    664                                       RCC_OscInitStruct->PLL.PLLDIV);
   \                     ??HAL_RCC_OscConfig_72: (+1)
   \   000007F4   0x.... 0x....      LDR.W    R0,??DataTable2  ;; 0x40023808
   \   000007F8   0x6800             LDR      R0,[R0, #+0]
   \   000007FA   0xF430 0x007D      BICS     R0,R0,#0xFD0000
   \   000007FE   0x6AA1             LDR      R1,[R4, #+40]
   \   00000800   0x4308             ORRS     R0,R1,R0
   \   00000802   0x6AE1             LDR      R1,[R4, #+44]
   \   00000804   0x4308             ORRS     R0,R1,R0
   \   00000806   0x6B21             LDR      R1,[R4, #+48]
   \   00000808   0x4308             ORRS     R0,R1,R0
   \   0000080A   0x.... 0x....      LDR.W    R1,??DataTable2  ;; 0x40023808
   \   0000080E   0x6008             STR      R0,[R1, #+0]
    665                  /* Enable the main PLL. */
    666                  __HAL_RCC_PLL_ENABLE();
   \   00000810   0x2001             MOVS     R0,#+1
   \   00000812   0x2180             MOVS     R1,#+128
   \   00000814   0xFAB1 0xF181      CLZ      R1,R1
   \   00000818   0x.... 0x....      LDR.W    R2,??DataTable9  ;; 0x42470000
   \   0000081C   0xEB12 0x0181      ADDS     R1,R2,R1, LSL #+2
   \   00000820   0x6008             STR      R0,[R1, #+0]
    667                  
    668                  /* Get Start Tick*/
    669                  tickstart = HAL_GetTick();
   \   00000822   0x.... 0x....      BL       HAL_GetTick
   \   00000826   0x0005             MOVS     R5,R0
    670                  
    671                  /* Wait till PLL is ready */
    672                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
   \                     ??HAL_RCC_OscConfig_73: (+1)
   \   00000828   0x2040             MOVS     R0,#+64
   \   0000082A   0xFAB0 0xF080      CLZ      R0,R0
   \   0000082E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000832   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000834   0x0940             LSRS     R0,R0,#+5
   \   00000836   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000838   0x2801             CMP      R0,#+1
   \   0000083A   0xD102             BNE.N    ??HAL_RCC_OscConfig_74
   \   0000083C   0x....             LDR.N    R0,??DataTable1  ;; 0x40023800
   \   0000083E   0x6800             LDR      R0,[R0, #+0]
   \   00000840   0xE002             B.N      ??HAL_RCC_OscConfig_75
   \                     ??HAL_RCC_OscConfig_74: (+1)
   \   00000842   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x40023834
   \   00000846   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_75: (+1)
   \   00000848   0x2140             MOVS     R1,#+64
   \   0000084A   0xFAB1 0xF181      CLZ      R1,R1
   \   0000084E   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000852   0x40C8             LSRS     R0,R0,R1
   \   00000854   0x07C0             LSLS     R0,R0,#+31
   \   00000856   0xD433             BMI.N    ??HAL_RCC_OscConfig_66
    673                  {
    674                    if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
   \   00000858   0x.... 0x....      BL       HAL_GetTick
   \   0000085C   0x1B40             SUBS     R0,R0,R5
   \   0000085E   0x2865             CMP      R0,#+101
   \   00000860   0xD3E2             BCC.N    ??HAL_RCC_OscConfig_73
    675                    {
    676                      return HAL_TIMEOUT;
   \   00000862   0x2003             MOVS     R0,#+3
   \   00000864   0xE02D             B.N      ??HAL_RCC_OscConfig_5
    677                    }
    678                  }
    679                }
    680                else
    681                {
    682                  /* Disable the main PLL. */
    683                  __HAL_RCC_PLL_DISABLE();
   \                     ??HAL_RCC_OscConfig_68: (+1)
   \   00000866   0x2000             MOVS     R0,#+0
   \   00000868   0x2180             MOVS     R1,#+128
   \   0000086A   0xFAB1 0xF181      CLZ      R1,R1
   \   0000086E   0x.... 0x....      LDR.W    R2,??DataTable9  ;; 0x42470000
   \   00000872   0xEB12 0x0181      ADDS     R1,R2,R1, LSL #+2
   \   00000876   0x6008             STR      R0,[R1, #+0]
    684           
    685                  /* Get Start Tick*/
    686                  tickstart = HAL_GetTick();
   \   00000878   0x.... 0x....      BL       HAL_GetTick
   \   0000087C   0x0005             MOVS     R5,R0
    687                  
    688                  /* Wait till PLL is disabled */  
    689                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
   \                     ??HAL_RCC_OscConfig_76: (+1)
   \   0000087E   0x2040             MOVS     R0,#+64
   \   00000880   0xFAB0 0xF080      CLZ      R0,R0
   \   00000884   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000888   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000088A   0x0940             LSRS     R0,R0,#+5
   \   0000088C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000088E   0x2801             CMP      R0,#+1
   \   00000890   0xD102             BNE.N    ??HAL_RCC_OscConfig_77
   \   00000892   0x....             LDR.N    R0,??DataTable1  ;; 0x40023800
   \   00000894   0x6800             LDR      R0,[R0, #+0]
   \   00000896   0xE002             B.N      ??HAL_RCC_OscConfig_78
   \                     ??HAL_RCC_OscConfig_77: (+1)
   \   00000898   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x40023834
   \   0000089C   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_78: (+1)
   \   0000089E   0x2140             MOVS     R1,#+64
   \   000008A0   0xFAB1 0xF181      CLZ      R1,R1
   \   000008A4   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000008A8   0x40C8             LSRS     R0,R0,R1
   \   000008AA   0x07C0             LSLS     R0,R0,#+31
   \   000008AC   0xD508             BPL.N    ??HAL_RCC_OscConfig_66
    690                  {
    691                    if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
   \   000008AE   0x.... 0x....      BL       HAL_GetTick
   \   000008B2   0x1B40             SUBS     R0,R0,R5
   \   000008B4   0x2865             CMP      R0,#+101
   \   000008B6   0xD3E2             BCC.N    ??HAL_RCC_OscConfig_76
    692                    {
    693                      return HAL_TIMEOUT;
   \   000008B8   0x2003             MOVS     R0,#+3
   \   000008BA   0xE002             B.N      ??HAL_RCC_OscConfig_5
    694                    }
    695                  }
    696                }
    697              }
    698              else
    699              {
    700                return HAL_ERROR;
   \                     ??HAL_RCC_OscConfig_67: (+1)
   \   000008BC   0x2001             MOVS     R0,#+1
   \   000008BE   0xE000             B.N      ??HAL_RCC_OscConfig_5
    701              }
    702            }
    703            
    704            return HAL_OK;
   \                     ??HAL_RCC_OscConfig_66: (+1)
   \   000008C0   0x2000             MOVS     R0,#+0
   \                     ??HAL_RCC_OscConfig_5: (+1)
   \   000008C2   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    705          }
    706          
    707          /**
    708            * @brief  Initializes the CPU, AHB and APB busses clocks according to the specified 
    709            *         parameters in the RCC_ClkInitStruct.
    710            * @param  RCC_ClkInitStruct: pointer to an RCC_OscInitTypeDef structure that
    711            *         contains the configuration information for the RCC peripheral.
    712            * @param  FLatency: FLASH Latency                   
    713            *          This parameter can be one of the following values:
    714            *            @arg FLASH_LATENCY_0:  FLASH 0 Latency cycle
    715            *            @arg FLASH_LATENCY_1:  FLASH 1 Latency cycle
    716            * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency 
    717            *         and updated by HAL_RCC_GetHCLKFreq() function called within this function
    718            *
    719            * @note   The MSI is used (enabled by hardware) as system clock source after
    720            *         startup from Reset, wake-up from STOP and STANDBY mode, or in case
    721            *         of failure of the HSE used directly or indirectly as system clock
    722            *         (if the Clock Security System CSS is enabled).
    723            *           
    724            * @note   A switch from one clock source to another occurs only if the target
    725            *         clock source is ready (clock stable after startup delay or PLL locked). 
    726            *         If a clock source which is not yet ready is selected, the switch will
    727            *         occur when the clock source will be ready. 
    728            *         You can use HAL_RCC_GetClockConfig() function to know which clock is
    729            *         currently used as system clock source.
    730            * @note   Depending on the device voltage range, the software has to set correctly
    731            *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
    732            *         (for more details refer to section above "Initialization/de-initialization functions")
    733            * @retval HAL status
    734            */

   \                                 In section .text, align 2, keep-with-next
    735          HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
    736          {
   \                     HAL_RCC_ClockConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    737            uint32_t tickstart = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    738            
    739            /* Check the parameters */
    740            assert_param(RCC_ClkInitStruct != NULL);
    741            assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
    742            assert_param(IS_FLASH_LATENCY(FLatency));
    743            
    744            /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
    745            must be correctly programmed according to the frequency of the CPU clock 
    746            (HCLK) and the supply voltage of the device. */
    747            
    748            /* Increasing the CPU frequency */
    749            if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable13_3  ;; 0x40023c00
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000012   0x42A8             CMP      R0,R5
   \   00000014   0xF080 0x8101      BCS.W    ??HAL_RCC_ClockConfig_0
    750            {    
    751              /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    752              __HAL_FLASH_SET_LATENCY(FLatency);
   \   00000018   0x2D01             CMP      R5,#+1
   \   0000001A   0xD107             BNE.N    ??HAL_RCC_ClockConfig_1
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable13_3  ;; 0x40023c00
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable13_3  ;; 0x40023c00
   \   0000002A   0x6008             STR      R0,[R1, #+0]
   \                     ??HAL_RCC_ClockConfig_1: (+1)
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable13_3  ;; 0x40023c00
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x0840             LSRS     R0,R0,#+1
   \   00000034   0x0040             LSLS     R0,R0,#+1
   \   00000036   0x4328             ORRS     R0,R5,R0
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable13_3  ;; 0x40023c00
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    753              
    754              /* Check that the new number of wait states is taken into account to access the Flash
    755              memory by reading the FLASH_ACR register */
    756              if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable13_3  ;; 0x40023c00
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000048   0x42A8             CMP      R0,R5
   \   0000004A   0xD001             BEQ.N    ??HAL_RCC_ClockConfig_2
    757              {
    758                return HAL_ERROR;
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0xE1FC             B.N      ??HAL_RCC_ClockConfig_3
    759              }
    760              
    761              /*-------------------------- HCLK Configuration --------------------------*/
    762              if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
   \                     ??HAL_RCC_ClockConfig_2: (+1)
   \   00000050   0x7820             LDRB     R0,[R4, #+0]
   \   00000052   0x0780             LSLS     R0,R0,#+30
   \   00000054   0xD509             BPL.N    ??HAL_RCC_ClockConfig_4
    763              {
    764                assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    765                MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable13_4  ;; 0x40023808
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0xF030 0x00F0      BICS     R0,R0,#0xF0
   \   00000060   0x68A1             LDR      R1,[R4, #+8]
   \   00000062   0x4308             ORRS     R0,R1,R0
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable13_4  ;; 0x40023808
   \   00000068   0x6008             STR      R0,[R1, #+0]
    766              }
    767          
    768              /*------------------------- SYSCLK Configuration ---------------------------*/ 
    769              if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
   \                     ??HAL_RCC_ClockConfig_4: (+1)
   \   0000006A   0x7820             LDRB     R0,[R4, #+0]
   \   0000006C   0x07C0             LSLS     R0,R0,#+31
   \   0000006E   0xF140 0x81CD      BPL.W    ??HAL_RCC_ClockConfig_5
    770              {    
    771                assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
    772                
    773                /* HSE is selected as System Clock Source */
    774                if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
   \   00000072   0x6860             LDR      R0,[R4, #+4]
   \   00000074   0x2802             CMP      R0,#+2
   \   00000076   0xD11C             BNE.N    ??HAL_RCC_ClockConfig_6
    775                {
    776                  /* Check the HSE ready flag */  
    777                  if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
   \   00000078   0xF44F 0x4080      MOV      R0,#+16384
   \   0000007C   0xFAB0 0xF080      CLZ      R0,R0
   \   00000080   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000084   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000086   0x0940             LSRS     R0,R0,#+5
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008A   0x2801             CMP      R0,#+1
   \   0000008C   0xD103             BNE.N    ??HAL_RCC_ClockConfig_7
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable13_5  ;; 0x40023800
   \   00000092   0x6800             LDR      R0,[R0, #+0]
   \   00000094   0xE002             B.N      ??HAL_RCC_ClockConfig_8
   \                     ??HAL_RCC_ClockConfig_7: (+1)
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x40023834
   \   0000009A   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_ClockConfig_8: (+1)
   \   0000009C   0xF44F 0x4180      MOV      R1,#+16384
   \   000000A0   0xFAB1 0xF181      CLZ      R1,R1
   \   000000A4   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000000A8   0x40C8             LSRS     R0,R0,R1
   \   000000AA   0x07C0             LSLS     R0,R0,#+31
   \   000000AC   0xD45C             BMI.N    ??HAL_RCC_ClockConfig_9
    778                  {
    779                    return HAL_ERROR;
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0xE1CB             B.N      ??HAL_RCC_ClockConfig_3
    780                  }
    781                }
    782                /* PLL is selected as System Clock Source */
    783                else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
   \                     ??HAL_RCC_ClockConfig_6: (+1)
   \   000000B2   0x6860             LDR      R0,[R4, #+4]
   \   000000B4   0x2803             CMP      R0,#+3
   \   000000B6   0xD11A             BNE.N    ??HAL_RCC_ClockConfig_10
    784                {
    785                  /* Check the PLL ready flag */  
    786                  if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
   \   000000B8   0x2040             MOVS     R0,#+64
   \   000000BA   0xFAB0 0xF080      CLZ      R0,R0
   \   000000BE   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000000C2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C4   0x0940             LSRS     R0,R0,#+5
   \   000000C6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C8   0x2801             CMP      R0,#+1
   \   000000CA   0xD103             BNE.N    ??HAL_RCC_ClockConfig_11
   \   000000CC   0x.... 0x....      LDR.W    R0,??DataTable13_5  ;; 0x40023800
   \   000000D0   0x6800             LDR      R0,[R0, #+0]
   \   000000D2   0xE002             B.N      ??HAL_RCC_ClockConfig_12
   \                     ??HAL_RCC_ClockConfig_11: (+1)
   \   000000D4   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x40023834
   \   000000D8   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_ClockConfig_12: (+1)
   \   000000DA   0x2140             MOVS     R1,#+64
   \   000000DC   0xFAB1 0xF181      CLZ      R1,R1
   \   000000E0   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000000E4   0x40C8             LSRS     R0,R0,R1
   \   000000E6   0x07C0             LSLS     R0,R0,#+31
   \   000000E8   0xD43E             BMI.N    ??HAL_RCC_ClockConfig_9
    787                  {
    788                    return HAL_ERROR;
   \   000000EA   0x2001             MOVS     R0,#+1
   \   000000EC   0xE1AD             B.N      ??HAL_RCC_ClockConfig_3
    789                  }
    790                }
    791                /* HSI is selected as System Clock Source */
    792                else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
   \                     ??HAL_RCC_ClockConfig_10: (+1)
   \   000000EE   0x6860             LDR      R0,[R4, #+4]
   \   000000F0   0x2801             CMP      R0,#+1
   \   000000F2   0xD11C             BNE.N    ??HAL_RCC_ClockConfig_13
    793                {
    794                  /* Check the HSI ready flag */  
    795                  if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
   \   000000F4   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   000000F8   0xFAB0 0xF080      CLZ      R0,R0
   \   000000FC   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000100   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000102   0x0940             LSRS     R0,R0,#+5
   \   00000104   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000106   0x2801             CMP      R0,#+1
   \   00000108   0xD103             BNE.N    ??HAL_RCC_ClockConfig_14
   \   0000010A   0x.... 0x....      LDR.W    R0,??DataTable13_5  ;; 0x40023800
   \   0000010E   0x6800             LDR      R0,[R0, #+0]
   \   00000110   0xE002             B.N      ??HAL_RCC_ClockConfig_15
   \                     ??HAL_RCC_ClockConfig_14: (+1)
   \   00000112   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x40023834
   \   00000116   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_ClockConfig_15: (+1)
   \   00000118   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   0000011C   0xFAB1 0xF181      CLZ      R1,R1
   \   00000120   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000124   0x40C8             LSRS     R0,R0,R1
   \   00000126   0x07C0             LSLS     R0,R0,#+31
   \   00000128   0xD41E             BMI.N    ??HAL_RCC_ClockConfig_9
    796                  {
    797                    return HAL_ERROR;
   \   0000012A   0x2001             MOVS     R0,#+1
   \   0000012C   0xE18D             B.N      ??HAL_RCC_ClockConfig_3
    798                  }
    799                }
    800                /* MSI is selected as System Clock Source */
    801                else
    802                {
    803                  /* Check the MSI ready flag */  
    804                  if(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
   \                     ??HAL_RCC_ClockConfig_13: (+1)
   \   0000012E   0xF45F 0x0080      MOVS     R0,#+4194304
   \   00000132   0xFAB0 0xF080      CLZ      R0,R0
   \   00000136   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000013A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000013C   0x0940             LSRS     R0,R0,#+5
   \   0000013E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000140   0x2801             CMP      R0,#+1
   \   00000142   0xD103             BNE.N    ??HAL_RCC_ClockConfig_16
   \   00000144   0x.... 0x....      LDR.W    R0,??DataTable13_5  ;; 0x40023800
   \   00000148   0x6800             LDR      R0,[R0, #+0]
   \   0000014A   0xE002             B.N      ??HAL_RCC_ClockConfig_17
   \                     ??HAL_RCC_ClockConfig_16: (+1)
   \   0000014C   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x40023834
   \   00000150   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_ClockConfig_17: (+1)
   \   00000152   0xF45F 0x0180      MOVS     R1,#+4194304
   \   00000156   0xFAB1 0xF181      CLZ      R1,R1
   \   0000015A   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   0000015E   0x40C8             LSRS     R0,R0,R1
   \   00000160   0x07C0             LSLS     R0,R0,#+31
   \   00000162   0xD401             BMI.N    ??HAL_RCC_ClockConfig_9
    805                  {
    806                    return HAL_ERROR;
   \   00000164   0x2001             MOVS     R0,#+1
   \   00000166   0xE170             B.N      ??HAL_RCC_ClockConfig_3
    807                  }
    808                }
    809                MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
   \                     ??HAL_RCC_ClockConfig_9: (+1)
   \   00000168   0x.... 0x....      LDR.W    R0,??DataTable13_4  ;; 0x40023808
   \   0000016C   0x6800             LDR      R0,[R0, #+0]
   \   0000016E   0x0880             LSRS     R0,R0,#+2
   \   00000170   0x0080             LSLS     R0,R0,#+2
   \   00000172   0x6861             LDR      R1,[R4, #+4]
   \   00000174   0x4308             ORRS     R0,R1,R0
   \   00000176   0x.... 0x....      LDR.W    R1,??DataTable13_4  ;; 0x40023808
   \   0000017A   0x6008             STR      R0,[R1, #+0]
    810                
    811                /* Get Start Tick*/
    812                tickstart = HAL_GetTick();
   \   0000017C   0x.... 0x....      BL       HAL_GetTick
   \   00000180   0x0006             MOVS     R6,R0
    813                
    814                if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
   \   00000182   0x6860             LDR      R0,[R4, #+4]
   \   00000184   0x2802             CMP      R0,#+2
   \   00000186   0xD110             BNE.N    ??HAL_RCC_ClockConfig_18
    815                {
    816                  while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
   \                     ??HAL_RCC_ClockConfig_19: (+1)
   \   00000188   0x.... 0x....      LDR.W    R0,??DataTable13_4  ;; 0x40023808
   \   0000018C   0x6800             LDR      R0,[R0, #+0]
   \   0000018E   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   00000192   0x2808             CMP      R0,#+8
   \   00000194   0xF000 0x813A      BEQ.W    ??HAL_RCC_ClockConfig_5
    817                  {
    818                    if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
   \   00000198   0x.... 0x....      BL       HAL_GetTick
   \   0000019C   0x1B80             SUBS     R0,R0,R6
   \   0000019E   0xF241 0x3189      MOVW     R1,#+5001
   \   000001A2   0x4288             CMP      R0,R1
   \   000001A4   0xD3F0             BCC.N    ??HAL_RCC_ClockConfig_19
    819                    {
    820                      return HAL_TIMEOUT;
   \   000001A6   0x2003             MOVS     R0,#+3
   \   000001A8   0xE14F             B.N      ??HAL_RCC_ClockConfig_3
    821                    }
    822                  }
    823                }
    824                else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
   \                     ??HAL_RCC_ClockConfig_18: (+1)
   \   000001AA   0x6860             LDR      R0,[R4, #+4]
   \   000001AC   0x2803             CMP      R0,#+3
   \   000001AE   0xD110             BNE.N    ??HAL_RCC_ClockConfig_20
    825                {
    826                  while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
   \                     ??HAL_RCC_ClockConfig_21: (+1)
   \   000001B0   0x.... 0x....      LDR.W    R0,??DataTable13_4  ;; 0x40023808
   \   000001B4   0x6800             LDR      R0,[R0, #+0]
   \   000001B6   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   000001BA   0x280C             CMP      R0,#+12
   \   000001BC   0xF000 0x8126      BEQ.W    ??HAL_RCC_ClockConfig_5
    827                  {
    828                    if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
   \   000001C0   0x.... 0x....      BL       HAL_GetTick
   \   000001C4   0x1B80             SUBS     R0,R0,R6
   \   000001C6   0xF241 0x3189      MOVW     R1,#+5001
   \   000001CA   0x4288             CMP      R0,R1
   \   000001CC   0xD3F0             BCC.N    ??HAL_RCC_ClockConfig_21
    829                    {
    830                      return HAL_TIMEOUT;
   \   000001CE   0x2003             MOVS     R0,#+3
   \   000001D0   0xE13B             B.N      ??HAL_RCC_ClockConfig_3
    831                    }
    832                  }
    833                }
    834                else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
   \                     ??HAL_RCC_ClockConfig_20: (+1)
   \   000001D2   0x6860             LDR      R0,[R4, #+4]
   \   000001D4   0x2801             CMP      R0,#+1
   \   000001D6   0xD110             BNE.N    ??HAL_RCC_ClockConfig_22
    835                {
    836                  while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
   \                     ??HAL_RCC_ClockConfig_23: (+1)
   \   000001D8   0x.... 0x....      LDR.W    R0,??DataTable13_4  ;; 0x40023808
   \   000001DC   0x6800             LDR      R0,[R0, #+0]
   \   000001DE   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   000001E2   0x2804             CMP      R0,#+4
   \   000001E4   0xF000 0x8112      BEQ.W    ??HAL_RCC_ClockConfig_5
    837                  {
    838                    if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
   \   000001E8   0x.... 0x....      BL       HAL_GetTick
   \   000001EC   0x1B80             SUBS     R0,R0,R6
   \   000001EE   0xF241 0x3189      MOVW     R1,#+5001
   \   000001F2   0x4288             CMP      R0,R1
   \   000001F4   0xD3F0             BCC.N    ??HAL_RCC_ClockConfig_23
    839                    {
    840                      return HAL_TIMEOUT;
   \   000001F6   0x2003             MOVS     R0,#+3
   \   000001F8   0xE127             B.N      ??HAL_RCC_ClockConfig_3
    841                    }
    842                  }
    843                }      
    844                else
    845                {
    846                  while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
   \                     ??HAL_RCC_ClockConfig_22: (+1)
   \   000001FA   0x.... 0x....      LDR.W    R0,??DataTable13_4  ;; 0x40023808
   \   000001FE   0x6800             LDR      R0,[R0, #+0]
   \   00000200   0xF010 0x0F0C      TST      R0,#0xC
   \   00000204   0xF000 0x8102      BEQ.W    ??HAL_RCC_ClockConfig_5
    847                  {
    848                    if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
   \   00000208   0x.... 0x....      BL       HAL_GetTick
   \   0000020C   0x1B80             SUBS     R0,R0,R6
   \   0000020E   0xF241 0x3189      MOVW     R1,#+5001
   \   00000212   0x4288             CMP      R0,R1
   \   00000214   0xD3F1             BCC.N    ??HAL_RCC_ClockConfig_22
    849                    {
    850                      return HAL_TIMEOUT;
   \   00000216   0x2003             MOVS     R0,#+3
   \   00000218   0xE117             B.N      ??HAL_RCC_ClockConfig_3
    851                    }
    852                  }
    853                }
    854              }    
    855            }
    856            /* Decreasing the CPU frequency */
    857            else
    858            {
    859              /*-------------------------- HCLK Configuration --------------------------*/
    860              if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
   \                     ??HAL_RCC_ClockConfig_0: (+1)
   \   0000021A   0x7820             LDRB     R0,[R4, #+0]
   \   0000021C   0x0780             LSLS     R0,R0,#+30
   \   0000021E   0xD509             BPL.N    ??HAL_RCC_ClockConfig_24
    861              {
    862                assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    863                MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
   \   00000220   0x.... 0x....      LDR.W    R0,??DataTable13_4  ;; 0x40023808
   \   00000224   0x6800             LDR      R0,[R0, #+0]
   \   00000226   0xF030 0x00F0      BICS     R0,R0,#0xF0
   \   0000022A   0x68A1             LDR      R1,[R4, #+8]
   \   0000022C   0x4308             ORRS     R0,R1,R0
   \   0000022E   0x.... 0x....      LDR.W    R1,??DataTable13_4  ;; 0x40023808
   \   00000232   0x6008             STR      R0,[R1, #+0]
    864              }
    865              
    866              /*------------------------- SYSCLK Configuration -------------------------*/
    867              if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
   \                     ??HAL_RCC_ClockConfig_24: (+1)
   \   00000234   0x7820             LDRB     R0,[R4, #+0]
   \   00000236   0x07C0             LSLS     R0,R0,#+31
   \   00000238   0xF140 0x80CC      BPL.W    ??HAL_RCC_ClockConfig_25
    868              {    
    869                assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
    870                
    871                /* HSE is selected as System Clock Source */
    872                if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
   \   0000023C   0x6860             LDR      R0,[R4, #+4]
   \   0000023E   0x2802             CMP      R0,#+2
   \   00000240   0xD11B             BNE.N    ??HAL_RCC_ClockConfig_26
    873                {
    874                  /* Check the HSE ready flag */  
    875                  if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
   \   00000242   0xF44F 0x4080      MOV      R0,#+16384
   \   00000246   0xFAB0 0xF080      CLZ      R0,R0
   \   0000024A   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000024E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000250   0x0940             LSRS     R0,R0,#+5
   \   00000252   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000254   0x2801             CMP      R0,#+1
   \   00000256   0xD103             BNE.N    ??HAL_RCC_ClockConfig_27
   \   00000258   0x.... 0x....      LDR.W    R0,??DataTable13_5  ;; 0x40023800
   \   0000025C   0x6800             LDR      R0,[R0, #+0]
   \   0000025E   0xE001             B.N      ??HAL_RCC_ClockConfig_28
   \                     ??HAL_RCC_ClockConfig_27: (+1)
   \   00000260   0x....             LDR.N    R0,??DataTable5_1  ;; 0x40023834
   \   00000262   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_ClockConfig_28: (+1)
   \   00000264   0xF44F 0x4180      MOV      R1,#+16384
   \   00000268   0xFAB1 0xF181      CLZ      R1,R1
   \   0000026C   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000270   0x40C8             LSRS     R0,R0,R1
   \   00000272   0x07C0             LSLS     R0,R0,#+31
   \   00000274   0xD459             BMI.N    ??HAL_RCC_ClockConfig_29
    876                  {
    877                    return HAL_ERROR;
   \   00000276   0x2001             MOVS     R0,#+1
   \   00000278   0xE0E7             B.N      ??HAL_RCC_ClockConfig_3
    878                  }
    879                }
    880                /* PLL is selected as System Clock Source */
    881                else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
   \                     ??HAL_RCC_ClockConfig_26: (+1)
   \   0000027A   0x6860             LDR      R0,[R4, #+4]
   \   0000027C   0x2803             CMP      R0,#+3
   \   0000027E   0xD119             BNE.N    ??HAL_RCC_ClockConfig_30
    882                {
    883                  /* Check the PLL ready flag */  
    884                  if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
   \   00000280   0x2040             MOVS     R0,#+64
   \   00000282   0xFAB0 0xF080      CLZ      R0,R0
   \   00000286   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000028A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000028C   0x0940             LSRS     R0,R0,#+5
   \   0000028E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000290   0x2801             CMP      R0,#+1
   \   00000292   0xD103             BNE.N    ??HAL_RCC_ClockConfig_31
   \   00000294   0x.... 0x....      LDR.W    R0,??DataTable13_5  ;; 0x40023800
   \   00000298   0x6800             LDR      R0,[R0, #+0]
   \   0000029A   0xE001             B.N      ??HAL_RCC_ClockConfig_32
   \                     ??HAL_RCC_ClockConfig_31: (+1)
   \   0000029C   0x....             LDR.N    R0,??DataTable5_1  ;; 0x40023834
   \   0000029E   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_ClockConfig_32: (+1)
   \   000002A0   0x2140             MOVS     R1,#+64
   \   000002A2   0xFAB1 0xF181      CLZ      R1,R1
   \   000002A6   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000002AA   0x40C8             LSRS     R0,R0,R1
   \   000002AC   0x07C0             LSLS     R0,R0,#+31
   \   000002AE   0xD43C             BMI.N    ??HAL_RCC_ClockConfig_29
    885                  {
    886                    return HAL_ERROR;
   \   000002B0   0x2001             MOVS     R0,#+1
   \   000002B2   0xE0CA             B.N      ??HAL_RCC_ClockConfig_3
    887                  }
    888                }
    889                /* HSI is selected as System Clock Source */
    890                else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
   \                     ??HAL_RCC_ClockConfig_30: (+1)
   \   000002B4   0x6860             LDR      R0,[R4, #+4]
   \   000002B6   0x2801             CMP      R0,#+1
   \   000002B8   0xD11B             BNE.N    ??HAL_RCC_ClockConfig_33
    891                {
    892                  /* Check the HSI ready flag */  
    893                  if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
   \   000002BA   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   000002BE   0xFAB0 0xF080      CLZ      R0,R0
   \   000002C2   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000002C6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002C8   0x0940             LSRS     R0,R0,#+5
   \   000002CA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002CC   0x2801             CMP      R0,#+1
   \   000002CE   0xD103             BNE.N    ??HAL_RCC_ClockConfig_34
   \   000002D0   0x.... 0x....      LDR.W    R0,??DataTable13_5  ;; 0x40023800
   \   000002D4   0x6800             LDR      R0,[R0, #+0]
   \   000002D6   0xE001             B.N      ??HAL_RCC_ClockConfig_35
   \                     ??HAL_RCC_ClockConfig_34: (+1)
   \   000002D8   0x....             LDR.N    R0,??DataTable5_1  ;; 0x40023834
   \   000002DA   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_ClockConfig_35: (+1)
   \   000002DC   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   000002E0   0xFAB1 0xF181      CLZ      R1,R1
   \   000002E4   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000002E8   0x40C8             LSRS     R0,R0,R1
   \   000002EA   0x07C0             LSLS     R0,R0,#+31
   \   000002EC   0xD41D             BMI.N    ??HAL_RCC_ClockConfig_29
    894                  {
    895                    return HAL_ERROR;
   \   000002EE   0x2001             MOVS     R0,#+1
   \   000002F0   0xE0AB             B.N      ??HAL_RCC_ClockConfig_3
    896                  }
    897                }
    898               /* MSI is selected as System Clock Source */
    899                else
    900                {
    901                  /* Check the MSI ready flag */  
    902                  if(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
   \                     ??HAL_RCC_ClockConfig_33: (+1)
   \   000002F2   0xF45F 0x0080      MOVS     R0,#+4194304
   \   000002F6   0xFAB0 0xF080      CLZ      R0,R0
   \   000002FA   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000002FE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000300   0x0940             LSRS     R0,R0,#+5
   \   00000302   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000304   0x2801             CMP      R0,#+1
   \   00000306   0xD103             BNE.N    ??HAL_RCC_ClockConfig_36
   \   00000308   0x.... 0x....      LDR.W    R0,??DataTable13_5  ;; 0x40023800
   \   0000030C   0x6800             LDR      R0,[R0, #+0]
   \   0000030E   0xE001             B.N      ??HAL_RCC_ClockConfig_37
   \                     ??HAL_RCC_ClockConfig_36: (+1)
   \   00000310   0x....             LDR.N    R0,??DataTable5_1  ;; 0x40023834
   \   00000312   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_ClockConfig_37: (+1)
   \   00000314   0xF45F 0x0180      MOVS     R1,#+4194304
   \   00000318   0xFAB1 0xF181      CLZ      R1,R1
   \   0000031C   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000320   0x40C8             LSRS     R0,R0,R1
   \   00000322   0x07C0             LSLS     R0,R0,#+31
   \   00000324   0xD401             BMI.N    ??HAL_RCC_ClockConfig_29
    903                  {
    904                    return HAL_ERROR;
   \   00000326   0x2001             MOVS     R0,#+1
   \   00000328   0xE08F             B.N      ??HAL_RCC_ClockConfig_3
    905                  }
    906                }
    907                MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
   \                     ??HAL_RCC_ClockConfig_29: (+1)
   \   0000032A   0x.... 0x....      LDR.W    R0,??DataTable13_4  ;; 0x40023808
   \   0000032E   0x6800             LDR      R0,[R0, #+0]
   \   00000330   0x0880             LSRS     R0,R0,#+2
   \   00000332   0x0080             LSLS     R0,R0,#+2
   \   00000334   0x6861             LDR      R1,[R4, #+4]
   \   00000336   0x4308             ORRS     R0,R1,R0
   \   00000338   0x.... 0x....      LDR.W    R1,??DataTable13_4  ;; 0x40023808
   \   0000033C   0x6008             STR      R0,[R1, #+0]
    908                
    909                /* Get Start Tick*/
    910                tickstart = HAL_GetTick();
   \   0000033E   0x.... 0x....      BL       HAL_GetTick
   \   00000342   0x0006             MOVS     R6,R0
    911                
    912                if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
   \   00000344   0x6860             LDR      R0,[R4, #+4]
   \   00000346   0x2802             CMP      R0,#+2
   \   00000348   0xD10F             BNE.N    ??HAL_RCC_ClockConfig_38
    913                {
    914                  while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
   \                     ??HAL_RCC_ClockConfig_39: (+1)
   \   0000034A   0x.... 0x....      LDR.W    R0,??DataTable13_4  ;; 0x40023808
   \   0000034E   0x6800             LDR      R0,[R0, #+0]
   \   00000350   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   00000354   0x2808             CMP      R0,#+8
   \   00000356   0xD03D             BEQ.N    ??HAL_RCC_ClockConfig_25
    915                  {
    916                    if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
   \   00000358   0x.... 0x....      BL       HAL_GetTick
   \   0000035C   0x1B80             SUBS     R0,R0,R6
   \   0000035E   0xF241 0x3189      MOVW     R1,#+5001
   \   00000362   0x4288             CMP      R0,R1
   \   00000364   0xD3F1             BCC.N    ??HAL_RCC_ClockConfig_39
    917                    {
    918                      return HAL_TIMEOUT;
   \   00000366   0x2003             MOVS     R0,#+3
   \   00000368   0xE06F             B.N      ??HAL_RCC_ClockConfig_3
    919                    }
    920                  }
    921                }
    922                else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
   \                     ??HAL_RCC_ClockConfig_38: (+1)
   \   0000036A   0x6860             LDR      R0,[R4, #+4]
   \   0000036C   0x2803             CMP      R0,#+3
   \   0000036E   0xD10F             BNE.N    ??HAL_RCC_ClockConfig_40
    923                {
    924                  while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
   \                     ??HAL_RCC_ClockConfig_41: (+1)
   \   00000370   0x.... 0x....      LDR.W    R0,??DataTable13_4  ;; 0x40023808
   \   00000374   0x6800             LDR      R0,[R0, #+0]
   \   00000376   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   0000037A   0x280C             CMP      R0,#+12
   \   0000037C   0xD02A             BEQ.N    ??HAL_RCC_ClockConfig_25
    925                  {
    926                    if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
   \   0000037E   0x.... 0x....      BL       HAL_GetTick
   \   00000382   0x1B80             SUBS     R0,R0,R6
   \   00000384   0xF241 0x3189      MOVW     R1,#+5001
   \   00000388   0x4288             CMP      R0,R1
   \   0000038A   0xD3F1             BCC.N    ??HAL_RCC_ClockConfig_41
    927                    {
    928                      return HAL_TIMEOUT;
   \   0000038C   0x2003             MOVS     R0,#+3
   \   0000038E   0xE05C             B.N      ??HAL_RCC_ClockConfig_3
    929                    }
    930                  }
    931                }
    932                else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
   \                     ??HAL_RCC_ClockConfig_40: (+1)
   \   00000390   0x6860             LDR      R0,[R4, #+4]
   \   00000392   0x2801             CMP      R0,#+1
   \   00000394   0xD10F             BNE.N    ??HAL_RCC_ClockConfig_42
    933                {
    934                  while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
   \                     ??HAL_RCC_ClockConfig_43: (+1)
   \   00000396   0x.... 0x....      LDR.W    R0,??DataTable13_4  ;; 0x40023808
   \   0000039A   0x6800             LDR      R0,[R0, #+0]
   \   0000039C   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   000003A0   0x2804             CMP      R0,#+4
   \   000003A2   0xD017             BEQ.N    ??HAL_RCC_ClockConfig_25
    935                  {
    936                    if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
   \   000003A4   0x.... 0x....      BL       HAL_GetTick
   \   000003A8   0x1B80             SUBS     R0,R0,R6
   \   000003AA   0xF241 0x3189      MOVW     R1,#+5001
   \   000003AE   0x4288             CMP      R0,R1
   \   000003B0   0xD3F1             BCC.N    ??HAL_RCC_ClockConfig_43
    937                    {
    938                      return HAL_TIMEOUT;
   \   000003B2   0x2003             MOVS     R0,#+3
   \   000003B4   0xE049             B.N      ??HAL_RCC_ClockConfig_3
    939                    }
    940                  }
    941                }      
    942                else
    943                {
    944                  while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
   \                     ??HAL_RCC_ClockConfig_42: (+1)
   \   000003B6   0x.... 0x....      LDR.W    R0,??DataTable13_4  ;; 0x40023808
   \   000003BA   0x6800             LDR      R0,[R0, #+0]
   \   000003BC   0xF010 0x0F0C      TST      R0,#0xC
   \   000003C0   0xD008             BEQ.N    ??HAL_RCC_ClockConfig_25
    945                  {
    946                    if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
   \   000003C2   0x.... 0x....      BL       HAL_GetTick
   \   000003C6   0x1B80             SUBS     R0,R0,R6
   \   000003C8   0xF241 0x3189      MOVW     R1,#+5001
   \   000003CC   0x4288             CMP      R0,R1
   \   000003CE   0xD3F2             BCC.N    ??HAL_RCC_ClockConfig_42
    947                    {
    948                      return HAL_TIMEOUT;
   \   000003D0   0x2003             MOVS     R0,#+3
   \   000003D2   0xE03A             B.N      ??HAL_RCC_ClockConfig_3
    949                    }
    950                  }
    951                }
    952              } 
    953              
    954              /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    955              __HAL_FLASH_SET_LATENCY(FLatency);
   \                     ??HAL_RCC_ClockConfig_25: (+1)
   \   000003D4   0x2D01             CMP      R5,#+1
   \   000003D6   0xD107             BNE.N    ??HAL_RCC_ClockConfig_44
   \   000003D8   0x.... 0x....      LDR.W    R0,??DataTable13_3  ;; 0x40023c00
   \   000003DC   0x6800             LDR      R0,[R0, #+0]
   \   000003DE   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   000003E2   0x.... 0x....      LDR.W    R1,??DataTable13_3  ;; 0x40023c00
   \   000003E6   0x6008             STR      R0,[R1, #+0]
   \                     ??HAL_RCC_ClockConfig_44: (+1)
   \   000003E8   0x.... 0x....      LDR.W    R0,??DataTable13_3  ;; 0x40023c00
   \   000003EC   0x6800             LDR      R0,[R0, #+0]
   \   000003EE   0x0840             LSRS     R0,R0,#+1
   \   000003F0   0x0040             LSLS     R0,R0,#+1
   \   000003F2   0x4328             ORRS     R0,R5,R0
   \   000003F4   0x.... 0x....      LDR.W    R1,??DataTable13_3  ;; 0x40023c00
   \   000003F8   0x6008             STR      R0,[R1, #+0]
    956              
    957              /* Check that the new number of wait states is taken into account to access the Flash
    958              memory by reading the FLASH_ACR register */
    959              if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
   \   000003FA   0x.... 0x....      LDR.W    R0,??DataTable13_3  ;; 0x40023c00
   \   000003FE   0x6800             LDR      R0,[R0, #+0]
   \   00000400   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000404   0x42A8             CMP      R0,R5
   \   00000406   0xD001             BEQ.N    ??HAL_RCC_ClockConfig_5
    960              {
    961                return HAL_ERROR;
   \   00000408   0x2001             MOVS     R0,#+1
   \   0000040A   0xE01E             B.N      ??HAL_RCC_ClockConfig_3
    962              }
    963            }
    964            
    965            /*-------------------------- PCLK1 Configuration ---------------------------*/ 
    966            if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
   \                     ??HAL_RCC_ClockConfig_5: (+1)
   \   0000040C   0x7820             LDRB     R0,[R4, #+0]
   \   0000040E   0x0740             LSLS     R0,R0,#+29
   \   00000410   0xD509             BPL.N    ??HAL_RCC_ClockConfig_45
    967            {
    968              assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    969              MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
   \   00000412   0x.... 0x....      LDR.W    R0,??DataTable13_4  ;; 0x40023808
   \   00000416   0x6800             LDR      R0,[R0, #+0]
   \   00000418   0xF430 0x60E0      BICS     R0,R0,#0x700
   \   0000041C   0x68E1             LDR      R1,[R4, #+12]
   \   0000041E   0x4308             ORRS     R0,R1,R0
   \   00000420   0x.... 0x....      LDR.W    R1,??DataTable13_4  ;; 0x40023808
   \   00000424   0x6008             STR      R0,[R1, #+0]
    970            }
    971            
    972            /*-------------------------- PCLK2 Configuration ---------------------------*/ 
    973            if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
   \                     ??HAL_RCC_ClockConfig_45: (+1)
   \   00000426   0x7820             LDRB     R0,[R4, #+0]
   \   00000428   0x0700             LSLS     R0,R0,#+28
   \   0000042A   0xD50A             BPL.N    ??HAL_RCC_ClockConfig_46
    974            {
    975              assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    976              MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
   \   0000042C   0x.... 0x....      LDR.W    R0,??DataTable13_4  ;; 0x40023808
   \   00000430   0x6800             LDR      R0,[R0, #+0]
   \   00000432   0xF430 0x5060      BICS     R0,R0,#0x3800
   \   00000436   0x6921             LDR      R1,[R4, #+16]
   \   00000438   0xEA50 0x00C1      ORRS     R0,R0,R1, LSL #+3
   \   0000043C   0x.... 0x....      LDR.W    R1,??DataTable13_4  ;; 0x40023808
   \   00000440   0x6008             STR      R0,[R1, #+0]
    977            }
    978           
    979            /* Configure the source of time base considering new system clocks settings*/
    980            HAL_InitTick (TICK_INT_PRIORITY);
   \                     ??HAL_RCC_ClockConfig_46: (+1)
   \   00000442   0x2000             MOVS     R0,#+0
   \   00000444   0x.... 0x....      BL       HAL_InitTick
    981            
    982            return HAL_OK;
   \   00000448   0x2000             MOVS     R0,#+0
   \                     ??HAL_RCC_ClockConfig_3: (+1)
   \   0000044A   0xBD70             POP      {R4-R6,PC}       ;; return
    983          }
    984          
    985          /**
    986            * @}
    987            */
    988          
    989          /** @defgroup RCC_Exported_Functions_Group2 Peripheral Control functions 
    990            *  @brief   RCC clocks control functions 
    991            *
    992            @verbatim   
    993            ===============================================================================
    994                            ##### Peripheral Control functions #####
    995            ===============================================================================  
    996              [..]
    997              This subsection provides a set of functions allowing to control the RCC Clocks 
    998              frequencies.
    999          
   1000            @endverbatim
   1001            * @{
   1002            */
   1003          
   1004          /**
   1005            * @brief  Selects the clock source to output on MCO pin.
   1006            * @note   MCO pin should be configured in alternate function mode.
   1007            * @param  RCC_MCOx: specifies the output direction for the clock source.
   1008            *          This parameter can be one of the following values:
   1009            *            @arg RCC_MCO: Clock source to output on MCO1 pin(PA8).
   1010            * @param  RCC_MCOSource: specifies the clock source to output.
   1011            *          This parameter can be one of the following values:
   1012            *     @arg RCC_MCO1SOURCE_NOCLOCK: No clock selected
   1013            *     @arg RCC_MCO1SOURCE_SYSCLK: System clock selected
   1014            *     @arg RCC_MCO1SOURCE_HSI: HSI oscillator clock selected
   1015            *     @arg RCC_MCO1SOURCE_MSI: MSI oscillator clock selected  
   1016            *     @arg RCC_MCO1SOURCE_HSE: HSE oscillator clock selected
   1017            *     @arg RCC_MCO1SOURCE_PLLCLK: PLL clock selected
   1018            *     @arg RCC_MCO1SOURCE_LSI: LSI clock selected
   1019            *     @arg RCC_MCO1SOURCE_LSE: LSE clock selected    
   1020            * @param  RCC_MCODiv: specifies the MCO DIV.
   1021            *          This parameter can be one of the following values:
   1022            *            @arg RCC_MCODIV_1: no division applied to MCO clock
   1023            *            @arg RCC_MCODIV_2: division by 2 applied to MCO clock
   1024            *            @arg RCC_MCODIV_4: division by 4 applied to MCO clock
   1025            *            @arg RCC_MCODIV_8: division by 8 applied to MCO clock
   1026            *            @arg RCC_MCODIV_16: division by 16 applied to MCO clock
   1027            * @retval None
   1028            */

   \                                 In section .text, align 2, keep-with-next
   1029          void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
   1030          {
   \                     HAL_RCC_MCOConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1031            GPIO_InitTypeDef gpio;
   1032            
   1033            /* Check the parameters */
   1034            assert_param(IS_RCC_MCO(RCC_MCOx));
   1035            assert_param(IS_RCC_MCODIV(RCC_MCODiv));
   1036            assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));
   1037            
   1038            /* MCO Clock Enable */
   1039            MCO1_CLK_ENABLE();
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable13_6  ;; 0x4002381c
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable13_6  ;; 0x4002381c
   \   00000018   0x6008             STR      R0,[R1, #+0]
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable13_6  ;; 0x4002381c
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000024   0x9000             STR      R0,[SP, #+0]
   \   00000026   0x9800             LDR      R0,[SP, #+0]
   1040            
   1041            /* Configure the MCO1 pin in alternate function mode */    
   1042            gpio.Pin = MCO1_PIN;
   \   00000028   0xF44F 0x7080      MOV      R0,#+256
   \   0000002C   0x9001             STR      R0,[SP, #+4]
   1043            gpio.Mode = GPIO_MODE_AF_PP;
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0x9002             STR      R0,[SP, #+8]
   1044            gpio.Speed = GPIO_SPEED_HIGH;
   \   00000032   0x2003             MOVS     R0,#+3
   \   00000034   0x9004             STR      R0,[SP, #+16]
   1045            gpio.Pull = GPIO_NOPULL;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x9003             STR      R0,[SP, #+12]
   1046            gpio.Alternate = GPIO_AF0_MCO;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x9005             STR      R0,[SP, #+20]
   1047            HAL_GPIO_Init(MCO1_GPIO_PORT, &gpio);
   \   0000003E   0xA901             ADD      R1,SP,#+4
   \   00000040   0x....             LDR.N    R0,??DataTable13_7  ;; 0x40020000
   \   00000042   0x.... 0x....      BL       HAL_GPIO_Init
   1048            
   1049            /* Configure the MCO clock source */
   1050            MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCOSEL | RCC_CFGR_MCOPRE), (RCC_MCOSource | RCC_MCODiv));
   \   00000046   0x....             LDR.N    R0,??DataTable13_4  ;; 0x40023808
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF030 0x40EE      BICS     R0,R0,#0x77000000
   \   0000004E   0x4328             ORRS     R0,R5,R0
   \   00000050   0x4330             ORRS     R0,R6,R0
   \   00000052   0x....             LDR.N    R1,??DataTable13_4  ;; 0x40023808
   \   00000054   0x6008             STR      R0,[R1, #+0]
   1051          }
   \   00000056   0xB006             ADD      SP,SP,#+24
   \   00000058   0xBD70             POP      {R4-R6,PC}       ;; return
   1052          
   1053          /**
   1054            * @brief  Enables the Clock Security System.
   1055            * @note   If a failure is detected on the HSE oscillator clock, this oscillator
   1056            *         is automatically disabled and an interrupt is generated to inform the
   1057            *         software about the failure (Clock Security System Interrupt, CSSI),
   1058            *         allowing the MCU to perform rescue operations. The CSSI is linked to 
   1059            *         the Cortex-M3 NMI (Non-Maskable Interrupt) exception vector.  
   1060            * @retval None
   1061            */

   \                                 In section .text, align 2, keep-with-next
   1062          void HAL_RCC_EnableCSS(void)
   1063          {
   1064            *(__IO uint32_t *) RCC_CR_CSSON_BB = (uint32_t)ENABLE;
   \                     HAL_RCC_EnableCSS: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x2108             MOVS     R1,#+8
   \   00000004   0xFAB1 0xF181      CLZ      R1,R1
   \   00000008   0x....             LDR.N    R2,??DataTable9  ;; 0x42470000
   \   0000000A   0xEB12 0x0181      ADDS     R1,R2,R1, LSL #+2
   \   0000000E   0x6008             STR      R0,[R1, #+0]
   1065          }
   \   00000010   0x4770             BX       LR               ;; return
   1066          
   1067          /**
   1068            * @brief  Disables the Clock Security System.
   1069            * @retval None
   1070            */

   \                                 In section .text, align 2, keep-with-next
   1071          void HAL_RCC_DisableCSS(void)
   1072          {
   1073            *(__IO uint32_t *) RCC_CR_CSSON_BB = (uint32_t)DISABLE;
   \                     HAL_RCC_DisableCSS: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x2108             MOVS     R1,#+8
   \   00000004   0xFAB1 0xF181      CLZ      R1,R1
   \   00000008   0x....             LDR.N    R2,??DataTable9  ;; 0x42470000
   \   0000000A   0xEB12 0x0181      ADDS     R1,R2,R1, LSL #+2
   \   0000000E   0x6008             STR      R0,[R1, #+0]
   1074          }
   \   00000010   0x4770             BX       LR               ;; return
   1075          
   1076          /**
   1077            * @brief  Returns the SYSCLK frequency     
   1078            *        
   1079            * @note   The system frequency computed by this function is not the real 
   1080            *         frequency in the chip. It is calculated based on the predefined 
   1081            *         constant and the selected clock source:
   1082            * @note     If SYSCLK source is MSI, function returns values based on MSI
   1083            *             Value as defined by the MSI range.
   1084            * @note     If SYSCLK source is HSI, function returns values based on HSI_VALUE(*)
   1085            * @note     If SYSCLK source is HSE, function returns values based on HSE_VALUE(**)
   1086            * @note     If SYSCLK source is PLL, function returns values based on HSE_VALUE(**) 
   1087            *           or HSI_VALUE(*) multiplied/divided by the PLL factors.         
   1088            * @note     (*) HSI_VALUE is a constant defined in stm32l1xx_hal_conf.h file (default value
   1089            *               16 MHz) but the real value may vary depending on the variations
   1090            *               in voltage and temperature.
   1091            * @note     (**) HSE_VALUE is a constant defined in stm32l1xx_hal_conf.h file (default value
   1092            *                8 MHz), user has to ensure that HSE_VALUE is same as the real
   1093            *                frequency of the crystal used. Otherwise, this function may
   1094            *                have wrong result.
   1095            *                  
   1096            * @note   The result of this function could be not correct when using fractional
   1097            *         value for HSE crystal.
   1098            *           
   1099            * @note   This function can be used by the user application to compute the 
   1100            *         baudrate for the communication peripherals or configure other parameters.
   1101            *           
   1102            * @note   Each time SYSCLK changes, this function must be called to update the
   1103            *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
   1104            *         
   1105            *               
   1106            * @retval SYSCLK frequency
   1107            */

   \                                 In section .text, align 2, keep-with-next
   1108          uint32_t HAL_RCC_GetSysClockFreq(void)
   1109          {
   \                     HAL_RCC_GetSysClockFreq: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   1110            uint32_t tmpreg = 0, pllm = 0, plld = 0, pllvco = 0, msiclkrange = 0;
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x2400             MOVS     R4,#+0
   \   0000000A   0x2500             MOVS     R5,#+0
   1111            uint32_t sysclockfreq = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   1112            
   1113            tmpreg = RCC->CFGR;
   \   0000000E   0x....             LDR.N    R6,??DataTable13_4  ;; 0x40023808
   \   00000010   0x6836             LDR      R6,[R6, #+0]
   \   00000012   0x0031             MOVS     R1,R6
   1114            
   1115            /* Get SYSCLK source -------------------------------------------------------*/
   1116            switch (tmpreg & RCC_CFGR_SWS)
   \   00000014   0xF011 0x060C      ANDS     R6,R1,#0xC
   \   00000018   0x2E04             CMP      R6,#+4
   \   0000001A   0xD004             BEQ.N    ??HAL_RCC_GetSysClockFreq_0
   \   0000001C   0x2E08             CMP      R6,#+8
   \   0000001E   0xD005             BEQ.N    ??HAL_RCC_GetSysClockFreq_1
   \   00000020   0x2E0C             CMP      R6,#+12
   \   00000022   0xD006             BEQ.N    ??HAL_RCC_GetSysClockFreq_2
   \   00000024   0xE02C             B.N      ??HAL_RCC_GetSysClockFreq_3
   1117            {
   1118              case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
   1119              {
   1120                sysclockfreq = HSI_VALUE;
   \                     ??HAL_RCC_GetSysClockFreq_0: (+1)
   \   00000026   0x....             LDR.N    R6,??DataTable13_8  ;; 0xf42400
   \   00000028   0x0030             MOVS     R0,R6
   1121                break;
   \   0000002A   0xE03A             B.N      ??HAL_RCC_GetSysClockFreq_4
   1122              }
   1123              case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock */
   1124              {
   1125                sysclockfreq = HSE_VALUE;
   \                     ??HAL_RCC_GetSysClockFreq_1: (+1)
   \   0000002C   0x....             LDR.N    R6,??DataTable13_9  ;; 0x7a1200
   \   0000002E   0x0030             MOVS     R0,R6
   1126                break;
   \   00000030   0xE037             B.N      ??HAL_RCC_GetSysClockFreq_4
   1127              }
   1128              case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
   1129              {
   1130                pllm = aPLLMulFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> POSITION_VAL(RCC_CFGR_PLLMUL)];
   \                     ??HAL_RCC_GetSysClockFreq_2: (+1)
   \   00000032   0x....             LDR.N    R6,??DataTable13_10
   \   00000034   0xF411 0x1770      ANDS     R7,R1,#0x3C0000
   \   00000038   0xF44F 0x5C70      MOV      R12,#+15360
   \   0000003C   0xFABC 0xFC8C      CLZ      R12,R12
   \   00000040   0xFA37 0xF70C      LSRS     R7,R7,R12
   \   00000044   0x5DF6             LDRB     R6,[R6, R7]
   \   00000046   0x0032             MOVS     R2,R6
   1131                plld = aPLLDivisionFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLDIV) >> POSITION_VAL(RCC_CFGR_PLLDIV)];
   \   00000048   0x....             LDR.N    R6,??DataTable13_11
   \   0000004A   0xF411 0x0740      ANDS     R7,R1,#0xC00000
   \   0000004E   0xF44F 0x7C40      MOV      R12,#+768
   \   00000052   0xFABC 0xFC8C      CLZ      R12,R12
   \   00000056   0xFA37 0xF70C      LSRS     R7,R7,R12
   \   0000005A   0x5DF6             LDRB     R6,[R6, R7]
   \   0000005C   0x0033             MOVS     R3,R6
   1132                if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
   \   0000005E   0x....             LDR.N    R6,??DataTable13_4  ;; 0x40023808
   \   00000060   0x6836             LDR      R6,[R6, #+0]
   \   00000062   0x03F6             LSLS     R6,R6,#+15
   \   00000064   0xD505             BPL.N    ??HAL_RCC_GetSysClockFreq_5
   1133                {
   1134                  /* HSE used as PLL clock source */
   1135                  pllvco = HSE_VALUE * (pllm / plld);
   \   00000066   0xFBB2 0xF6F3      UDIV     R6,R2,R3
   \   0000006A   0x....             LDR.N    R7,??DataTable13_9  ;; 0x7a1200
   \   0000006C   0x437E             MULS     R6,R7,R6
   \   0000006E   0x0034             MOVS     R4,R6
   \   00000070   0xE004             B.N      ??HAL_RCC_GetSysClockFreq_6
   1136                }
   1137                else
   1138                {
   1139                  /* HSI used as PLL clock source */
   1140                  pllvco = HSI_VALUE * (pllm / plld);
   \                     ??HAL_RCC_GetSysClockFreq_5: (+1)
   \   00000072   0xFBB2 0xF6F3      UDIV     R6,R2,R3
   \   00000076   0x....             LDR.N    R7,??DataTable13_8  ;; 0xf42400
   \   00000078   0x437E             MULS     R6,R7,R6
   \   0000007A   0x0034             MOVS     R4,R6
   1141                }
   1142                sysclockfreq = pllvco;
   \                     ??HAL_RCC_GetSysClockFreq_6: (+1)
   \   0000007C   0x0020             MOVS     R0,R4
   1143                break;
   \   0000007E   0xE010             B.N      ??HAL_RCC_GetSysClockFreq_4
   1144              }
   1145            case RCC_SYSCLKSOURCE_STATUS_MSI:  /* MSI used as system clock source */
   1146            default: /* MSI used as system clock */
   1147             {
   1148                msiclkrange = (RCC->ICSCR & RCC_ICSCR_MSIRANGE ) >> POSITION_VAL(RCC_ICSCR_MSIRANGE);
   \                     ??HAL_RCC_GetSysClockFreq_3: (+1)
   \   00000080   0x....             LDR.N    R6,??DataTable13_12  ;; 0x40023804
   \   00000082   0x6836             LDR      R6,[R6, #+0]
   \   00000084   0xF416 0x4660      ANDS     R6,R6,#0xE000
   \   00000088   0xF45F 0x27E0      MOVS     R7,#+458752
   \   0000008C   0xFAB7 0xF787      CLZ      R7,R7
   \   00000090   0x40FE             LSRS     R6,R6,R7
   \   00000092   0x0035             MOVS     R5,R6
   1149                sysclockfreq = (32768 * (1 << (msiclkrange + 1)));
   \   00000094   0x2601             MOVS     R6,#+1
   \   00000096   0x1C6F             ADDS     R7,R5,#+1
   \   00000098   0x40BE             LSLS     R6,R6,R7
   \   0000009A   0xF44F 0x4700      MOV      R7,#+32768
   \   0000009E   0x437E             MULS     R6,R7,R6
   \   000000A0   0x0030             MOVS     R0,R6
   1150                break;
   1151              }
   1152            }
   1153            return sysclockfreq;
   \                     ??HAL_RCC_GetSysClockFreq_4: (+1)
   \   000000A2   0xBCF0             POP      {R4-R7}
   \   000000A4   0x4770             BX       LR               ;; return
   1154          }
   1155          
   1156          /**
   1157            * @brief  Returns the HCLK frequency     
   1158            * @note   Each time HCLK changes, this function must be called to update the
   1159            *         right HCLK value. Otherwise, any configuration based on this function will be incorrect.
   1160            * 
   1161            * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency 
   1162            *         and updated within this function
   1163            * @retval HCLK frequency
   1164            */

   \                                 In section .text, align 2, keep-with-next
   1165          uint32_t HAL_RCC_GetHCLKFreq(void)
   1166          {
   \                     HAL_RCC_GetHCLKFreq: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1167            SystemCoreClock = HAL_RCC_GetSysClockFreq() >> aAPBAHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
   \   00000002   0x.... 0x....      BL       HAL_RCC_GetSysClockFreq
   \   00000006   0x....             LDR.N    R1,??DataTable13_4  ;; 0x40023808
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x....             LDR.N    R2,??DataTable13_13
   \   0000000C   0xF011 0x01F0      ANDS     R1,R1,#0xF0
   \   00000010   0xF05F 0x6370      MOVS     R3,#+251658240
   \   00000014   0xFAB3 0xF383      CLZ      R3,R3
   \   00000018   0x40D9             LSRS     R1,R1,R3
   \   0000001A   0x5C51             LDRB     R1,[R2, R1]
   \   0000001C   0x40C8             LSRS     R0,R0,R1
   \   0000001E   0x....             LDR.N    R1,??DataTable13_14
   \   00000020   0x6008             STR      R0,[R1, #+0]
   1168            return SystemCoreClock;
   \   00000022   0x....             LDR.N    R0,??DataTable13_14
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xBD02             POP      {R1,PC}          ;; return
   1169          }
   1170          
   1171          /**
   1172            * @brief  Returns the PCLK1 frequency     
   1173            * @note   Each time PCLK1 changes, this function must be called to update the
   1174            *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
   1175            * @retval PCLK1 frequency
   1176            */

   \                                 In section .text, align 2, keep-with-next
   1177          uint32_t HAL_RCC_GetPCLK1Freq(void)
   1178          {
   \                     HAL_RCC_GetPCLK1Freq: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1179            /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
   1180            return (HAL_RCC_GetHCLKFreq() >> aAPBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> POSITION_VAL(RCC_CFGR_PPRE1)]);
   \   00000002   0x.... 0x....      BL       HAL_RCC_GetHCLKFreq
   \   00000006   0x....             LDR.N    R1,??DataTable13_4  ;; 0x40023808
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x....             LDR.N    R2,??DataTable13_13
   \   0000000C   0xF411 0x61E0      ANDS     R1,R1,#0x700
   \   00000010   0xF45F 0x0360      MOVS     R3,#+14680064
   \   00000014   0xFAB3 0xF383      CLZ      R3,R3
   \   00000018   0x40D9             LSRS     R1,R1,R3
   \   0000001A   0x5C51             LDRB     R1,[R2, R1]
   \   0000001C   0x40C8             LSRS     R0,R0,R1
   \   0000001E   0xBD02             POP      {R1,PC}          ;; return
   1181          }    
   1182          
   1183          /**
   1184            * @brief  Returns the PCLK2 frequency     
   1185            * @note   Each time PCLK2 changes, this function must be called to update the
   1186            *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
   1187            * @retval PCLK2 frequency
   1188            */

   \                                 In section .text, align 2, keep-with-next
   1189          uint32_t HAL_RCC_GetPCLK2Freq(void)
   1190          {
   \                     HAL_RCC_GetPCLK2Freq: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1191            /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
   1192            return (HAL_RCC_GetHCLKFreq()>> aAPBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> POSITION_VAL(RCC_CFGR_PPRE2)]);
   \   00000002   0x.... 0x....      BL       HAL_RCC_GetHCLKFreq
   \   00000006   0x....             LDR.N    R1,??DataTable13_4  ;; 0x40023808
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x....             LDR.N    R2,??DataTable13_13
   \   0000000C   0xF411 0x5160      ANDS     R1,R1,#0x3800
   \   00000010   0xF45F 0x13E0      MOVS     R3,#+1835008
   \   00000014   0xFAB3 0xF383      CLZ      R3,R3
   \   00000018   0x40D9             LSRS     R1,R1,R3
   \   0000001A   0x5C51             LDRB     R1,[R2, R1]
   \   0000001C   0x40C8             LSRS     R0,R0,R1
   \   0000001E   0xBD02             POP      {R1,PC}          ;; return
   1193          } 
   1194          
   1195          /**
   1196            * @brief  Configures the RCC_OscInitStruct according to the internal 
   1197            * RCC configuration registers.
   1198            * @param  RCC_OscInitStruct: pointer to an RCC_OscInitTypeDef structure that 
   1199            * will be configured.
   1200            * @retval None
   1201            */

   \                                 In section .text, align 2, keep-with-next
   1202          void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
   1203          {
   1204            /* Check the parameters */
   1205            assert_param(RCC_OscInitStruct != NULL);
   1206          
   1207            /* Set all possible values for the Oscillator type parameter ---------------*/
   1208            RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI  \
   1209                            | RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_MSI;
   \                     HAL_RCC_GetOscConfig: (+1)
   \   00000000   0x211F             MOVS     R1,#+31
   \   00000002   0x6001             STR      R1,[R0, #+0]
   1210            
   1211            /* Get the HSE configuration -----------------------------------------------*/
   1212            if((RCC->CR &RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
   \   00000004   0x....             LDR.N    R1,??DataTable13_5  ;; 0x40023800
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x0349             LSLS     R1,R1,#+13
   \   0000000A   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_0
   1213            {
   1214              RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
   \   0000000C   0x2105             MOVS     R1,#+5
   \   0000000E   0x6041             STR      R1,[R0, #+4]
   \   00000010   0xE008             B.N      ??HAL_RCC_GetOscConfig_1
   1215            }
   1216            else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)
   \                     ??HAL_RCC_GetOscConfig_0: (+1)
   \   00000012   0x....             LDR.N    R1,??DataTable13_5  ;; 0x40023800
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x03C9             LSLS     R1,R1,#+15
   \   00000018   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_2
   1217            {
   1218              RCC_OscInitStruct->HSEState = RCC_HSE_ON;
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x6041             STR      R1,[R0, #+4]
   \   0000001E   0xE001             B.N      ??HAL_RCC_GetOscConfig_1
   1219            }
   1220            else
   1221            {
   1222              RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
   \                     ??HAL_RCC_GetOscConfig_2: (+1)
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x6041             STR      R1,[R0, #+4]
   1223            }
   1224            
   1225            /* Get the HSI configuration -----------------------------------------------*/
   1226            if((RCC->CR &RCC_CR_HSION) == RCC_CR_HSION)
   \                     ??HAL_RCC_GetOscConfig_1: (+1)
   \   00000024   0x....             LDR.N    R1,??DataTable13_5  ;; 0x40023800
   \   00000026   0x6809             LDR      R1,[R1, #+0]
   \   00000028   0x07C9             LSLS     R1,R1,#+31
   \   0000002A   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_3
   1227            {
   1228              RCC_OscInitStruct->HSIState = RCC_HSI_ON;
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0x60C1             STR      R1,[R0, #+12]
   \   00000030   0xE001             B.N      ??HAL_RCC_GetOscConfig_4
   1229            }
   1230            else
   1231            {
   1232              RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
   \                     ??HAL_RCC_GetOscConfig_3: (+1)
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x60C1             STR      R1,[R0, #+12]
   1233            }
   1234            
   1235            RCC_OscInitStruct->HSICalibrationValue = (uint32_t)((RCC->ICSCR & RCC_ICSCR_HSITRIM) >> POSITION_VAL(RCC_ICSCR_HSITRIM));
   \                     ??HAL_RCC_GetOscConfig_4: (+1)
   \   00000036   0x....             LDR.N    R1,??DataTable13_12  ;; 0x40023804
   \   00000038   0x6809             LDR      R1,[R1, #+0]
   \   0000003A   0xF411 0x51F8      ANDS     R1,R1,#0x1F00
   \   0000003E   0xF45F 0x0278      MOVS     R2,#+16252928
   \   00000042   0xFAB2 0xF282      CLZ      R2,R2
   \   00000046   0x40D1             LSRS     R1,R1,R2
   \   00000048   0x6101             STR      R1,[R0, #+16]
   1236            
   1237            /* Get the MSI configuration -----------------------------------------------*/
   1238            if((RCC->CR &RCC_CR_MSION) == RCC_CR_MSION)
   \   0000004A   0x....             LDR.N    R1,??DataTable13_5  ;; 0x40023800
   \   0000004C   0x6809             LDR      R1,[R1, #+0]
   \   0000004E   0x05C9             LSLS     R1,R1,#+23
   \   00000050   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_5
   1239            {
   1240              RCC_OscInitStruct->MSIState = RCC_MSI_ON;
   \   00000052   0x2101             MOVS     R1,#+1
   \   00000054   0x6181             STR      R1,[R0, #+24]
   \   00000056   0xE001             B.N      ??HAL_RCC_GetOscConfig_6
   1241            }
   1242            else
   1243            {
   1244              RCC_OscInitStruct->MSIState = RCC_MSI_OFF;
   \                     ??HAL_RCC_GetOscConfig_5: (+1)
   \   00000058   0x2100             MOVS     R1,#+0
   \   0000005A   0x6181             STR      R1,[R0, #+24]
   1245            }
   1246            
   1247            RCC_OscInitStruct->MSICalibrationValue = (uint32_t)((RCC->ICSCR & RCC_ICSCR_MSITRIM) >> POSITION_VAL(RCC_ICSCR_MSITRIM));
   \                     ??HAL_RCC_GetOscConfig_6: (+1)
   \   0000005C   0x....             LDR.N    R1,??DataTable13_12  ;; 0x40023804
   \   0000005E   0x6809             LDR      R1,[R1, #+0]
   \   00000060   0xF011 0x417F      ANDS     R1,R1,#0xFF000000
   \   00000064   0x22FF             MOVS     R2,#+255
   \   00000066   0xFAB2 0xF282      CLZ      R2,R2
   \   0000006A   0x40D1             LSRS     R1,R1,R2
   \   0000006C   0x61C1             STR      R1,[R0, #+28]
   1248            RCC_OscInitStruct->MSIClockRange = (uint32_t)((RCC->ICSCR & RCC_ICSCR_MSIRANGE));
   \   0000006E   0x....             LDR.N    R1,??DataTable13_12  ;; 0x40023804
   \   00000070   0x6809             LDR      R1,[R1, #+0]
   \   00000072   0xF411 0x4160      ANDS     R1,R1,#0xE000
   \   00000076   0x6201             STR      R1,[R0, #+32]
   1249            
   1250            /* Get the LSE configuration -----------------------------------------------*/
   1251            if((RCC->CSR &RCC_CSR_LSEBYP) == RCC_CSR_LSEBYP)
   \   00000078   0x....             LDR.N    R1,??DataTable13_15  ;; 0x40023834
   \   0000007A   0x6809             LDR      R1,[R1, #+0]
   \   0000007C   0x0549             LSLS     R1,R1,#+21
   \   0000007E   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_7
   1252            {
   1253              RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
   \   00000080   0x2105             MOVS     R1,#+5
   \   00000082   0x6081             STR      R1,[R0, #+8]
   \   00000084   0xE008             B.N      ??HAL_RCC_GetOscConfig_8
   1254            }
   1255            else if((RCC->CSR &RCC_CSR_LSEON) == RCC_CSR_LSEON)
   \                     ??HAL_RCC_GetOscConfig_7: (+1)
   \   00000086   0x....             LDR.N    R1,??DataTable13_15  ;; 0x40023834
   \   00000088   0x6809             LDR      R1,[R1, #+0]
   \   0000008A   0x05C9             LSLS     R1,R1,#+23
   \   0000008C   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_9
   1256            {
   1257              RCC_OscInitStruct->LSEState = RCC_LSE_ON;
   \   0000008E   0x2101             MOVS     R1,#+1
   \   00000090   0x6081             STR      R1,[R0, #+8]
   \   00000092   0xE001             B.N      ??HAL_RCC_GetOscConfig_8
   1258            }
   1259            else
   1260            {
   1261              RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
   \                     ??HAL_RCC_GetOscConfig_9: (+1)
   \   00000094   0x2100             MOVS     R1,#+0
   \   00000096   0x6081             STR      R1,[R0, #+8]
   1262            }
   1263            
   1264            /* Get the LSI configuration -----------------------------------------------*/
   1265            if((RCC->CSR &RCC_CSR_LSION) == RCC_CSR_LSION)
   \                     ??HAL_RCC_GetOscConfig_8: (+1)
   \   00000098   0x....             LDR.N    R1,??DataTable13_15  ;; 0x40023834
   \   0000009A   0x6809             LDR      R1,[R1, #+0]
   \   0000009C   0x07C9             LSLS     R1,R1,#+31
   \   0000009E   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_10
   1266            {
   1267              RCC_OscInitStruct->LSIState = RCC_LSI_ON;
   \   000000A0   0x2101             MOVS     R1,#+1
   \   000000A2   0x6141             STR      R1,[R0, #+20]
   \   000000A4   0xE001             B.N      ??HAL_RCC_GetOscConfig_11
   1268            }
   1269            else
   1270            {
   1271              RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
   \                     ??HAL_RCC_GetOscConfig_10: (+1)
   \   000000A6   0x2100             MOVS     R1,#+0
   \   000000A8   0x6141             STR      R1,[R0, #+20]
   1272            }
   1273            
   1274            /* Get the PLL configuration -----------------------------------------------*/
   1275            if((RCC->CR &RCC_CR_PLLON) == RCC_CR_PLLON)
   \                     ??HAL_RCC_GetOscConfig_11: (+1)
   \   000000AA   0x....             LDR.N    R1,??DataTable13_5  ;; 0x40023800
   \   000000AC   0x6809             LDR      R1,[R1, #+0]
   \   000000AE   0x01C9             LSLS     R1,R1,#+7
   \   000000B0   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_12
   1276            {
   1277              RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
   \   000000B2   0x2102             MOVS     R1,#+2
   \   000000B4   0x6241             STR      R1,[R0, #+36]
   \   000000B6   0xE001             B.N      ??HAL_RCC_GetOscConfig_13
   1278            }
   1279            else
   1280            {
   1281              RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
   \                     ??HAL_RCC_GetOscConfig_12: (+1)
   \   000000B8   0x2101             MOVS     R1,#+1
   \   000000BA   0x6241             STR      R1,[R0, #+36]
   1282            }
   1283            RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLSRC);
   \                     ??HAL_RCC_GetOscConfig_13: (+1)
   \   000000BC   0x....             LDR.N    R1,??DataTable13_4  ;; 0x40023808
   \   000000BE   0x6809             LDR      R1,[R1, #+0]
   \   000000C0   0xF411 0x3180      ANDS     R1,R1,#0x10000
   \   000000C4   0x6281             STR      R1,[R0, #+40]
   1284            RCC_OscInitStruct->PLL.PLLMUL = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLMUL);
   \   000000C6   0x....             LDR.N    R1,??DataTable13_4  ;; 0x40023808
   \   000000C8   0x6809             LDR      R1,[R1, #+0]
   \   000000CA   0xF411 0x1170      ANDS     R1,R1,#0x3C0000
   \   000000CE   0x62C1             STR      R1,[R0, #+44]
   1285            RCC_OscInitStruct->PLL.PLLDIV = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLDIV);
   \   000000D0   0x....             LDR.N    R1,??DataTable13_4  ;; 0x40023808
   \   000000D2   0x6809             LDR      R1,[R1, #+0]
   \   000000D4   0xF411 0x0140      ANDS     R1,R1,#0xC00000
   \   000000D8   0x6301             STR      R1,[R0, #+48]
   1286          }
   \   000000DA   0x4770             BX       LR               ;; return
   1287          
   1288          /**
   1289            * @brief  Get the RCC_ClkInitStruct according to the internal 
   1290            * RCC configuration registers.
   1291            * @param  RCC_ClkInitStruct: pointer to an RCC_ClkInitTypeDef structure that 
   1292            * contains the current clock configuration.
   1293            * @param  pFLatency: Pointer on the Flash Latency.
   1294            * @retval None
   1295            */

   \                                 In section .text, align 2, keep-with-next
   1296          void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
   1297          {
   1298            /* Check the parameters */
   1299            assert_param(RCC_ClkInitStruct != NULL);
   1300            assert_param(pFLatency != NULL);
   1301          
   1302            /* Set all possible values for the Clock type parameter --------------------*/
   1303            RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
   \                     HAL_RCC_GetClockConfig: (+1)
   \   00000000   0x220F             MOVS     R2,#+15
   \   00000002   0x6002             STR      R2,[R0, #+0]
   1304            
   1305            /* Get the SYSCLK configuration --------------------------------------------*/ 
   1306            RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
   \   00000004   0x....             LDR.N    R2,??DataTable13_4  ;; 0x40023808
   \   00000006   0x6812             LDR      R2,[R2, #+0]
   \   00000008   0xF012 0x0203      ANDS     R2,R2,#0x3
   \   0000000C   0x6042             STR      R2,[R0, #+4]
   1307            
   1308            /* Get the HCLK configuration ----------------------------------------------*/ 
   1309            RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE); 
   \   0000000E   0x....             LDR.N    R2,??DataTable13_4  ;; 0x40023808
   \   00000010   0x6812             LDR      R2,[R2, #+0]
   \   00000012   0xF012 0x02F0      ANDS     R2,R2,#0xF0
   \   00000016   0x6082             STR      R2,[R0, #+8]
   1310            
   1311            /* Get the APB1 configuration ----------------------------------------------*/ 
   1312            RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);   
   \   00000018   0x....             LDR.N    R2,??DataTable13_4  ;; 0x40023808
   \   0000001A   0x6812             LDR      R2,[R2, #+0]
   \   0000001C   0xF412 0x62E0      ANDS     R2,R2,#0x700
   \   00000020   0x60C2             STR      R2,[R0, #+12]
   1313            
   1314            /* Get the APB2 configuration ----------------------------------------------*/ 
   1315            RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
   \   00000022   0x....             LDR.N    R2,??DataTable13_4  ;; 0x40023808
   \   00000024   0x6812             LDR      R2,[R2, #+0]
   \   00000026   0x08D2             LSRS     R2,R2,#+3
   \   00000028   0xF412 0x62E0      ANDS     R2,R2,#0x700
   \   0000002C   0x6102             STR      R2,[R0, #+16]
   1316            
   1317            /* Get the Flash Wait State (Latency) configuration ------------------------*/   
   1318            *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY); 
   \   0000002E   0x....             LDR.N    R2,??DataTable13_3  ;; 0x40023c00
   \   00000030   0x6812             LDR      R2,[R2, #+0]
   \   00000032   0xF012 0x0201      ANDS     R2,R2,#0x1
   \   00000036   0x600A             STR      R2,[R1, #+0]
   1319          }
   \   00000038   0x4770             BX       LR               ;; return
   1320          
   1321          /**
   1322            * @brief This function handles the RCC CSS interrupt request.
   1323            * @note This API should be called under the NMI_Handler().
   1324            * @retval None
   1325            */

   \                                 In section .text, align 2, keep-with-next
   1326          void HAL_RCC_NMI_IRQHandler(void)
   1327          {
   \                     HAL_RCC_NMI_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1328            /* Check RCC CSSF flag  */
   1329            if(__HAL_RCC_GET_IT(RCC_IT_CSS))
   \   00000002   0x....             LDR.N    R0,??DataTable13_16  ;; 0x4002380c
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x0600             LSLS     R0,R0,#+24
   \   00000008   0xD504             BPL.N    ??HAL_RCC_NMI_IRQHandler_0
   1330            {
   1331              /* RCC Clock Security System interrupt user callback */
   1332              HAL_RCC_CSSCallback();
   \   0000000A   0x.... 0x....      BL       HAL_RCC_CSSCallback
   1333              
   1334              /* Clear RCC CSS pending bit */
   1335              __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
   \   0000000E   0x2080             MOVS     R0,#+128
   \   00000010   0x....             LDR.N    R1,??DataTable13_17  ;; 0x4002380e
   \   00000012   0x7008             STRB     R0,[R1, #+0]
   1336            }
   1337          }
   \                     ??HAL_RCC_NMI_IRQHandler_0: (+1)
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
   1338          
   1339          /**
   1340            * @brief  RCC Clock Security System interrupt callback
   1341            * @retval none
   1342            */

   \                                 In section .text, align 2
   1343          __weak void HAL_RCC_CSSCallback(void)
   1344          {
   1345            /* NOTE : This function Should not be modified, when the callback is needed,
   1346              the HAL_RCC_CSSCallback could be implemented in the user file
   1347              */ 
   1348          }
   \                     HAL_RCC_CSSCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1349          
   1350          /**
   1351            * @}
   1352            */
   1353          
   1354          /**
   1355            * @}
   1356            */
   1357          
   1358          /* Private function prototypes -----------------------------------------------*/
   1359          /** @addtogroup RCC_Private_Functions
   1360            * @{
   1361            */
   1362          /**
   1363            * @brief  Update number of Flash wait states in line with MSI range and current 
   1364                      voltage range
   1365            * @param  msirange : MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_6
   1366            * @retval HAL status
   1367            */

   \                                 In section .text, align 2, keep-with-next
   1368          static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
   1369          {
   \                     RCC_SetFlashLatencyFromMSIRange: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   1370            uint32_t vos = 0;
   \   00000006   0x2500             MOVS     R5,#+0
   1371            uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
   \   00000008   0x2600             MOVS     R6,#+0
   1372          
   1373            /* HCLK can reach 4 MHz only if AHB prescaler = 1 */
   1374            if (READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) == RCC_SYSCLK_DIV1)
   \   0000000A   0x....             LDR.N    R0,??DataTable13_4  ;; 0x40023808
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF010 0x0FF0      TST      R0,#0xF0
   \   00000012   0xD124             BNE.N    ??RCC_SetFlashLatencyFromMSIRange_0
   1375            {
   1376              if(__HAL_RCC_PWR_IS_CLK_ENABLED())
   \   00000014   0x....             LDR.N    R0,??DataTable13_1  ;; 0x40023824
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x00C0             LSLS     R0,R0,#+3
   \   0000001A   0xD503             BPL.N    ??RCC_SetFlashLatencyFromMSIRange_1
   1377              {
   1378                vos = HAL_PWREx_GetVoltageRange();
   \   0000001C   0x.... 0x....      BL       HAL_PWREx_GetVoltageRange
   \   00000020   0x0005             MOVS     R5,R0
   \   00000022   0xE014             B.N      ??RCC_SetFlashLatencyFromMSIRange_2
   1379              }
   1380              else
   1381              {
   1382                __HAL_RCC_PWR_CLK_ENABLE();
   \                     ??RCC_SetFlashLatencyFromMSIRange_1: (+1)
   \   00000024   0x....             LDR.N    R0,??DataTable13_1  ;; 0x40023824
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   0000002C   0x....             LDR.N    R1,??DataTable13_1  ;; 0x40023824
   \   0000002E   0x6008             STR      R0,[R1, #+0]
   \   00000030   0x....             LDR.N    R0,??DataTable13_1  ;; 0x40023824
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0xF010 0x5080      ANDS     R0,R0,#0x10000000
   \   00000038   0x9000             STR      R0,[SP, #+0]
   \   0000003A   0x9800             LDR      R0,[SP, #+0]
   1383                vos = HAL_PWREx_GetVoltageRange();
   \   0000003C   0x.... 0x....      BL       HAL_PWREx_GetVoltageRange
   \   00000040   0x0005             MOVS     R5,R0
   1384                __HAL_RCC_PWR_CLK_DISABLE();
   \   00000042   0x....             LDR.N    R0,??DataTable13_1  ;; 0x40023824
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xF030 0x5080      BICS     R0,R0,#0x10000000
   \   0000004A   0x....             LDR.N    R1,??DataTable13_1  ;; 0x40023824
   \   0000004C   0x6008             STR      R0,[R1, #+0]
   1385              }
   1386              
   1387              /* Check if need to set latency 1 only for Range 3 & HCLK = 4MHz */
   1388              if((vos == PWR_REGULATOR_VOLTAGE_SCALE3) && (msirange == RCC_MSIRANGE_6))
   \                     ??RCC_SetFlashLatencyFromMSIRange_2: (+1)
   \   0000004E   0xF5B5 0x5FC0      CMP      R5,#+6144
   \   00000052   0xD104             BNE.N    ??RCC_SetFlashLatencyFromMSIRange_0
   \   00000054   0xF5B4 0x4F40      CMP      R4,#+49152
   \   00000058   0xD101             BNE.N    ??RCC_SetFlashLatencyFromMSIRange_0
   1389              {
   1390                latency = FLASH_LATENCY_1; /* 1WS */
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0x0006             MOVS     R6,R0
   1391              }
   1392            }
   1393            
   1394            __HAL_FLASH_SET_LATENCY(latency);
   \                     ??RCC_SetFlashLatencyFromMSIRange_0: (+1)
   \   0000005E   0x2E01             CMP      R6,#+1
   \   00000060   0xD105             BNE.N    ??RCC_SetFlashLatencyFromMSIRange_3
   \   00000062   0x....             LDR.N    R0,??DataTable13_3  ;; 0x40023c00
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000006A   0x....             LDR.N    R1,??DataTable13_3  ;; 0x40023c00
   \   0000006C   0x6008             STR      R0,[R1, #+0]
   \                     ??RCC_SetFlashLatencyFromMSIRange_3: (+1)
   \   0000006E   0x....             LDR.N    R0,??DataTable13_3  ;; 0x40023c00
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0x0840             LSRS     R0,R0,#+1
   \   00000074   0x0040             LSLS     R0,R0,#+1
   \   00000076   0x4330             ORRS     R0,R6,R0
   \   00000078   0x....             LDR.N    R1,??DataTable13_3  ;; 0x40023c00
   \   0000007A   0x6008             STR      R0,[R1, #+0]
   1395            
   1396            /* Check that the new number of wait states is taken into account to access the Flash
   1397               memory by reading the FLASH_ACR register */
   1398            if((FLASH->ACR & FLASH_ACR_LATENCY) != latency)
   \   0000007C   0x....             LDR.N    R0,??DataTable13_3  ;; 0x40023c00
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000084   0x42B0             CMP      R0,R6
   \   00000086   0xD001             BEQ.N    ??RCC_SetFlashLatencyFromMSIRange_4
   1399            {
   1400              return HAL_ERROR;
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0xE000             B.N      ??RCC_SetFlashLatencyFromMSIRange_5
   1401            }
   1402            
   1403            return HAL_OK;
   \                     ??RCC_SetFlashLatencyFromMSIRange_4: (+1)
   \   0000008C   0x2000             MOVS     R0,#+0
   \                     ??RCC_SetFlashLatencyFromMSIRange_5: (+1)
   \   0000008E   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1404          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x40023800         DC32     0x40023800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x40023808         DC32     0x40023808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0xEEFAFFFE         DC32     0xeefafffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x40023804         DC32     0x40023804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x00FF1FFF         DC32     0xff1fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x4002380C         DC32     0x4002380c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x40023834         DC32     0x40023834

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x40023802         DC32     0x40023802

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x42470000         DC32     0x42470000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x42470680         DC32     0x42470680

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x40023824         DC32     0x40023824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x40007000         DC32     0x40007000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x40023C00         DC32     0x40023c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x40023808         DC32     0x40023808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x40023800         DC32     0x40023800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x4002381C         DC32     0x4002381c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \   00000000   0x00F42400         DC32     0xf42400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \   00000000   0x007A1200         DC32     0x7a1200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_10:
   \   00000000   0x........         DC32     aPLLMulFactorTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_11:
   \   00000000   0x........         DC32     aPLLDivisionFactorTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_12:
   \   00000000   0x40023804         DC32     0x40023804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_13:
   \   00000000   0x........         DC32     aAPBAHBPrescTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_14:
   \   00000000   0x........         DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_15:
   \   00000000   0x40023834         DC32     0x40023834

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_16:
   \   00000000   0x4002380C         DC32     0x4002380c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_17:
   \   00000000   0x4002380E         DC32     0x4002380e
   1405          
   1406          /**
   1407            * @}
   1408            */
   1409            
   1410          #endif /* HAL_RCC_MODULE_ENABLED */
   1411          /**
   1412            * @}
   1413            */
   1414          
   1415          /**
   1416            * @}
   1417            */
   1418          
   1419          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_RCC_CSSCallback
      16   HAL_RCC_ClockConfig
        16   -> HAL_GetTick
        16   -> HAL_InitTick
       0   HAL_RCC_DeInit
       0   HAL_RCC_DisableCSS
       0   HAL_RCC_EnableCSS
       0   HAL_RCC_GetClockConfig
       8   HAL_RCC_GetHCLKFreq
         8   -> HAL_RCC_GetSysClockFreq
       0   HAL_RCC_GetOscConfig
       8   HAL_RCC_GetPCLK1Freq
         8   -> HAL_RCC_GetHCLKFreq
       8   HAL_RCC_GetPCLK2Freq
         8   -> HAL_RCC_GetHCLKFreq
      16   HAL_RCC_GetSysClockFreq
      40   HAL_RCC_MCOConfig
        40   -> HAL_GPIO_Init
       8   HAL_RCC_NMI_IRQHandler
         8   -> HAL_RCC_CSSCallback
      16   HAL_RCC_OscConfig
        16   -> HAL_GetTick
        16   -> HAL_InitTick
        16   -> RCC_SetFlashLatencyFromMSIRange
      24   RCC_SetFlashLatencyFromMSIRange
        24   -> HAL_PWREx_GetVoltageRange


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_12
       4  ??DataTable13_13
       4  ??DataTable13_14
       4  ??DataTable13_15
       4  ??DataTable13_16
       4  ??DataTable13_17
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable6
       4  ??DataTable9
       2  HAL_RCC_CSSCallback
    1100  HAL_RCC_ClockConfig
     126  HAL_RCC_DeInit
      18  HAL_RCC_DisableCSS
      18  HAL_RCC_EnableCSS
      58  HAL_RCC_GetClockConfig
      40  HAL_RCC_GetHCLKFreq
     220  HAL_RCC_GetOscConfig
      32  HAL_RCC_GetPCLK1Freq
      32  HAL_RCC_GetPCLK2Freq
     166  HAL_RCC_GetSysClockFreq
      90  HAL_RCC_MCOConfig
      22  HAL_RCC_NMI_IRQHandler
    2244  HAL_RCC_OscConfig
     144  RCC_SetFlashLatencyFromMSIRange
      16  aAPBAHBPrescTable
       4  aPLLDivisionFactorTable
      12  aPLLMulFactorTable

 
    32 bytes in section .rodata
 4 420 bytes in section .text
 
 4 418 bytes of CODE  memory (+ 2 bytes shared)
    32 bytes of CONST memory

Errors: none
Warnings: none
