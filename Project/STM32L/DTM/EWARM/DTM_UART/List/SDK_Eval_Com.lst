###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       29/Jan/2018  14:45:22
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Library\STM32L\Drivers\BSP\STM32L1xx_Nucleo\src\SDK_Eval_Com.c
#    Command line =  
#        "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Library\STM32L\Drivers\BSP\STM32L1xx_Nucleo\src\SDK_Eval_Com.c"
#        -D STM32L151xB -D STM32L1XX_XL -D USE_STM32L1XX_STEVAL_IDB00xV1 -D
#        USE_HAL_DRIVER -D HCLK_32MHZ=1 -D SYSCLK_MSI=1 -D ENABLE_USART -D
#        USER_DEFINED_PLATFORM=USER_EVAL_PLATFORM -D IRQ_RESET_PIN -D DTM_UART
#        -lC "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\List"
#        -o "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        D:\Software\IAR_BlueNRG\arm\INC\c\DLib_Config_Normal.h -I
#        "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\HAL\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\BSP\STM32L1xx_BlueNRG1\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\BSP\STM32L1xx_Nucleo\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\CMSIS\Device\ST\STM32L1xx\Include\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\STM32L1xx_HAL_BlueNRG1_Drivers\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\SimpleBlueNRG1_HCI\includes\"
#        -On --use_c++_inline -I D:\Software\IAR_BlueNRG\arm\CMSIS\Include\
#    Locale       =  Chinese (Simplified)_China.936
#    List file    =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\List\SDK_Eval_Com.lst
#    Object file  =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\Obj\SDK_Eval_Com.o
#
###############################################################################

C:\Users\Administrator\Desktop\Temporary Files\eeworld_project\Project_Test\Library\STM32L\Drivers\BSP\STM32L1xx_Nucleo\src\SDK_Eval_Com.c
      1          /**
      2           * @file    SDK_EVAL_Io.c
      3           * @author  AMS VMA RF application team
      4           * @version V1.0.1
      5           * @date    March,17 2015
      6           * @brief   This file provides all the low level API to manage SDK I/O ports.
      7           * @details
      8           *
      9           * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     10           * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     11           * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     12           * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     13           * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     14           * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     15           *
     16           * THIS SOURCE CODE IS PROTECTED BY A LICENSE.
     17           * FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED
     18           * IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
     19           *
     20           * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     21           */
     22          
     23          
     24          /* Includes ------------------------------------------------------------------*/
     25          #include "SDK_EVAL_Config.h"
     26          
     27          
     28          #ifdef ENABLE_USB
     29          #include "usbd_core.h"
     30          #include "usbd_desc.h"
     31          #include "usbd_cdc.h" 
     32          #include "usbd_cdc_interface.h"
     33          #endif 
     34          
     35          #include <stdio.h>
     36          #include <yfuns.h>
     37          
     38          /** @addtogroup SDK_EVAL_STM32L
     39           * @{
     40           */
     41          
     42          
     43          /** @addtogroup SDK_EVAL_Io
     44           * @{
     45           */
     46          
     47          
     48          /** @defgroup SDK_EVAL_Io_Private_TypesDefinitions             SDK EVAL IO Private Types Definitions
     49           * @{
     50           */
     51          
     52          /**
     53           * @brief  IO_Receive_Data User callback 
     54           */
     55          typedef struct _IO_ReceiveCallBack
     56          {
     57            /**
     58             * callback to notify the applicatio with the received I/O data
     59             */ 
     60            IO_RECEIVE_DATA_USER_CALLBACK_TYPE IO_user_application;
     61          } IO_ReceiveCallBack;
     62          /**
     63           * @}
     64           */
     65          
     66          
     67          /** @defgroup SDK_EVAL_Io_Private_Defines                      SDK EVAL IO Private Defines
     68           * @{
     69           */
     70          #define READ_DATA_SIZE      1024
     71          #define READ_BUFFER_IS_EMPTY() (Read_ptr_in == Read_ptr_out)
     72          
     73          #ifdef ENABLE_USART
     74          #define UART_TX_TIMEOUT 5 
     75          #endif 
     76          
     77          /**
     78           * @}
     79           */
     80          
     81          
     82          /** @defgroup SDK_EVAL_Io_Private_Macros                       SDK EVAL IO Private Macros
     83           * @{
     84           */
     85          
     86          /* IO User Callback used to handle received data from I/O channel*/

   \                                 In section .bss, align 4
     87          static IO_ReceiveCallBack IO_Receive_Data;
   \                     IO_Receive_Data:
   \   00000000                      DS8 4
     88          
     89          /**
     90           * @}
     91           */
     92          
     93          /** @defgroup SDK_EVAL_Io_Private_Variables                    SDK EVAL IO Private Variables
     94           * @{
     95           */
     96          

   \                                 In section .bss, align 4
     97          static uint8_t  Read_Buffer [READ_DATA_SIZE]; 
   \                     Read_Buffer:
   \   00000000                      DS8 1024

   \                                 In section .bss, align 4
     98          static uint32_t Read_ptr_in = 0;
   \                     Read_ptr_in:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     99          static uint32_t Read_ptr_out = 0;
   \                     Read_ptr_out:
   \   00000000                      DS8 4
    100          
    101          #ifdef ENABLE_USART

   \                                 In section .bss, align 4
    102          UART_HandleTypeDef xUsartInit;
   \                     xUsartInit:
   \   00000000                      DS8 64

   \                                 In section .bss, align 1
    103          uint8_t read_data; 
   \                     read_data:
   \   00000000                      DS8 1
    104          #endif 
    105          
    106          #ifdef ENABLE_USB
    107          void USB_Send_Data(uint8_t byte);
    108          #endif
    109          
    110          /**
    111           * @}
    112           */
    113          
    114          
    115          /** @defgroup SDK_EVAL_Io_Private_FunctionPrototypes                   SDK EVAL IO Private Function Prototypes
    116           * @{
    117           */
    118          
    119          /**
    120           * @}
    121           */
    122          
    123          
    124          /** @defgroup SDK_EVAL_IO_Private_Functions                            SDK EVAL IO Private Functions
    125           * @{
    126           */
    127          
    128          #ifdef ENABLE_USART
    129          
    130          /**
    131           * @brief  Configures Uart port.
    132           * @param  xCom Specifies the COM port to be configured.
    133           * @retval None.
    134           */

   \                                 In section .text, align 2, keep-with-next
    135          static void SdkEvalComUart_Init(uint32_t baudrate)
    136          {
   \                     SdkEvalComUart_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x0004             MOVS     R4,R0
    137            GPIO_InitTypeDef GPIO_InitStructure;
    138            
    139            
    140            /* Enable GPIO clock */
    141            UART_CLOCK();
   \   00000006   0x....             LDR.N    R0,??DataTable8  ;; 0x40023824
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xF450 0x3000      ORRS     R0,R0,#0x20000
   \   0000000E   0x....             LDR.N    R1,??DataTable8  ;; 0x40023824
   \   00000010   0x6008             STR      R0,[R1, #+0]
   \   00000012   0x....             LDR.N    R0,??DataTable8  ;; 0x40023824
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF410 0x3000      ANDS     R0,R0,#0x20000
   \   0000001A   0x9000             STR      R0,[SP, #+0]
   \   0000001C   0x9800             LDR      R0,[SP, #+0]
    142            UART_TX_CLOCK();
   \   0000001E   0x....             LDR.N    R0,??DataTable8_1  ;; 0x4002381c
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000026   0x....             LDR.N    R1,??DataTable8_1  ;; 0x4002381c
   \   00000028   0x6008             STR      R0,[R1, #+0]
   \   0000002A   0x....             LDR.N    R0,??DataTable8_1  ;; 0x4002381c
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000032   0x9000             STR      R0,[SP, #+0]
   \   00000034   0x9800             LDR      R0,[SP, #+0]
    143            UART_RX_CLOCK();
   \   00000036   0x....             LDR.N    R0,??DataTable8_1  ;; 0x4002381c
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000003E   0x....             LDR.N    R1,??DataTable8_1  ;; 0x4002381c
   \   00000040   0x6008             STR      R0,[R1, #+0]
   \   00000042   0x....             LDR.N    R0,??DataTable8_1  ;; 0x4002381c
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000004A   0x9000             STR      R0,[SP, #+0]
   \   0000004C   0x9800             LDR      R0,[SP, #+0]
    144            xUsartInit.Instance      = UART_PORT;
   \   0000004E   0x....             LDR.N    R0,??DataTable8_2  ;; 0x40004400
   \   00000050   0x....             LDR.N    R1,??DataTable8_3
   \   00000052   0x6008             STR      R0,[R1, #+0]
    145            HAL_UART_DeInit(&xUsartInit);
   \   00000054   0x....             LDR.N    R0,??DataTable8_3
   \   00000056   0x.... 0x....      BL       HAL_UART_DeInit
    146            
    147            xUsartInit.Init.BaudRate   = baudrate;
   \   0000005A   0x....             LDR.N    R0,??DataTable8_3
   \   0000005C   0x6044             STR      R4,[R0, #+4]
    148            xUsartInit.Init.WordLength = UART_WORDLENGTH_8B;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x....             LDR.N    R1,??DataTable8_3
   \   00000062   0x6088             STR      R0,[R1, #+8]
    149            xUsartInit.Init.StopBits   = UART_STOPBITS_1;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x....             LDR.N    R1,??DataTable8_3
   \   00000068   0x60C8             STR      R0,[R1, #+12]
    150            xUsartInit.Init.Parity     = UART_PARITY_NONE;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x....             LDR.N    R1,??DataTable8_3
   \   0000006E   0x6108             STR      R0,[R1, #+16]
    151            xUsartInit.Init.HwFlowCtl  = UART_HWCONTROL_NONE;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x....             LDR.N    R1,??DataTable8_3
   \   00000074   0x6188             STR      R0,[R1, #+24]
    152            xUsartInit.Init.Mode       = UART_MODE_TX_RX;
   \   00000076   0x200C             MOVS     R0,#+12
   \   00000078   0x....             LDR.N    R1,??DataTable8_3
   \   0000007A   0x6148             STR      R0,[R1, #+20]
    153            
    154            /* Configure USART Tx as alternate function push-pull */
    155            GPIO_InitStructure.Pin       = UART_TX_PIN;
   \   0000007C   0x2004             MOVS     R0,#+4
   \   0000007E   0x9001             STR      R0,[SP, #+4]
    156            GPIO_InitStructure.Mode      = GPIO_MODE_AF_PP;
   \   00000080   0x2002             MOVS     R0,#+2
   \   00000082   0x9002             STR      R0,[SP, #+8]
    157            GPIO_InitStructure.Pull      = GPIO_PULLUP;
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0x9003             STR      R0,[SP, #+12]
    158            GPIO_InitStructure.Speed     = GPIO_SPEED_HIGH;
   \   00000088   0x2003             MOVS     R0,#+3
   \   0000008A   0x9004             STR      R0,[SP, #+16]
    159            GPIO_InitStructure.Alternate = UART_TX_AF;
   \   0000008C   0x2007             MOVS     R0,#+7
   \   0000008E   0x9005             STR      R0,[SP, #+20]
    160            HAL_GPIO_Init(UART_TX_PORT, &GPIO_InitStructure);
   \   00000090   0xA901             ADD      R1,SP,#+4
   \   00000092   0x....             LDR.N    R0,??DataTable8_4  ;; 0x40020000
   \   00000094   0x.... 0x....      BL       HAL_GPIO_Init
    161            
    162            /* Configure USART Rx as input floating */
    163            GPIO_InitStructure.Pin = UART_RX_PIN;
   \   00000098   0x2008             MOVS     R0,#+8
   \   0000009A   0x9001             STR      R0,[SP, #+4]
    164            GPIO_InitStructure.Alternate = UART_RX_AF;
   \   0000009C   0x2007             MOVS     R0,#+7
   \   0000009E   0x9005             STR      R0,[SP, #+20]
    165            HAL_GPIO_Init(UART_RX_PORT, &GPIO_InitStructure);
   \   000000A0   0xA901             ADD      R1,SP,#+4
   \   000000A2   0x....             LDR.N    R0,??DataTable8_4  ;; 0x40020000
   \   000000A4   0x.... 0x....      BL       HAL_GPIO_Init
    166            
    167            /* Configure the NVIC for SPI */  
    168            HAL_NVIC_SetPriority(UART_IRQ, 4, 0); //TBR Which priority < spi
   \   000000A8   0x2200             MOVS     R2,#+0
   \   000000AA   0x2104             MOVS     R1,#+4
   \   000000AC   0x2026             MOVS     R0,#+38
   \   000000AE   0x.... 0x....      BL       HAL_NVIC_SetPriority
    169            HAL_NVIC_EnableIRQ(UART_IRQ);
   \   000000B2   0x2026             MOVS     R0,#+38
   \   000000B4   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    170            
    171            /* USART configuration */
    172            HAL_UART_Init(&xUsartInit);  
   \   000000B8   0x....             LDR.N    R0,??DataTable8_3
   \   000000BA   0x.... 0x....      BL       HAL_UART_Init
    173            
    174            /* Enable the USARTx Receive interrupt: this interrupt is generated when the
    175            USARTx receive data register is not empty */
    176            HAL_UART_Receive_IT(&xUsartInit, &read_data, 1);
   \   000000BE   0x2201             MOVS     R2,#+1
   \   000000C0   0x....             LDR.N    R1,??DataTable8_5
   \   000000C2   0x....             LDR.N    R0,??DataTable8_3
   \   000000C4   0x.... 0x....      BL       HAL_UART_Receive_IT
    177          }/* end SdkEvalUart_Init() */
   \   000000C8   0xB006             ADD      SP,SP,#+24
   \   000000CA   0xBD10             POP      {R4,PC}          ;; return
    178          
    179          /**
    180           * @brief  Configures Uart port.
    181           * @param  xCom Specifies the COM port to be configured.
    182           * @retval None.
    183           */

   \                                 In section .text, align 2, keep-with-next
    184          static void SdkEvalUart_Init(SdkEvalCom xCom)
    185          {
   \                     SdkEvalUart_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x0004             MOVS     R4,R0
    186            GPIO_InitTypeDef GPIO_InitStructure;
    187          
    188          
    189            /* Enable GPIO clock */
    190            if(xCom==COM1) {
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD13C             BNE.N    ??SdkEvalUart_Init_0
    191              UART_CLOCK();
   \   0000000C   0x....             LDR.N    R0,??DataTable8  ;; 0x40023824
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF450 0x3000      ORRS     R0,R0,#0x20000
   \   00000014   0x....             LDR.N    R1,??DataTable8  ;; 0x40023824
   \   00000016   0x6008             STR      R0,[R1, #+0]
   \   00000018   0x....             LDR.N    R0,??DataTable8  ;; 0x40023824
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF410 0x3000      ANDS     R0,R0,#0x20000
   \   00000020   0x9000             STR      R0,[SP, #+0]
   \   00000022   0x9800             LDR      R0,[SP, #+0]
    192              UART_TX_CLOCK();
   \   00000024   0x....             LDR.N    R0,??DataTable8_1  ;; 0x4002381c
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000002C   0x....             LDR.N    R1,??DataTable8_1  ;; 0x4002381c
   \   0000002E   0x6008             STR      R0,[R1, #+0]
   \   00000030   0x....             LDR.N    R0,??DataTable8_1  ;; 0x4002381c
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000038   0x9000             STR      R0,[SP, #+0]
   \   0000003A   0x9800             LDR      R0,[SP, #+0]
    193              UART_RX_CLOCK();
   \   0000003C   0x....             LDR.N    R0,??DataTable8_1  ;; 0x4002381c
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000044   0x....             LDR.N    R1,??DataTable8_1  ;; 0x4002381c
   \   00000046   0x6008             STR      R0,[R1, #+0]
   \   00000048   0x....             LDR.N    R0,??DataTable8_1  ;; 0x4002381c
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000050   0x9000             STR      R0,[SP, #+0]
   \   00000052   0x9800             LDR      R0,[SP, #+0]
    194              xUsartInit.Instance      = UART_PORT;
   \   00000054   0x....             LDR.N    R0,??DataTable8_2  ;; 0x40004400
   \   00000056   0x....             LDR.N    R1,??DataTable8_3
   \   00000058   0x6008             STR      R0,[R1, #+0]
    195              HAL_UART_DeInit(&xUsartInit);
   \   0000005A   0x....             LDR.N    R0,??DataTable8_3
   \   0000005C   0x.... 0x....      BL       HAL_UART_DeInit
    196            
    197              xUsartInit.Init.BaudRate   = UART_BAUDRATE;
   \   00000060   0xF45F 0x30E1      MOVS     R0,#+115200
   \   00000064   0x....             LDR.N    R1,??DataTable8_3
   \   00000066   0x6048             STR      R0,[R1, #+4]
    198              xUsartInit.Init.WordLength = UART_WORDLENGTH_8B;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x....             LDR.N    R1,??DataTable8_3
   \   0000006C   0x6088             STR      R0,[R1, #+8]
    199              xUsartInit.Init.StopBits   = UART_STOPBITS_1;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x....             LDR.N    R1,??DataTable8_3
   \   00000072   0x60C8             STR      R0,[R1, #+12]
    200              xUsartInit.Init.Parity     = UART_PARITY_NONE;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x....             LDR.N    R1,??DataTable8_3
   \   00000078   0x6108             STR      R0,[R1, #+16]
    201              xUsartInit.Init.HwFlowCtl  = UART_HWCONTROL_NONE;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x....             LDR.N    R1,??DataTable8_3
   \   0000007E   0x6188             STR      R0,[R1, #+24]
    202              xUsartInit.Init.Mode       = UART_MODE_TX_RX;
   \   00000080   0x200C             MOVS     R0,#+12
   \   00000082   0x....             LDR.N    R1,??DataTable8_3
   \   00000084   0x6148             STR      R0,[R1, #+20]
    203            }
    204            
    205            /* Configure USART Tx as alternate function push-pull */
    206            GPIO_InitStructure.Pin       = UART_TX_PIN;
   \                     ??SdkEvalUart_Init_0: (+1)
   \   00000086   0x2004             MOVS     R0,#+4
   \   00000088   0x9001             STR      R0,[SP, #+4]
    207            GPIO_InitStructure.Mode      = GPIO_MODE_AF_PP;
   \   0000008A   0x2002             MOVS     R0,#+2
   \   0000008C   0x9002             STR      R0,[SP, #+8]
    208            GPIO_InitStructure.Pull      = GPIO_PULLUP;
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0x9003             STR      R0,[SP, #+12]
    209            GPIO_InitStructure.Speed     = GPIO_SPEED_HIGH;
   \   00000092   0x2003             MOVS     R0,#+3
   \   00000094   0x9004             STR      R0,[SP, #+16]
    210            GPIO_InitStructure.Alternate = UART_TX_AF;
   \   00000096   0x2007             MOVS     R0,#+7
   \   00000098   0x9005             STR      R0,[SP, #+20]
    211            HAL_GPIO_Init(UART_TX_PORT, &GPIO_InitStructure);
   \   0000009A   0xA901             ADD      R1,SP,#+4
   \   0000009C   0x....             LDR.N    R0,??DataTable8_4  ;; 0x40020000
   \   0000009E   0x.... 0x....      BL       HAL_GPIO_Init
    212            
    213            /* Configure USART Rx as input floating */
    214            GPIO_InitStructure.Pin = UART_RX_PIN;
   \   000000A2   0x2008             MOVS     R0,#+8
   \   000000A4   0x9001             STR      R0,[SP, #+4]
    215            GPIO_InitStructure.Alternate = UART_RX_AF;
   \   000000A6   0x2007             MOVS     R0,#+7
   \   000000A8   0x9005             STR      R0,[SP, #+20]
    216            HAL_GPIO_Init(UART_RX_PORT, &GPIO_InitStructure);
   \   000000AA   0xA901             ADD      R1,SP,#+4
   \   000000AC   0x....             LDR.N    R0,??DataTable8_4  ;; 0x40020000
   \   000000AE   0x.... 0x....      BL       HAL_GPIO_Init
    217             
    218            /* Configure the NVIC for SPI */  
    219            HAL_NVIC_SetPriority(UART_IRQ, 2, 0); //TBR Which priority < spi
   \   000000B2   0x2200             MOVS     R2,#+0
   \   000000B4   0x2102             MOVS     R1,#+2
   \   000000B6   0x2026             MOVS     R0,#+38
   \   000000B8   0x.... 0x....      BL       HAL_NVIC_SetPriority
    220            HAL_NVIC_EnableIRQ(UART_IRQ);
   \   000000BC   0x2026             MOVS     R0,#+38
   \   000000BE   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    221            
    222             /* USART configuration */
    223            HAL_UART_Init(&xUsartInit);  
   \   000000C2   0x....             LDR.N    R0,??DataTable8_3
   \   000000C4   0x.... 0x....      BL       HAL_UART_Init
    224            
    225            /* Enable the USARTx Receive interrupt: this interrupt is generated when the
    226            USARTx receive data register is not empty */
    227            HAL_UART_Receive_IT(&xUsartInit, &read_data, 1);
   \   000000C8   0x2201             MOVS     R2,#+1
   \   000000CA   0x....             LDR.N    R1,??DataTable8_5
   \   000000CC   0x....             LDR.N    R0,??DataTable8_3
   \   000000CE   0x.... 0x....      BL       HAL_UART_Receive_IT
    228          }/* end SdkEvalUart_Init() */
   \   000000D2   0xB006             ADD      SP,SP,#+24
   \   000000D4   0xBD10             POP      {R4,PC}          ;; return
    229          
    230          
    231          /**
    232           * @brief  Wait for serial data tx end
    233           * @param  None.
    234           * @retval None.
    235           */

   \                                 In section .text, align 2, keep-with-next
    236          static void SdkEvalUart_Wait_Send_Data()  
    237          {	
    238            while(!(__HAL_UART_GET_FLAG(&xUsartInit, UART_FLAG_TXE)));
   \                     SdkEvalUart_Wait_Send_Data: (+1)
   \                     ??SdkEvalUart_Wait_Send_Data_0: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable8_3
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x0600             LSLS     R0,R0,#+24
   \   00000008   0xD5FA             BPL.N    ??SdkEvalUart_Wait_Send_Data_0
    239          }/* end SdkEvalUart_Wait_Send_Data() */
   \   0000000A   0x4770             BX       LR               ;; return
    240          
    241          
    242          
    243          
    244          /**
    245           * @brief  Send a byte on Serial port
    246           * @param  tx_data byte to be sent
    247           * @retval None.
    248           */

   \                                 In section .text, align 2, keep-with-next
    249          static void SdkEvalUart_Send_Data(uint8_t tx_data)
    250          {
   \                     SdkEvalUart_Send_Data: (+1)
   \   00000000   0xB501             PUSH     {R0,LR}
    251            /* wait for the transmission end */
    252            SdkEvalUart_Wait_Send_Data();
   \   00000002   0x.... 0x....      BL       SdkEvalUart_Wait_Send_Data
    253            /* send the data */
    254            HAL_UART_Transmit(&xUsartInit, &tx_data, 1, UART_TX_TIMEOUT);
   \   00000006   0x2305             MOVS     R3,#+5
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x....             LDR.N    R0,??DataTable8_3
   \   0000000E   0x.... 0x....      BL       HAL_UART_Transmit
    255          }/* end SdkEvalUart_Send_Data() */
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
    256          
    257          
    258          /**
    259           * @brief  Serial IRQ handler body to be put on user USARTx_IRQHandler() (stm32l1xx_it.c)
    260           * @param  None
    261           * @retval None.
    262           */

   \                                 In section .text, align 2, keep-with-next
    263          void SdkEval_IO_Uart_Irq_Handler(void)
    264          {
   \                     SdkEval_IO_Uart_Irq_Handler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    265            HAL_UART_IRQHandler(&xUsartInit);
   \   00000002   0x....             LDR.N    R0,??DataTable8_3
   \   00000004   0x.... 0x....      BL       HAL_UART_IRQHandler
    266          }/* SdkEval_IO_Uart_Irq_Handler() */
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    267          
    268          /**
    269           * @brief  Configure the selected I/O communication channel
    270           * @param  None.
    271           * @retval None.
    272           */

   \                                 In section .text, align 2, keep-with-next
    273          void SdkEvalComUartInit(uint32_t baudrate)
    274          {
   \                     SdkEvalComUartInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    275            /* Init Serial Uart */
    276            SdkEvalComUart_Init(baudrate);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       SdkEvalComUart_Init
    277            
    278          }/* end SdkEval_IO_Config() */
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return
    279          
    280          #endif /* #ifdef ENABLE_USART */
    281          
    282          /**
    283           * @brief  Configure the selected I/O communication channel
    284           * @param  None.
    285           * @retval None.
    286           */

   \                                 In section .text, align 2, keep-with-next
    287          void SdkEval_IO_Config(IO_RECEIVE_DATA_USER_CALLBACK_TYPE io_receive_function)
    288          {
   \                     SdkEval_IO_Config: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    289              IO_Receive_Data.IO_user_application = io_receive_function;
   \   00000004   0x....             LDR.N    R0,??DataTable8_6
   \   00000006   0x6004             STR      R4,[R0, #+0]
    290          #if defined (ENABLE_USB)
    291             /* Init Device Library */
    292            USBD_Init(&USBD_Device, &VCP_Desc, 0);
    293            
    294            /* Add Supported Class */
    295            USBD_RegisterClass(&USBD_Device, USBD_CDC_CLASS);
    296            
    297            /* Add CDC Interface Class */
    298            USBD_CDC_RegisterInterface(&USBD_Device, &USBD_CDC_fops);
    299            
    300            /* Start Device Process */
    301            USBD_Start(&USBD_Device);
    302            
    303          #elif defined (ENABLE_USART)
    304            /* Init Serial Uart */
    305            SdkEvalUart_Init(COM1);
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x.... 0x....      BL       SdkEvalUart_Init
    306          #endif 
    307          
    308            
    309          }/* end SdkEval_IO_Config() */
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
    310          
    311          /**
    312           * @brief  Send a byte on selected I/O port
    313           * @param  tx_data byte to be sent
    314           * @retval None.
    315           */

   \                                 In section .text, align 2, keep-with-next
    316          void SdkEval_IO_Send_Data(uint8_t tx_data)
    317          {
   \                     SdkEval_IO_Send_Data: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    318          #if defined (ENABLE_USB)
    319            /* Call USB send data API on hw_config.c */
    320            USB_Send_Data(tx_data); 
    321          #elif defined (ENABLE_USART)
    322            SdkEvalUart_Send_Data(tx_data);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x.... 0x....      BL       SdkEvalUart_Send_Data
    323          #endif
    324          }/* end SdkEval_IO_Send_Data() */
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    325          
    326          /**
    327           * @brief  Receive data on selected I/O port
    328           * @param  rx_data pointer to buffer of received
    329           * @param  data_size number of received data 
    330           * @retval None.
    331           */

   \                                 In section .text, align 2, keep-with-next
    332          void SdkEval_IO_Receive_Data(uint8_t * rx_data, uint16_t data_size)
    333          {
   \                     SdkEval_IO_Receive_Data: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    334            if(IO_Receive_Data.IO_user_application)
   \   00000006   0x....             LDR.N    R0,??DataTable8_6
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD005             BEQ.N    ??SdkEval_IO_Receive_Data_0
    335              IO_Receive_Data.IO_user_application(rx_data,data_size);
   \   0000000E   0x0029             MOVS     R1,R5
   \   00000010   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x....             LDR.N    R2,??DataTable8_6
   \   00000016   0x6812             LDR      R2,[R2, #+0]
   \   00000018   0x4790             BLX      R2
    336            
    337          }/* end SdkEval_IO_Receive_Data() */
   \                     ??SdkEval_IO_Receive_Data_0: (+1)
   \   0000001A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    338          

   \                                 In section .text, align 2, keep-with-next
    339          void Read_Buffer_Push(uint8_t byte)
    340          {
    341              Read_Buffer[Read_ptr_in] = byte;
   \                     Read_Buffer_Push: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable8_7
   \   00000002   0x....             LDR.N    R2,??DataTable8_8
   \   00000004   0x6812             LDR      R2,[R2, #+0]
   \   00000006   0x5488             STRB     R0,[R1, R2]
    342              
    343              Read_ptr_in++;
   \   00000008   0x....             LDR.N    R1,??DataTable8_8
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x1C49             ADDS     R1,R1,#+1
   \   0000000E   0x....             LDR.N    R2,??DataTable8_8
   \   00000010   0x6011             STR      R1,[R2, #+0]
    344              
    345              /* To avoid buffer overflow */
    346              if(Read_ptr_in == READ_DATA_SIZE)
   \   00000012   0x....             LDR.N    R1,??DataTable8_8
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0xF5B1 0x6F80      CMP      R1,#+1024
   \   0000001A   0xD102             BNE.N    ??Read_Buffer_Push_0
    347              {
    348                  Read_ptr_in = 0;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x....             LDR.N    R2,??DataTable8_8
   \   00000020   0x6011             STR      R1,[R2, #+0]
    349              }        
    350          }
   \                     ??Read_Buffer_Push_0: (+1)
   \   00000022   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    351          int Read_Buffer_Pop(uint8_t *byte)
    352          {
   \                     Read_Buffer_Pop: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    353              if(READ_BUFFER_IS_EMPTY())
   \   00000002   0x....             LDR.N    R0,??DataTable8_8
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x....             LDR.N    R2,??DataTable8_9
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0x4290             CMP      R0,R2
   \   0000000C   0xD101             BNE.N    ??Read_Buffer_Pop_0
    354                  return 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE012             B.N      ??Read_Buffer_Pop_1
    355              
    356              *byte = Read_Buffer[Read_ptr_out];
   \                     ??Read_Buffer_Pop_0: (+1)
   \   00000012   0x....             LDR.N    R0,??DataTable8_7
   \   00000014   0x....             LDR.N    R2,??DataTable8_9
   \   00000016   0x6812             LDR      R2,[R2, #+0]
   \   00000018   0x5C80             LDRB     R0,[R0, R2]
   \   0000001A   0x7008             STRB     R0,[R1, #+0]
    357              
    358              Read_ptr_out++;
   \   0000001C   0x....             LDR.N    R0,??DataTable8_9
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x1C40             ADDS     R0,R0,#+1
   \   00000022   0x....             LDR.N    R2,??DataTable8_9
   \   00000024   0x6010             STR      R0,[R2, #+0]
    359              
    360              if(Read_ptr_out == READ_DATA_SIZE)
   \   00000026   0x....             LDR.N    R0,??DataTable8_9
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0xF5B0 0x6F80      CMP      R0,#+1024
   \   0000002E   0xD102             BNE.N    ??Read_Buffer_Pop_2
    361                  Read_ptr_out = 0;  
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x....             LDR.N    R2,??DataTable8_9
   \   00000034   0x6010             STR      R0,[R2, #+0]
    362              
    363              return 1;
   \                     ??Read_Buffer_Pop_2: (+1)
   \   00000036   0x2001             MOVS     R0,#+1
   \                     ??Read_Buffer_Pop_1: (+1)
   \   00000038   0x4770             BX       LR               ;; return
    364          }
    365          
    366          

   \                                 In section .text, align 2, keep-with-next
    367          void SdkEval_IO_processInputData(uint8_t * rx_data, uint16_t data_size)
    368          {
   \                     SdkEval_IO_processInputData: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    369            for(int i = 0; i < data_size; i++){
   \   00000006   0x2600             MOVS     R6,#+0
   \                     ??SdkEval_IO_processInputData_0: (+1)
   \   00000008   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000000A   0x42AE             CMP      R6,R5
   \   0000000C   0xDA04             BGE.N    ??SdkEval_IO_processInputData_1
    370                Read_Buffer_Push(rx_data[i]);
   \   0000000E   0x5DA0             LDRB     R0,[R4, R6]
   \   00000010   0x.... 0x....      BL       Read_Buffer_Push
    371            }
   \   00000014   0x1C76             ADDS     R6,R6,#+1
   \   00000016   0xE7F7             B.N      ??SdkEval_IO_processInputData_0
    372          }
   \                     ??SdkEval_IO_processInputData_1: (+1)
   \   00000018   0xBD70             POP      {R4-R6,PC}       ;; return
    373          
    374          #undef putchar
    375          

   \                                 In section .text, align 2, keep-with-next
    376          int putchar(int c)
    377          {
   \                     putchar: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    378            SdkEval_IO_Send_Data((uint8_t) c);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x.... 0x....      BL       SdkEval_IO_Send_Data
    379            return c;
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
    380          }
    381          

   \                                 In section .text, align 2, keep-with-next
    382          void __io_putchar(char c)
    383          {
   \                     __io_putchar: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    384            putchar(c);
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       putchar
    385          }
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    386          

   \                                 In section .text, align 2, keep-with-next
    387          size_t _write(int handle, const unsigned char * buffer, size_t size)
    388          {
   \                     _write: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    389            size_t nChars = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    390          
    391            if (handle != _LLIO_STDOUT && handle != _LLIO_STDERR) {
   \   0000000A   0x2C01             CMP      R4,#+1
   \   0000000C   0xD004             BEQ.N    ??_write_0
   \   0000000E   0x2C02             CMP      R4,#+2
   \   00000010   0xD002             BEQ.N    ??_write_0
    392              return _LLIO_ERROR;
   \   00000012   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000016   0xE00E             B.N      ??_write_1
    393            }
    394          
    395            if (buffer == 0) {
   \                     ??_write_0: (+1)
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD101             BNE.N    ??_write_2
    396              // This means that we should flush internal buffers.
    397              //spin until TX complete (TX is idle)
    398          #ifdef ENABLE_USB
    399              while (!USB_OUT_BUFFER_IS_EMPTY()) {}   
    400          #endif // ENABLE_USB
    401              return 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE00A             B.N      ??_write_1
    402            }
    403          
    404            while(size--) {
   \                     ??_write_2: (+1)
   \   00000020   0x0030             MOVS     R0,R6
   \   00000022   0x1E46             SUBS     R6,R0,#+1
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD005             BEQ.N    ??_write_3
    405              __io_putchar(*buffer++);
   \   00000028   0x7828             LDRB     R0,[R5, #+0]
   \   0000002A   0x.... 0x....      BL       __io_putchar
   \   0000002E   0x1C6D             ADDS     R5,R5,#+1
    406              ++nChars;
   \   00000030   0x1C7F             ADDS     R7,R7,#+1
   \   00000032   0xE7F5             B.N      ??_write_2
    407            }
    408          
    409            return nChars;
   \                     ??_write_3: (+1)
   \   00000034   0x0038             MOVS     R0,R7
   \                     ??_write_1: (+1)
   \   00000036   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    410          }
    411          
    412          

   \                                 In section .text, align 2, keep-with-next
    413          size_t __read(int handle, unsigned char * buffer, size_t size)
    414          {
   \                     __read: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    415            size_t bytes = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    416            
    417            while(bytes < size && Read_Buffer_Pop(buffer+bytes)){
   \                     ??__read_0: (+1)
   \   0000000A   0x42B7             CMP      R7,R6
   \   0000000C   0xD207             BCS.N    ??__read_1
   \   0000000E   0xEB05 0x0007      ADD      R0,R5,R7
   \   00000012   0x.... 0x....      BL       Read_Buffer_Pop
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD001             BEQ.N    ??__read_1
    418              bytes++;
   \   0000001A   0x1C7F             ADDS     R7,R7,#+1
   \   0000001C   0xE7F5             B.N      ??__read_0
    419            }
    420            return bytes;
   \                     ??__read_1: (+1)
   \   0000001E   0x0038             MOVS     R0,R7
   \   00000020   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    421          }
    422          

   \                                 In section .text, align 2, keep-with-next
    423          uint8_t __io_getcharNonBlocking(uint8_t *data)
    424          {
   \                     __io_getcharNonBlocking: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    425            if (__read(_LLIO_STDIN,data,1))
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x0021             MOVS     R1,R4
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x.... 0x....      BL       __read
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD001             BEQ.N    ??__io_getcharNonBlocking_0
    426              return 1;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xE000             B.N      ??__io_getcharNonBlocking_1
    427            else
    428              return 0;
   \                     ??__io_getcharNonBlocking_0: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \                     ??__io_getcharNonBlocking_1: (+1)
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    429          }/* end serialReadByte() */

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x40023824         DC32     0x40023824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x4002381C         DC32     0x4002381c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x40004400         DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x........         DC32     xUsartInit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x........         DC32     read_data

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x........         DC32     IO_Receive_Data

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x........         DC32     Read_Buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x........         DC32     Read_ptr_in

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \   00000000   0x........         DC32     Read_ptr_out
    430          
    431          /**
    432           * @}
    433           */
    434          
    435          
    436          /**
    437           * @}
    438           */
    439          
    440          
    441          /**
    442           * @}
    443           */
    444          
    445          
    446          /******************* (C) COPYRIGHT 2012 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   Read_Buffer_Pop
       0   Read_Buffer_Push
       8   SdkEvalComUartInit
         8   -> SdkEvalComUart_Init
      32   SdkEvalComUart_Init
        32   -> HAL_GPIO_Init
        32   -> HAL_NVIC_EnableIRQ
        32   -> HAL_NVIC_SetPriority
        32   -> HAL_UART_DeInit
        32   -> HAL_UART_Init
        32   -> HAL_UART_Receive_IT
      32   SdkEvalUart_Init
        32   -> HAL_GPIO_Init
        32   -> HAL_NVIC_EnableIRQ
        32   -> HAL_NVIC_SetPriority
        32   -> HAL_UART_DeInit
        32   -> HAL_UART_Init
        32   -> HAL_UART_Receive_IT
       8   SdkEvalUart_Send_Data
         8   -> HAL_UART_Transmit
         8   -> SdkEvalUart_Wait_Send_Data
       0   SdkEvalUart_Wait_Send_Data
       8   SdkEval_IO_Config
         8   -> SdkEvalUart_Init
      16   SdkEval_IO_Receive_Data
        16   -- Indirect call
       8   SdkEval_IO_Send_Data
         8   -> SdkEvalUart_Send_Data
       8   SdkEval_IO_Uart_Irq_Handler
         8   -> HAL_UART_IRQHandler
      16   SdkEval_IO_processInputData
        16   -> Read_Buffer_Push
       8   __io_getcharNonBlocking
         8   -> __read
       8   __io_putchar
         8   -> putchar
      24   __read
        24   -> Read_Buffer_Pop
      24   _write
        24   -> __io_putchar
       8   putchar
         8   -> SdkEval_IO_Send_Data


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
       4  IO_Receive_Data
    1024  Read_Buffer
      58  Read_Buffer_Pop
      36  Read_Buffer_Push
       4  Read_ptr_in
       4  Read_ptr_out
      12  SdkEvalComUartInit
     204  SdkEvalComUart_Init
     214  SdkEvalUart_Init
      20  SdkEvalUart_Send_Data
      12  SdkEvalUart_Wait_Send_Data
      16  SdkEval_IO_Config
      28  SdkEval_IO_Receive_Data
      14  SdkEval_IO_Send_Data
      10  SdkEval_IO_Uart_Irq_Handler
      26  SdkEval_IO_processInputData
      26  __io_getcharNonBlocking
      14  __io_putchar
      34  __read
      56  _write
      16  putchar
       1  read_data
      64  xUsartInit

 
 1 101 bytes in section .bss
   836 bytes in section .text
 
   836 bytes of CODE memory
 1 101 bytes of DATA memory

Errors: none
Warnings: none
