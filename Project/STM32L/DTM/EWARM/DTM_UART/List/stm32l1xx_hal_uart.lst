###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       29/Jan/2018  14:45:28
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_uart.c
#    Command line =  
#        "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_uart.c"
#        -D STM32L151xB -D STM32L1XX_XL -D USE_STM32L1XX_STEVAL_IDB00xV1 -D
#        USE_HAL_DRIVER -D HCLK_32MHZ=1 -D SYSCLK_MSI=1 -D ENABLE_USART -D
#        USER_DEFINED_PLATFORM=USER_EVAL_PLATFORM -D IRQ_RESET_PIN -D DTM_UART
#        -lC "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\List"
#        -o "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        D:\Software\IAR_BlueNRG\arm\INC\c\DLib_Config_Normal.h -I
#        "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\HAL\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\BSP\STM32L1xx_BlueNRG1\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\BSP\STM32L1xx_Nucleo\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\CMSIS\Device\ST\STM32L1xx\Include\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\STM32L1xx_HAL_BlueNRG1_Drivers\inc\"
#        -I "C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\..\..\..\..\Library\STM32L\Middlewares\ST\STM32_BlueNRG1\SimpleBlueNRG1_HCI\includes\"
#        -On --use_c++_inline -I D:\Software\IAR_BlueNRG\arm\CMSIS\Include\
#    Locale       =  Chinese (Simplified)_China.936
#    List file    =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\List\stm32l1xx_hal_uart.lst
#    Object file  =  
#        C:\Users\Administrator\Desktop\Temporary
#        Files\eeworld_project\Project_Test\Project\STM32L\DTM\EWARM\DTM_UART\Obj\stm32l1xx_hal_uart.o
#
###############################################################################

C:\Users\Administrator\Desktop\Temporary Files\eeworld_project\Project_Test\Library\STM32L\Drivers\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_uart.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_hal_uart.c
      4            * @author  MCD Application Team
      5            * @version V1.1.1
      6            * @date    31-March-2015
      7            * @brief   UART HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Universal Asynchronous Receiver Transmitter (UART) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral Control functions 
     13            *           + Peripheral State and Errors functions  
     14            @verbatim
     15            ==============================================================================
     16                                  ##### How to use this driver #####
     17            ==============================================================================
     18            [..]
     19              The UART HAL driver can be used as follows:
     20              
     21              (#) Declare a UART_HandleTypeDef handle structure.
     22          
     23              (#) Initialize the UART low level resources by implementing the HAL_UART_MspInit() API:
     24                  (##) Enable the USARTx interface clock.
     25                  (##) UART pins configuration:
     26                      (+++) Enable the clock for the UART GPIOs.
     27                      (+++) Configure the UART pins as alternate function pull-up.
     28                  (##) NVIC configuration if you need to use interrupt process (HAL_UART_Transmit_IT()
     29                       and HAL_UART_Receive_IT() APIs):
     30                      (+++) Configure the USARTx interrupt priority.
     31                      (+++) Enable the NVIC USART IRQ handle.
     32                  (##) DMA Configuration if you need to use DMA process (HAL_UART_Transmit_DMA()
     33                       and HAL_UART_Receive_DMA() APIs):
     34                      (+++) Declare a DMA handle structure for the Tx/Rx channel.
     35                      (+++) Enable the DMAx interface clock.
     36                      (+++) Configure the declared DMA handle structure with the required 
     37                            Tx/Rx parameters.                
     38                      (+++) Configure the DMA Tx/Rx channel.
     39                      (+++) Associate the initialized DMA handle to the UART DMA Tx/Rx handle.
     40                      (+++) Configure the priority and enable the NVIC for the transfer complete 
     41                            interrupt on the DMA Tx/Rx channel.
     42                      (+++) Configure the USARTx interrupt priority and enable the NVIC USART IRQ handle
     43                            (used for last byte sending completion detection in DMA non circular mode)
     44          
     45              (#) Program the Baud Rate, Word Length, Stop Bit, Parity, Hardware 
     46                  flow control and Mode(Receiver/Transmitter) in the huart Init structure.
     47          
     48              (#) For the UART asynchronous mode, initialize the UART registers by calling
     49                  the HAL_UART_Init() API.
     50          
     51              (#) For the UART Half duplex mode, initialize the UART registers by calling 
     52                  the HAL_HalfDuplex_Init() API.
     53          
     54              (#) For the LIN mode, initialize the UART registers by calling the HAL_LIN_Init() API.
     55          
     56              (#) For the Multi-Processor mode, initialize the UART registers by calling 
     57                  the HAL_MultiProcessor_Init() API.
     58          
     59               [..] 
     60                 (@) The specific UART interrupts (Transmission complete interrupt, 
     61                      RXNE interrupt and Error Interrupts) will be managed using the macros
     62                      __HAL_UART_ENABLE_IT() and __HAL_UART_DISABLE_IT() inside the transmit 
     63                      and receive process.
     64          
     65               [..] 
     66                 (@) These APIs (HAL_UART_Init() and HAL_HalfDuplex_Init()) configure also the 
     67                      low level Hardware GPIO, CLOCK, CORTEX...etc) by calling the customed 
     68                      HAL_UART_MspInit() API.
     69          
     70               [..] 
     71                  Three operation modes are available within this driver :
     72          
     73               *** Polling mode IO operation ***
     74               =================================
     75               [..]    
     76                 (+) Send an amount of data in blocking mode using HAL_UART_Transmit() 
     77                 (+) Receive an amount of data in blocking mode using HAL_UART_Receive()
     78                 
     79               *** Interrupt mode IO operation ***
     80               ===================================
     81               [..]
     82                 (+) Send an amount of data in non blocking mode using HAL_UART_Transmit_IT() 
     83                 (+) At transmission end of transfer HAL_UART_TxCpltCallback is executed and user can 
     84                      add his own code by customization of function pointer HAL_UART_TxCpltCallback
     85                 (+) Receive an amount of data in non blocking mode using HAL_UART_Receive_IT() 
     86                 (+) At reception end of transfer HAL_UART_RxCpltCallback is executed and user can 
     87                      add his own code by customization of function pointer HAL_UART_RxCpltCallback
     88                 (+) In case of transfer Error, HAL_UART_ErrorCallback() function is executed and user can 
     89                      add his own code by customization of function pointer HAL_UART_ErrorCallback
     90          
     91               *** DMA mode IO operation ***
     92               ==============================
     93               [..] 
     94                 (+) Send an amount of data in non blocking mode (DMA) using HAL_UART_Transmit_DMA() 
     95                 (+) At transmission end of half transfer HAL_UART_TxHalfCpltCallback is executed and user can 
     96                      add his own code by customization of function pointer HAL_UART_TxHalfCpltCallback 
     97                 (+) At transmission end of transfer HAL_UART_TxCpltCallback is executed and user can 
     98                      add his own code by customization of function pointer HAL_UART_TxCpltCallback
     99                 (+) Receive an amount of data in non blocking mode (DMA) using HAL_UART_Receive_DMA() 
    100                 (+) At reception end of half transfer HAL_UART_RxHalfCpltCallback is executed and user can 
    101                      add his own code by customization of function pointer HAL_UART_RxHalfCpltCallback 
    102                 (+) At reception end of transfer HAL_UART_RxCpltCallback is executed and user can 
    103                      add his own code by customization of function pointer HAL_UART_RxCpltCallback
    104                 (+) In case of transfer Error, HAL_UART_ErrorCallback() function is executed and user can 
    105                      add his own code by customization of function pointer HAL_UART_ErrorCallback
    106                 (+) Pause the DMA Transfer using HAL_UART_DMAPause()
    107                 (+) Resume the DMA Transfer using HAL_UART_DMAResume()
    108                 (+) Stop the DMA Transfer using HAL_UART_DMAStop()
    109          
    110               *** UART HAL driver macros list ***
    111               =============================================
    112               [..]
    113                 Below the list of most used macros in UART HAL driver.
    114          
    115                (+) __HAL_UART_ENABLE: Enable the UART peripheral 
    116                (+) __HAL_UART_DISABLE: Disable the UART peripheral
    117                (+) __HAL_UART_GET_FLAG : Check whether the specified UART flag is set or not
    118                (+) __HAL_UART_CLEAR_FLAG : Clear the specified UART pending flag
    119                (+) __HAL_UART_ENABLE_IT: Enable the specified UART interrupt
    120                (+) __HAL_UART_DISABLE_IT: Disable the specified UART interrupt
    121                (+) __HAL_UART_GET_IT_SOURCE: Check whether the specified UART interrupt has occurred or not
    122          
    123               [..]
    124                 (@) You can refer to the UART HAL driver header file for more useful macros 
    125                
    126            @endverbatim
    127            ******************************************************************************
    128            * @attention
    129            *
    130            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
    131            *
    132            * Redistribution and use in source and binary forms, with or without modification,
    133            * are permitted provided that the following conditions are met:
    134            *   1. Redistributions of source code must retain the above copyright notice,
    135            *      this list of conditions and the following disclaimer.
    136            *   2. Redistributions in binary form must reproduce the above copyright notice,
    137            *      this list of conditions and the following disclaimer in the documentation
    138            *      and/or other materials provided with the distribution.
    139            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    140            *      may be used to endorse or promote products derived from this software
    141            *      without specific prior written permission.
    142            *
    143            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    144            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    145            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    146            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    147            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    148            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    149            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    150            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    151            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    152            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    153            *
    154            ******************************************************************************
    155            */
    156          
    157          /* Includes ------------------------------------------------------------------*/
    158          #include "stm32l1xx_hal.h"
    159          
    160          /** @addtogroup STM32L1xx_HAL_Driver
    161            * @{
    162            */
    163          
    164          /** @defgroup UART UART
    165            * @brief HAL UART module driver
    166            * @{
    167            */
    168          #ifdef HAL_UART_MODULE_ENABLED
    169              
    170          /* Private typedef -----------------------------------------------------------*/
    171          /* Private define ------------------------------------------------------------*/
    172          /* Private macros ------------------------------------------------------------*/
    173          /* Private variables ---------------------------------------------------------*/
    174          /* Private function prototypes -----------------------------------------------*/
    175          /** @addtogroup UART_Private_Functions   UART Private Functions
    176            * @{
    177            */
    178          static void UART_SetConfig (UART_HandleTypeDef *huart);
    179          static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart);
    180          static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart);
    181          static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart);
    182          static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma);
    183          static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma);
    184          static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma);
    185          static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma);
    186          static void UART_DMAError(DMA_HandleTypeDef *hdma); 
    187          static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Timeout);
    188          /**
    189            * @}
    190            */
    191          
    192          /* Exported functions ---------------------------------------------------------*/
    193          
    194          /** @defgroup UART_Exported_Functions UART Exported Functions
    195            * @{
    196            */
    197          
    198          /** @defgroup UART_Exported_Functions_Group1 Initialization and de-initialization functions 
    199            *  @brief    Initialization and Configuration functions 
    200            *
    201          @verbatim
    202          ===============================================================================
    203                      ##### Initialization and Configuration functions #####
    204           ===============================================================================  
    205              [..]
    206              This subsection provides a set of functions allowing to initialize the USARTx or the UARTy 
    207              in asynchronous mode.
    208                (+) For the asynchronous mode only these parameters can be configured: 
    209                  (++) Baud Rate
    210                  (++) Word Length 
    211                  (++) Stop Bit
    212                  (++) Parity: If the parity is enabled, then the MSB bit of the data written
    213                       in the data register is transmitted but is changed by the parity bit.
    214                       Depending on the frame length defined by the M bit (8-bits or 9-bits),
    215                       the possible UART frame formats are as listed in the following table:
    216                  (+++)    +-------------------------------------------------------------+     
    217                  (+++)    |   M bit |  PCE bit  |            UART frame                 |
    218                  (+++)    |---------------------|---------------------------------------|             
    219                  (+++)    |    0    |    0      |    | SB | 8 bit data | STB |          |
    220                  (+++)    |---------|-----------|---------------------------------------|  
    221                  (+++)    |    0    |    1      |    | SB | 7 bit data | PB | STB |     |
    222                  (+++)    |---------|-----------|---------------------------------------|  
    223                  (+++)    |    1    |    0      |    | SB | 9 bit data | STB |          |
    224                  (+++)    |---------|-----------|---------------------------------------|  
    225                  (+++)    |    1    |    1      |    | SB | 8 bit data | PB | STB |     |
    226                  (+++)    +-------------------------------------------------------------+            
    227                  (++) Hardware flow control
    228                  (++) Receiver/transmitter modes
    229                  (++) Over Sampling Methode
    230              [..]
    231              The HAL_UART_Init(), HAL_HalfDuplex_Init(), HAL_LIN_Init() and HAL_MultiProcessor_Init() APIs 
    232              follow respectively the UART asynchronous, UART Half duplex, LIN and Multi-Processor
    233              configuration procedures (details for the procedures are available in reference manual (RM0038)).
    234          
    235          @endverbatim
    236            * @{
    237            */
    238          
    239          /**
    240            * @brief  Initializes the UART mode according to the specified parameters in
    241            *         the UART_InitTypeDef and create the associated handle.
    242            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    243            *                the configuration information for the specified UART module.
    244            * @retval HAL status
    245            */

   \                                 In section .text, align 2, keep-with-next
    246          HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
    247          {
   \                     HAL_UART_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    248            /* Check the UART handle allocation */
    249            if(huart == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_UART_Init_0
    250            {
    251              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE030             B.N      ??HAL_UART_Init_1
    252            }
    253          
    254            /* Check the parameters */
    255            if(huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
   \                     ??HAL_UART_Init_0: (+1)
   \   0000000C   0x69A0             LDR      R0,[R4, #+24]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD1FF             BNE.N    ??HAL_UART_Init_2
    256            {
    257              /* The hardware flow control is available only for USART1, USART2, USART3 */
    258              assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
    259              assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
    260            }
    261            else
    262            {
    263              assert_param(IS_UART_INSTANCE(huart->Instance));
    264            }
    265            assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
    266            assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
    267            
    268            if(huart->State == HAL_UART_STATE_RESET)
   \                     ??HAL_UART_Init_3: (+1)
   \                     ??HAL_UART_Init_2: (+1)
   \   00000012   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD105             BNE.N    ??HAL_UART_Init_4
    269            {  
    270              /* Allocate lock resource and initialize it */
    271              huart->Lock = HAL_UNLOCKED;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF884 0x0038      STRB     R0,[R4, #+56]
    272          
    273              /* Init the low level hardware */
    274              HAL_UART_MspInit(huart);
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       HAL_UART_MspInit
    275            }
    276          
    277            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_UART_Init_4: (+1)
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0xF884 0x0039      STRB     R0,[R4, #+57]
    278          
    279            /* Disable the peripheral */
    280            __HAL_UART_DISABLE(huart);
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x68C0             LDR      R0,[R0, #+12]
   \   00000030   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   00000034   0x6821             LDR      R1,[R4, #+0]
   \   00000036   0x60C8             STR      R0,[R1, #+12]
    281            
    282            /* Set the UART Communication parameters */
    283            UART_SetConfig(huart);
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       UART_SetConfig
    284            
    285            /* In asynchronous mode, the following bits must be kept cleared: 
    286               - LINEN and CLKEN bits in the USART_CR2 register,
    287               - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
    288            CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6900             LDR      R0,[R0, #+16]
   \   00000042   0xF430 0x4090      BICS     R0,R0,#0x4800
   \   00000046   0x6821             LDR      R1,[R4, #+0]
   \   00000048   0x6108             STR      R0,[R1, #+16]
    289            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x6940             LDR      R0,[R0, #+20]
   \   0000004E   0xF030 0x002A      BICS     R0,R0,#0x2A
   \   00000052   0x6821             LDR      R1,[R4, #+0]
   \   00000054   0x6148             STR      R0,[R1, #+20]
    290            
    291            /* Enable the peripheral */
    292            __HAL_UART_ENABLE(huart);
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x68C0             LDR      R0,[R0, #+12]
   \   0000005A   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   0000005E   0x6821             LDR      R1,[R4, #+0]
   \   00000060   0x60C8             STR      R0,[R1, #+12]
    293            
    294            /* Initialize the UART state */
    295            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x63E0             STR      R0,[R4, #+60]
    296            huart->State= HAL_UART_STATE_READY;
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0xF884 0x0039      STRB     R0,[R4, #+57]
    297            
    298            return HAL_OK;
   \   0000006C   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_Init_1: (+1)
   \   0000006E   0xBD10             POP      {R4,PC}          ;; return
    299          }
    300          
    301          /**
    302            * @brief  Initializes the half-duplex mode according to the specified
    303            *         parameters in the UART_InitTypeDef and create the associated handle.
    304            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    305            *                the configuration information for the specified UART module.
    306            * @retval HAL status
    307            */

   \                                 In section .text, align 2, keep-with-next
    308          HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
    309          {
   \                     HAL_HalfDuplex_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    310            /* Check the UART handle allocation */
    311            if(huart == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_HalfDuplex_Init_0
    312            {
    313              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE033             B.N      ??HAL_HalfDuplex_Init_1
    314            }
    315            
    316            /* Check UART instance */
    317            assert_param(IS_UART_HALFDUPLEX_INSTANCE(huart->Instance));
    318            assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
    319            assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
    320          
    321            if(huart->State == HAL_UART_STATE_RESET)
   \                     ??HAL_HalfDuplex_Init_0: (+1)
   \   0000000C   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD105             BNE.N    ??HAL_HalfDuplex_Init_2
    322            {   
    323              /* Allocate lock resource and initialize it */
    324              huart->Lock = HAL_UNLOCKED;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF884 0x0038      STRB     R0,[R4, #+56]
    325          
    326              /* Init the low level hardware */
    327              HAL_UART_MspInit(huart);
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_UART_MspInit
    328            }
    329          
    330            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_HalfDuplex_Init_2: (+1)
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xF884 0x0039      STRB     R0,[R4, #+57]
    331          
    332            /* Disable the peripheral */
    333            __HAL_UART_DISABLE(huart);
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x68C0             LDR      R0,[R0, #+12]
   \   0000002A   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   0000002E   0x6821             LDR      R1,[R4, #+0]
   \   00000030   0x60C8             STR      R0,[R1, #+12]
    334            
    335            /* Set the UART Communication parameters */
    336            UART_SetConfig(huart);
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       UART_SetConfig
    337            
    338            /* In half-duplex mode, the following bits must be kept cleared: 
    339               - LINEN and CLKEN bits in the USART_CR2 register,
    340               - SCEN and IREN bits in the USART_CR3 register.*/
    341            CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x6900             LDR      R0,[R0, #+16]
   \   0000003C   0xF430 0x4090      BICS     R0,R0,#0x4800
   \   00000040   0x6821             LDR      R1,[R4, #+0]
   \   00000042   0x6108             STR      R0,[R1, #+16]
    342            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x6940             LDR      R0,[R0, #+20]
   \   00000048   0xF030 0x0022      BICS     R0,R0,#0x22
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x6148             STR      R0,[R1, #+20]
    343            
    344            /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    345            SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x6940             LDR      R0,[R0, #+20]
   \   00000054   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000058   0x6821             LDR      R1,[R4, #+0]
   \   0000005A   0x6148             STR      R0,[R1, #+20]
    346           
    347            /* Enable the peripheral */
    348            __HAL_UART_ENABLE(huart);
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x68C0             LDR      R0,[R0, #+12]
   \   00000060   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x60C8             STR      R0,[R1, #+12]
    349            
    350            /* Initialize the UART state*/
    351            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x63E0             STR      R0,[R4, #+60]
    352            huart->State= HAL_UART_STATE_READY;
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0xF884 0x0039      STRB     R0,[R4, #+57]
    353            
    354            return HAL_OK;
   \   00000072   0x2000             MOVS     R0,#+0
   \                     ??HAL_HalfDuplex_Init_1: (+1)
   \   00000074   0xBD10             POP      {R4,PC}          ;; return
    355          }
    356          
    357          /**
    358            * @brief  Initializes the LIN mode according to the specified
    359            *         parameters in the UART_InitTypeDef and create the associated handle.
    360            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    361            *                the configuration information for the specified UART module.
    362            * @param  BreakDetectLength: Specifies the LIN break detection length.
    363            *         This parameter can be one of the following values:
    364            *            @arg UART_LINBREAKDETECTLENGTH_10B: 10-bit break detection
    365            *            @arg UART_LINBREAKDETECTLENGTH_11B: 11-bit break detection
    366            * @retval HAL status
    367            */

   \                                 In section .text, align 2, keep-with-next
    368          HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
    369          {
   \                     HAL_LIN_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    370            /* Check the UART handle allocation */
    371            if(huart == NULL)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??HAL_LIN_Init_0
    372            {
    373              return HAL_ERROR;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE03A             B.N      ??HAL_LIN_Init_1
    374            }
    375            
    376            /* Check the LIN UART instance */  
    377            assert_param(IS_UART_LIN_INSTANCE(huart->Instance));
    378            /* Check the Break detection length parameter */
    379            assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
    380            assert_param(IS_UART_LIN_WORD_LENGTH(huart->Init.WordLength));
    381            assert_param(IS_UART_LIN_OVERSAMPLING(huart->Init.OverSampling));
    382            
    383            if(huart->State == HAL_UART_STATE_RESET)
   \                     ??HAL_LIN_Init_0: (+1)
   \   0000000E   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD105             BNE.N    ??HAL_LIN_Init_2
    384            {   
    385              /* Allocate lock resource and initialize it */
    386              huart->Lock = HAL_UNLOCKED;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF884 0x0038      STRB     R0,[R4, #+56]
    387          
    388              /* Init the low level hardware */
    389              HAL_UART_MspInit(huart);
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       HAL_UART_MspInit
    390            }
    391          
    392            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_LIN_Init_2: (+1)
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xF884 0x0039      STRB     R0,[R4, #+57]
    393          
    394            /* Disable the peripheral */
    395            __HAL_UART_DISABLE(huart);
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x68C0             LDR      R0,[R0, #+12]
   \   0000002C   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x60C8             STR      R0,[R1, #+12]
    396            
    397            /* Set the UART Communication parameters */
    398            UART_SetConfig(huart);
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       UART_SetConfig
    399            
    400            /* In LIN mode, the following bits must be kept cleared: 
    401               - CLKEN bits in the USART_CR2 register,
    402               - SCEN and IREN bits in the USART_CR3 register.*/
    403            CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6900             LDR      R0,[R0, #+16]
   \   0000003E   0xF430 0x6000      BICS     R0,R0,#0x800
   \   00000042   0x6821             LDR      R1,[R4, #+0]
   \   00000044   0x6108             STR      R0,[R1, #+16]
    404            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6940             LDR      R0,[R0, #+20]
   \   0000004A   0xF030 0x002A      BICS     R0,R0,#0x2A
   \   0000004E   0x6821             LDR      R1,[R4, #+0]
   \   00000050   0x6148             STR      R0,[R1, #+20]
    405            
    406            /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    407            SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x6900             LDR      R0,[R0, #+16]
   \   00000056   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   0000005A   0x6821             LDR      R1,[R4, #+0]
   \   0000005C   0x6108             STR      R0,[R1, #+16]
    408            
    409            /* Set the USART LIN Break detection length. */
    410            MODIFY_REG(huart->Instance->CR2, USART_CR2_LBDL, BreakDetectLength);
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x6900             LDR      R0,[R0, #+16]
   \   00000062   0xF030 0x0020      BICS     R0,R0,#0x20
   \   00000066   0x4328             ORRS     R0,R5,R0
   \   00000068   0x6821             LDR      R1,[R4, #+0]
   \   0000006A   0x6108             STR      R0,[R1, #+16]
    411            
    412            /* Enable the peripheral */
    413            __HAL_UART_ENABLE(huart);
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x68C0             LDR      R0,[R0, #+12]
   \   00000070   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   00000074   0x6821             LDR      R1,[R4, #+0]
   \   00000076   0x60C8             STR      R0,[R1, #+12]
    414            
    415            /* Initialize the UART state*/
    416            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x63E0             STR      R0,[R4, #+60]
    417            huart->State= HAL_UART_STATE_READY;
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0xF884 0x0039      STRB     R0,[R4, #+57]
    418            
    419            return HAL_OK;
   \   00000082   0x2000             MOVS     R0,#+0
   \                     ??HAL_LIN_Init_1: (+1)
   \   00000084   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    420          }
    421          
    422          /**
    423            * @brief  Initializes the Multi-Processor mode according to the specified
    424            *         parameters in the UART_InitTypeDef and create the associated handle.
    425            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    426            *                the configuration information for the specified UART module.
    427            * @param  Address: UART node address
    428            * @param  WakeUpMethod: specifies the UART wakeup method.
    429            *         This parameter can be one of the following values:
    430            *            @arg UART_WAKEUPMETHOD_IDLELINE: Wakeup by an idle line detection
    431            *            @arg UART_WAKEUPMETHOD_ADDRESSMARK: Wakeup by an address mark
    432            * @retval HAL status
    433            */

   \                                 In section .text, align 2, keep-with-next
    434          HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
    435          {
   \                     HAL_MultiProcessor_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    436            /* Check the UART handle allocation */
    437            if(huart == NULL)
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE.N    ??HAL_MultiProcessor_Init_0
    438            {
    439              return HAL_ERROR;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE03C             B.N      ??HAL_MultiProcessor_Init_1
    440            }
    441          
    442            /* Check UART instance capabilities */  
    443            assert_param(IS_UART_MULTIPROCESSOR_INSTANCE(huart->Instance));
    444          
    445            /* Check the Address & wake up method parameters */
    446            assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
    447            assert_param(IS_UART_ADDRESS(Address));
    448            assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
    449            assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
    450          
    451            if(huart->State == HAL_UART_STATE_RESET)
   \                     ??HAL_MultiProcessor_Init_0: (+1)
   \   00000010   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD105             BNE.N    ??HAL_MultiProcessor_Init_2
    452            {   
    453              /* Allocate lock resource and initialize it */
    454              huart->Lock = HAL_UNLOCKED;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF884 0x0038      STRB     R0,[R4, #+56]
    455          
    456              /* Init the low level hardware */
    457              HAL_UART_MspInit(huart);
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       HAL_UART_MspInit
    458            }
    459          
    460            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_MultiProcessor_Init_2: (+1)
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0xF884 0x0039      STRB     R0,[R4, #+57]
    461          
    462            /* Disable the peripheral */
    463            __HAL_UART_DISABLE(huart);
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x68C0             LDR      R0,[R0, #+12]
   \   0000002E   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   00000032   0x6821             LDR      R1,[R4, #+0]
   \   00000034   0x60C8             STR      R0,[R1, #+12]
    464            
    465            /* Set the UART Communication parameters */
    466            UART_SetConfig(huart);
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       UART_SetConfig
    467            
    468            /* In Multi-Processor mode, the following bits must be kept cleared: 
    469               - LINEN and CLKEN bits in the USART_CR2 register,
    470               - SCEN, HDSEL and IREN  bits in the USART_CR3 register */
    471            CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6900             LDR      R0,[R0, #+16]
   \   00000040   0xF430 0x4090      BICS     R0,R0,#0x4800
   \   00000044   0x6821             LDR      R1,[R4, #+0]
   \   00000046   0x6108             STR      R0,[R1, #+16]
    472            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x6940             LDR      R0,[R0, #+20]
   \   0000004C   0xF030 0x002A      BICS     R0,R0,#0x2A
   \   00000050   0x6821             LDR      R1,[R4, #+0]
   \   00000052   0x6148             STR      R0,[R1, #+20]
    473            
    474            /* Set the USART address node */
    475            MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, Address);
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x6900             LDR      R0,[R0, #+16]
   \   00000058   0x0900             LSRS     R0,R0,#+4
   \   0000005A   0x0100             LSLS     R0,R0,#+4
   \   0000005C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005E   0x4328             ORRS     R0,R5,R0
   \   00000060   0x6821             LDR      R1,[R4, #+0]
   \   00000062   0x6108             STR      R0,[R1, #+16]
    476            
    477            /* Set the wake up method by setting the WAKE bit in the CR1 register */
    478            MODIFY_REG(huart->Instance->CR1, USART_CR1_WAKE, WakeUpMethod);
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x68C0             LDR      R0,[R0, #+12]
   \   00000068   0xF430 0x6000      BICS     R0,R0,#0x800
   \   0000006C   0x4330             ORRS     R0,R6,R0
   \   0000006E   0x6821             LDR      R1,[R4, #+0]
   \   00000070   0x60C8             STR      R0,[R1, #+12]
    479            
    480            /* Enable the peripheral */
    481            __HAL_UART_ENABLE(huart);
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0x68C0             LDR      R0,[R0, #+12]
   \   00000076   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   0000007A   0x6821             LDR      R1,[R4, #+0]
   \   0000007C   0x60C8             STR      R0,[R1, #+12]
    482            
    483            /* Initialize the UART state */
    484            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x63E0             STR      R0,[R4, #+60]
    485            huart->State= HAL_UART_STATE_READY;
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0xF884 0x0039      STRB     R0,[R4, #+57]
    486            
    487            return HAL_OK;
   \   00000088   0x2000             MOVS     R0,#+0
   \                     ??HAL_MultiProcessor_Init_1: (+1)
   \   0000008A   0xBD70             POP      {R4-R6,PC}       ;; return
    488          }
    489          
    490          /**
    491            * @brief  DeInitializes the UART peripheral. 
    492            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    493            *                the configuration information for the specified UART module.
    494            * @retval HAL status
    495            */

   \                                 In section .text, align 2, keep-with-next
    496          HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
    497          {
   \                     HAL_UART_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    498            /* Check the UART handle allocation */
    499            if(huart == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_UART_DeInit_0
    500            {
    501              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE01D             B.N      ??HAL_UART_DeInit_1
    502            }
    503            
    504            /* Check the parameters */
    505            assert_param(IS_UART_INSTANCE(huart->Instance));
    506          
    507            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_UART_DeInit_0: (+1)
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xF884 0x0039      STRB     R0,[R4, #+57]
    508            
    509            /* Disable the Peripheral */
    510            __HAL_UART_DISABLE(huart);
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x68C0             LDR      R0,[R0, #+12]
   \   00000016   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   0000001A   0x6821             LDR      R1,[R4, #+0]
   \   0000001C   0x60C8             STR      R0,[R1, #+12]
    511            
    512            huart->Instance->CR1 = 0x0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x6821             LDR      R1,[R4, #+0]
   \   00000022   0x60C8             STR      R0,[R1, #+12]
    513            huart->Instance->CR2 = 0x0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x6821             LDR      R1,[R4, #+0]
   \   00000028   0x6108             STR      R0,[R1, #+16]
    514            huart->Instance->CR3 = 0x0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x6821             LDR      R1,[R4, #+0]
   \   0000002E   0x6148             STR      R0,[R1, #+20]
    515            
    516            /* DeInit the low level hardware */
    517            HAL_UART_MspDeInit(huart);
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       HAL_UART_MspDeInit
    518          
    519            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x63E0             STR      R0,[R4, #+60]
    520            huart->State = HAL_UART_STATE_RESET;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF884 0x0039      STRB     R0,[R4, #+57]
    521          
    522            /* Process Unlock */
    523            __HAL_UNLOCK(huart);
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF884 0x0038      STRB     R0,[R4, #+56]
    524          
    525            return HAL_OK;
   \   00000046   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_DeInit_1: (+1)
   \   00000048   0xBD10             POP      {R4,PC}          ;; return
    526          }
    527          
    528          /**
    529            * @brief  UART MSP Init.
    530            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    531            *                the configuration information for the specified UART module.
    532            * @retval None
    533            */

   \                                 In section .text, align 2
    534           __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
    535          {
    536            /* NOTE: This function should not be modified, when the callback is needed,
    537                     the HAL_UART_MspInit can be implemented in the user file
    538             */ 
    539          }
   \                     HAL_UART_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    540          
    541          /**
    542            * @brief  UART MSP DeInit.
    543            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    544            *                the configuration information for the specified UART module.
    545            * @retval None
    546            */

   \                                 In section .text, align 2
    547           __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
    548          {
    549            /* NOTE: This function should not be modified, when the callback is needed,
    550                     the HAL_UART_MspDeInit can be implemented in the user file
    551             */ 
    552          }
   \                     HAL_UART_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    553          
    554          /**
    555            * @}
    556            */
    557          
    558          /** @defgroup UART_Exported_Functions_Group2 IO operation functions 
    559            *  @brief UART Transmit and Receive functions 
    560            *
    561          @verbatim
    562            ==============================================================================
    563                                ##### IO operation functions #####
    564            ==============================================================================  
    565            [..]
    566              This subsection provides a set of functions allowing to manage the UART asynchronous
    567              and Half duplex data transfers.
    568          
    569              (#) There are two modes of transfer:
    570                 (++) Blocking mode: The communication is performed in polling mode. 
    571                      The HAL status of all data processing is returned by the same function 
    572                      after finishing transfer.  
    573                 (++) Non blocking mode: The communication is performed using Interrupts 
    574                      or DMA, these APIs return the HAL status.
    575                      The end of the data processing will be indicated through the 
    576                      dedicated UART IRQ when using Interrupt mode or the DMA IRQ when 
    577                      using DMA mode.
    578                      The HAL_UART_TxCpltCallback(), HAL_UART_RxCpltCallback() user callbacks 
    579                      will be executed respectively at the end of the transmit or receive process.
    580                      The HAL_UART_ErrorCallback() user callback will be executed when 
    581                      a communication error is detected.
    582          
    583              (#) Blocking mode APIs are:
    584                  (++) HAL_UART_Transmit()
    585                  (++) HAL_UART_Receive() 
    586          
    587              (#) Non Blocking mode APIs with Interrupt are:
    588                  (++) HAL_UART_Transmit_IT()
    589                  (++) HAL_UART_Receive_IT()
    590                  (++) HAL_UART_IRQHandler()
    591          
    592              (#) Non Blocking mode functions with DMA are:
    593                  (++) HAL_UART_Transmit_DMA()
    594                  (++) HAL_UART_Receive_DMA()
    595                  (++) HAL_UART_DMAPause()
    596                  (++) HAL_UART_DMAResume()
    597                  (++) HAL_UART_DMAStop()
    598          
    599              (#) A set of Transfer Complete Callbacks are provided in non blocking mode:
    600                  (++) HAL_UART_TxHalfCpltCallback()
    601                  (++) HAL_UART_TxCpltCallback()
    602                  (++) HAL_UART_RxHalfCpltCallback()
    603                  (++) HAL_UART_RxCpltCallback()
    604                  (++) HAL_UART_ErrorCallback()
    605          
    606              [..] 
    607                (@) In the Half duplex communication, it is forbidden to run the transmit 
    608                    and receive process in parallel, the UART state HAL_UART_STATE_BUSY_TX_RX 
    609                    can't be useful.
    610                
    611          @endverbatim
    612            * @{
    613            */
    614          
    615          /**
    616            * @brief  Sends an amount of data in blocking mode. 
    617            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    618            *                the configuration information for the specified UART module.
    619            * @param  pData: Pointer to data buffer
    620            * @param  Size: Amount of data to be sent
    621            * @param  Timeout: Timeout duration  
    622            * @retval HAL status
    623            */

   \                                 In section .text, align 2, keep-with-next
    624          HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    625          {
   \                     HAL_UART_Transmit: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    626            uint16_t* tmp;
    627            uint32_t tmp_state = 0;
   \   0000000C   0xF05F 0x0900      MOVS     R9,#+0
    628            
    629            tmp_state = huart->State;
   \   00000010   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000014   0x4681             MOV      R9,R0
    630            if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_RX))
   \   00000016   0xF1B9 0x0F01      CMP      R9,#+1
   \   0000001A   0xD002             BEQ.N    ??HAL_UART_Transmit_0
   \   0000001C   0xF1B9 0x0F22      CMP      R9,#+34
   \   00000020   0xD169             BNE.N    ??HAL_UART_Transmit_1
    631            {
    632              if((pData == NULL) || (Size == 0))
   \                     ??HAL_UART_Transmit_0: (+1)
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD002             BEQ.N    ??HAL_UART_Transmit_2
   \   00000026   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000028   0x2E00             CMP      R6,#+0
   \   0000002A   0xD101             BNE.N    ??HAL_UART_Transmit_3
    633              {
    634                return  HAL_ERROR;
   \                     ??HAL_UART_Transmit_2: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xE063             B.N      ??HAL_UART_Transmit_4
    635              }
    636          
    637              /* Process Locked */
    638              __HAL_LOCK(huart);
   \                     ??HAL_UART_Transmit_3: (+1)
   \   00000030   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD101             BNE.N    ??HAL_UART_Transmit_5
   \   00000038   0x2002             MOVS     R0,#+2
   \   0000003A   0xE05D             B.N      ??HAL_UART_Transmit_4
   \                     ??HAL_UART_Transmit_5: (+1)
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xF884 0x0038      STRB     R0,[R4, #+56]
    639          
    640              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x63E0             STR      R0,[R4, #+60]
    641              /* Check if a non-blocking receive process is ongoing or not */
    642              if(huart->State == HAL_UART_STATE_BUSY_RX) 
   \   00000046   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000004A   0x2822             CMP      R0,#+34
   \   0000004C   0xD103             BNE.N    ??HAL_UART_Transmit_6
    643              {
    644                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   0000004E   0x2032             MOVS     R0,#+50
   \   00000050   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000054   0xE002             B.N      ??HAL_UART_Transmit_7
    645              }
    646              else
    647              {
    648                huart->State = HAL_UART_STATE_BUSY_TX;
   \                     ??HAL_UART_Transmit_6: (+1)
   \   00000056   0x2012             MOVS     R0,#+18
   \   00000058   0xF884 0x0039      STRB     R0,[R4, #+57]
    649              }
    650          
    651              huart->TxXferSize = Size;
   \                     ??HAL_UART_Transmit_7: (+1)
   \   0000005C   0x84A6             STRH     R6,[R4, #+36]
    652              huart->TxXferCount = Size;
   \   0000005E   0x84E6             STRH     R6,[R4, #+38]
    653              while(huart->TxXferCount > 0)
   \                     ??HAL_UART_Transmit_8: (+1)
   \   00000060   0x8CE0             LDRH     R0,[R4, #+38]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD02D             BEQ.N    ??HAL_UART_Transmit_9
    654              {
    655                huart->TxXferCount--;
   \   00000066   0x8CE0             LDRH     R0,[R4, #+38]
   \   00000068   0x1E40             SUBS     R0,R0,#+1
   \   0000006A   0x84E0             STRH     R0,[R4, #+38]
    656                if(huart->Init.WordLength == UART_WORDLENGTH_9B)
   \   0000006C   0x68A0             LDR      R0,[R4, #+8]
   \   0000006E   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000072   0xD117             BNE.N    ??HAL_UART_Transmit_10
    657                {
    658                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, Timeout) != HAL_OK)
   \   00000074   0x003B             MOVS     R3,R7
   \   00000076   0x2200             MOVS     R2,#+0
   \   00000078   0x2180             MOVS     R1,#+128
   \   0000007A   0x0020             MOVS     R0,R4
   \   0000007C   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD001             BEQ.N    ??HAL_UART_Transmit_11
    659                  {
    660                    return HAL_TIMEOUT;
   \   00000084   0x2003             MOVS     R0,#+3
   \   00000086   0xE037             B.N      ??HAL_UART_Transmit_4
    661                  }
    662                  tmp = (uint16_t*) pData;
   \                     ??HAL_UART_Transmit_11: (+1)
   \   00000088   0x46A8             MOV      R8,R5
    663                  huart->Instance->DR = (*tmp & (uint16_t)0x01FF);
   \   0000008A   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   0000008E   0x05C0             LSLS     R0,R0,#+23       ;; ZeroExtS R0,R0,#+23,#+23
   \   00000090   0x0DC0             LSRS     R0,R0,#+23
   \   00000092   0x6821             LDR      R1,[R4, #+0]
   \   00000094   0x6048             STR      R0,[R1, #+4]
    664                  if(huart->Init.Parity == UART_PARITY_NONE)
   \   00000096   0x6920             LDR      R0,[R4, #+16]
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD101             BNE.N    ??HAL_UART_Transmit_12
    665                  {
    666                    pData +=2;
   \   0000009C   0x1CAD             ADDS     R5,R5,#+2
   \   0000009E   0xE7DF             B.N      ??HAL_UART_Transmit_8
    667                  }
    668                  else
    669                  { 
    670                    pData +=1;
   \                     ??HAL_UART_Transmit_12: (+1)
   \   000000A0   0x1C6D             ADDS     R5,R5,#+1
   \   000000A2   0xE7DD             B.N      ??HAL_UART_Transmit_8
    671                  }
    672                } 
    673                else
    674                {
    675                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, Timeout) != HAL_OK)
   \                     ??HAL_UART_Transmit_10: (+1)
   \   000000A4   0x003B             MOVS     R3,R7
   \   000000A6   0x2200             MOVS     R2,#+0
   \   000000A8   0x2180             MOVS     R1,#+128
   \   000000AA   0x0020             MOVS     R0,R4
   \   000000AC   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD001             BEQ.N    ??HAL_UART_Transmit_13
    676                  {
    677                    return HAL_TIMEOUT;
   \   000000B4   0x2003             MOVS     R0,#+3
   \   000000B6   0xE01F             B.N      ??HAL_UART_Transmit_4
    678                  }
    679                  huart->Instance->DR = (*pData++ & (uint8_t)0xFF);
   \                     ??HAL_UART_Transmit_13: (+1)
   \   000000B8   0x7828             LDRB     R0,[R5, #+0]
   \   000000BA   0x6821             LDR      R1,[R4, #+0]
   \   000000BC   0x6048             STR      R0,[R1, #+4]
   \   000000BE   0x1C6D             ADDS     R5,R5,#+1
   \   000000C0   0xE7CE             B.N      ??HAL_UART_Transmit_8
    680                }
    681              }
    682          
    683              if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, Timeout) != HAL_OK)
   \                     ??HAL_UART_Transmit_9: (+1)
   \   000000C2   0x003B             MOVS     R3,R7
   \   000000C4   0x2200             MOVS     R2,#+0
   \   000000C6   0x2140             MOVS     R1,#+64
   \   000000C8   0x0020             MOVS     R0,R4
   \   000000CA   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD001             BEQ.N    ??HAL_UART_Transmit_14
    684              { 
    685                return HAL_TIMEOUT;
   \   000000D2   0x2003             MOVS     R0,#+3
   \   000000D4   0xE010             B.N      ??HAL_UART_Transmit_4
    686              }
    687          
    688              /* Check if a non-blocking receive process is ongoing or not */
    689              if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   \                     ??HAL_UART_Transmit_14: (+1)
   \   000000D6   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   000000DA   0x2832             CMP      R0,#+50
   \   000000DC   0xD103             BNE.N    ??HAL_UART_Transmit_15
    690              {
    691                huart->State = HAL_UART_STATE_BUSY_RX;
   \   000000DE   0x2022             MOVS     R0,#+34
   \   000000E0   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   000000E4   0xE002             B.N      ??HAL_UART_Transmit_16
    692              }
    693              else
    694              {
    695                huart->State = HAL_UART_STATE_READY;
   \                     ??HAL_UART_Transmit_15: (+1)
   \   000000E6   0x2001             MOVS     R0,#+1
   \   000000E8   0xF884 0x0039      STRB     R0,[R4, #+57]
    696              }
    697          
    698              /* Process Unlocked */
    699              __HAL_UNLOCK(huart);
   \                     ??HAL_UART_Transmit_16: (+1)
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0xF884 0x0038      STRB     R0,[R4, #+56]
    700          
    701              return HAL_OK;
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0xE000             B.N      ??HAL_UART_Transmit_4
    702            }
    703            else
    704            {
    705              return HAL_BUSY;
   \                     ??HAL_UART_Transmit_1: (+1)
   \   000000F6   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Transmit_4: (+1)
   \   000000F8   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    706            }
    707          }
    708          
    709          /**
    710            * @brief  Receives an amount of data in blocking mode. 
    711            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    712            *                the configuration information for the specified UART module.
    713            * @param  pData: Pointer to data buffer
    714            * @param  Size: Amount of data to be received
    715            * @param  Timeout: Timeout duration
    716            * @retval HAL status
    717            */

   \                                 In section .text, align 2, keep-with-next
    718          HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    719          {
   \                     HAL_UART_Receive: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    720            uint16_t* tmp;
    721            uint32_t  tmp_state = 0;
   \   0000000C   0xF05F 0x0900      MOVS     R9,#+0
    722          
    723            tmp_state = huart->State;
   \   00000010   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000014   0x4681             MOV      R9,R0
    724            if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_TX))
   \   00000016   0xF1B9 0x0F01      CMP      R9,#+1
   \   0000001A   0xD002             BEQ.N    ??HAL_UART_Receive_0
   \   0000001C   0xF1B9 0x0F12      CMP      R9,#+18
   \   00000020   0xD16F             BNE.N    ??HAL_UART_Receive_1
    725            {
    726              if((pData == NULL ) || (Size == 0))
   \                     ??HAL_UART_Receive_0: (+1)
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD002             BEQ.N    ??HAL_UART_Receive_2
   \   00000026   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000028   0x2E00             CMP      R6,#+0
   \   0000002A   0xD101             BNE.N    ??HAL_UART_Receive_3
    727              {
    728                return  HAL_ERROR;
   \                     ??HAL_UART_Receive_2: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xE069             B.N      ??HAL_UART_Receive_4
    729              }
    730          
    731              /* Process Locked */
    732              __HAL_LOCK(huart);
   \                     ??HAL_UART_Receive_3: (+1)
   \   00000030   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD101             BNE.N    ??HAL_UART_Receive_5
   \   00000038   0x2002             MOVS     R0,#+2
   \   0000003A   0xE063             B.N      ??HAL_UART_Receive_4
   \                     ??HAL_UART_Receive_5: (+1)
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xF884 0x0038      STRB     R0,[R4, #+56]
    733          
    734              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x63E0             STR      R0,[R4, #+60]
    735              /* Check if a non-blocking transmit process is ongoing or not */
    736              if(huart->State == HAL_UART_STATE_BUSY_TX)
   \   00000046   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000004A   0x2812             CMP      R0,#+18
   \   0000004C   0xD103             BNE.N    ??HAL_UART_Receive_6
    737              {
    738                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   0000004E   0x2032             MOVS     R0,#+50
   \   00000050   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000054   0xE002             B.N      ??HAL_UART_Receive_7
    739              }
    740              else
    741              {
    742                huart->State = HAL_UART_STATE_BUSY_RX;
   \                     ??HAL_UART_Receive_6: (+1)
   \   00000056   0x2022             MOVS     R0,#+34
   \   00000058   0xF884 0x0039      STRB     R0,[R4, #+57]
    743              }
    744          
    745              huart->RxXferSize = Size;
   \                     ??HAL_UART_Receive_7: (+1)
   \   0000005C   0x85A6             STRH     R6,[R4, #+44]
    746              huart->RxXferCount = Size;
   \   0000005E   0x85E6             STRH     R6,[R4, #+46]
    747          
    748              /* Check the remain data to be received */
    749              while(huart->RxXferCount > 0)
   \                     ??HAL_UART_Receive_8: (+1)
   \   00000060   0x8DE0             LDRH     R0,[R4, #+46]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD03D             BEQ.N    ??HAL_UART_Receive_9
    750              {
    751                huart->RxXferCount--;
   \   00000066   0x8DE0             LDRH     R0,[R4, #+46]
   \   00000068   0x1E40             SUBS     R0,R0,#+1
   \   0000006A   0x85E0             STRH     R0,[R4, #+46]
    752                if(huart->Init.WordLength == UART_WORDLENGTH_9B)
   \   0000006C   0x68A0             LDR      R0,[R4, #+8]
   \   0000006E   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000072   0xD11D             BNE.N    ??HAL_UART_Receive_10
    753                {
    754                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \   00000074   0x003B             MOVS     R3,R7
   \   00000076   0x2200             MOVS     R2,#+0
   \   00000078   0x2120             MOVS     R1,#+32
   \   0000007A   0x0020             MOVS     R0,R4
   \   0000007C   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD001             BEQ.N    ??HAL_UART_Receive_11
    755                  {
    756                    return HAL_TIMEOUT;
   \   00000084   0x2003             MOVS     R0,#+3
   \   00000086   0xE03D             B.N      ??HAL_UART_Receive_4
    757                  }
    758                  tmp = (uint16_t*) pData ;
   \                     ??HAL_UART_Receive_11: (+1)
   \   00000088   0x46A8             MOV      R8,R5
    759                  if(huart->Init.Parity == UART_PARITY_NONE)
   \   0000008A   0x6920             LDR      R0,[R4, #+16]
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD107             BNE.N    ??HAL_UART_Receive_12
    760                  {
    761                    *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0x6840             LDR      R0,[R0, #+4]
   \   00000094   0x05C0             LSLS     R0,R0,#+23       ;; ZeroExtS R0,R0,#+23,#+23
   \   00000096   0x0DC0             LSRS     R0,R0,#+23
   \   00000098   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    762                    pData +=2;
   \   0000009C   0x1CAD             ADDS     R5,R5,#+2
   \   0000009E   0xE7DF             B.N      ??HAL_UART_Receive_8
    763                  }
    764                  else
    765                  {
    766                    *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
   \                     ??HAL_UART_Receive_12: (+1)
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x6840             LDR      R0,[R0, #+4]
   \   000000A4   0xF000 0x00FF      AND      R0,R0,#0xFF
   \   000000A8   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    767                    pData +=1;
   \   000000AC   0x1C6D             ADDS     R5,R5,#+1
   \   000000AE   0xE7D7             B.N      ??HAL_UART_Receive_8
    768                  }
    769          
    770                }
    771                else
    772                {
    773                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \                     ??HAL_UART_Receive_10: (+1)
   \   000000B0   0x003B             MOVS     R3,R7
   \   000000B2   0x2200             MOVS     R2,#+0
   \   000000B4   0x2120             MOVS     R1,#+32
   \   000000B6   0x0020             MOVS     R0,R4
   \   000000B8   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD001             BEQ.N    ??HAL_UART_Receive_13
    774                  {
    775                    return HAL_TIMEOUT;
   \   000000C0   0x2003             MOVS     R0,#+3
   \   000000C2   0xE01F             B.N      ??HAL_UART_Receive_4
    776                  }
    777                  if(huart->Init.Parity == UART_PARITY_NONE)
   \                     ??HAL_UART_Receive_13: (+1)
   \   000000C4   0x6920             LDR      R0,[R4, #+16]
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD104             BNE.N    ??HAL_UART_Receive_14
    778                  {
    779                    *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
   \   000000CA   0x6820             LDR      R0,[R4, #+0]
   \   000000CC   0x6840             LDR      R0,[R0, #+4]
   \   000000CE   0x7028             STRB     R0,[R5, #+0]
   \   000000D0   0x1C6D             ADDS     R5,R5,#+1
   \   000000D2   0xE7C5             B.N      ??HAL_UART_Receive_8
    780                  }
    781                  else
    782                  {
    783                    *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
   \                     ??HAL_UART_Receive_14: (+1)
   \   000000D4   0x6820             LDR      R0,[R4, #+0]
   \   000000D6   0x6840             LDR      R0,[R0, #+4]
   \   000000D8   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   000000DC   0x7028             STRB     R0,[R5, #+0]
   \   000000DE   0x1C6D             ADDS     R5,R5,#+1
   \   000000E0   0xE7BE             B.N      ??HAL_UART_Receive_8
    784                  }
    785          
    786                }
    787              }
    788          
    789              /* Check if a non-blocking transmit process is ongoing or not */
    790              if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   \                     ??HAL_UART_Receive_9: (+1)
   \   000000E2   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   000000E6   0x2832             CMP      R0,#+50
   \   000000E8   0xD103             BNE.N    ??HAL_UART_Receive_15
    791              {
    792                huart->State = HAL_UART_STATE_BUSY_TX;
   \   000000EA   0x2012             MOVS     R0,#+18
   \   000000EC   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   000000F0   0xE002             B.N      ??HAL_UART_Receive_16
    793              }
    794              else
    795              {
    796                huart->State = HAL_UART_STATE_READY;
   \                     ??HAL_UART_Receive_15: (+1)
   \   000000F2   0x2001             MOVS     R0,#+1
   \   000000F4   0xF884 0x0039      STRB     R0,[R4, #+57]
    797              }
    798              /* Process Unlocked */
    799              __HAL_UNLOCK(huart);
   \                     ??HAL_UART_Receive_16: (+1)
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0xF884 0x0038      STRB     R0,[R4, #+56]
    800          
    801              return HAL_OK;
   \   000000FE   0x2000             MOVS     R0,#+0
   \   00000100   0xE000             B.N      ??HAL_UART_Receive_4
    802            }
    803            else
    804            {
    805              return HAL_BUSY;
   \                     ??HAL_UART_Receive_1: (+1)
   \   00000102   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Receive_4: (+1)
   \   00000104   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    806            }
    807          }
    808          
    809          /**
    810            * @brief  Sends an amount of data in non blocking mode.
    811            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    812            *                the configuration information for the specified UART module.
    813            * @param  pData: Pointer to data buffer
    814            * @param  Size: Amount of data to be sent
    815            * @retval HAL status
    816            */

   \                                 In section .text, align 2, keep-with-next
    817          HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    818          {
   \                     HAL_UART_Transmit_IT: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0003             MOVS     R3,R0
    819            uint32_t tmp_state = 0;
   \   00000004   0x2400             MOVS     R4,#+0
    820          
    821            tmp_state = huart->State;
   \   00000006   0xF893 0x0039      LDRB     R0,[R3, #+57]
   \   0000000A   0x0004             MOVS     R4,R0
    822            if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_RX))
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD001             BEQ.N    ??HAL_UART_Transmit_IT_0
   \   00000010   0x2C22             CMP      R4,#+34
   \   00000012   0xD130             BNE.N    ??HAL_UART_Transmit_IT_1
    823            {
    824              if((pData == NULL ) || (Size == 0))
   \                     ??HAL_UART_Transmit_IT_0: (+1)
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xD002             BEQ.N    ??HAL_UART_Transmit_IT_2
   \   00000018   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xD101             BNE.N    ??HAL_UART_Transmit_IT_3
    825              {
    826                return HAL_ERROR;
   \                     ??HAL_UART_Transmit_IT_2: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE02A             B.N      ??HAL_UART_Transmit_IT_4
    827              }
    828              
    829              /* Process Locked */
    830              __HAL_LOCK(huart);
   \                     ??HAL_UART_Transmit_IT_3: (+1)
   \   00000022   0xF893 0x0038      LDRB     R0,[R3, #+56]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD101             BNE.N    ??HAL_UART_Transmit_IT_5
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0xE024             B.N      ??HAL_UART_Transmit_IT_4
   \                     ??HAL_UART_Transmit_IT_5: (+1)
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF883 0x0038      STRB     R0,[R3, #+56]
    831              
    832              huart->pTxBuffPtr = pData;
   \   00000034   0x6219             STR      R1,[R3, #+32]
    833              huart->TxXferSize = Size;
   \   00000036   0x849A             STRH     R2,[R3, #+36]
    834              huart->TxXferCount = Size;
   \   00000038   0x84DA             STRH     R2,[R3, #+38]
    835          
    836              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x63D8             STR      R0,[R3, #+60]
    837              /* Check if a receive process is ongoing or not */
    838              if(huart->State == HAL_UART_STATE_BUSY_RX) 
   \   0000003E   0xF893 0x0039      LDRB     R0,[R3, #+57]
   \   00000042   0x2822             CMP      R0,#+34
   \   00000044   0xD103             BNE.N    ??HAL_UART_Transmit_IT_6
    839              {
    840                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   00000046   0x2032             MOVS     R0,#+50
   \   00000048   0xF883 0x0039      STRB     R0,[R3, #+57]
   \   0000004C   0xE002             B.N      ??HAL_UART_Transmit_IT_7
    841              }
    842              else
    843              {
    844                huart->State = HAL_UART_STATE_BUSY_TX;
   \                     ??HAL_UART_Transmit_IT_6: (+1)
   \   0000004E   0x2012             MOVS     R0,#+18
   \   00000050   0xF883 0x0039      STRB     R0,[R3, #+57]
    845              }
    846          
    847              /* Process Unlocked */
    848              __HAL_UNLOCK(huart);
   \                     ??HAL_UART_Transmit_IT_7: (+1)
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xF883 0x0038      STRB     R0,[R3, #+56]
    849          
    850              /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
    851              __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
   \   0000005A   0x6818             LDR      R0,[R3, #+0]
   \   0000005C   0x6940             LDR      R0,[R0, #+20]
   \   0000005E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000062   0x681D             LDR      R5,[R3, #+0]
   \   00000064   0x6168             STR      R0,[R5, #+20]
    852          
    853              /* Enable the UART Transmit data register empty Interrupt */
    854              __HAL_UART_ENABLE_IT(huart, UART_IT_TXE);
   \   00000066   0x6818             LDR      R0,[R3, #+0]
   \   00000068   0x68C0             LDR      R0,[R0, #+12]
   \   0000006A   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000006E   0x681D             LDR      R5,[R3, #+0]
   \   00000070   0x60E8             STR      R0,[R5, #+12]
    855              
    856              return HAL_OK;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xE000             B.N      ??HAL_UART_Transmit_IT_4
    857            }
    858            else
    859            {
    860              return HAL_BUSY;
   \                     ??HAL_UART_Transmit_IT_1: (+1)
   \   00000076   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Transmit_IT_4: (+1)
   \   00000078   0xBC30             POP      {R4,R5}
   \   0000007A   0x4770             BX       LR               ;; return
    861            }
    862          }
    863          
    864          /**
    865            * @brief  Receives an amount of data in non blocking mode 
    866            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    867            *                the configuration information for the specified UART module.
    868            * @param  pData: Pointer to data buffer
    869            * @param  Size: Amount of data to be received
    870            * @retval HAL status
    871            */

   \                                 In section .text, align 2, keep-with-next
    872          HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    873          {
   \                     HAL_UART_Receive_IT: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0003             MOVS     R3,R0
    874            uint32_t tmp_state = 0;
   \   00000004   0x2400             MOVS     R4,#+0
    875            
    876            tmp_state = huart->State;
   \   00000006   0xF893 0x0039      LDRB     R0,[R3, #+57]
   \   0000000A   0x0004             MOVS     R4,R0
    877            if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_TX))
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD001             BEQ.N    ??HAL_UART_Receive_IT_0
   \   00000010   0x2C12             CMP      R4,#+18
   \   00000012   0xD136             BNE.N    ??HAL_UART_Receive_IT_1
    878            {
    879              if((pData == NULL ) || (Size == 0))
   \                     ??HAL_UART_Receive_IT_0: (+1)
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xD002             BEQ.N    ??HAL_UART_Receive_IT_2
   \   00000018   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xD101             BNE.N    ??HAL_UART_Receive_IT_3
    880              {
    881                return HAL_ERROR;
   \                     ??HAL_UART_Receive_IT_2: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE030             B.N      ??HAL_UART_Receive_IT_4
    882              }
    883          
    884              /* Process Locked */
    885              __HAL_LOCK(huart);
   \                     ??HAL_UART_Receive_IT_3: (+1)
   \   00000022   0xF893 0x0038      LDRB     R0,[R3, #+56]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD101             BNE.N    ??HAL_UART_Receive_IT_5
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0xE02A             B.N      ??HAL_UART_Receive_IT_4
   \                     ??HAL_UART_Receive_IT_5: (+1)
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF883 0x0038      STRB     R0,[R3, #+56]
    886          
    887              huart->pRxBuffPtr = pData;
   \   00000034   0x6299             STR      R1,[R3, #+40]
    888              huart->RxXferSize = Size;
   \   00000036   0x859A             STRH     R2,[R3, #+44]
    889              huart->RxXferCount = Size;
   \   00000038   0x85DA             STRH     R2,[R3, #+46]
    890          
    891              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x63D8             STR      R0,[R3, #+60]
    892              /* Check if a transmit process is ongoing or not */
    893              if(huart->State == HAL_UART_STATE_BUSY_TX)
   \   0000003E   0xF893 0x0039      LDRB     R0,[R3, #+57]
   \   00000042   0x2812             CMP      R0,#+18
   \   00000044   0xD103             BNE.N    ??HAL_UART_Receive_IT_6
    894              {
    895                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   00000046   0x2032             MOVS     R0,#+50
   \   00000048   0xF883 0x0039      STRB     R0,[R3, #+57]
   \   0000004C   0xE002             B.N      ??HAL_UART_Receive_IT_7
    896              }
    897              else
    898              {
    899                huart->State = HAL_UART_STATE_BUSY_RX;
   \                     ??HAL_UART_Receive_IT_6: (+1)
   \   0000004E   0x2022             MOVS     R0,#+34
   \   00000050   0xF883 0x0039      STRB     R0,[R3, #+57]
    900              }
    901          
    902              /* Process Unlocked */
    903              __HAL_UNLOCK(huart);
   \                     ??HAL_UART_Receive_IT_7: (+1)
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xF883 0x0038      STRB     R0,[R3, #+56]
    904          
    905              /* Enable the UART Parity Error Interrupt */
    906              __HAL_UART_ENABLE_IT(huart, UART_IT_PE);
   \   0000005A   0x6818             LDR      R0,[R3, #+0]
   \   0000005C   0x68C0             LDR      R0,[R0, #+12]
   \   0000005E   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000062   0x681D             LDR      R5,[R3, #+0]
   \   00000064   0x60E8             STR      R0,[R5, #+12]
    907          
    908              /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
    909              __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
   \   00000066   0x6818             LDR      R0,[R3, #+0]
   \   00000068   0x6940             LDR      R0,[R0, #+20]
   \   0000006A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000006E   0x681D             LDR      R5,[R3, #+0]
   \   00000070   0x6168             STR      R0,[R5, #+20]
    910          
    911              /* Enable the UART Data Register not empty Interrupt */
    912              __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);
   \   00000072   0x6818             LDR      R0,[R3, #+0]
   \   00000074   0x68C0             LDR      R0,[R0, #+12]
   \   00000076   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000007A   0x681D             LDR      R5,[R3, #+0]
   \   0000007C   0x60E8             STR      R0,[R5, #+12]
    913          
    914              return HAL_OK;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xE000             B.N      ??HAL_UART_Receive_IT_4
    915            }
    916            else
    917            {
    918              return HAL_BUSY;
   \                     ??HAL_UART_Receive_IT_1: (+1)
   \   00000082   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Receive_IT_4: (+1)
   \   00000084   0xBC30             POP      {R4,R5}
   \   00000086   0x4770             BX       LR               ;; return
    919            }
    920          }
    921          
    922          /**
    923            * @brief  Sends an amount of data in non blocking mode. 
    924            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    925            *                the configuration information for the specified UART module.
    926            * @param  pData: Pointer to data buffer
    927            * @param  Size: Amount of data to be sent
    928            * @retval HAL status
    929            */

   \                                 In section .text, align 2, keep-with-next
    930          HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    931          {
   \                     HAL_UART_Transmit_DMA: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0015             MOVS     R5,R2
    932            uint32_t *tmp;
    933            uint32_t tmp_state = 0;
   \   00000006   0x2700             MOVS     R7,#+0
    934          
    935            tmp_state = huart->State;
   \   00000008   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000000C   0x0007             MOVS     R7,R0
    936            if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_RX))
   \   0000000E   0x2F01             CMP      R7,#+1
   \   00000010   0xD001             BEQ.N    ??HAL_UART_Transmit_DMA_0
   \   00000012   0x2F22             CMP      R7,#+34
   \   00000014   0xD146             BNE.N    ??HAL_UART_Transmit_DMA_1
    937            {
    938              if((pData == NULL ) || (Size == 0)) 
   \                     ??HAL_UART_Transmit_DMA_0: (+1)
   \   00000016   0x9800             LDR      R0,[SP, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD002             BEQ.N    ??HAL_UART_Transmit_DMA_2
   \   0000001C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD101             BNE.N    ??HAL_UART_Transmit_DMA_3
    939              {
    940                return HAL_ERROR;
   \                     ??HAL_UART_Transmit_DMA_2: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xE03F             B.N      ??HAL_UART_Transmit_DMA_4
    941              }
    942          
    943              /* Process Locked */
    944              __HAL_LOCK(huart);
   \                     ??HAL_UART_Transmit_DMA_3: (+1)
   \   00000026   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   0000002A   0x2801             CMP      R0,#+1
   \   0000002C   0xD101             BNE.N    ??HAL_UART_Transmit_DMA_5
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0xE039             B.N      ??HAL_UART_Transmit_DMA_4
   \                     ??HAL_UART_Transmit_DMA_5: (+1)
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xF884 0x0038      STRB     R0,[R4, #+56]
    945          
    946              huart->pTxBuffPtr = pData;
   \   00000038   0x9800             LDR      R0,[SP, #+0]
   \   0000003A   0x6220             STR      R0,[R4, #+32]
    947              huart->TxXferSize = Size;
   \   0000003C   0x84A5             STRH     R5,[R4, #+36]
    948              huart->TxXferCount = Size;
   \   0000003E   0x84E5             STRH     R5,[R4, #+38]
    949          
    950              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x63E0             STR      R0,[R4, #+60]
    951              /* Check if a receive process is ongoing or not */
    952              if(huart->State == HAL_UART_STATE_BUSY_RX)
   \   00000044   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000048   0x2822             CMP      R0,#+34
   \   0000004A   0xD103             BNE.N    ??HAL_UART_Transmit_DMA_6
    953              {
    954                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   0000004C   0x2032             MOVS     R0,#+50
   \   0000004E   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000052   0xE002             B.N      ??HAL_UART_Transmit_DMA_7
    955              }
    956              else
    957              {
    958                huart->State = HAL_UART_STATE_BUSY_TX;
   \                     ??HAL_UART_Transmit_DMA_6: (+1)
   \   00000054   0x2012             MOVS     R0,#+18
   \   00000056   0xF884 0x0039      STRB     R0,[R4, #+57]
    959              }
    960          
    961              /* Set the UART DMA transfer complete callback */
    962              huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
   \                     ??HAL_UART_Transmit_DMA_7: (+1)
   \   0000005A   0x.... 0x....      ADR.W    R0,UART_DMATransmitCplt
   \   0000005E   0x6B21             LDR      R1,[R4, #+48]
   \   00000060   0x6288             STR      R0,[R1, #+40]
    963          
    964              /* Set the UART DMA Half transfer complete callback */
    965              huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
   \   00000062   0x.... 0x....      ADR.W    R0,UART_DMATxHalfCplt
   \   00000066   0x6B21             LDR      R1,[R4, #+48]
   \   00000068   0x62C8             STR      R0,[R1, #+44]
    966          
    967              /* Set the DMA error callback */
    968              huart->hdmatx->XferErrorCallback = UART_DMAError;
   \   0000006A   0x.... 0x....      ADR.W    R0,UART_DMAError
   \   0000006E   0x6B21             LDR      R1,[R4, #+48]
   \   00000070   0x6308             STR      R0,[R1, #+48]
    969          
    970              /* Enable the UART transmit DMA channel */
    971              tmp = (uint32_t*)&pData;
   \   00000072   0x4668             MOV      R0,SP
   \   00000074   0x0006             MOVS     R6,R0
    972              HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t*)tmp, (uint32_t)&huart->Instance->DR, Size);
   \   00000076   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000078   0x002B             MOVS     R3,R5
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x1D02             ADDS     R2,R0,#+4
   \   0000007E   0x6831             LDR      R1,[R6, #+0]
   \   00000080   0x6B20             LDR      R0,[R4, #+48]
   \   00000082   0x.... 0x....      BL       HAL_DMA_Start_IT
    973          
    974              /* Clear the TC flag in the SR register by writing 0 to it */
    975              __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
   \   00000086   0xF07F 0x0040      MVNS     R0,#+64
   \   0000008A   0x6821             LDR      R1,[R4, #+0]
   \   0000008C   0x6008             STR      R0,[R1, #+0]
    976          
    977              /* Enable the DMA transfer for transmit request by setting the DMAT bit
    978                 in the UART CR3 register */
    979              SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0x6940             LDR      R0,[R0, #+20]
   \   00000092   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000096   0x6821             LDR      R1,[R4, #+0]
   \   00000098   0x6148             STR      R0,[R1, #+20]
    980          
    981              /* Process Unlocked */
    982              __HAL_UNLOCK(huart);
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xF884 0x0038      STRB     R0,[R4, #+56]
    983          
    984              return HAL_OK;
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0xE000             B.N      ??HAL_UART_Transmit_DMA_4
    985            }
    986            else
    987            {
    988              return HAL_BUSY;
   \                     ??HAL_UART_Transmit_DMA_1: (+1)
   \   000000A4   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Transmit_DMA_4: (+1)
   \   000000A6   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    989            }
    990          }
    991          
    992          /**
    993            * @brief  Receives an amount of data in non blocking mode. 
    994            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    995            *                the configuration information for the specified UART module.
    996            * @param  pData: Pointer to data buffer
    997            * @param  Size: Amount of data to be received
    998            * @note   When the UART parity is enabled (PCE = 1), the received data contain 
    999            *         the parity bit (MSB position)     
   1000            * @retval HAL status
   1001            */

   \                                 In section .text, align 2, keep-with-next
   1002          HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
   1003          {
   \                     HAL_UART_Receive_DMA: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0015             MOVS     R5,R2
   1004            uint32_t *tmp;
   1005            uint32_t tmp_state = 0;
   \   00000006   0x2700             MOVS     R7,#+0
   1006          
   1007            tmp_state = huart->State;
   \   00000008   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000000C   0x0007             MOVS     R7,R0
   1008            if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_TX))
   \   0000000E   0x2F01             CMP      R7,#+1
   \   00000010   0xD001             BEQ.N    ??HAL_UART_Receive_DMA_0
   \   00000012   0x2F12             CMP      R7,#+18
   \   00000014   0xD141             BNE.N    ??HAL_UART_Receive_DMA_1
   1009            {
   1010              if((pData == NULL ) || (Size == 0))
   \                     ??HAL_UART_Receive_DMA_0: (+1)
   \   00000016   0x9800             LDR      R0,[SP, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD002             BEQ.N    ??HAL_UART_Receive_DMA_2
   \   0000001C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD101             BNE.N    ??HAL_UART_Receive_DMA_3
   1011              {
   1012                return HAL_ERROR;
   \                     ??HAL_UART_Receive_DMA_2: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xE03A             B.N      ??HAL_UART_Receive_DMA_4
   1013              }
   1014          
   1015              /* Process Locked */
   1016              __HAL_LOCK(huart);
   \                     ??HAL_UART_Receive_DMA_3: (+1)
   \   00000026   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   0000002A   0x2801             CMP      R0,#+1
   \   0000002C   0xD101             BNE.N    ??HAL_UART_Receive_DMA_5
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0xE034             B.N      ??HAL_UART_Receive_DMA_4
   \                     ??HAL_UART_Receive_DMA_5: (+1)
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xF884 0x0038      STRB     R0,[R4, #+56]
   1017          
   1018              huart->pRxBuffPtr = pData;
   \   00000038   0x9800             LDR      R0,[SP, #+0]
   \   0000003A   0x62A0             STR      R0,[R4, #+40]
   1019              huart->RxXferSize = Size;
   \   0000003C   0x85A5             STRH     R5,[R4, #+44]
   1020          
   1021              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x63E0             STR      R0,[R4, #+60]
   1022              /* Check if a transmit process is ongoing or not */
   1023              if(huart->State == HAL_UART_STATE_BUSY_TX)
   \   00000042   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000046   0x2812             CMP      R0,#+18
   \   00000048   0xD103             BNE.N    ??HAL_UART_Receive_DMA_6
   1024              {
   1025                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   0000004A   0x2032             MOVS     R0,#+50
   \   0000004C   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000050   0xE002             B.N      ??HAL_UART_Receive_DMA_7
   1026              }
   1027              else
   1028              {
   1029                huart->State = HAL_UART_STATE_BUSY_RX;
   \                     ??HAL_UART_Receive_DMA_6: (+1)
   \   00000052   0x2022             MOVS     R0,#+34
   \   00000054   0xF884 0x0039      STRB     R0,[R4, #+57]
   1030              }
   1031          
   1032              /* Set the UART DMA transfer complete callback */
   1033              huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
   \                     ??HAL_UART_Receive_DMA_7: (+1)
   \   00000058   0x.... 0x....      ADR.W    R0,UART_DMAReceiveCplt
   \   0000005C   0x6B61             LDR      R1,[R4, #+52]
   \   0000005E   0x6288             STR      R0,[R1, #+40]
   1034          
   1035              /* Set the UART DMA Half transfer complete callback */
   1036              huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
   \   00000060   0x.... 0x....      ADR.W    R0,UART_DMARxHalfCplt
   \   00000064   0x6B61             LDR      R1,[R4, #+52]
   \   00000066   0x62C8             STR      R0,[R1, #+44]
   1037          
   1038              /* Set the DMA error callback */
   1039              huart->hdmarx->XferErrorCallback = UART_DMAError;
   \   00000068   0x.... 0x....      ADR.W    R0,UART_DMAError
   \   0000006C   0x6B61             LDR      R1,[R4, #+52]
   \   0000006E   0x6308             STR      R0,[R1, #+48]
   1040          
   1041              /* Enable the DMA channel */
   1042              tmp = (uint32_t*)&pData;
   \   00000070   0x4668             MOV      R0,SP
   \   00000072   0x0006             MOVS     R6,R0
   1043              HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t*)tmp, Size);
   \   00000074   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000076   0x002B             MOVS     R3,R5
   \   00000078   0x6832             LDR      R2,[R6, #+0]
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x1D01             ADDS     R1,R0,#+4
   \   0000007E   0x6B60             LDR      R0,[R4, #+52]
   \   00000080   0x.... 0x....      BL       HAL_DMA_Start_IT
   1044          
   1045              /* Enable the DMA transfer for the receiver request by setting the DMAR bit 
   1046                 in the UART CR3 register */
   1047              SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6940             LDR      R0,[R0, #+20]
   \   00000088   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000008C   0x6821             LDR      R1,[R4, #+0]
   \   0000008E   0x6148             STR      R0,[R1, #+20]
   1048          
   1049              /* Process Unlocked */
   1050              __HAL_UNLOCK(huart);
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0xF884 0x0038      STRB     R0,[R4, #+56]
   1051          
   1052              return HAL_OK;
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0xE000             B.N      ??HAL_UART_Receive_DMA_4
   1053            }
   1054            else
   1055            {
   1056              return HAL_BUSY;
   \                     ??HAL_UART_Receive_DMA_1: (+1)
   \   0000009A   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Receive_DMA_4: (+1)
   \   0000009C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1057            }
   1058          }
   1059              
   1060          /**
   1061            * @brief Pauses the DMA Transfer.
   1062            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1063            *                the configuration information for the specified UART module.
   1064            * @retval HAL status
   1065            */

   \                                 In section .text, align 2, keep-with-next
   1066          HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
   1067          {
   \                     HAL_UART_DMAPause: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1068            /* Process Locked */
   1069            __HAL_LOCK(huart);
   \   00000002   0xF891 0x0038      LDRB     R0,[R1, #+56]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_UART_DMAPause_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE02C             B.N      ??HAL_UART_DMAPause_1
   \                     ??HAL_UART_DMAPause_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x0038      STRB     R0,[R1, #+56]
   1070            
   1071            if(huart->State == HAL_UART_STATE_BUSY_TX)
   \   00000014   0xF891 0x0039      LDRB     R0,[R1, #+57]
   \   00000018   0x2812             CMP      R0,#+18
   \   0000001A   0xD106             BNE.N    ??HAL_UART_DMAPause_2
   1072            {
   1073              /* Disable the UART DMA Tx request */
   1074              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \   0000001C   0x6808             LDR      R0,[R1, #+0]
   \   0000001E   0x6940             LDR      R0,[R0, #+20]
   \   00000020   0xF030 0x0080      BICS     R0,R0,#0x80
   \   00000024   0x680A             LDR      R2,[R1, #+0]
   \   00000026   0x6150             STR      R0,[R2, #+20]
   \   00000028   0xE01A             B.N      ??HAL_UART_DMAPause_3
   1075            }
   1076            else if(huart->State == HAL_UART_STATE_BUSY_RX)
   \                     ??HAL_UART_DMAPause_2: (+1)
   \   0000002A   0xF891 0x0039      LDRB     R0,[R1, #+57]
   \   0000002E   0x2822             CMP      R0,#+34
   \   00000030   0xD106             BNE.N    ??HAL_UART_DMAPause_4
   1077            {
   1078              /* Disable the UART DMA Rx request */
   1079              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \   00000032   0x6808             LDR      R0,[R1, #+0]
   \   00000034   0x6940             LDR      R0,[R0, #+20]
   \   00000036   0xF030 0x0040      BICS     R0,R0,#0x40
   \   0000003A   0x680A             LDR      R2,[R1, #+0]
   \   0000003C   0x6150             STR      R0,[R2, #+20]
   \   0000003E   0xE00F             B.N      ??HAL_UART_DMAPause_3
   1080            }
   1081            else if (huart->State == HAL_UART_STATE_BUSY_TX_RX)
   \                     ??HAL_UART_DMAPause_4: (+1)
   \   00000040   0xF891 0x0039      LDRB     R0,[R1, #+57]
   \   00000044   0x2832             CMP      R0,#+50
   \   00000046   0xD106             BNE.N    ??HAL_UART_DMAPause_5
   1082            {
   1083              /* Disable the UART DMA Tx & Rx requests */
   1084              CLEAR_BIT(huart->Instance->CR3, (USART_CR3_DMAT | USART_CR3_DMAR));
   \   00000048   0x6808             LDR      R0,[R1, #+0]
   \   0000004A   0x6940             LDR      R0,[R0, #+20]
   \   0000004C   0xF030 0x00C0      BICS     R0,R0,#0xC0
   \   00000050   0x680A             LDR      R2,[R1, #+0]
   \   00000052   0x6150             STR      R0,[R2, #+20]
   \   00000054   0xE004             B.N      ??HAL_UART_DMAPause_3
   1085            }
   1086            else
   1087            {
   1088              /* Process Unlocked */
   1089              __HAL_UNLOCK(huart);
   \                     ??HAL_UART_DMAPause_5: (+1)
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xF881 0x0038      STRB     R0,[R1, #+56]
   1090            
   1091              return HAL_ERROR; 
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0xE003             B.N      ??HAL_UART_DMAPause_1
   1092            }
   1093            
   1094            /* Process Unlocked */
   1095            __HAL_UNLOCK(huart);
   \                     ??HAL_UART_DMAPause_3: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xF881 0x0038      STRB     R0,[R1, #+56]
   1096          
   1097            return HAL_OK; 
   \   00000066   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_DMAPause_1: (+1)
   \   00000068   0x4770             BX       LR               ;; return
   1098          }
   1099          
   1100          /**
   1101            * @brief Resumes the DMA Transfer.
   1102            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1103            *                the configuration information for the specified UART module.
   1104            * @retval HAL status
   1105            */

   \                                 In section .text, align 2, keep-with-next
   1106          HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
   1107          {
   \                     HAL_UART_DMAResume: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
   \   00000002   0x0001             MOVS     R1,R0
   1108            /* Process Locked */
   1109            __HAL_LOCK(huart);
   \   00000004   0xF891 0x0038      LDRB     R0,[R1, #+56]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_UART_DMAResume_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE03A             B.N      ??HAL_UART_DMAResume_1
   \                     ??HAL_UART_DMAResume_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF881 0x0038      STRB     R0,[R1, #+56]
   1110          
   1111            if(huart->State == HAL_UART_STATE_BUSY_TX)
   \   00000016   0xF891 0x0039      LDRB     R0,[R1, #+57]
   \   0000001A   0x2812             CMP      R0,#+18
   \   0000001C   0xD106             BNE.N    ??HAL_UART_DMAResume_2
   1112            {
   1113              /* Enable the UART DMA Tx request */
   1114              SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \   0000001E   0x6808             LDR      R0,[R1, #+0]
   \   00000020   0x6940             LDR      R0,[R0, #+20]
   \   00000022   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000026   0x680A             LDR      R2,[R1, #+0]
   \   00000028   0x6150             STR      R0,[R2, #+20]
   \   0000002A   0xE028             B.N      ??HAL_UART_DMAResume_3
   1115            }
   1116            else if(huart->State == HAL_UART_STATE_BUSY_RX)
   \                     ??HAL_UART_DMAResume_2: (+1)
   \   0000002C   0xF891 0x0039      LDRB     R0,[R1, #+57]
   \   00000030   0x2822             CMP      R0,#+34
   \   00000032   0xD10D             BNE.N    ??HAL_UART_DMAResume_4
   1117            {
   1118              /* Clear the Overrun flag before resumming the Rx transfer*/
   1119              __HAL_UART_CLEAR_OREFLAG(huart);
   \   00000034   0x6808             LDR      R0,[R1, #+0]
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x9000             STR      R0,[SP, #+0]
   \   0000003A   0x6808             LDR      R0,[R1, #+0]
   \   0000003C   0x6840             LDR      R0,[R0, #+4]
   \   0000003E   0x9000             STR      R0,[SP, #+0]
   \   00000040   0x9800             LDR      R0,[SP, #+0]
   1120              /* Enable the UART DMA Rx request */
   1121              SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \   00000042   0x6808             LDR      R0,[R1, #+0]
   \   00000044   0x6940             LDR      R0,[R0, #+20]
   \   00000046   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000004A   0x680A             LDR      R2,[R1, #+0]
   \   0000004C   0x6150             STR      R0,[R2, #+20]
   \   0000004E   0xE016             B.N      ??HAL_UART_DMAResume_3
   1122            }
   1123            else if(huart->State == HAL_UART_STATE_BUSY_TX_RX)
   \                     ??HAL_UART_DMAResume_4: (+1)
   \   00000050   0xF891 0x0039      LDRB     R0,[R1, #+57]
   \   00000054   0x2832             CMP      R0,#+50
   \   00000056   0xD10D             BNE.N    ??HAL_UART_DMAResume_5
   1124            {
   1125              /* Clear the Overrun flag before resumming the Rx transfer*/
   1126              __HAL_UART_CLEAR_OREFLAG(huart);
   \   00000058   0x6808             LDR      R0,[R1, #+0]
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0x9000             STR      R0,[SP, #+0]
   \   0000005E   0x6808             LDR      R0,[R1, #+0]
   \   00000060   0x6840             LDR      R0,[R0, #+4]
   \   00000062   0x9000             STR      R0,[SP, #+0]
   \   00000064   0x9800             LDR      R0,[SP, #+0]
   1127              /* Enable the UART DMA Tx & Rx request */
   1128              SET_BIT(huart->Instance->CR3, (USART_CR3_DMAT | USART_CR3_DMAR));
   \   00000066   0x6808             LDR      R0,[R1, #+0]
   \   00000068   0x6940             LDR      R0,[R0, #+20]
   \   0000006A   0xF050 0x00C0      ORRS     R0,R0,#0xC0
   \   0000006E   0x680A             LDR      R2,[R1, #+0]
   \   00000070   0x6150             STR      R0,[R2, #+20]
   \   00000072   0xE004             B.N      ??HAL_UART_DMAResume_3
   1129            }
   1130            else
   1131            {
   1132              /* Process Unlocked */
   1133              __HAL_UNLOCK(huart);
   \                     ??HAL_UART_DMAResume_5: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xF881 0x0038      STRB     R0,[R1, #+56]
   1134          
   1135              return HAL_ERROR; 
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0xE003             B.N      ??HAL_UART_DMAResume_1
   1136            }
   1137          
   1138            /* Process Unlocked */
   1139            __HAL_UNLOCK(huart);
   \                     ??HAL_UART_DMAResume_3: (+1)
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xF881 0x0038      STRB     R0,[R1, #+56]
   1140          
   1141            return HAL_OK;
   \   00000084   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_DMAResume_1: (+1)
   \   00000086   0xB001             ADD      SP,SP,#+4
   \   00000088   0x4770             BX       LR               ;; return
   1142          }
   1143          
   1144          /**
   1145            * @brief Stops the DMA Transfer.
   1146            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1147            *                the configuration information for the specified UART module.
   1148            * @retval HAL status
   1149            */

   \                                 In section .text, align 2, keep-with-next
   1150          HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
   1151          {
   \                     HAL_UART_DMAStop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1152            /* The Lock is not implemented on this API to allow the user application
   1153               to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback():
   1154               when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
   1155               and the correspond call back is executed HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback()
   1156               */
   1157            
   1158            /* Disable the UART Tx/Rx DMA requests */
   1159            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_DMAT | USART_CR3_DMAR));
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6940             LDR      R0,[R0, #+20]
   \   00000008   0xF030 0x00C0      BICS     R0,R0,#0xC0
   \   0000000C   0x6821             LDR      R1,[R4, #+0]
   \   0000000E   0x6148             STR      R0,[R1, #+20]
   1160            
   1161            /* Abort the UART DMA tx channel */
   1162            if(huart->hdmatx != NULL)
   \   00000010   0x6B20             LDR      R0,[R4, #+48]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD002             BEQ.N    ??HAL_UART_DMAStop_0
   1163            {
   1164              HAL_DMA_Abort(huart->hdmatx);
   \   00000016   0x6B20             LDR      R0,[R4, #+48]
   \   00000018   0x.... 0x....      BL       HAL_DMA_Abort
   1165            }
   1166            /* Abort the UART DMA rx channel */
   1167            if(huart->hdmarx != NULL)
   \                     ??HAL_UART_DMAStop_0: (+1)
   \   0000001C   0x6B60             LDR      R0,[R4, #+52]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD002             BEQ.N    ??HAL_UART_DMAStop_1
   1168            {
   1169              HAL_DMA_Abort(huart->hdmarx);
   \   00000022   0x6B60             LDR      R0,[R4, #+52]
   \   00000024   0x.... 0x....      BL       HAL_DMA_Abort
   1170            }
   1171            
   1172            huart->State = HAL_UART_STATE_READY;
   \                     ??HAL_UART_DMAStop_1: (+1)
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xF884 0x0039      STRB     R0,[R4, #+57]
   1173            
   1174            return HAL_OK;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
   1175          }
   1176          
   1177          /**
   1178            * @brief  This function handles UART interrupt request.
   1179            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1180            *                the configuration information for the specified UART module.
   1181            * @retval None
   1182            */

   \                                 In section .text, align 2, keep-with-next
   1183          void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
   1184          {
   \                     HAL_UART_IRQHandler: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   1185            uint32_t tmp_flag = 0, tmp_it_source = 0;
   \   00000006   0x2500             MOVS     R5,#+0
   \   00000008   0x2600             MOVS     R6,#+0
   1186          
   1187            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_PE);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000012   0x0005             MOVS     R5,R0
   1188            tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_PE);  
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x68C0             LDR      R0,[R0, #+12]
   \   00000018   0xF410 0x7080      ANDS     R0,R0,#0x100
   \   0000001C   0x0006             MOVS     R6,R0
   1189            /* UART parity error interrupt occurred ------------------------------------*/
   1190            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD00C             BEQ.N    ??HAL_UART_IRQHandler_0
   \   00000022   0x2E00             CMP      R6,#+0
   \   00000024   0xD00A             BEQ.N    ??HAL_UART_IRQHandler_0
   1191            { 
   1192              __HAL_UART_CLEAR_PEFLAG(huart);
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x9000             STR      R0,[SP, #+0]
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x6840             LDR      R0,[R0, #+4]
   \   00000030   0x9000             STR      R0,[SP, #+0]
   \   00000032   0x9800             LDR      R0,[SP, #+0]
   1193              
   1194              huart->ErrorCode |= HAL_UART_ERROR_PE;
   \   00000034   0x6BE0             LDR      R0,[R4, #+60]
   \   00000036   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000003A   0x63E0             STR      R0,[R4, #+60]
   1195            }
   1196            
   1197            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_FE);
   \                     ??HAL_UART_IRQHandler_0: (+1)
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x0840             LSRS     R0,R0,#+1
   \   00000042   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000046   0x0005             MOVS     R5,R0
   1198            tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_ERR);
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x6940             LDR      R0,[R0, #+20]
   \   0000004C   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000050   0x0006             MOVS     R6,R0
   1199            /* UART frame error interrupt occurred -------------------------------------*/
   1200            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   00000052   0x2D00             CMP      R5,#+0
   \   00000054   0xD00C             BEQ.N    ??HAL_UART_IRQHandler_1
   \   00000056   0x2E00             CMP      R6,#+0
   \   00000058   0xD00A             BEQ.N    ??HAL_UART_IRQHandler_1
   1201            { 
   1202              __HAL_UART_CLEAR_FEFLAG(huart);
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x9000             STR      R0,[SP, #+0]
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x6840             LDR      R0,[R0, #+4]
   \   00000064   0x9000             STR      R0,[SP, #+0]
   \   00000066   0x9800             LDR      R0,[SP, #+0]
   1203              
   1204              huart->ErrorCode |= HAL_UART_ERROR_FE;
   \   00000068   0x6BE0             LDR      R0,[R4, #+60]
   \   0000006A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000006E   0x63E0             STR      R0,[R4, #+60]
   1205            }
   1206            
   1207            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_NE);
   \                     ??HAL_UART_IRQHandler_1: (+1)
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x0880             LSRS     R0,R0,#+2
   \   00000076   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000007A   0x0005             MOVS     R5,R0
   1208            /* UART noise error interrupt occurred -------------------------------------*/
   1209            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   0000007C   0x2D00             CMP      R5,#+0
   \   0000007E   0xD00C             BEQ.N    ??HAL_UART_IRQHandler_2
   \   00000080   0x2E00             CMP      R6,#+0
   \   00000082   0xD00A             BEQ.N    ??HAL_UART_IRQHandler_2
   1210            { 
   1211              __HAL_UART_CLEAR_NEFLAG(huart);
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0x9000             STR      R0,[SP, #+0]
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x6840             LDR      R0,[R0, #+4]
   \   0000008E   0x9000             STR      R0,[SP, #+0]
   \   00000090   0x9800             LDR      R0,[SP, #+0]
   1212              
   1213              huart->ErrorCode |= HAL_UART_ERROR_NE;
   \   00000092   0x6BE0             LDR      R0,[R4, #+60]
   \   00000094   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000098   0x63E0             STR      R0,[R4, #+60]
   1214            }
   1215            
   1216            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_ORE);
   \                     ??HAL_UART_IRQHandler_2: (+1)
   \   0000009A   0x6820             LDR      R0,[R4, #+0]
   \   0000009C   0x6800             LDR      R0,[R0, #+0]
   \   0000009E   0x08C0             LSRS     R0,R0,#+3
   \   000000A0   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   000000A4   0x0005             MOVS     R5,R0
   1217            /* UART Over-Run interrupt occurred ----------------------------------------*/
   1218            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   000000A6   0x2D00             CMP      R5,#+0
   \   000000A8   0xD00C             BEQ.N    ??HAL_UART_IRQHandler_3
   \   000000AA   0x2E00             CMP      R6,#+0
   \   000000AC   0xD00A             BEQ.N    ??HAL_UART_IRQHandler_3
   1219            { 
   1220              __HAL_UART_CLEAR_OREFLAG(huart);
   \   000000AE   0x6820             LDR      R0,[R4, #+0]
   \   000000B0   0x6800             LDR      R0,[R0, #+0]
   \   000000B2   0x9000             STR      R0,[SP, #+0]
   \   000000B4   0x6820             LDR      R0,[R4, #+0]
   \   000000B6   0x6840             LDR      R0,[R0, #+4]
   \   000000B8   0x9000             STR      R0,[SP, #+0]
   \   000000BA   0x9800             LDR      R0,[SP, #+0]
   1221              
   1222              huart->ErrorCode |= HAL_UART_ERROR_ORE;
   \   000000BC   0x6BE0             LDR      R0,[R4, #+60]
   \   000000BE   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   000000C2   0x63E0             STR      R0,[R4, #+60]
   1223            }
   1224            
   1225            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_RXNE);
   \                     ??HAL_UART_IRQHandler_3: (+1)
   \   000000C4   0x6820             LDR      R0,[R4, #+0]
   \   000000C6   0x6800             LDR      R0,[R0, #+0]
   \   000000C8   0x0940             LSRS     R0,R0,#+5
   \   000000CA   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   000000CE   0x0005             MOVS     R5,R0
   1226            tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_RXNE);
   \   000000D0   0x6820             LDR      R0,[R4, #+0]
   \   000000D2   0x68C0             LDR      R0,[R0, #+12]
   \   000000D4   0xF010 0x0020      ANDS     R0,R0,#0x20
   \   000000D8   0x0006             MOVS     R6,R0
   1227            /* UART in mode Receiver ---------------------------------------------------*/
   1228            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   000000DA   0x2D00             CMP      R5,#+0
   \   000000DC   0xD004             BEQ.N    ??HAL_UART_IRQHandler_4
   \   000000DE   0x2E00             CMP      R6,#+0
   \   000000E0   0xD002             BEQ.N    ??HAL_UART_IRQHandler_4
   1229            { 
   1230              UART_Receive_IT(huart);
   \   000000E2   0x0020             MOVS     R0,R4
   \   000000E4   0x.... 0x....      BL       UART_Receive_IT
   1231            }
   1232            
   1233            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_TXE);
   \                     ??HAL_UART_IRQHandler_4: (+1)
   \   000000E8   0x6820             LDR      R0,[R4, #+0]
   \   000000EA   0x6800             LDR      R0,[R0, #+0]
   \   000000EC   0x09C0             LSRS     R0,R0,#+7
   \   000000EE   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   000000F2   0x0005             MOVS     R5,R0
   1234            tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_TXE);
   \   000000F4   0x6820             LDR      R0,[R4, #+0]
   \   000000F6   0x68C0             LDR      R0,[R0, #+12]
   \   000000F8   0xF010 0x0080      ANDS     R0,R0,#0x80
   \   000000FC   0x0006             MOVS     R6,R0
   1235            /* UART in mode Transmitter ------------------------------------------------*/
   1236            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   000000FE   0x2D00             CMP      R5,#+0
   \   00000100   0xD004             BEQ.N    ??HAL_UART_IRQHandler_5
   \   00000102   0x2E00             CMP      R6,#+0
   \   00000104   0xD002             BEQ.N    ??HAL_UART_IRQHandler_5
   1237            {
   1238              UART_Transmit_IT(huart);
   \   00000106   0x0020             MOVS     R0,R4
   \   00000108   0x.... 0x....      BL       UART_Transmit_IT
   1239            }
   1240          
   1241            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_TC);
   \                     ??HAL_UART_IRQHandler_5: (+1)
   \   0000010C   0x6820             LDR      R0,[R4, #+0]
   \   0000010E   0x6800             LDR      R0,[R0, #+0]
   \   00000110   0x0980             LSRS     R0,R0,#+6
   \   00000112   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000116   0x0005             MOVS     R5,R0
   1242            tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_TC);
   \   00000118   0x6820             LDR      R0,[R4, #+0]
   \   0000011A   0x68C0             LDR      R0,[R0, #+12]
   \   0000011C   0xF010 0x0040      ANDS     R0,R0,#0x40
   \   00000120   0x0006             MOVS     R6,R0
   1243            /* UART in mode Transmitter end --------------------------------------------*/
   1244            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   00000122   0x2D00             CMP      R5,#+0
   \   00000124   0xD004             BEQ.N    ??HAL_UART_IRQHandler_6
   \   00000126   0x2E00             CMP      R6,#+0
   \   00000128   0xD002             BEQ.N    ??HAL_UART_IRQHandler_6
   1245            {
   1246              UART_EndTransmit_IT(huart);
   \   0000012A   0x0020             MOVS     R0,R4
   \   0000012C   0x.... 0x....      BL       UART_EndTransmit_IT
   1247            }  
   1248          
   1249            if(huart->ErrorCode != HAL_UART_ERROR_NONE)
   \                     ??HAL_UART_IRQHandler_6: (+1)
   \   00000130   0x6BE0             LDR      R0,[R4, #+60]
   \   00000132   0x2800             CMP      R0,#+0
   \   00000134   0xD005             BEQ.N    ??HAL_UART_IRQHandler_7
   1250            {
   1251              /* Set the UART state ready to be able to start again the process */
   1252              huart->State = HAL_UART_STATE_READY;
   \   00000136   0x2001             MOVS     R0,#+1
   \   00000138   0xF884 0x0039      STRB     R0,[R4, #+57]
   1253              
   1254              HAL_UART_ErrorCallback(huart);
   \   0000013C   0x0020             MOVS     R0,R4
   \   0000013E   0x.... 0x....      BL       HAL_UART_ErrorCallback
   1255            }  
   1256          }
   \                     ??HAL_UART_IRQHandler_7: (+1)
   \   00000142   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
   1257          
   1258          /**
   1259            * @brief  Tx Transfer completed callbacks.
   1260            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1261            *                the configuration information for the specified UART module.
   1262            * @retval None
   1263            */

   \                                 In section .text, align 2
   1264           __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
   1265          {
   1266            /* NOTE: This function should not be modified, when the callback is needed,
   1267                     the HAL_UART_TxCpltCallback can be implemented in the user file
   1268             */ 
   1269          }
   \                     HAL_UART_TxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1270          
   1271          /**
   1272            * @brief  Tx Half Transfer completed callbacks.
   1273            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1274            *                the configuration information for the specified UART module.
   1275            * @retval None
   1276            */

   \                                 In section .text, align 2
   1277           __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
   1278          {
   1279            /* NOTE: This function should not be modified, when the callback is needed,
   1280                     the HAL_UART_TxHalfCpltCallback can be implemented in the user file
   1281             */ 
   1282          }
   \                     HAL_UART_TxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1283          
   1284          /**
   1285            * @brief  Rx Transfer completed callbacks.
   1286            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1287            *                the configuration information for the specified UART module.
   1288            * @retval None
   1289            */

   \                                 In section .text, align 2
   1290          __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
   1291          {
   1292            /* NOTE: This function should not be modified, when the callback is needed,
   1293                     the HAL_UART_RxCpltCallback can be implemented in the user file
   1294             */
   1295          }
   \                     HAL_UART_RxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1296          
   1297          /**
   1298            * @brief  Rx Half Transfer completed callbacks.
   1299            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1300            *                the configuration information for the specified UART module.
   1301            * @retval None
   1302            */

   \                                 In section .text, align 2
   1303          __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
   1304          {
   1305            /* NOTE: This function should not be modified, when the callback is needed,
   1306                     the HAL_UART_RxHalfCpltCallback can be implemented in the user file
   1307             */
   1308          }
   \                     HAL_UART_RxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1309          
   1310          /**
   1311            * @brief  UART error callbacks.
   1312            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1313            *                the configuration information for the specified UART module.
   1314            * @retval None
   1315            */

   \                                 In section .text, align 2
   1316           __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
   1317          {
   1318            /* NOTE: This function should not be modified, when the callback is needed,
   1319                     the HAL_UART_ErrorCallback can be implemented in the user file
   1320             */ 
   1321          }
   \                     HAL_UART_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1322          
   1323          /**
   1324            * @}
   1325            */
   1326          
   1327          /** @defgroup UART_Exported_Functions_Group3 Peripheral Control functions 
   1328            *  @brief   UART control functions 
   1329            *
   1330          @verbatim   
   1331            ==============================================================================
   1332                                ##### Peripheral Control functions #####
   1333            ==============================================================================  
   1334            [..]
   1335              This subsection provides a set of functions allowing to control the UART:
   1336              (+) HAL_LIN_SendBreak() API can be helpful to transmit the break character.
   1337              (+) HAL_MultiProcessor_EnterMuteMode() API can be helpful to enter the UART in mute mode. 
   1338              (+) HAL_MultiProcessor_ExitMuteMode() API can be helpful to exit the UART mute mode by software.
   1339              (+) HAL_HalfDuplex_EnableTransmitter() API to enable the UART transmitter and disables the UART receiver in Half Duplex mode
   1340              (+) HAL_HalfDuplex_EnableReceiver() API to enable the UART receiver and disables the UART transmitter in Half Duplex mode
   1341              
   1342          @endverbatim
   1343            * @{
   1344            */
   1345          
   1346          /**
   1347            * @brief  Transmits break characters.
   1348            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1349            *                the configuration information for the specified UART module.
   1350            * @retval HAL status
   1351            */

   \                                 In section .text, align 2, keep-with-next
   1352          HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
   1353          {
   \                     HAL_LIN_SendBreak: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1354            /* Check the parameters */
   1355            assert_param(IS_UART_INSTANCE(huart->Instance));
   1356            
   1357            /* Process Locked */
   1358            __HAL_LOCK(huart);
   \   00000002   0xF891 0x0038      LDRB     R0,[R1, #+56]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_LIN_SendBreak_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE012             B.N      ??HAL_LIN_SendBreak_1
   \                     ??HAL_LIN_SendBreak_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x0038      STRB     R0,[R1, #+56]
   1359            
   1360            huart->State = HAL_UART_STATE_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xF881 0x0039      STRB     R0,[R1, #+57]
   1361            
   1362            /* Send break characters */
   1363            SET_BIT(huart->Instance->CR1, USART_CR1_SBK);
   \   0000001A   0x6808             LDR      R0,[R1, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000022   0x680A             LDR      R2,[R1, #+0]
   \   00000024   0x60D0             STR      R0,[R2, #+12]
   1364           
   1365            huart->State = HAL_UART_STATE_READY;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xF881 0x0039      STRB     R0,[R1, #+57]
   1366            
   1367            /* Process Unlocked */
   1368            __HAL_UNLOCK(huart);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xF881 0x0038      STRB     R0,[R1, #+56]
   1369            
   1370            return HAL_OK; 
   \   00000032   0x2000             MOVS     R0,#+0
   \                     ??HAL_LIN_SendBreak_1: (+1)
   \   00000034   0x4770             BX       LR               ;; return
   1371          }
   1372          
   1373          /**
   1374            * @brief  Enters the UART in mute mode. 
   1375            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1376            *                the configuration information for the specified UART module.
   1377            * @retval HAL status
   1378            */

   \                                 In section .text, align 2, keep-with-next
   1379          HAL_StatusTypeDef HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
   1380          {
   \                     HAL_MultiProcessor_EnterMuteMode: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1381            /* Check the parameters */
   1382            assert_param(IS_UART_INSTANCE(huart->Instance));
   1383            
   1384            /* Process Locked */
   1385            __HAL_LOCK(huart);
   \   00000002   0xF891 0x0038      LDRB     R0,[R1, #+56]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_MultiProcessor_EnterMuteMode_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE012             B.N      ??HAL_MultiProcessor_EnterMuteMode_1
   \                     ??HAL_MultiProcessor_EnterMuteMode_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x0038      STRB     R0,[R1, #+56]
   1386            
   1387            huart->State = HAL_UART_STATE_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xF881 0x0039      STRB     R0,[R1, #+57]
   1388            
   1389            /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
   1390            SET_BIT(huart->Instance->CR1, USART_CR1_RWU);
   \   0000001A   0x6808             LDR      R0,[R1, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000022   0x680A             LDR      R2,[R1, #+0]
   \   00000024   0x60D0             STR      R0,[R2, #+12]
   1391            
   1392            huart->State = HAL_UART_STATE_READY;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xF881 0x0039      STRB     R0,[R1, #+57]
   1393            
   1394            /* Process Unlocked */
   1395            __HAL_UNLOCK(huart);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xF881 0x0038      STRB     R0,[R1, #+56]
   1396            
   1397            return HAL_OK; 
   \   00000032   0x2000             MOVS     R0,#+0
   \                     ??HAL_MultiProcessor_EnterMuteMode_1: (+1)
   \   00000034   0x4770             BX       LR               ;; return
   1398          }
   1399          
   1400          /**
   1401            * @brief  Exits the UART mute mode: wake up software. 
   1402            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1403            *                the configuration information for the specified UART module.
   1404            * @retval HAL status
   1405            */

   \                                 In section .text, align 2, keep-with-next
   1406          HAL_StatusTypeDef HAL_MultiProcessor_ExitMuteMode(UART_HandleTypeDef *huart)
   1407          {
   \                     HAL_MultiProcessor_ExitMuteMode: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1408            /* Check the parameters */
   1409            assert_param(IS_UART_INSTANCE(huart->Instance));
   1410            
   1411            /* Process Locked */
   1412            __HAL_LOCK(huart);
   \   00000002   0xF891 0x0038      LDRB     R0,[R1, #+56]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_MultiProcessor_ExitMuteMode_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE012             B.N      ??HAL_MultiProcessor_ExitMuteMode_1
   \                     ??HAL_MultiProcessor_ExitMuteMode_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x0038      STRB     R0,[R1, #+56]
   1413            
   1414            huart->State = HAL_UART_STATE_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xF881 0x0039      STRB     R0,[R1, #+57]
   1415            
   1416            /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
   1417            CLEAR_BIT(huart->Instance->CR1, USART_CR1_RWU);
   \   0000001A   0x6808             LDR      R0,[R1, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000022   0x680A             LDR      R2,[R1, #+0]
   \   00000024   0x60D0             STR      R0,[R2, #+12]
   1418            
   1419            huart->State = HAL_UART_STATE_READY;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xF881 0x0039      STRB     R0,[R1, #+57]
   1420            
   1421            /* Process Unlocked */
   1422            __HAL_UNLOCK(huart);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xF881 0x0038      STRB     R0,[R1, #+56]
   1423            
   1424            return HAL_OK; 
   \   00000032   0x2000             MOVS     R0,#+0
   \                     ??HAL_MultiProcessor_ExitMuteMode_1: (+1)
   \   00000034   0x4770             BX       LR               ;; return
   1425          }
   1426          
   1427          /**
   1428            * @brief  Enables the UART transmitter and disables the UART receiver.
   1429            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1430            *                the configuration information for the specified UART module.
   1431            * @retval HAL status
   1432            */

   \                                 In section .text, align 2, keep-with-next
   1433          HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
   1434          {
   \                     HAL_HalfDuplex_EnableTransmitter: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1435            /* Process Locked */
   1436            __HAL_LOCK(huart);
   \   00000002   0xF891 0x0038      LDRB     R0,[R1, #+56]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_HalfDuplex_EnableTransmitter_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE014             B.N      ??HAL_HalfDuplex_EnableTransmitter_1
   \                     ??HAL_HalfDuplex_EnableTransmitter_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x0038      STRB     R0,[R1, #+56]
   1437            
   1438            huart->State = HAL_UART_STATE_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xF881 0x0039      STRB     R0,[R1, #+57]
   1439          
   1440            /*-------------------------- USART CR1 Configuration -----------------------*/
   1441            /* Clear TE and RE bits */
   1442            /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
   1443            MODIFY_REG(huart->Instance->CR1, (uint32_t)(USART_CR1_TE | USART_CR1_RE), USART_CR1_TE);
   \   0000001A   0x6808             LDR      R0,[R1, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF030 0x000C      BICS     R0,R0,#0xC
   \   00000022   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000026   0x680A             LDR      R2,[R1, #+0]
   \   00000028   0x60D0             STR      R0,[R2, #+12]
   1444           
   1445            huart->State = HAL_UART_STATE_READY;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xF881 0x0039      STRB     R0,[R1, #+57]
   1446            
   1447            /* Process Unlocked */
   1448            __HAL_UNLOCK(huart);
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xF881 0x0038      STRB     R0,[R1, #+56]
   1449            
   1450            return HAL_OK; 
   \   00000036   0x2000             MOVS     R0,#+0
   \                     ??HAL_HalfDuplex_EnableTransmitter_1: (+1)
   \   00000038   0x4770             BX       LR               ;; return
   1451          }
   1452          
   1453          /**
   1454            * @brief  Enables the UART receiver and disables the UART transmitter.
   1455            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1456            *                the configuration information for the specified UART module.
   1457            * @retval HAL status
   1458            */

   \                                 In section .text, align 2, keep-with-next
   1459          HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
   1460          {
   \                     HAL_HalfDuplex_EnableReceiver: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1461            /* Process Locked */
   1462            __HAL_LOCK(huart);
   \   00000002   0xF891 0x0038      LDRB     R0,[R1, #+56]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_HalfDuplex_EnableReceiver_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE014             B.N      ??HAL_HalfDuplex_EnableReceiver_1
   \                     ??HAL_HalfDuplex_EnableReceiver_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x0038      STRB     R0,[R1, #+56]
   1463            
   1464            huart->State = HAL_UART_STATE_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xF881 0x0039      STRB     R0,[R1, #+57]
   1465          
   1466            /*-------------------------- USART CR1 Configuration -----------------------*/
   1467            /* Clear TE and RE bits */
   1468            /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
   1469            MODIFY_REG(huart->Instance->CR1, (uint32_t)(USART_CR1_TE | USART_CR1_RE), USART_CR1_RE);
   \   0000001A   0x6808             LDR      R0,[R1, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF030 0x000C      BICS     R0,R0,#0xC
   \   00000022   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000026   0x680A             LDR      R2,[R1, #+0]
   \   00000028   0x60D0             STR      R0,[R2, #+12]
   1470            
   1471            huart->State = HAL_UART_STATE_READY;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xF881 0x0039      STRB     R0,[R1, #+57]
   1472            
   1473            /* Process Unlocked */
   1474            __HAL_UNLOCK(huart);
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xF881 0x0038      STRB     R0,[R1, #+56]
   1475            
   1476            return HAL_OK; 
   \   00000036   0x2000             MOVS     R0,#+0
   \                     ??HAL_HalfDuplex_EnableReceiver_1: (+1)
   \   00000038   0x4770             BX       LR               ;; return
   1477          }
   1478          
   1479          /**
   1480            * @}
   1481            */
   1482          
   1483          /** @defgroup UART_Exported_Functions_Group4 Peripheral State and Errors functions 
   1484            *  @brief   UART State and Errors functions 
   1485            *
   1486          @verbatim   
   1487            ==============================================================================
   1488                           ##### Peripheral State and Errors functions #####
   1489            ==============================================================================  
   1490           [..]
   1491             This subsection provides a set of functions allowing to return the State of 
   1492             UART communication process, return Peripheral Errors occurred during communication 
   1493             process
   1494             (+) HAL_UART_GetState() API can be helpful to check in run-time the state of the UART peripheral.
   1495             (+) HAL_UART_GetError() check in run-time errors that could be occurred during communication. 
   1496          
   1497          @endverbatim
   1498            * @{
   1499            */
   1500            
   1501          /**
   1502            * @brief  Returns the UART state.
   1503            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1504            *                the configuration information for the specified UART module.
   1505            * @retval HAL state
   1506            */

   \                                 In section .text, align 2, keep-with-next
   1507          HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
   1508          {
   1509            return huart->State;
   \                     HAL_UART_GetState: (+1)
   \   00000000   0xF890 0x0039      LDRB     R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   1510          }
   1511          
   1512          /**
   1513          * @brief  Return the UART error code
   1514          * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1515            *              the configuration information for the specified UART.
   1516          * @retval UART Error Code
   1517          */

   \                                 In section .text, align 2, keep-with-next
   1518          uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
   1519          {
   1520            return huart->ErrorCode;
   \                     HAL_UART_GetError: (+1)
   \   00000000   0x6BC0             LDR      R0,[R0, #+60]
   \   00000002   0x4770             BX       LR               ;; return
   1521          }
   1522          
   1523          /**
   1524            * @}
   1525            */
   1526          
   1527          /**
   1528            * @}
   1529            */
   1530          
   1531          /** @defgroup UART_Private_Functions   UART Private Functions
   1532            *  @brief   UART Private functions 
   1533            * @{
   1534            */
   1535          /**
   1536            * @brief  DMA UART transmit process complete callback. 
   1537            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
   1538            *               the configuration information for the specified DMA module.
   1539            * @retval None
   1540            */

   \                                 In section .text, align 4, keep-with-next
   1541          static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)     
   1542          {
   \                     UART_DMATransmitCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1543            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   1544            /* DMA Normal mode*/
   1545            if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0680             LSLS     R0,R0,#+26
   \   0000000C   0xD40E             BMI.N    ??UART_DMATransmitCplt_0
   1546            {
   1547              huart->TxXferCount = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x84E8             STRH     R0,[R5, #+38]
   1548          
   1549              /* Disable the DMA transfer for transmit request by setting the DMAT bit
   1550                 in the UART CR3 register */
   1551              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \   00000012   0x6828             LDR      R0,[R5, #+0]
   \   00000014   0x6940             LDR      R0,[R0, #+20]
   \   00000016   0xF030 0x0080      BICS     R0,R0,#0x80
   \   0000001A   0x6829             LDR      R1,[R5, #+0]
   \   0000001C   0x6148             STR      R0,[R1, #+20]
   1552          
   1553              /* Enable the UART Transmit Complete Interrupt */    
   1554              __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
   \   0000001E   0x6828             LDR      R0,[R5, #+0]
   \   00000020   0x68C0             LDR      R0,[R0, #+12]
   \   00000022   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000026   0x6829             LDR      R1,[R5, #+0]
   \   00000028   0x60C8             STR      R0,[R1, #+12]
   \   0000002A   0xE002             B.N      ??UART_DMATransmitCplt_1
   1555            }
   1556            /* DMA Circular mode */
   1557            else
   1558            {
   1559              HAL_UART_TxCpltCallback(huart);
   \                     ??UART_DMATransmitCplt_0: (+1)
   \   0000002C   0x0028             MOVS     R0,R5
   \   0000002E   0x.... 0x....      BL       HAL_UART_TxCpltCallback
   1560            }
   1561          }
   \                     ??UART_DMATransmitCplt_1: (+1)
   \   00000032   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1562          
   1563          /**
   1564            * @brief DMA UART transmit process half complete callback 
   1565            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
   1566            *               the configuration information for the specified DMA module.
   1567            * @retval None
   1568            */

   \                                 In section .text, align 4, keep-with-next
   1569          static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
   1570          {
   \                     UART_DMATxHalfCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1571            UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   1572          
   1573            HAL_UART_TxHalfCpltCallback(huart);
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x.... 0x....      BL       HAL_UART_TxHalfCpltCallback
   1574          }
   \   0000000C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1575          
   1576          /**
   1577            * @brief  DMA UART receive process complete callback. 
   1578            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
   1579            *               the configuration information for the specified DMA module.
   1580            * @retval None
   1581            */

   \                                 In section .text, align 4, keep-with-next
   1582          static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)  
   1583          {
   \                     UART_DMAReceiveCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1584            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   1585            /* DMA Normal mode*/
   1586            if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0680             LSLS     R0,R0,#+26
   \   0000000C   0xD412             BMI.N    ??UART_DMAReceiveCplt_0
   1587            {
   1588              huart->RxXferCount = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x85E8             STRH     R0,[R5, #+46]
   1589            
   1590              /* Disable the DMA transfer for the receiver request by setting the DMAR bit 
   1591                 in the UART CR3 register */
   1592              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \   00000012   0x6828             LDR      R0,[R5, #+0]
   \   00000014   0x6940             LDR      R0,[R0, #+20]
   \   00000016   0xF030 0x0040      BICS     R0,R0,#0x40
   \   0000001A   0x6829             LDR      R1,[R5, #+0]
   \   0000001C   0x6148             STR      R0,[R1, #+20]
   1593          
   1594              /* Check if a transmit process is ongoing or not */
   1595              if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   \   0000001E   0xF895 0x0039      LDRB     R0,[R5, #+57]
   \   00000022   0x2832             CMP      R0,#+50
   \   00000024   0xD103             BNE.N    ??UART_DMAReceiveCplt_1
   1596              {
   1597                huart->State = HAL_UART_STATE_BUSY_TX;
   \   00000026   0x2012             MOVS     R0,#+18
   \   00000028   0xF885 0x0039      STRB     R0,[R5, #+57]
   \   0000002C   0xE002             B.N      ??UART_DMAReceiveCplt_0
   1598              }
   1599              else
   1600              {
   1601                huart->State = HAL_UART_STATE_READY;
   \                     ??UART_DMAReceiveCplt_1: (+1)
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF885 0x0039      STRB     R0,[R5, #+57]
   1602              }
   1603            }
   1604            HAL_UART_RxCpltCallback(huart);
   \                     ??UART_DMAReceiveCplt_0: (+1)
   \   00000034   0x0028             MOVS     R0,R5
   \   00000036   0x.... 0x....      BL       HAL_UART_RxCpltCallback
   1605          }
   \   0000003A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1606          
   1607          /**
   1608            * @brief DMA UART receive process half complete callback 
   1609            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
   1610            *               the configuration information for the specified DMA module.
   1611            * @retval None
   1612            */

   \                                 In section .text, align 4, keep-with-next
   1613          static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
   1614          {
   \                     UART_DMARxHalfCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1615            UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   1616          
   1617            HAL_UART_RxHalfCpltCallback(huart); 
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x.... 0x....      BL       HAL_UART_RxHalfCpltCallback
   1618          }
   \   0000000C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1619          
   1620          /**
   1621            * @brief  DMA UART communication error callback.
   1622            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
   1623            *               the configuration information for the specified DMA module.
   1624            * @retval None
   1625            */

   \                                 In section .text, align 4, keep-with-next
   1626          static void UART_DMAError(DMA_HandleTypeDef *hdma)   
   1627          {
   \                     UART_DMAError: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1628            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   1629            huart->RxXferCount = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x85E8             STRH     R0,[R5, #+46]
   1630            huart->TxXferCount = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x84E8             STRH     R0,[R5, #+38]
   1631            huart->State= HAL_UART_STATE_READY;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF885 0x0039      STRB     R0,[R5, #+57]
   1632            huart->ErrorCode |= HAL_UART_ERROR_DMA;
   \   00000014   0x6BE8             LDR      R0,[R5, #+60]
   \   00000016   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000001A   0x63E8             STR      R0,[R5, #+60]
   1633            HAL_UART_ErrorCallback(huart);
   \   0000001C   0x0028             MOVS     R0,R5
   \   0000001E   0x.... 0x....      BL       HAL_UART_ErrorCallback
   1634          }
   \   00000022   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1635          
   1636          /**
   1637            * @brief  This function handles UART Communication Timeout.
   1638            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1639            *                the configuration information for the specified UART module.
   1640            * @param  Flag: specifies the UART flag to check.
   1641            * @param  Status: The new Flag status (SET or RESET).
   1642            * @param  Timeout: Timeout duration
   1643            * @retval HAL status
   1644            */

   \                                 In section .text, align 2, keep-with-next
   1645          static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Timeout)
   1646          {
   \                     UART_WaitOnFlagUntilTimeout: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   1647            uint32_t tickstart = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   1648          
   1649            /* Get tick */ 
   1650            tickstart = HAL_GetTick();
   \   00000010   0x.... 0x....      BL       HAL_GetTick
   \   00000014   0x4680             MOV      R8,R0
   1651          
   1652            /* Wait until flag is set */
   1653            if(Status == RESET)
   \   00000016   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000018   0x2E00             CMP      R6,#+0
   \   0000001A   0xD12F             BNE.N    ??UART_WaitOnFlagUntilTimeout_0
   1654            {
   1655              while(__HAL_UART_GET_FLAG(huart, Flag) == RESET)
   \                     ??UART_WaitOnFlagUntilTimeout_1: (+1)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x4028             ANDS     R0,R5,R0
   \   00000022   0x42A8             CMP      R0,R5
   \   00000024   0xD05A             BEQ.N    ??UART_WaitOnFlagUntilTimeout_2
   1656              {
   1657                /* Check for the Timeout */
   1658                if(Timeout != HAL_MAX_DELAY)
   \   00000026   0xF117 0x0F01      CMN      R7,#+1
   \   0000002A   0xD0F7             BEQ.N    ??UART_WaitOnFlagUntilTimeout_1
   1659                {
   1660                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   0000002C   0x2F00             CMP      R7,#+0
   \   0000002E   0xD005             BEQ.N    ??UART_WaitOnFlagUntilTimeout_3
   \   00000030   0x.... 0x....      BL       HAL_GetTick
   \   00000034   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   00000038   0x4287             CMP      R7,R0
   \   0000003A   0xD2EF             BCS.N    ??UART_WaitOnFlagUntilTimeout_1
   1661                  {
   1662                    /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
   1663                    __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
   \                     ??UART_WaitOnFlagUntilTimeout_3: (+1)
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x68C0             LDR      R0,[R0, #+12]
   \   00000040   0xF030 0x0080      BICS     R0,R0,#0x80
   \   00000044   0x6821             LDR      R1,[R4, #+0]
   \   00000046   0x60C8             STR      R0,[R1, #+12]
   1664                    __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x68C0             LDR      R0,[R0, #+12]
   \   0000004C   0xF030 0x0020      BICS     R0,R0,#0x20
   \   00000050   0x6821             LDR      R1,[R4, #+0]
   \   00000052   0x60C8             STR      R0,[R1, #+12]
   1665                    __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x68C0             LDR      R0,[R0, #+12]
   \   00000058   0xF430 0x7080      BICS     R0,R0,#0x100
   \   0000005C   0x6821             LDR      R1,[R4, #+0]
   \   0000005E   0x60C8             STR      R0,[R1, #+12]
   1666                    __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x6940             LDR      R0,[R0, #+20]
   \   00000064   0x0840             LSRS     R0,R0,#+1
   \   00000066   0x0040             LSLS     R0,R0,#+1
   \   00000068   0x6821             LDR      R1,[R4, #+0]
   \   0000006A   0x6148             STR      R0,[R1, #+20]
   1667          
   1668                    huart->State= HAL_UART_STATE_READY;
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0xF884 0x0039      STRB     R0,[R4, #+57]
   1669          
   1670                    /* Process Unlocked */
   1671                    __HAL_UNLOCK(huart);
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xF884 0x0038      STRB     R0,[R4, #+56]
   1672          
   1673                    return HAL_TIMEOUT;
   \   00000078   0x2003             MOVS     R0,#+3
   \   0000007A   0xE030             B.N      ??UART_WaitOnFlagUntilTimeout_4
   1674                  }
   1675                }
   1676              }
   1677            }
   1678            else
   1679            {
   1680              while(__HAL_UART_GET_FLAG(huart, Flag) != RESET)
   \                     ??UART_WaitOnFlagUntilTimeout_0: (+1)
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x4028             ANDS     R0,R5,R0
   \   00000082   0x42A8             CMP      R0,R5
   \   00000084   0xD12A             BNE.N    ??UART_WaitOnFlagUntilTimeout_2
   1681              {
   1682                /* Check for the Timeout */
   1683                if(Timeout != HAL_MAX_DELAY)
   \   00000086   0xF117 0x0F01      CMN      R7,#+1
   \   0000008A   0xD0F7             BEQ.N    ??UART_WaitOnFlagUntilTimeout_0
   1684                {
   1685                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   0000008C   0x2F00             CMP      R7,#+0
   \   0000008E   0xD005             BEQ.N    ??UART_WaitOnFlagUntilTimeout_5
   \   00000090   0x.... 0x....      BL       HAL_GetTick
   \   00000094   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   00000098   0x4287             CMP      R7,R0
   \   0000009A   0xD2EF             BCS.N    ??UART_WaitOnFlagUntilTimeout_0
   1686                  {
   1687                    /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
   1688                    __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
   \                     ??UART_WaitOnFlagUntilTimeout_5: (+1)
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0x68C0             LDR      R0,[R0, #+12]
   \   000000A0   0xF030 0x0080      BICS     R0,R0,#0x80
   \   000000A4   0x6821             LDR      R1,[R4, #+0]
   \   000000A6   0x60C8             STR      R0,[R1, #+12]
   1689                    __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
   \   000000A8   0x6820             LDR      R0,[R4, #+0]
   \   000000AA   0x68C0             LDR      R0,[R0, #+12]
   \   000000AC   0xF030 0x0020      BICS     R0,R0,#0x20
   \   000000B0   0x6821             LDR      R1,[R4, #+0]
   \   000000B2   0x60C8             STR      R0,[R1, #+12]
   1690                    __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
   \   000000B4   0x6820             LDR      R0,[R4, #+0]
   \   000000B6   0x68C0             LDR      R0,[R0, #+12]
   \   000000B8   0xF430 0x7080      BICS     R0,R0,#0x100
   \   000000BC   0x6821             LDR      R1,[R4, #+0]
   \   000000BE   0x60C8             STR      R0,[R1, #+12]
   1691                    __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
   \   000000C0   0x6820             LDR      R0,[R4, #+0]
   \   000000C2   0x6940             LDR      R0,[R0, #+20]
   \   000000C4   0x0840             LSRS     R0,R0,#+1
   \   000000C6   0x0040             LSLS     R0,R0,#+1
   \   000000C8   0x6821             LDR      R1,[R4, #+0]
   \   000000CA   0x6148             STR      R0,[R1, #+20]
   1692          
   1693                    huart->State= HAL_UART_STATE_READY;
   \   000000CC   0x2001             MOVS     R0,#+1
   \   000000CE   0xF884 0x0039      STRB     R0,[R4, #+57]
   1694          
   1695                    /* Process Unlocked */
   1696                    __HAL_UNLOCK(huart);
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0xF884 0x0038      STRB     R0,[R4, #+56]
   1697          
   1698                    return HAL_TIMEOUT;
   \   000000D8   0x2003             MOVS     R0,#+3
   \   000000DA   0xE000             B.N      ??UART_WaitOnFlagUntilTimeout_4
   1699                  }
   1700                }
   1701              }
   1702            }
   1703            return HAL_OK;
   \                     ??UART_WaitOnFlagUntilTimeout_2: (+1)
   \   000000DC   0x2000             MOVS     R0,#+0
   \                     ??UART_WaitOnFlagUntilTimeout_4: (+1)
   \   000000DE   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1704          }
   1705          
   1706          /**
   1707            * @brief  Sends an amount of data in non blocking mode.
   1708            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1709            *                the configuration information for the specified UART module.
   1710            * @retval HAL status
   1711            */

   \                                 In section .text, align 2, keep-with-next
   1712          static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
   1713          {
   \                     UART_Transmit_IT: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0001             MOVS     R1,R0
   1714            uint16_t* tmp;
   1715            uint32_t tmp_state = 0;
   \   00000004   0x2300             MOVS     R3,#+0
   1716            
   1717            tmp_state = huart->State;
   \   00000006   0xF891 0x0039      LDRB     R0,[R1, #+57]
   \   0000000A   0x0003             MOVS     R3,R0
   1718            if((tmp_state == HAL_UART_STATE_BUSY_TX) || (tmp_state == HAL_UART_STATE_BUSY_TX_RX))
   \   0000000C   0x2B12             CMP      R3,#+18
   \   0000000E   0xD001             BEQ.N    ??UART_Transmit_IT_0
   \   00000010   0x2B32             CMP      R3,#+50
   \   00000012   0xD12F             BNE.N    ??UART_Transmit_IT_1
   1719            {
   1720              if(huart->Init.WordLength == UART_WORDLENGTH_9B)
   \                     ??UART_Transmit_IT_0: (+1)
   \   00000014   0x6888             LDR      R0,[R1, #+8]
   \   00000016   0xF5B0 0x5F80      CMP      R0,#+4096
   \   0000001A   0xD111             BNE.N    ??UART_Transmit_IT_2
   1721              {
   1722                tmp = (uint16_t*) huart->pTxBuffPtr;
   \   0000001C   0x6A08             LDR      R0,[R1, #+32]
   \   0000001E   0x0002             MOVS     R2,R0
   1723                huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
   \   00000020   0x8810             LDRH     R0,[R2, #+0]
   \   00000022   0x05C0             LSLS     R0,R0,#+23       ;; ZeroExtS R0,R0,#+23,#+23
   \   00000024   0x0DC0             LSRS     R0,R0,#+23
   \   00000026   0x680C             LDR      R4,[R1, #+0]
   \   00000028   0x6060             STR      R0,[R4, #+4]
   1724                if(huart->Init.Parity == UART_PARITY_NONE)
   \   0000002A   0x6908             LDR      R0,[R1, #+16]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD103             BNE.N    ??UART_Transmit_IT_3
   1725                {
   1726                  huart->pTxBuffPtr += 2;
   \   00000030   0x6A08             LDR      R0,[R1, #+32]
   \   00000032   0x1C80             ADDS     R0,R0,#+2
   \   00000034   0x6208             STR      R0,[R1, #+32]
   \   00000036   0xE009             B.N      ??UART_Transmit_IT_4
   1727                }
   1728                else
   1729                {
   1730                  huart->pTxBuffPtr += 1;
   \                     ??UART_Transmit_IT_3: (+1)
   \   00000038   0x6A08             LDR      R0,[R1, #+32]
   \   0000003A   0x1C40             ADDS     R0,R0,#+1
   \   0000003C   0x6208             STR      R0,[R1, #+32]
   \   0000003E   0xE005             B.N      ??UART_Transmit_IT_4
   1731                }
   1732              } 
   1733              else
   1734              {
   1735                huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
   \                     ??UART_Transmit_IT_2: (+1)
   \   00000040   0x6A08             LDR      R0,[R1, #+32]
   \   00000042   0x1C44             ADDS     R4,R0,#+1
   \   00000044   0x620C             STR      R4,[R1, #+32]
   \   00000046   0x7800             LDRB     R0,[R0, #+0]
   \   00000048   0x680C             LDR      R4,[R1, #+0]
   \   0000004A   0x6060             STR      R0,[R4, #+4]
   1736              }
   1737          
   1738              if(--huart->TxXferCount == 0)
   \                     ??UART_Transmit_IT_4: (+1)
   \   0000004C   0x8CC8             LDRH     R0,[R1, #+38]
   \   0000004E   0x1E40             SUBS     R0,R0,#+1
   \   00000050   0x84C8             STRH     R0,[R1, #+38]
   \   00000052   0x8CC8             LDRH     R0,[R1, #+38]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD10B             BNE.N    ??UART_Transmit_IT_5
   1739              {
   1740                /* Disable the UART Transmit Complete Interrupt */
   1741                __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
   \   00000058   0x6808             LDR      R0,[R1, #+0]
   \   0000005A   0x68C0             LDR      R0,[R0, #+12]
   \   0000005C   0xF030 0x0080      BICS     R0,R0,#0x80
   \   00000060   0x680C             LDR      R4,[R1, #+0]
   \   00000062   0x60E0             STR      R0,[R4, #+12]
   1742          
   1743                /* Enable the UART Transmit Complete Interrupt */    
   1744                __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
   \   00000064   0x6808             LDR      R0,[R1, #+0]
   \   00000066   0x68C0             LDR      R0,[R0, #+12]
   \   00000068   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000006C   0x680C             LDR      R4,[R1, #+0]
   \   0000006E   0x60E0             STR      R0,[R4, #+12]
   1745              }
   1746              return HAL_OK;
   \                     ??UART_Transmit_IT_5: (+1)
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xE000             B.N      ??UART_Transmit_IT_6
   1747            }
   1748            else
   1749            {
   1750              return HAL_BUSY;
   \                     ??UART_Transmit_IT_1: (+1)
   \   00000074   0x2002             MOVS     R0,#+2
   \                     ??UART_Transmit_IT_6: (+1)
   \   00000076   0xBC10             POP      {R4}
   \   00000078   0x4770             BX       LR               ;; return
   1751            }
   1752          }
   1753          
   1754          
   1755          /**
   1756            * @brief  Wraps up transmission in non blocking mode.
   1757            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
   1758            *                the configuration information for the specified UART module.
   1759            * @retval HAL status
   1760            */

   \                                 In section .text, align 2, keep-with-next
   1761          static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
   1762          {
   \                     UART_EndTransmit_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1763            /* Disable the UART Transmit Complete Interrupt */    
   1764            __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x68C0             LDR      R0,[R0, #+12]
   \   00000008   0xF030 0x0040      BICS     R0,R0,#0x40
   \   0000000C   0x6821             LDR      R1,[R4, #+0]
   \   0000000E   0x60C8             STR      R0,[R1, #+12]
   1765            
   1766            /* Check if a receive process is ongoing or not */
   1767            if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   \   00000010   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000014   0x2832             CMP      R0,#+50
   \   00000016   0xD103             BNE.N    ??UART_EndTransmit_IT_0
   1768            {
   1769              huart->State = HAL_UART_STATE_BUSY_RX;
   \   00000018   0x2022             MOVS     R0,#+34
   \   0000001A   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   0000001E   0xE008             B.N      ??UART_EndTransmit_IT_1
   1770            }
   1771            else
   1772            {
   1773              /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
   1774              __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
   \                     ??UART_EndTransmit_IT_0: (+1)
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x6940             LDR      R0,[R0, #+20]
   \   00000024   0x0840             LSRS     R0,R0,#+1
   \   00000026   0x0040             LSLS     R0,R0,#+1
   \   00000028   0x6821             LDR      R1,[R4, #+0]
   \   0000002A   0x6148             STR      R0,[R1, #+20]
   1775          
   1776              huart->State = HAL_UART_STATE_READY;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF884 0x0039      STRB     R0,[R4, #+57]
   1777            }
   1778            
   1779            HAL_UART_TxCpltCallback(huart);
   \                     ??UART_EndTransmit_IT_1: (+1)
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       HAL_UART_TxCpltCallback
   1780            
   1781            return HAL_OK;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
   1782          }
   1783          
   1784          /**
   1785            * @brief  Receives an amount of data in non blocking mode 
   1786            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1787            *                the configuration information for the specified UART module.
   1788            * @retval HAL status
   1789            */

   \                                 In section .text, align 2, keep-with-next
   1790          static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
   1791          {
   \                     UART_Receive_IT: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1792            uint16_t* tmp;
   1793            uint32_t tmp_state = 0;
   \   00000004   0x2600             MOVS     R6,#+0
   1794            
   1795            tmp_state = huart->State; 
   \   00000006   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000000A   0x0006             MOVS     R6,R0
   1796            if((tmp_state == HAL_UART_STATE_BUSY_RX) || (tmp_state == HAL_UART_STATE_BUSY_TX_RX))
   \   0000000C   0x2E22             CMP      R6,#+34
   \   0000000E   0xD001             BEQ.N    ??UART_Receive_IT_0
   \   00000010   0x2E32             CMP      R6,#+50
   \   00000012   0xD156             BNE.N    ??UART_Receive_IT_1
   1797            {
   1798              if(huart->Init.WordLength == UART_WORDLENGTH_9B)
   \                     ??UART_Receive_IT_0: (+1)
   \   00000014   0x68A0             LDR      R0,[R4, #+8]
   \   00000016   0xF5B0 0x5F80      CMP      R0,#+4096
   \   0000001A   0xD116             BNE.N    ??UART_Receive_IT_2
   1799              {
   1800                tmp = (uint16_t*) huart->pRxBuffPtr;
   \   0000001C   0x6AA0             LDR      R0,[R4, #+40]
   \   0000001E   0x0005             MOVS     R5,R0
   1801                if(huart->Init.Parity == UART_PARITY_NONE)
   \   00000020   0x6920             LDR      R0,[R4, #+16]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD108             BNE.N    ??UART_Receive_IT_3
   1802                {
   1803                  *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6840             LDR      R0,[R0, #+4]
   \   0000002A   0x05C0             LSLS     R0,R0,#+23       ;; ZeroExtS R0,R0,#+23,#+23
   \   0000002C   0x0DC0             LSRS     R0,R0,#+23
   \   0000002E   0x8028             STRH     R0,[R5, #+0]
   1804                  huart->pRxBuffPtr += 2;
   \   00000030   0x6AA0             LDR      R0,[R4, #+40]
   \   00000032   0x1C80             ADDS     R0,R0,#+2
   \   00000034   0x62A0             STR      R0,[R4, #+40]
   \   00000036   0xE01A             B.N      ??UART_Receive_IT_4
   1805                }
   1806                else
   1807                {
   1808                  *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
   \                     ??UART_Receive_IT_3: (+1)
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x6840             LDR      R0,[R0, #+4]
   \   0000003C   0xF000 0x00FF      AND      R0,R0,#0xFF
   \   00000040   0x8028             STRH     R0,[R5, #+0]
   1809                  huart->pRxBuffPtr += 1;
   \   00000042   0x6AA0             LDR      R0,[R4, #+40]
   \   00000044   0x1C40             ADDS     R0,R0,#+1
   \   00000046   0x62A0             STR      R0,[R4, #+40]
   \   00000048   0xE011             B.N      ??UART_Receive_IT_4
   1810                }
   1811              }
   1812              else
   1813              {
   1814                if(huart->Init.Parity == UART_PARITY_NONE)
   \                     ??UART_Receive_IT_2: (+1)
   \   0000004A   0x6920             LDR      R0,[R4, #+16]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD106             BNE.N    ??UART_Receive_IT_5
   1815                {
   1816                  *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
   \   00000050   0x6AA0             LDR      R0,[R4, #+40]
   \   00000052   0x1C41             ADDS     R1,R0,#+1
   \   00000054   0x62A1             STR      R1,[R4, #+40]
   \   00000056   0x6821             LDR      R1,[R4, #+0]
   \   00000058   0x6849             LDR      R1,[R1, #+4]
   \   0000005A   0x7001             STRB     R1,[R0, #+0]
   \   0000005C   0xE007             B.N      ??UART_Receive_IT_4
   1817                }
   1818                else
   1819                {
   1820                  *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
   \                     ??UART_Receive_IT_5: (+1)
   \   0000005E   0x6AA0             LDR      R0,[R4, #+40]
   \   00000060   0x1C41             ADDS     R1,R0,#+1
   \   00000062   0x62A1             STR      R1,[R4, #+40]
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x6849             LDR      R1,[R1, #+4]
   \   00000068   0xF011 0x017F      ANDS     R1,R1,#0x7F
   \   0000006C   0x7001             STRB     R1,[R0, #+0]
   1821                }
   1822              }
   1823          
   1824              if(--huart->RxXferCount == 0)
   \                     ??UART_Receive_IT_4: (+1)
   \   0000006E   0x8DE0             LDRH     R0,[R4, #+46]
   \   00000070   0x1E40             SUBS     R0,R0,#+1
   \   00000072   0x85E0             STRH     R0,[R4, #+46]
   \   00000074   0x8DE0             LDRH     R0,[R4, #+46]
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD121             BNE.N    ??UART_Receive_IT_6
   1825              {
   1826                __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x68C0             LDR      R0,[R0, #+12]
   \   0000007E   0xF030 0x0020      BICS     R0,R0,#0x20
   \   00000082   0x6821             LDR      R1,[R4, #+0]
   \   00000084   0x60C8             STR      R0,[R1, #+12]
   1827          
   1828                /* Check if a transmit process is ongoing or not */
   1829                if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   \   00000086   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000008A   0x2832             CMP      R0,#+50
   \   0000008C   0xD103             BNE.N    ??UART_Receive_IT_7
   1830                {
   1831                  huart->State = HAL_UART_STATE_BUSY_TX;
   \   0000008E   0x2012             MOVS     R0,#+18
   \   00000090   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000094   0xE00E             B.N      ??UART_Receive_IT_8
   1832                }
   1833                else
   1834                {
   1835                  /* Disable the UART Parity Error Interrupt */
   1836                  __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
   \                     ??UART_Receive_IT_7: (+1)
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0x68C0             LDR      R0,[R0, #+12]
   \   0000009A   0xF430 0x7080      BICS     R0,R0,#0x100
   \   0000009E   0x6821             LDR      R1,[R4, #+0]
   \   000000A0   0x60C8             STR      R0,[R1, #+12]
   1837          
   1838                  /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
   1839                  __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x6940             LDR      R0,[R0, #+20]
   \   000000A6   0x0840             LSRS     R0,R0,#+1
   \   000000A8   0x0040             LSLS     R0,R0,#+1
   \   000000AA   0x6821             LDR      R1,[R4, #+0]
   \   000000AC   0x6148             STR      R0,[R1, #+20]
   1840          
   1841                  huart->State = HAL_UART_STATE_READY;
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0xF884 0x0039      STRB     R0,[R4, #+57]
   1842                }
   1843                HAL_UART_RxCpltCallback(huart);
   \                     ??UART_Receive_IT_8: (+1)
   \   000000B4   0x0020             MOVS     R0,R4
   \   000000B6   0x.... 0x....      BL       HAL_UART_RxCpltCallback
   1844          
   1845                return HAL_OK;
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0xE002             B.N      ??UART_Receive_IT_9
   1846              }
   1847              return HAL_OK;
   \                     ??UART_Receive_IT_6: (+1)
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0xE000             B.N      ??UART_Receive_IT_9
   1848            }
   1849            else
   1850            {
   1851              return HAL_BUSY; 
   \                     ??UART_Receive_IT_1: (+1)
   \   000000C2   0x2002             MOVS     R0,#+2
   \                     ??UART_Receive_IT_9: (+1)
   \   000000C4   0xBD70             POP      {R4-R6,PC}       ;; return
   1852            }
   1853          }
   1854          
   1855          /**
   1856            * @brief  Configures the UART peripheral. 
   1857            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1858            *                the configuration information for the specified UART module.
   1859            * @retval None
   1860            */

   \                                 In section .text, align 2, keep-with-next
   1861          static void UART_SetConfig(UART_HandleTypeDef *huart)
   1862          {
   \                     UART_SetConfig: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1863            uint32_t tmpreg = 0x00;
   \   00000004   0x2500             MOVS     R5,#+0
   1864            
   1865            /* Check the parameters */
   1866            assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));  
   1867            assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
   1868            assert_param(IS_UART_PARITY(huart->Init.Parity));
   1869            assert_param(IS_UART_MODE(huart->Init.Mode));
   1870          
   1871            /*------- UART-associated USART registers setting : CR2 Configuration ------*/
   1872            /* Configure the UART Stop Bits: Set STOP[13:12] bits according 
   1873             * to huart->Init.StopBits value */
   1874            MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x6900             LDR      R0,[R0, #+16]
   \   0000000A   0xF430 0x5040      BICS     R0,R0,#0x3000
   \   0000000E   0x68E1             LDR      R1,[R4, #+12]
   \   00000010   0x4308             ORRS     R0,R1,R0
   \   00000012   0x6821             LDR      R1,[R4, #+0]
   \   00000014   0x6108             STR      R0,[R1, #+16]
   1875          
   1876            /*------- UART-associated USART registers setting : CR1 Configuration ------*/
   1877            /* Configure the UART Word Length, Parity and mode: 
   1878               Set the M bits according to huart->Init.WordLength value 
   1879               Set PCE and PS bits according to huart->Init.Parity value
   1880               Set TE and RE bits according to huart->Init.Mode value
   1881               Set OVER8 bit according to huart->Init.OverSampling value */
   1882            tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
   \   00000016   0x68A0             LDR      R0,[R4, #+8]
   \   00000018   0x6921             LDR      R1,[R4, #+16]
   \   0000001A   0x4308             ORRS     R0,R1,R0
   \   0000001C   0x6961             LDR      R1,[R4, #+20]
   \   0000001E   0x4308             ORRS     R0,R1,R0
   \   00000020   0x69E1             LDR      R1,[R4, #+28]
   \   00000022   0x4308             ORRS     R0,R1,R0
   \   00000024   0x0005             MOVS     R5,R0
   1883            MODIFY_REG(huart->Instance->CR1, 
   1884                       (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8), 
   1885                       tmpreg);
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x68C0             LDR      R0,[R0, #+12]
   \   0000002A   0x....             LDR.N    R1,??DataTable0  ;; 0xffff69f3
   \   0000002C   0x4008             ANDS     R0,R1,R0
   \   0000002E   0x4328             ORRS     R0,R5,R0
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x60C8             STR      R0,[R1, #+12]
   1886            
   1887            /*------- UART-associated USART registers setting : CR3 Configuration ------*/
   1888            /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
   1889            MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x6940             LDR      R0,[R0, #+20]
   \   00000038   0xF430 0x7040      BICS     R0,R0,#0x300
   \   0000003C   0x69A1             LDR      R1,[R4, #+24]
   \   0000003E   0x4308             ORRS     R0,R1,R0
   \   00000040   0x6821             LDR      R1,[R4, #+0]
   \   00000042   0x6148             STR      R0,[R1, #+20]
   1890            
   1891            /* Check the Over Sampling */
   1892            if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
   \   00000044   0x69E0             LDR      R0,[R4, #+28]
   \   00000046   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000004A   0xD165             BNE.N    ??UART_SetConfig_0
   1893            {
   1894              /*------- UART-associated USART registers setting : BRR Configuration ------*/
   1895              if((huart->Instance == USART1))
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x....             LDR.N    R1,??DataTable0_1  ;; 0x40013800
   \   00000050   0x4288             CMP      R0,R1
   \   00000052   0xD130             BNE.N    ??UART_SetConfig_1
   1896              {
   1897                huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
   \   00000054   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   00000058   0x0007             MOVS     R7,R0
   \   0000005A   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   0000005E   0x0006             MOVS     R6,R0
   \   00000060   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   00000064   0x2119             MOVS     R1,#+25
   \   00000066   0xFB01 0xF107      MUL      R1,R1,R7
   \   0000006A   0x6862             LDR      R2,[R4, #+4]
   \   0000006C   0x0052             LSLS     R2,R2,#+1
   \   0000006E   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000072   0x2264             MOVS     R2,#+100
   \   00000074   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000078   0x2219             MOVS     R2,#+25
   \   0000007A   0xFB02 0xF206      MUL      R2,R2,R6
   \   0000007E   0x6863             LDR      R3,[R4, #+4]
   \   00000080   0x005B             LSLS     R3,R3,#+1
   \   00000082   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   00000086   0x2319             MOVS     R3,#+25
   \   00000088   0x4358             MULS     R0,R3,R0
   \   0000008A   0x6863             LDR      R3,[R4, #+4]
   \   0000008C   0x005B             LSLS     R3,R3,#+1
   \   0000008E   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   00000092   0x2364             MOVS     R3,#+100
   \   00000094   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   00000098   0x2364             MOVS     R3,#+100
   \   0000009A   0xFB03 0x2010      MLS      R0,R3,R0,R2
   \   0000009E   0x0100             LSLS     R0,R0,#+4
   \   000000A0   0x3032             ADDS     R0,R0,#+50
   \   000000A2   0x2264             MOVS     R2,#+100
   \   000000A4   0xFBB0 0xF0F2      UDIV     R0,R0,R2
   \   000000A8   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   000000AC   0xEA50 0x1001      ORRS     R0,R0,R1, LSL #+4
   \   000000B0   0x6821             LDR      R1,[R4, #+0]
   \   000000B2   0x6088             STR      R0,[R1, #+8]
   \   000000B4   0xE095             B.N      ??UART_SetConfig_2
   1898              }
   1899              else
   1900              {
   1901                huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
   \                     ??UART_SetConfig_1: (+1)
   \   000000B6   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   000000BA   0x0007             MOVS     R7,R0
   \   000000BC   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   000000C0   0x0006             MOVS     R6,R0
   \   000000C2   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   000000C6   0x2119             MOVS     R1,#+25
   \   000000C8   0xFB01 0xF107      MUL      R1,R1,R7
   \   000000CC   0x6862             LDR      R2,[R4, #+4]
   \   000000CE   0x0052             LSLS     R2,R2,#+1
   \   000000D0   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   000000D4   0x2264             MOVS     R2,#+100
   \   000000D6   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   000000DA   0x2219             MOVS     R2,#+25
   \   000000DC   0xFB02 0xF206      MUL      R2,R2,R6
   \   000000E0   0x6863             LDR      R3,[R4, #+4]
   \   000000E2   0x005B             LSLS     R3,R3,#+1
   \   000000E4   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   000000E8   0x2319             MOVS     R3,#+25
   \   000000EA   0x4358             MULS     R0,R3,R0
   \   000000EC   0x6863             LDR      R3,[R4, #+4]
   \   000000EE   0x005B             LSLS     R3,R3,#+1
   \   000000F0   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   000000F4   0x2364             MOVS     R3,#+100
   \   000000F6   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   000000FA   0x2364             MOVS     R3,#+100
   \   000000FC   0xFB03 0x2010      MLS      R0,R3,R0,R2
   \   00000100   0x0100             LSLS     R0,R0,#+4
   \   00000102   0x3032             ADDS     R0,R0,#+50
   \   00000104   0x2264             MOVS     R2,#+100
   \   00000106   0xFBB0 0xF0F2      UDIV     R0,R0,R2
   \   0000010A   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   0000010E   0xEA50 0x1001      ORRS     R0,R0,R1, LSL #+4
   \   00000112   0x6821             LDR      R1,[R4, #+0]
   \   00000114   0x6088             STR      R0,[R1, #+8]
   \   00000116   0xE064             B.N      ??UART_SetConfig_2
   1902              }
   1903            }
   1904            else
   1905            {
   1906              /*------- UART-associated USART registers setting : BRR Configuration ------*/
   1907              if((huart->Instance == USART1))
   \                     ??UART_SetConfig_0: (+1)
   \   00000118   0x6820             LDR      R0,[R4, #+0]
   \   0000011A   0x....             LDR.N    R1,??DataTable0_1  ;; 0x40013800
   \   0000011C   0x4288             CMP      R0,R1
   \   0000011E   0xD130             BNE.N    ??UART_SetConfig_3
   1908              {
   1909                huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
   \   00000120   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   00000124   0x0007             MOVS     R7,R0
   \   00000126   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   0000012A   0x0006             MOVS     R6,R0
   \   0000012C   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   00000130   0x2119             MOVS     R1,#+25
   \   00000132   0xFB01 0xF107      MUL      R1,R1,R7
   \   00000136   0x6862             LDR      R2,[R4, #+4]
   \   00000138   0x0092             LSLS     R2,R2,#+2
   \   0000013A   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   0000013E   0x2264             MOVS     R2,#+100
   \   00000140   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000144   0x2219             MOVS     R2,#+25
   \   00000146   0xFB02 0xF206      MUL      R2,R2,R6
   \   0000014A   0x6863             LDR      R3,[R4, #+4]
   \   0000014C   0x009B             LSLS     R3,R3,#+2
   \   0000014E   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   00000152   0x2319             MOVS     R3,#+25
   \   00000154   0x4358             MULS     R0,R3,R0
   \   00000156   0x6863             LDR      R3,[R4, #+4]
   \   00000158   0x009B             LSLS     R3,R3,#+2
   \   0000015A   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   0000015E   0x2364             MOVS     R3,#+100
   \   00000160   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   00000164   0x2364             MOVS     R3,#+100
   \   00000166   0xFB03 0x2010      MLS      R0,R3,R0,R2
   \   0000016A   0x0100             LSLS     R0,R0,#+4
   \   0000016C   0x3032             ADDS     R0,R0,#+50
   \   0000016E   0x2264             MOVS     R2,#+100
   \   00000170   0xFBB0 0xF0F2      UDIV     R0,R0,R2
   \   00000174   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000178   0xEA50 0x1001      ORRS     R0,R0,R1, LSL #+4
   \   0000017C   0x6821             LDR      R1,[R4, #+0]
   \   0000017E   0x6088             STR      R0,[R1, #+8]
   \   00000180   0xE02F             B.N      ??UART_SetConfig_2
   1910              }
   1911              else
   1912              {
   1913                huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
   \                     ??UART_SetConfig_3: (+1)
   \   00000182   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   00000186   0x0007             MOVS     R7,R0
   \   00000188   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   0000018C   0x0006             MOVS     R6,R0
   \   0000018E   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   00000192   0x2119             MOVS     R1,#+25
   \   00000194   0xFB01 0xF107      MUL      R1,R1,R7
   \   00000198   0x6862             LDR      R2,[R4, #+4]
   \   0000019A   0x0092             LSLS     R2,R2,#+2
   \   0000019C   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   000001A0   0x2264             MOVS     R2,#+100
   \   000001A2   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   000001A6   0x2219             MOVS     R2,#+25
   \   000001A8   0xFB02 0xF206      MUL      R2,R2,R6
   \   000001AC   0x6863             LDR      R3,[R4, #+4]
   \   000001AE   0x009B             LSLS     R3,R3,#+2
   \   000001B0   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   000001B4   0x2319             MOVS     R3,#+25
   \   000001B6   0x4358             MULS     R0,R3,R0
   \   000001B8   0x6863             LDR      R3,[R4, #+4]
   \   000001BA   0x009B             LSLS     R3,R3,#+2
   \   000001BC   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   000001C0   0x2364             MOVS     R3,#+100
   \   000001C2   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   000001C6   0x2364             MOVS     R3,#+100
   \   000001C8   0xFB03 0x2010      MLS      R0,R3,R0,R2
   \   000001CC   0x0100             LSLS     R0,R0,#+4
   \   000001CE   0x3032             ADDS     R0,R0,#+50
   \   000001D0   0x2264             MOVS     R2,#+100
   \   000001D2   0xFBB0 0xF0F2      UDIV     R0,R0,R2
   \   000001D6   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   000001DA   0xEA50 0x1001      ORRS     R0,R0,R1, LSL #+4
   \   000001DE   0x6821             LDR      R1,[R4, #+0]
   \   000001E0   0x6088             STR      R0,[R1, #+8]
   1914              }
   1915            }
   1916          }
   \                     ??UART_SetConfig_2: (+1)
   \   000001E2   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0xFFFF69F3         DC32     0xffff69f3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0x40013800         DC32     0x40013800
   1917          /**
   1918            * @}
   1919            */
   1920          
   1921          #endif /* HAL_UART_MODULE_ENABLED */
   1922          /**
   1923            * @}
   1924            */
   1925          
   1926          /**
   1927            * @}
   1928            */
   1929          
   1930          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_HalfDuplex_EnableReceiver
       0   HAL_HalfDuplex_EnableTransmitter
       8   HAL_HalfDuplex_Init
         8   -> HAL_UART_MspInit
         8   -> UART_SetConfig
      16   HAL_LIN_Init
        16   -> HAL_UART_MspInit
        16   -> UART_SetConfig
       0   HAL_LIN_SendBreak
       0   HAL_MultiProcessor_EnterMuteMode
       0   HAL_MultiProcessor_ExitMuteMode
      16   HAL_MultiProcessor_Init
        16   -> HAL_UART_MspInit
        16   -> UART_SetConfig
       0   HAL_UART_DMAPause
       4   HAL_UART_DMAResume
       8   HAL_UART_DMAStop
         8   -> HAL_DMA_Abort
       8   HAL_UART_DeInit
         8   -> HAL_UART_MspDeInit
       0   HAL_UART_ErrorCallback
       0   HAL_UART_GetError
       0   HAL_UART_GetState
      24   HAL_UART_IRQHandler
        24   -> HAL_UART_ErrorCallback
        24   -> UART_EndTransmit_IT
        24   -> UART_Receive_IT
        24   -> UART_Transmit_IT
       8   HAL_UART_Init
         8   -> HAL_UART_MspInit
         8   -> UART_SetConfig
       0   HAL_UART_MspDeInit
       0   HAL_UART_MspInit
      32   HAL_UART_Receive
        32   -> UART_WaitOnFlagUntilTimeout
      24   HAL_UART_Receive_DMA
        24   -> HAL_DMA_Start_IT
       8   HAL_UART_Receive_IT
       0   HAL_UART_RxCpltCallback
       0   HAL_UART_RxHalfCpltCallback
      32   HAL_UART_Transmit
        32   -> UART_WaitOnFlagUntilTimeout
      24   HAL_UART_Transmit_DMA
        24   -> HAL_DMA_Start_IT
       8   HAL_UART_Transmit_IT
       0   HAL_UART_TxCpltCallback
       0   HAL_UART_TxHalfCpltCallback
      16   UART_DMAError
        16   -> HAL_UART_ErrorCallback
      16   UART_DMAReceiveCplt
        16   -> HAL_UART_RxCpltCallback
      16   UART_DMARxHalfCplt
        16   -> HAL_UART_RxHalfCpltCallback
      16   UART_DMATransmitCplt
        16   -> HAL_UART_TxCpltCallback
      16   UART_DMATxHalfCplt
        16   -> HAL_UART_TxHalfCpltCallback
       8   UART_EndTransmit_IT
         8   -> HAL_UART_TxCpltCallback
      16   UART_Receive_IT
        16   -> HAL_UART_RxCpltCallback
      24   UART_SetConfig
        24   -> HAL_RCC_GetPCLK1Freq
        24   -> HAL_RCC_GetPCLK2Freq
       4   UART_Transmit_IT
      24   UART_WaitOnFlagUntilTimeout
        24   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
      58  HAL_HalfDuplex_EnableReceiver
      58  HAL_HalfDuplex_EnableTransmitter
     118  HAL_HalfDuplex_Init
     134  HAL_LIN_Init
      54  HAL_LIN_SendBreak
      54  HAL_MultiProcessor_EnterMuteMode
      54  HAL_MultiProcessor_ExitMuteMode
     140  HAL_MultiProcessor_Init
     106  HAL_UART_DMAPause
     138  HAL_UART_DMAResume
      50  HAL_UART_DMAStop
      74  HAL_UART_DeInit
       2  HAL_UART_ErrorCallback
       4  HAL_UART_GetError
       6  HAL_UART_GetState
     324  HAL_UART_IRQHandler
     112  HAL_UART_Init
       2  HAL_UART_MspDeInit
       2  HAL_UART_MspInit
     264  HAL_UART_Receive
     158  HAL_UART_Receive_DMA
     136  HAL_UART_Receive_IT
       2  HAL_UART_RxCpltCallback
       2  HAL_UART_RxHalfCpltCallback
     252  HAL_UART_Transmit
     168  HAL_UART_Transmit_DMA
     124  HAL_UART_Transmit_IT
       2  HAL_UART_TxCpltCallback
       2  HAL_UART_TxHalfCpltCallback
      36  UART_DMAError
      60  UART_DMAReceiveCplt
      14  UART_DMARxHalfCplt
      52  UART_DMATransmitCplt
      14  UART_DMATxHalfCplt
      60  UART_EndTransmit_IT
     198  UART_Receive_IT
     484  UART_SetConfig
     122  UART_Transmit_IT
     226  UART_WaitOnFlagUntilTimeout

 
 3 874 bytes in section .text
 
 3 860 bytes of CODE memory (+ 14 bytes shared)

Errors: none
Warnings: none
