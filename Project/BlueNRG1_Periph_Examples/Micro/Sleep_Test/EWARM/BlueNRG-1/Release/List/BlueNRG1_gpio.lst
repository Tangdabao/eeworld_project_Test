###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       29/Nov/2017  10:11:18
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Library\BlueNRG1_Periph_Driver\src\BlueNRG1_gpio.c
#    Command line =  
#        "D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Library\BlueNRG1_Periph_Driver\src\BlueNRG1_gpio.c" -D
#        HS_SPEED_XTAL=HS_SPEED_XTAL_16MHZ -D
#        LS_SOURCE=LS_SOURCE_EXTERNAL_32KHZ -D SMPS_INDUCTOR=SMPS_INDUCTOR_10uH
#        --preprocess=cl "D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2
#        DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\Release\List"
#        -lCN "D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\Release\List"
#        -lb "D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\Release\List"
#        --diag_suppress Pe1665 -o "D:\Program Files
#        (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\Release\Obj"
#        --debug --endian=little --cpu=Cortex-M0 --diag_warning Pe1665
#        --diag_suppress Pe1665 -e --fpu=None --dlib_config
#        D:\Software\IAR_BlueNRG\arm\INC\c\DLib_Config_Normal.h -I "D:\Program
#        Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\..\..\"
#        -I "D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\..\..\..\..\..\..\Library\BlueNRG1_Periph_Driver\inc\"
#        -I "D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\..\..\..\..\..\..\Library\CMSIS\Device\ST\BlueNRG1\Include\"
#        -I "D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\..\..\..\..\..\..\Library\SDK_Eval_BlueNRG1\inc\"
#        -I "D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\..\..\..\..\..\..\Library\CMSIS\Include\"
#        -I "D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\..\..\..\..\..\..\Library\hal\inc\"
#        -I "D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\..\..\..\..\..\..\Library\Bluetooth_LE\inc\"
#        -Ohz
#    Locale       =  Chinese (Simplified)_China.936
#    List file    =  
#        D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\Release\List\BlueNRG1_gpio.lst
#    Object file  =  
#        D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK
#        2.5.0\Project\BlueNRG1_Periph_Examples\Micro\Sleep_Test\EWARM\BlueNRG-1\Release\Obj\BlueNRG1_gpio.o
#
###############################################################################

D:\Program Files (x86)\STMicroelectronics\BlueNRG-1_2 DK 2.5.0\Library\BlueNRG1_Periph_Driver\src\BlueNRG1_gpio.c
      1          /**
      2          ******************************************************************************
      3          * @file    BlueNRG1_gpio.c
      4          * @author  VMA Application Team
      5          * @version V2.2.0
      6          * @date    31-January-2017
      7          * @brief   This file provides all the GPIO firmware functions.
      8          ******************************************************************************
      9          * @attention
     10          *
     11          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13          * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14          * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15          * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16          * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17          *
     18          * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
     19          ******************************************************************************
     20          */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "BlueNRG1_gpio.h"
     24          
     25          /** @addtogroup BLUENRG1_Peripheral_Driver BLUENRG1 Peripheral Driver
     26          * @{
     27          */
     28          
     29          /** @addtogroup GPIO_Peripheral  GPIO Peripheral
     30          * @{
     31          */ 
     32          
     33          /** @defgroup GPIO_Private_TypesDefinitions Private Type Definitions
     34          * @{
     35          */
     36          
     37          /**
     38          * @}
     39          */
     40          
     41          /** @defgroup GPIO_Private_Defines Private Defines
     42          * @{
     43          */
     44          
     45          /**
     46          * @}
     47          */
     48          
     49          /** @defgroup GPIO_Private_Macros Private Macros
     50          * @{
     51          */
     52          
     53          /**
     54          * @}
     55          */
     56          
     57          /** @defgroup GPIO_Private_Variables Private Variables
     58          * @{
     59          */
     60          
     61          /**
     62          * @}
     63          */
     64          
     65          /** @defgroup GPIO_Private_FunctionPrototypes Private Function Prototypes
     66          * @{
     67          */
     68          
     69          /**
     70          * @}
     71          */
     72          
     73          /** @defgroup GPIO_Private_Functions Private Functions
     74          * @{
     75          */
     76          
     77          
     78          
     79          /**
     80          * @}
     81          */
     82          
     83          /** @defgroup GPIO_Public_Functions Public Functions
     84          * @{
     85          */
     86          
     87          /**
     88          * @brief  Deinitializes the GPIO peripheral registers to their default reset values.
     89          * @param  None
     90          * @retval None
     91          */

   \                                 In section .text, align 2, keep-with-next
     92          void GPIO_DeInit(void)
     93          {
     94            /* Set all GPIO registers to default/reset configuration */
     95            GPIO->OEN   = 0x00000000;
   \                     GPIO_DeInit: (+1)
   \   00000000   0x....             LDR      R0,??DataTable7  ;; 0x40000004
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x6001             STR      R1,[R0, #+0]
     96            GPIO->PE    = 0x03FFFFFF;
   \   00000006   0x....             LDR      R2,??DataTable7_1  ;; 0x3ffffff
   \   00000008   0x6042             STR      R2,[R0, #+4]
     97            GPIO->DS    = 0x00000000;
   \   0000000A   0x6081             STR      R1,[R0, #+8]
     98            GPIO->IS    = 0x00000000;
   \   0000000C   0x60C1             STR      R1,[R0, #+12]
     99            GPIO->IBE   = 0x00000000;
   \   0000000E   0x6101             STR      R1,[R0, #+16]
    100            GPIO->IEV   = 0x00000000;
   \   00000010   0x6141             STR      R1,[R0, #+20]
    101            GPIO->IE    = 0x00000000;
   \   00000012   0x6181             STR      R1,[R0, #+24]
    102            GPIO->IC    = 0xFFFFFFFF;
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0x43D2             MVNS     R2,R2            ;; #-1
   \   00000018   0x6242             STR      R2,[R0, #+36]
    103            GPIO->MODE0 = 0x00000000;
   \   0000001A   0x6281             STR      R1,[R0, #+40]
    104            GPIO->MODE1 = 0x00000110;
   \   0000001C   0x2288             MOVS     R2,#+136
   \   0000001E   0x0052             LSLS     R2,R2,#+1        ;; #+272
   \   00000020   0x62C2             STR      R2,[R0, #+44]
    105            GPIO->MFTX  = 0x00000000;
   \   00000022   0x6401             STR      R1,[R0, #+64]
    106          }
   \   00000024   0x4770             BX       LR               ;; return
    107          
    108          
    109          /**
    110          * @brief  Initializes the GPIO peripheral according to the specified
    111          *         parameters in the GPIO_InitStruct.
    112          * @param  GPIO_InitStruct: pointer to a @ref GPIO_InitType structure that
    113          *         contains the configuration information for the specified GPIO peripheral.
    114          * @retval None
    115          */

   \                                 In section .text, align 2, keep-with-next
    116          void GPIO_Init(GPIO_InitType* GPIO_InitStruct)
    117          {
   \                     GPIO_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0001             MOVS     R1,R0
    118            uint8_t tmp;
    119            
    120            /* Check the parameters */
    121            assert_param(IS_GPIO_PINS(GPIO_InitStruct->GPIO_Pin));
    122            assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
    123            assert_param(IS_FUNCTIONAL_STATE(GPIO_InitStruct->GPIO_Pull));
    124            assert_param(IS_FUNCTIONAL_STATE(GPIO_InitStruct->GPIO_HighPwr));
    125            
    126            /* IO12 and IO13 cannot be programmed in output mode */
    127            assert_param( ((GPIO_InitStruct->GPIO_Pin & GPIO_Pin_12) != GPIO_Pin_12) || (GPIO_InitStruct->GPIO_Mode != GPIO_Output));
    128            assert_param( ((GPIO_InitStruct->GPIO_Pin & GPIO_Pin_13) != GPIO_Pin_13) || (GPIO_InitStruct->GPIO_Mode != GPIO_Output));
    129            
    130            
    131            /* Configure the IO mode */
    132            if(GPIO_InitStruct->GPIO_Mode == GPIO_Input) {
   \   00000004   0x7908             LDRB     R0,[R1, #+4]
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x....             LDR      R2,??DataTable7  ;; 0x40000004
   \   0000000A   0x0004             MOVS     R4,R0
   \   0000000C   0xD104             BNE      ??GPIO_Init_0
    133              CLEAR_BIT(GPIO->OEN, GPIO_InitStruct->GPIO_Pin);
   \   0000000E   0x6810             LDR      R0,[R2, #+0]
   \   00000010   0x680C             LDR      R4,[R1, #+0]
   \   00000012   0x43A0             BICS     R0,R0,R4
   \   00000014   0x6010             STR      R0,[R2, #+0]
   \   00000016   0xE006             B        ??GPIO_Init_1
    134          #ifdef BLUENRG2_DEVICE
    135              if((GPIO_InitStruct->GPIO_Pin&GPIO_Pin_9) == GPIO_Pin_9  ||
    136                 (GPIO_InitStruct->GPIO_Pin&GPIO_Pin_10) == GPIO_Pin_10 ||
    137                 (GPIO_InitStruct->GPIO_Pin&GPIO_Pin_11) == GPIO_Pin_11) {
    138                   SET_BIT(SYSTEM_CTRL->SLEEPIO_OEN, (GPIO_InitStruct->GPIO_Pin>>9));
    139              }
    140          #endif
    141            }
    142            else if(GPIO_InitStruct->GPIO_Mode == GPIO_Output) {
   \                     ??GPIO_Init_0: (+1)
   \   00000018   0x2806             CMP      R0,#+6
   \   0000001A   0xD104             BNE      ??GPIO_Init_1
    143              GPIO_InitStruct->GPIO_Mode = GPIO_Input;
   \   0000001C   0x710B             STRB     R3,[R1, #+4]
    144              SET_BIT(GPIO->OEN, GPIO_InitStruct->GPIO_Pin);
   \   0000001E   0x6810             LDR      R0,[R2, #+0]
   \   00000020   0x680C             LDR      R4,[R1, #+0]
   \   00000022   0x4304             ORRS     R4,R4,R0
   \   00000024   0x6014             STR      R4,[R2, #+0]
    145          #ifdef BLUENRG2_DEVICE
    146              if((GPIO_InitStruct->GPIO_Pin&GPIO_Pin_9) == GPIO_Pin_9  ||
    147                 (GPIO_InitStruct->GPIO_Pin&GPIO_Pin_10) == GPIO_Pin_10 ||
    148                 (GPIO_InitStruct->GPIO_Pin&GPIO_Pin_11) == GPIO_Pin_11) {
    149                   CLEAR_BIT(SYSTEM_CTRL->SLEEPIO_OEN, (GPIO_InitStruct->GPIO_Pin>>9));
    150              }
    151          #endif
    152            }
    153            
    154            for(uint8_t i = 0; i < GPIO_PIN_COUNT; i++) {
    155              tmp = (uint8_t)((GPIO_InitStruct->GPIO_Pin>>i) & 0x01);
    156              if(tmp!=0) {
   \                     ??GPIO_Init_1: (+1)
   \   00000026   0x6808             LDR      R0,[R1, #+0]
   \   00000028   0x40D8             LSRS     R0,R0,R3
   \   0000002A   0x07C0             LSLS     R0,R0,#+31
   \   0000002C   0xD51A             BPL      ??GPIO_Init_2
    157          
    158                if(i < 8) {
   \   0000002E   0x2B08             CMP      R3,#+8
   \   00000030   0xDA09             BGE      ??GPIO_Init_3
    159                  MODIFY_REG(GPIO->MODE0, (0xF<<(i*4)), (GPIO_InitStruct->GPIO_Mode << (i*4)) );
   \   00000032   0x009D             LSLS     R5,R3,#+2
   \   00000034   0x6A96             LDR      R6,[R2, #+40]
   \   00000036   0x200F             MOVS     R0,#+15
   \   00000038   0x40A8             LSLS     R0,R0,R5
   \   0000003A   0x4386             BICS     R6,R6,R0
   \   0000003C   0x7908             LDRB     R0,[R1, #+4]
   \   0000003E   0x40A8             LSLS     R0,R0,R5
   \   00000040   0x4330             ORRS     R0,R0,R6
   \   00000042   0x6290             STR      R0,[R2, #+40]
   \   00000044   0xE00E             B        ??GPIO_Init_2
    160                }
    161                else if((i > 7) && (i < 16)) {
   \                     ??GPIO_Init_3: (+1)
   \   00000046   0x0018             MOVS     R0,R3
   \   00000048   0x3808             SUBS     R0,R0,#+8
   \   0000004A   0x2808             CMP      R0,#+8
   \   0000004C   0xD20A             BCS      ??GPIO_Init_2
    162                  MODIFY_REG(GPIO->MODE1, (0xF<<((i-8)*4)), (GPIO_InitStruct->GPIO_Mode << ((i-8)*4)) );
   \   0000004E   0x0018             MOVS     R0,R3
   \   00000050   0x3808             SUBS     R0,R0,#+8
   \   00000052   0x0085             LSLS     R5,R0,#+2
   \   00000054   0x6AD6             LDR      R6,[R2, #+44]
   \   00000056   0x200F             MOVS     R0,#+15
   \   00000058   0x40A8             LSLS     R0,R0,R5
   \   0000005A   0x4386             BICS     R6,R6,R0
   \   0000005C   0x7908             LDRB     R0,[R1, #+4]
   \   0000005E   0x40A8             LSLS     R0,R0,R5
   \   00000060   0x4330             ORRS     R0,R0,R6
   \   00000062   0x62D0             STR      R0,[R2, #+44]
    163                }
    164          #ifdef BLUENRG2_DEVICE
    165                else if((i > 15) && (i < 24)) {
    166                  MODIFY_REG(GPIO->MODE2, (0xF<<((i-16)*4)), (GPIO_InitStruct->GPIO_Mode << ((i-16)*4)) );
    167                }
    168                else if(i > 23) {
    169                  MODIFY_REG(GPIO->MODE3, (0xF<<((i-24)*4)), (GPIO_InitStruct->GPIO_Mode << ((i-24)*4)) );
    170                }
    171          #endif
    172              }
    173            }
   \                     ??GPIO_Init_2: (+1)
   \   00000064   0x1C5B             ADDS     R3,R3,#+1
   \   00000066   0x2B1A             CMP      R3,#+26
   \   00000068   0xDBDD             BLT      ??GPIO_Init_1
    174          
    175            /* Set the current mode */
    176            if(GPIO_InitStruct->GPIO_HighPwr == ENABLE) {
   \   0000006A   0x6808             LDR      R0,[R1, #+0]
   \   0000006C   0x794B             LDRB     R3,[R1, #+5]
   \   0000006E   0x2B01             CMP      R3,#+1
   \   00000070   0x6893             LDR      R3,[R2, #+8]
   \   00000072   0xD102             BNE      ??GPIO_Init_4
    177              SET_BIT(GPIO->DS, GPIO_InitStruct->GPIO_Pin);
   \   00000074   0x4318             ORRS     R0,R0,R3
   \   00000076   0x6090             STR      R0,[R2, #+8]
   \   00000078   0xE001             B        ??GPIO_Init_5
    178          #ifdef BLUENRG2_DEVICE
    179              if((GPIO_InitStruct->GPIO_Pin&GPIO_Pin_9) == GPIO_Pin_9  ||
    180                 (GPIO_InitStruct->GPIO_Pin&GPIO_Pin_10) == GPIO_Pin_10 ||
    181                 (GPIO_InitStruct->GPIO_Pin&GPIO_Pin_11) == GPIO_Pin_11) {
    182                   SET_BIT(SYSTEM_CTRL->SLEEPIO_DS, (GPIO_InitStruct->GPIO_Pin>>9));
    183                 }
    184          #endif
    185            }
    186            else {
    187              CLEAR_BIT(GPIO->DS, GPIO_InitStruct->GPIO_Pin);
   \                     ??GPIO_Init_4: (+1)
   \   0000007A   0x4383             BICS     R3,R3,R0
   \   0000007C   0x6093             STR      R3,[R2, #+8]
    188          #ifdef BLUENRG2_DEVICE
    189              if((GPIO_InitStruct->GPIO_Pin&GPIO_Pin_9) == GPIO_Pin_9  ||
    190                 (GPIO_InitStruct->GPIO_Pin&GPIO_Pin_10) == GPIO_Pin_10 ||
    191                 (GPIO_InitStruct->GPIO_Pin&GPIO_Pin_11) == GPIO_Pin_11) {
    192                   CLEAR_BIT(SYSTEM_CTRL->SLEEPIO_DS, (GPIO_InitStruct->GPIO_Pin>>9));
    193                 }
    194          #endif
    195            }
    196          
    197            /* Set the pull on IO */
    198            if(GPIO_InitStruct->GPIO_Pull == ENABLE) {
   \                     ??GPIO_Init_5: (+1)
   \   0000007E   0x6808             LDR      R0,[R1, #+0]
   \   00000080   0x7989             LDRB     R1,[R1, #+6]
   \   00000082   0x2901             CMP      R1,#+1
   \   00000084   0x6851             LDR      R1,[R2, #+4]
   \   00000086   0xD102             BNE      ??GPIO_Init_6
    199              SET_BIT(GPIO->PE, GPIO_InitStruct->GPIO_Pin);
   \   00000088   0x4308             ORRS     R0,R0,R1
   \   0000008A   0x6050             STR      R0,[R2, #+4]
   \   0000008C   0xBD70             POP      {R4-R6,PC}
    200          #ifdef BLUENRG2_DEVICE
    201              if((GPIO_InitStruct->GPIO_Pin&GPIO_Pin_9) == GPIO_Pin_9  ||
    202                 (GPIO_InitStruct->GPIO_Pin&GPIO_Pin_10) == GPIO_Pin_10 ||
    203                 (GPIO_InitStruct->GPIO_Pin&GPIO_Pin_11) == GPIO_Pin_11) {
    204                   SET_BIT(SYSTEM_CTRL->SLEEPIO_PE, (GPIO_InitStruct->GPIO_Pin>>9));
    205                 }
    206          #endif
    207            }
    208            else {
    209              CLEAR_BIT(GPIO->PE, GPIO_InitStruct->GPIO_Pin);
   \                     ??GPIO_Init_6: (+1)
   \   0000008E   0x4381             BICS     R1,R1,R0
   \   00000090   0x6051             STR      R1,[R2, #+4]
    210          #ifdef BLUENRG2_DEVICE
    211              if((GPIO_InitStruct->GPIO_Pin&GPIO_Pin_9) == GPIO_Pin_9  ||
    212                 (GPIO_InitStruct->GPIO_Pin&GPIO_Pin_10) == GPIO_Pin_10 ||
    213                 (GPIO_InitStruct->GPIO_Pin&GPIO_Pin_11) == GPIO_Pin_11) {
    214                   CLEAR_BIT(SYSTEM_CTRL->SLEEPIO_PE, (GPIO_InitStruct->GPIO_Pin>>9));
    215                 }
    216          #endif
    217            }
    218          
    219          }
   \   00000092   0xBD70             POP      {R4-R6,PC}       ;; return
    220          
    221          /**
    222          * @brief  Fills the GPIO_InitStruct member with its default value.
    223          * @param  GPIO_InitStruct : pointer to a @ref GPIO_InitType structure which will
    224          *         be initialized.
    225          * @retval None
    226          */

   \                                 In section .text, align 2, keep-with-next
    227          void GPIO_StructInit(GPIO_InitType* GPIO_InitStruct)
    228          {
    229            /* Reset GPIO init structure parameters values */
    230            GPIO_InitStruct->GPIO_Pin  = 0x00000000;
   \                     GPIO_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    231            GPIO_InitStruct->GPIO_Mode = GPIO_Input;
   \   00000004   0x7101             STRB     R1,[R0, #+4]
    232            GPIO_InitStruct->GPIO_Pull = DISABLE;
   \   00000006   0x7181             STRB     R1,[R0, #+6]
    233            GPIO_InitStruct->GPIO_HighPwr = DISABLE;
   \   00000008   0x7141             STRB     R1,[R0, #+5]
    234          }
   \   0000000A   0x4770             BX       LR               ;; return
    235          
    236          /**
    237          * @brief  Set the retention state of the retained GPIO: IO9, IO10, IO11.
    238          * @param  GPIO_Pin: specifies the GPIO pin bits to read.
    239          *         This parameter can be GPIO_Pin_x where x can be (0..25) @ref GPIO_Pins_Definition.
    240          *         QFN32 package: 15 pins, WLCSP32 package: 14 pins, QFN48 package: 26.
    241          * @retval None
    242          */

   \                                 In section .text, align 2, keep-with-next
    243          void GPIO_SetRetentionState(uint32_t GPIO_Pin, BitAction BitVal)
    244          {
    245          #ifdef BLUENRG2_DEVICE
    246            /* Check the parameters */
    247            assert_param(IS_GPIO_PIN(GPIO_Pin));
    248            assert_param(IS_GPIO_BIT_ACTION(BitVal)); 
    249            
    250            /* Reset GPIO init structure parameters values */
    251            if((GPIO_Pin&GPIO_Pin_9) == GPIO_Pin_9  ||
    252               (GPIO_Pin&GPIO_Pin_10) == GPIO_Pin_10 ||
    253                 (GPIO_Pin&GPIO_Pin_11) == GPIO_Pin_11) {
    254                   if (BitVal == Bit_SET) {
    255                     SET_BIT(SYSTEM_CTRL->SLEEPIO_OUT, (GPIO_Pin>>9));
    256                   }         
    257                   else {
    258                     CLEAR_BIT(SYSTEM_CTRL->SLEEPIO_OUT, (GPIO_Pin>>9));
    259                   }
    260                 }
    261          #endif
    262          }
   \                     GPIO_SetRetentionState: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    263          
    264          
    265          
    266          /**
    267          * @brief  Reads the specified input pin value.
    268          * @param  GPIO_Pin: specifies the GPIO pin bits to read.
    269          *         This parameter can be GPIO_Pin_x where x can be (0..25) @ref GPIO_Pins_Definition.
    270          *         QFN32 package: 15 pins, WLCSP32 package: 14 pins, QFN48 package: 26.
    271          * @retval The input pin value @ref BitAction.
    272          */

   \                                 In section .text, align 2, keep-with-next
    273          BitAction GPIO_ReadBit(uint32_t GPIO_Pin)
    274          {
    275            /* Check the parameters */
    276            assert_param(IS_GPIO_PIN(GPIO_Pin)); 
    277            
    278            if(READ_BIT(GPIO->DATA, GPIO_Pin)) {
   \                     GPIO_ReadBit: (+1)
   \   00000000   0x2180             MOVS     R1,#+128
   \   00000002   0x05C9             LSLS     R1,R1,#+23       ;; #+1073741824
   \   00000004   0x....             B.N      ?Subroutine0
    279              return Bit_SET;
    280            }
    281            else {
    282              return Bit_RESET;
    283            }
    284          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x6809             LDR      R1,[R1, #+0]
   \   00000002   0x4008             ANDS     R0,R0,R1
   \   00000004   0xD000             BEQ      ??Subroutine0_0
   \   00000006   0x2001             MOVS     R0,#+1
   \                     ??Subroutine0_0: (+1)
   \   00000008   0xB2C0             UXTB     R0,R0
   \   0000000A   0x4770             BX       LR               ;; return
    285          
    286          
    287          /**
    288          * @brief  Sets the selected IO pin bit.
    289          * @param  GPIO_Pin: specifies the pins to be written.
    290          *         This parameter can be GPIO_Pin_x where x can be (0..25) @ref GPIO_Pins_Definition.
    291          *         QFN32 package: 15 pins, WLCSP32 package: 14 pins, QFN48 package: 26.
    292          *         More than one pin can be specified in OR logic, i.e. (GPIO_Pin_0 | GPIO_Pin_1).
    293          * @retval None
    294          */

   \                                 In section .text, align 2, keep-with-next
    295          void GPIO_SetBits(uint32_t GPIO_Pins)
    296          {
    297            /* Check the parameters */
    298            assert_param(IS_GPIO_PINS(GPIO_Pins));
    299            
    300            WRITE_REG(GPIO->DATS, GPIO_Pins);
   \                     GPIO_SetBits: (+1)
   \   00000000   0x....             LDR      R1,??DataTable7_2  ;; 0x4000003c
   \   00000002   0x6008             STR      R0,[R1, #+0]
    301          }
   \   00000004   0x4770             BX       LR               ;; return
    302          
    303          /**
    304          * @brief  Clears the selected IO pin bits.
    305          * @param  GPIO_Pin: specifies the pins to be written.
    306          *         This parameter can be GPIO_Pin_x where x can be (0..25) @ref GPIO_Pins_Definition.
    307          *         QFN32 package: 15 pins, WLCSP32 package: 14 pins, QFN48 package: 26.
    308          *         More than one pin can be specified in OR logic, i.e. (GPIO_Pin_0 | GPIO_Pin_1).
    309          * @retval None
    310          */

   \                                 In section .text, align 2, keep-with-next
    311          void GPIO_ResetBits(uint32_t GPIO_Pins)
    312          {
    313            /* Check the parameters */
    314            assert_param(IS_GPIO_PINS(GPIO_Pins));
    315            
    316            WRITE_REG(GPIO->DATC, GPIO_Pins);
   \                     GPIO_ResetBits: (+1)
   \   00000000   0x....             LDR      R1,??DataTable7_3  ;; 0x40000040
   \   00000002   0x6008             STR      R0,[R1, #+0]
    317          }
   \   00000004   0x4770             BX       LR               ;; return
    318          
    319          /**
    320          * @brief  Sets or clears the selected IO pin bit.
    321          * @param  GPIO_Pin: specifies the IO bits to be written.
    322          *         This parameter can be GPIO_Pin_x where x can be (0..25) @ref GPIO_Pins_Definition.
    323          *         QFN32 package: 15 pins, WLCSP32 package: 14 pins, QFN48 package: 26.
    324          *         More than one pin can be specified in OR logic, i.e. (GPIO_Pin_0 | GPIO_Pin_1).
    325          * @param  BitVal: specifies the value to be written to the selected bit.
    326          *         This parameter can be any value of @ref BitAction.
    327          * @retval None
    328          */

   \                                 In section .text, align 2, keep-with-next
    329          void GPIO_WriteBit(uint32_t GPIO_Pins, BitAction BitVal)
    330          {
    331            /* Check the parameters */
    332            assert_param(IS_GPIO_PINS(GPIO_Pins));
    333            assert_param(IS_GPIO_BIT_ACTION(BitVal)); 
    334            
    335            if (BitVal == Bit_SET) {
   \                     GPIO_WriteBit: (+1)
   \   00000000   0x....             LDR      R2,??DataTable7_2  ;; 0x4000003c
   \   00000002   0x2901             CMP      R1,#+1
   \   00000004   0xD101             BNE      ??GPIO_WriteBit_0
    336              WRITE_REG(GPIO->DATS, GPIO_Pins);
   \   00000006   0x6010             STR      R0,[R2, #+0]
   \   00000008   0x4770             BX       LR
    337            }
    338            else {
    339              WRITE_REG(GPIO->DATC, GPIO_Pins);
   \                     ??GPIO_WriteBit_0: (+1)
   \   0000000A   0x6050             STR      R0,[R2, #+4]
    340            }
    341          }
   \   0000000C   0x4770             BX       LR               ;; return
    342          
    343          /**
    344          * @brief  Toggles data to the specified IO pin.
    345          * @param  GPIO_Pin: specifies the IO bits to be toggled.
    346          *         This parameter can be GPIO_Pin_x where x can be (0..25) @ref GPIO_Pins_Definition.
    347          *         QFN32 package: 15 pins, WLCSP32 package: 14 pins, QFN48 package: 26.
    348          *         More than one pin can be specified in OR logic, i.e. (GPIO_Pin_0 | GPIO_Pin_1).
    349          * @retval None
    350          */

   \                                 In section .text, align 2, keep-with-next
    351          void GPIO_ToggleBits(uint32_t GPIO_Pins)
    352          {  
    353            /* Check the parameters */  
    354            assert_param(IS_GPIO_PINS(GPIO_Pins));
    355            
    356            GPIO->DATA ^= GPIO_Pins;
   \                     GPIO_ToggleBits: (+1)
   \   00000000   0x2180             MOVS     R1,#+128
   \   00000002   0x05C9             LSLS     R1,R1,#+23       ;; #+1073741824
   \   00000004   0x680A             LDR      R2,[R1, #+0]
   \   00000006   0x4050             EORS     R0,R0,R2
   \   00000008   0x6008             STR      R0,[R1, #+0]
    357          }
   \   0000000A   0x4770             BX       LR               ;; return
    358          
    359          /**
    360          * @brief  Fills each GPIO_EXTIStruct member with its default value.
    361          * @param  GPIO_EXTIInitStruct : pointer to a @ref GPIO_EXTIConfigType structure.
    362          * @retval None
    363          */

   \                                 In section .text, align 2, keep-with-next
    364          void GPIO_EXTIStructInit(GPIO_EXTIConfigType* GPIO_EXTIInitStruct)
    365          {
    366            /* Reset GPIO init structure parameters values */
    367            GPIO_EXTIInitStruct->GPIO_Pin = 0x00000000;
   \                     GPIO_EXTIStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    368            GPIO_EXTIInitStruct->GPIO_IrqSense = GPIO_IrqSense_Edge;
   \   00000004   0x6041             STR      R1,[R0, #+4]
    369            GPIO_EXTIInitStruct->GPIO_Event = GPIO_Event_Low;
   \   00000006   0x6081             STR      R1,[R0, #+8]
    370          }
   \   00000008   0x4770             BX       LR               ;; return
    371          
    372          
    373          /**
    374          * @brief  Selects the GPIO pins used as EXTI Line.
    375          * @param  EXTIConfig: pointer to a @ref GPIO_EXTIConfigType structure that
    376          *   contains the configuration information for the specified GPIO pins.
    377          * @retval None
    378          */

   \                                 In section .text, align 2, keep-with-next
    379          void GPIO_EXTIConfig(GPIO_EXTIConfigType* EXTIConfig)
    380          {
    381            /* Check the parameters */
    382            assert_param(IS_GPIO_PINS(EXTIConfig->GPIO_Pin));
    383            assert_param(IS_GPIO_IRQSENSE(EXTIConfig->GPIO_IrqSense));
    384            assert_param(IS_GPIO_EVENT(EXTIConfig->GPIO_Event));
    385            
    386            /* Interrupt sense configuration */
    387            if (EXTIConfig->GPIO_IrqSense == GPIO_IrqSense_Level) {
   \                     GPIO_EXTIConfig: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   \   00000002   0x....             LDR      R1,??DataTable7_4  ;; 0x40000010
   \   00000004   0x6843             LDR      R3,[R0, #+4]
   \   00000006   0x2B01             CMP      R3,#+1
   \   00000008   0x680B             LDR      R3,[R1, #+0]
   \   0000000A   0xD102             BNE      ??GPIO_EXTIConfig_0
    388              /* Configure level detection */
    389              SET_BIT(GPIO->IS, EXTIConfig->GPIO_Pin);
   \   0000000C   0x431A             ORRS     R2,R2,R3
   \   0000000E   0x600A             STR      R2,[R1, #+0]
   \   00000010   0xE001             B        ??GPIO_EXTIConfig_1
    390            }
    391            else {
    392              /* Configure edge detection */
    393              CLEAR_BIT(GPIO->IS, EXTIConfig->GPIO_Pin);
   \                     ??GPIO_EXTIConfig_0: (+1)
   \   00000012   0x4393             BICS     R3,R3,R2
   \   00000014   0x600B             STR      R3,[R1, #+0]
    394            }
    395            
    396            /* Configure event */
    397            if (EXTIConfig->GPIO_Event == GPIO_Event_High) {
   \                     ??GPIO_EXTIConfig_1: (+1)
   \   00000016   0x6882             LDR      R2,[R0, #+8]
   \   00000018   0x6803             LDR      R3,[R0, #+0]
   \   0000001A   0x2A01             CMP      R2,#+1
   \   0000001C   0xD103             BNE      ??GPIO_EXTIConfig_2
    398              /* Configure interrupt on high level or rising edge event */
    399              SET_BIT(GPIO->IEV, EXTIConfig->GPIO_Pin);
   \   0000001E   0x688A             LDR      R2,[R1, #+8]
   \   00000020   0x4313             ORRS     R3,R3,R2
   \   00000022   0x608B             STR      R3,[R1, #+8]
    400              CLEAR_BIT(GPIO->IBE, EXTIConfig->GPIO_Pin);
   \   00000024   0xE004             B.N      ??GPIO_EXTIConfig_3
    401            }
    402            else if (EXTIConfig->GPIO_Event == GPIO_Event_Low) {
   \                     ??GPIO_EXTIConfig_2: (+1)
   \   00000026   0x2A00             CMP      R2,#+0
   \   00000028   0xD107             BNE      ??GPIO_EXTIConfig_4
    403              /* Configure interrupt on low level or falling edge event */
    404              CLEAR_BIT(GPIO->IEV, EXTIConfig->GPIO_Pin);
   \   0000002A   0x688A             LDR      R2,[R1, #+8]
   \   0000002C   0x439A             BICS     R2,R2,R3
   \   0000002E   0x608A             STR      R2,[R1, #+8]
    405              CLEAR_BIT(GPIO->IBE, EXTIConfig->GPIO_Pin);
   \                     ??GPIO_EXTIConfig_3: (+1)
   \   00000030   0x684A             LDR      R2,[R1, #+4]
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x4382             BICS     R2,R2,R0
   \   00000036   0x604A             STR      R2,[R1, #+4]
   \   00000038   0x4770             BX       LR
    406            }
    407            else {
    408              /* Configure interrupt on both edge */
    409              SET_BIT(GPIO->IBE, EXTIConfig->GPIO_Pin);
   \                     ??GPIO_EXTIConfig_4: (+1)
   \   0000003A   0x6848             LDR      R0,[R1, #+4]
   \   0000003C   0x4303             ORRS     R3,R3,R0
   \   0000003E   0x604B             STR      R3,[R1, #+4]
    410            }
    411            
    412          }
   \   00000040   0x4770             BX       LR               ;; return
    413          
    414          /**
    415          * @brief  Enables or disables interrupts on specified pins.
    416          * @param  GPIO_Pin: specifies the IO pins as an interrupt source.
    417          *         This parameter can be GPIO_Pin_x where x can be (0..25) @ref GPIO_Pins_Definition.
    418          *         QFN32 package: 15 pins, WLCSP32 package: 14 pins, QFN48 package: 26.
    419          *         More than one pin can be specified in OR logic, i.e. (GPIO_Pin_0 | GPIO_Pin_1).
    420          * @param  NewState: functional state @ref FunctionalState
    421          *         This parameter can be: ENABLE or DISABLE.
    422          * @retval None
    423          */

   \                                 In section .text, align 2, keep-with-next
    424          void GPIO_EXTICmd(uint32_t GPIO_Pins, FunctionalState NewState)
    425          {
    426            /* Check the parameters */
    427            assert_param(IS_GPIO_PINS(GPIO_Pins));
    428            
    429            if (NewState != DISABLE) {
   \                     GPIO_EXTICmd: (+1)
   \   00000000   0x....             LDR      R2,??DataTable7_5  ;; 0x4000001c
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0x6811             LDR      R1,[R2, #+0]
   \   00000006   0xD002             BEQ      ??GPIO_EXTICmd_0
    430              SET_BIT(GPIO->IE, GPIO_Pins);
   \   00000008   0x4308             ORRS     R0,R0,R1
   \   0000000A   0x6010             STR      R0,[R2, #+0]
   \   0000000C   0x4770             BX       LR
    431            }
    432            else {
    433              CLEAR_BIT(GPIO->IE, GPIO_Pins);
   \                     ??GPIO_EXTICmd_0: (+1)
   \   0000000E   0x4381             BICS     R1,R1,R0
   \   00000010   0x6011             STR      R1,[R2, #+0]
    434            }
    435          }
   \   00000012   0x4770             BX       LR               ;; return
    436          
    437          /**
    438          * @brief  Clears the GPIO interrupt pending bits.
    439          * @param  GPIO_Pin: specifies the GPIO interrupt pending bit to clear.
    440          *         This parameter can be GPIO_Pin_x where x can be (0..25) @ref GPIO_Pins_Definition.
    441          *         QFN32 package: 15 pins, WLCSP32 package: 14 pins, QFN48 package: 26.
    442          *         More than one pin can be specified in OR logic, i.e. (GPIO_Pin_0 | GPIO_Pin_1).
    443          * @retval None
    444          */

   \                                 In section .text, align 2, keep-with-next
    445          void GPIO_ClearITPendingBit(uint32_t GPIO_Pins)
    446          {
    447            /* Check the parameters */
    448            assert_param(IS_GPIO_PINS(GPIO_Pins));
    449          
    450            SET_BIT(GPIO->IC, GPIO_Pins);
   \                     GPIO_ClearITPendingBit: (+1)
   \   00000000   0x....             LDR      R1,??DataTable7_6  ;; 0x40000028
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0x4310             ORRS     R0,R0,R2
   \   00000006   0x6008             STR      R0,[R1, #+0]
    451          }
   \   00000008   0x4770             BX       LR               ;; return
    452          
    453          
    454          /**
    455          * @brief  Checks whether the specified enabled GPIO interrupt is active.
    456          * @param  GPIO_Pin: Specifies the GPIO interrupt to check.
    457          *         This parameter can be GPIO_Pin_x where x can be (0..25) @ref GPIO_Pins_Definition.
    458          *         QFN32 package: 15 pins, WLCSP32 package: 14 pins, QFN48 package: 26.
    459          * @param  FlagStatus: functional state @ref FlagStatus
    460          *         This parameter can be: SET or RESET.
    461          */

   \                                 In section .text, align 4, keep-with-next
    462          FlagStatus GPIO_GetITPendingBit(uint32_t GPIO_Pin)
    463          {  
    464            /* Check the parameters */
    465            assert_param(IS_GPIO_PIN(GPIO_Pin));
    466            
    467            if(READ_BIT(GPIO->MIS, GPIO_Pin) != (uint32_t)RESET) {
   \                     GPIO_GetITPendingBit: (+1)
   \   00000000   0x4900             LDR      R1,??GPIO_GetITPendingBit_0  ;; 0x40000024
   \   00000002   0xE001             B.N      ??GPIO_GetITPendingBit_1
   \                     ??GPIO_GetITPendingBit_0:
   \   00000004   0x40000024         DC32     0x40000024
   \                     ??GPIO_GetITPendingBit_1: (+1)
   \   00000008                      REQUIRE ?Subroutine0
   \   00000008                      ;; // Fall through to label ?Subroutine0
    468              return SET;
    469            }
    470            else {
    471              return RESET;
    472            }
    473          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x40000004         DC32     0x40000004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x03FFFFFF         DC32     0x3ffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x4000003C         DC32     0x4000003c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x40000040         DC32     0x40000040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x40000010         DC32     0x40000010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0x4000001C         DC32     0x4000001c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \   00000000   0x40000028         DC32     0x40000028
    474          
    475          
    476          /**
    477          * @}
    478          */
    479          
    480          /**
    481          * @}
    482          */
    483          
    484          /**
    485          * @}
    486          */
    487          
    488          /**
    489          * @}
    490          */
    491          
    492          /******************* (C) COPYRIGHT 2016 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   GPIO_ClearITPendingBit
       0   GPIO_DeInit
       0   GPIO_EXTICmd
       0   GPIO_EXTIConfig
       0   GPIO_EXTIStructInit
       0   GPIO_GetITPendingBit
      16   GPIO_Init
       0   GPIO_ReadBit
       0   GPIO_ResetBits
       0   GPIO_SetBits
       0   GPIO_SetRetentionState
       0   GPIO_StructInit
       0   GPIO_ToggleBits
       0   GPIO_WriteBit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
      12  ?Subroutine0
      10  GPIO_ClearITPendingBit
      38  GPIO_DeInit
      20  GPIO_EXTICmd
      66  GPIO_EXTIConfig
      10  GPIO_EXTIStructInit
       8  GPIO_GetITPendingBit
     148  GPIO_Init
       6  GPIO_ReadBit
       6  GPIO_ResetBits
       6  GPIO_SetBits
       2  GPIO_SetRetentionState
      12  GPIO_StructInit
      12  GPIO_ToggleBits
      14  GPIO_WriteBit

 
 398 bytes in section .text
 
 398 bytes of CODE memory

Errors: none
Warnings: none
